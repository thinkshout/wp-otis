// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"jKlMn":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = 1234;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
var HMR_USE_SSE = false;
module.bundle.HMR_BUNDLE_ID = "e5ed768d34024d9c";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, HMR_USE_SSE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var HMR_USE_SSE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && ![
        "localhost",
        "127.0.0.1",
        "0.0.0.0"
    ].includes(hostname) ? "wss" : "ws";
    var ws;
    if (HMR_USE_SSE) ws = new EventSource("/__parcel_hmr");
    else try {
        ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/");
    } catch (err) {
        if (err.message) console.error(err.message);
        ws = {};
    }
    // Web extension context
    var extCtx = typeof browser === "undefined" ? typeof chrome === "undefined" ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    }
    // $FlowFixMe
    ws.onmessage = async function(event /*: {data: string, ...} */ ) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data /*: HMRMessage */  = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH);
            // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                }
                // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html);
                // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    if (ws instanceof WebSocket) {
        ws.onerror = function(e) {
            if (e.message) console.error(e.message);
        };
        ws.onclose = function() {
            console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
        };
    }
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute("href");
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", // $FlowFixMe
    href.split("?")[0] + "?" + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            });
            // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"6gilS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _dashboard = require("./js/dashboard");
var _dashboardDefault = parcelHelpers.interopDefault(_dashboard);
var _dashboardCss = require("./css/dashboard.css");
(0, _dashboardDefault.default)();

},{"./js/dashboard":"4ePVI","./css/dashboard.css":"clNoW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4ePVI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>dashboardVue);
var _vue = require("vue");
var _vueDatepicker = require("@vuepic/vue-datepicker");
var _vueDatepickerDefault = parcelHelpers.interopDefault(_vueDatepicker);
var _mainCss = require("@vuepic/vue-datepicker/dist/main.css");
var _dashboardVue = require("./vue/components/04_templates/Dashboard.vue");
var _dashboardVueDefault = parcelHelpers.interopDefault(_dashboardVue);
var _vuesticUi = require("vuestic-ui");
function dashboardVue() {
    const app = (0, _vue.createApp)((0, _dashboardVueDefault.default));
    app.component("Datepicker", (0, _vueDatepickerDefault.default));
    app.use((0, _vuesticUi.createVuestic)({
        config: {
            colors: {
                primary: "#23e066",
                secondary: "#002c85",
                success: "#40e583",
                info: "#2c82e0",
                danger: "#e34b4a",
                warning: "#ffc200",
                gray: "#babfc2",
                dark: "#34495e"
            }
        }
    }));
    app.mount("#otis-dashboard-mount");
}

},{"vue":"gzxs9","@vuepic/vue-datepicker":"lOLHi","@vuepic/vue-datepicker/dist/main.css":"d7I8C","vuestic-ui":"8BiRm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","./vue/components/04_templates/Dashboard.vue":"3Snlp"}],"gzxs9":[function(require,module,exports) {
/**
* vue v3.4.22
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "compile", ()=>compile);
var _runtimeDom = require("@vue/runtime-dom");
parcelHelpers.exportAll(_runtimeDom, exports);
function initDev() {
    (0, _runtimeDom.initCustomFormatter)();
}
initDev();
const compile = ()=>{
    (0, _runtimeDom.warn)(`Runtime compilation is not supported in this build of Vue.` + ` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`);
};

},{"@vue/runtime-dom":"9wNvI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9wNvI":[function(require,module,exports) {
/**
* @vue/runtime-dom v3.4.22
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Transition", ()=>Transition);
parcelHelpers.export(exports, "TransitionGroup", ()=>TransitionGroup);
parcelHelpers.export(exports, "VueElement", ()=>VueElement);
parcelHelpers.export(exports, "createApp", ()=>createApp);
parcelHelpers.export(exports, "createSSRApp", ()=>createSSRApp);
parcelHelpers.export(exports, "defineCustomElement", ()=>defineCustomElement);
parcelHelpers.export(exports, "defineSSRCustomElement", ()=>defineSSRCustomElement);
parcelHelpers.export(exports, "hydrate", ()=>hydrate);
parcelHelpers.export(exports, "initDirectivesForSSR", ()=>initDirectivesForSSR);
parcelHelpers.export(exports, "render", ()=>render);
parcelHelpers.export(exports, "useCssModule", ()=>useCssModule);
parcelHelpers.export(exports, "useCssVars", ()=>useCssVars);
parcelHelpers.export(exports, "vModelCheckbox", ()=>vModelCheckbox);
parcelHelpers.export(exports, "vModelDynamic", ()=>vModelDynamic);
parcelHelpers.export(exports, "vModelRadio", ()=>vModelRadio);
parcelHelpers.export(exports, "vModelSelect", ()=>vModelSelect);
parcelHelpers.export(exports, "vModelText", ()=>vModelText);
parcelHelpers.export(exports, "vShow", ()=>vShow);
parcelHelpers.export(exports, "withKeys", ()=>withKeys);
parcelHelpers.export(exports, "withModifiers", ()=>withModifiers);
var _runtimeCore = require("@vue/runtime-core");
parcelHelpers.exportAll(_runtimeCore, exports);
var _shared = require("@vue/shared");
const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
    insert: (child, parent, anchor)=>{
        parent.insertBefore(child, anchor || null);
    },
    remove: (child)=>{
        const parent = child.parentNode;
        if (parent) parent.removeChild(child);
    },
    createElement: (tag, namespace, is, props)=>{
        const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : doc.createElement(tag, is ? {
            is
        } : void 0);
        if (tag === "select" && props && props.multiple != null) el.setAttribute("multiple", props.multiple);
        return el;
    },
    createText: (text)=>doc.createTextNode(text),
    createComment: (text)=>doc.createComment(text),
    setText: (node, text)=>{
        node.nodeValue = text;
    },
    setElementText: (el, text)=>{
        el.textContent = text;
    },
    parentNode: (node)=>node.parentNode,
    nextSibling: (node)=>node.nextSibling,
    querySelector: (selector)=>doc.querySelector(selector),
    setScopeId (el, id) {
        el.setAttribute(id, "");
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent (content, parent, anchor, namespace, start, end) {
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        if (start && (start === end || start.nextSibling)) while(true){
            parent.insertBefore(start.cloneNode(true), anchor);
            if (start === end || !(start = start.nextSibling)) break;
        }
        else {
            templateContainer.innerHTML = namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content;
            const template = templateContainer.content;
            if (namespace === "svg" || namespace === "mathml") {
                const wrapper = template.firstChild;
                while(wrapper.firstChild)template.appendChild(wrapper.firstChild);
                template.removeChild(wrapper);
            }
            parent.insertBefore(template, anchor);
        }
        return [
            // first
            before ? before.nextSibling : parent.firstChild,
            // last
            anchor ? anchor.previousSibling : parent.lastChild
        ];
    }
};
const TRANSITION = "transition";
const ANIMATION = "animation";
const vtcKey = Symbol("_vtc");
const Transition = (props, { slots })=>(0, _runtimeCore.h)((0, _runtimeCore.BaseTransition), resolveTransitionProps(props), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: true
    },
    duration: [
        String,
        Number,
        Object
    ],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
};
const TransitionPropsValidators = Transition.props = /* @__PURE__ */ (0, _shared.extend)({}, (0, _runtimeCore.BaseTransitionPropsValidators), DOMTransitionPropsValidators);
const callHook = (hook, args = [])=>{
    if ((0, _shared.isArray)(hook)) hook.forEach((h2)=>h2(...args));
    else if (hook) hook(...args);
};
const hasExplicitCallback = (hook)=>{
    return hook ? (0, _shared.isArray)(hook) ? hook.some((h2)=>h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for(const key in rawProps)if (!(key in DOMTransitionPropsValidators)) baseProps[key] = rawProps[key];
    if (rawProps.css === false) return baseProps;
    const { name = "v", type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
    const finishEnter = (el, isAppear, done)=>{
        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
    };
    const finishLeave = (el, done)=>{
        el._isLeaving = false;
        removeTransitionClass(el, leaveFromClass);
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
    };
    const makeEnterHook = (isAppear)=>{
        return (el, done)=>{
            const hook = isAppear ? onAppear : onEnter;
            const resolve = ()=>finishEnter(el, isAppear, done);
            callHook(hook, [
                el,
                resolve
            ]);
            nextFrame(()=>{
                removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
                addTransitionClass(el, isAppear ? appearToClass : enterToClass);
                if (!hasExplicitCallback(hook)) whenTransitionEnds(el, type, enterDuration, resolve);
            });
        };
    };
    return (0, _shared.extend)(baseProps, {
        onBeforeEnter (el) {
            callHook(onBeforeEnter, [
                el
            ]);
            addTransitionClass(el, enterFromClass);
            addTransitionClass(el, enterActiveClass);
        },
        onBeforeAppear (el) {
            callHook(onBeforeAppear, [
                el
            ]);
            addTransitionClass(el, appearFromClass);
            addTransitionClass(el, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave (el, done) {
            el._isLeaving = true;
            const resolve = ()=>finishLeave(el, done);
            addTransitionClass(el, leaveFromClass);
            forceReflow();
            addTransitionClass(el, leaveActiveClass);
            nextFrame(()=>{
                if (!el._isLeaving) return;
                removeTransitionClass(el, leaveFromClass);
                addTransitionClass(el, leaveToClass);
                if (!hasExplicitCallback(onLeave)) whenTransitionEnds(el, type, leaveDuration, resolve);
            });
            callHook(onLeave, [
                el,
                resolve
            ]);
        },
        onEnterCancelled (el) {
            finishEnter(el, false);
            callHook(onEnterCancelled, [
                el
            ]);
        },
        onAppearCancelled (el) {
            finishEnter(el, true);
            callHook(onAppearCancelled, [
                el
            ]);
        },
        onLeaveCancelled (el) {
            finishLeave(el);
            callHook(onLeaveCancelled, [
                el
            ]);
        }
    });
}
function normalizeDuration(duration) {
    if (duration == null) return null;
    else if ((0, _shared.isObject)(duration)) return [
        NumberOf(duration.enter),
        NumberOf(duration.leave)
    ];
    else {
        const n = NumberOf(duration);
        return [
            n,
            n
        ];
    }
}
function NumberOf(val) {
    const res = (0, _shared.toNumber)(val);
    (0, _runtimeCore.assertNumber)(res, "<transition> explicit duration");
    return res;
}
function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c)=>c && el.classList.add(c));
    (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c)=>c && el.classList.remove(c));
    const _vtc = el[vtcKey];
    if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) el[vtcKey] = void 0;
    }
}
function nextFrame(cb) {
    requestAnimationFrame(()=>{
        requestAnimationFrame(cb);
    });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
    const id = el._endId = ++endId;
    const resolveIfNotStale = ()=>{
        if (id === el._endId) resolve();
    };
    if (explicitTimeout) return setTimeout(resolveIfNotStale, explicitTimeout);
    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
    if (!type) return resolve();
    const endEvent = type + "end";
    let ended = 0;
    const end = ()=>{
        el.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
    };
    const onEnd = (e)=>{
        if (e.target === el && ++ended >= propCount) end();
    };
    setTimeout(()=>{
        if (ended < propCount) end();
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    const getStyleProperties = (key)=>(styles[key] || "").split(", ");
    const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
    const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
    const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout = 0;
    let propCount = 0;
    if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
            type = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
        }
    } else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
            type = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
        }
    } else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
        propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(getStyleProperties(`${TRANSITION}Property`).toString());
    return {
        type,
        timeout,
        propCount,
        hasTransform
    };
}
function getTimeout(delays, durations) {
    while(delays.length < durations.length)delays = delays.concat(delays);
    return Math.max(...durations.map((d, i)=>toMs(d) + toMs(delays[i])));
}
function toMs(s) {
    if (s === "auto") return 0;
    return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
    return document.body.offsetHeight;
}
function patchClass(el, value, isSVG) {
    const transitionClasses = el[vtcKey];
    if (transitionClasses) value = (value ? [
        value,
        ...transitionClasses
    ] : [
        ...transitionClasses
    ]).join(" ");
    if (value == null) el.removeAttribute("class");
    else if (isSVG) el.setAttribute("class", value);
    else el.className = value;
}
const vShowOriginalDisplay = Symbol("_vod");
const vShowHidden = Symbol("_vsh");
const vShow = {
    beforeMount (el, { value }, { transition }) {
        el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
        if (transition && value) transition.beforeEnter(el);
        else setDisplay(el, value);
    },
    mounted (el, { value }, { transition }) {
        if (transition && value) transition.enter(el);
    },
    updated (el, { value, oldValue }, { transition }) {
        if (!value === !oldValue) return;
        if (transition) {
            if (value) {
                transition.beforeEnter(el);
                setDisplay(el, true);
                transition.enter(el);
            } else transition.leave(el, ()=>{
                setDisplay(el, false);
            });
        } else setDisplay(el, value);
    },
    beforeUnmount (el, { value }) {
        setDisplay(el, value);
    }
};
vShow.name = "show";
function setDisplay(el, value) {
    el.style.display = value ? el[vShowOriginalDisplay] : "none";
    el[vShowHidden] = !value;
}
function initVShowForSSR() {
    vShow.getSSRProps = ({ value })=>{
        if (!value) return {
            style: {
                display: "none"
            }
        };
    };
}
const CSS_VAR_TEXT = Symbol("CSS_VAR_TEXT");
function useCssVars(getter) {
    const instance = (0, _runtimeCore.getCurrentInstance)();
    if (!instance) {
        (0, _runtimeCore.warn)(`useCssVars is called without current active component instance.`);
        return;
    }
    const updateTeleports = instance.ut = (vars = getter(instance.proxy))=>{
        Array.from(document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)).forEach((node)=>setVarsOnNode(node, vars));
    };
    instance.getCssVars = ()=>getter(instance.proxy);
    const setVars = ()=>{
        const vars = getter(instance.proxy);
        setVarsOnVNode(instance.subTree, vars);
        updateTeleports(vars);
    };
    (0, _runtimeCore.onMounted)(()=>{
        (0, _runtimeCore.watchPostEffect)(setVars);
        const ob = new MutationObserver(setVars);
        ob.observe(instance.subTree.el.parentNode, {
            childList: true
        });
        (0, _runtimeCore.onUnmounted)(()=>ob.disconnect());
    });
}
function setVarsOnVNode(vnode, vars) {
    if (vnode.shapeFlag & 128) {
        const suspense = vnode.suspense;
        vnode = suspense.activeBranch;
        if (suspense.pendingBranch && !suspense.isHydrating) suspense.effects.push(()=>{
            setVarsOnVNode(suspense.activeBranch, vars);
        });
    }
    while(vnode.component)vnode = vnode.component.subTree;
    if (vnode.shapeFlag & 1 && vnode.el) setVarsOnNode(vnode.el, vars);
    else if (vnode.type === (0, _runtimeCore.Fragment)) vnode.children.forEach((c)=>setVarsOnVNode(c, vars));
    else if (vnode.type === (0, _runtimeCore.Static)) {
        let { el, anchor } = vnode;
        while(el){
            setVarsOnNode(el, vars);
            if (el === anchor) break;
            el = el.nextSibling;
        }
    }
}
function setVarsOnNode(el, vars) {
    if (el.nodeType === 1) {
        const style = el.style;
        let cssText = "";
        for(const key in vars){
            style.setProperty(`--${key}`, vars[key]);
            cssText += `--${key}: ${vars[key]};`;
        }
        style[CSS_VAR_TEXT] = cssText;
    }
}
const displayRE = /(^|;)\s*display\s*:/;
function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = (0, _shared.isString)(next);
    let hasControlledDisplay = false;
    if (next && !isCssString) {
        if (prev) {
            if (!(0, _shared.isString)(prev)) {
                for(const key in prev)if (next[key] == null) setStyle(style, key, "");
            } else for (const prevStyle of prev.split(";")){
                const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
                if (next[key] == null) setStyle(style, key, "");
            }
        }
        for(const key in next){
            if (key === "display") hasControlledDisplay = true;
            setStyle(style, key, next[key]);
        }
    } else {
        if (isCssString) {
            if (prev !== next) {
                const cssVarText = style[CSS_VAR_TEXT];
                if (cssVarText) next += ";" + cssVarText;
                style.cssText = next;
                hasControlledDisplay = displayRE.test(next);
            }
        } else if (prev) el.removeAttribute("style");
    }
    if (vShowOriginalDisplay in el) {
        el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
        if (el[vShowHidden]) style.display = "none";
    }
}
const semicolonRE = /[^\\];\s*$/;
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
    if ((0, _shared.isArray)(val)) val.forEach((v)=>setStyle(style, name, v));
    else {
        if (val == null) val = "";
        if (semicolonRE.test(val)) (0, _runtimeCore.warn)(`Unexpected semicolon at the end of '${name}' style value: '${val}'`);
        if (name.startsWith("--")) style.setProperty(name, val);
        else {
            const prefixed = autoPrefix(style, name);
            if (importantRE.test(val)) style.setProperty((0, _shared.hyphenate)(prefixed), val.replace(importantRE, ""), "important");
            else style[prefixed] = val;
        }
    }
}
const prefixes = [
    "Webkit",
    "Moz",
    "ms"
];
const prefixCache = {};
function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) return cached;
    let name = (0, _runtimeCore.camelize)(rawName);
    if (name !== "filter" && name in style) return prefixCache[rawName] = name;
    name = (0, _shared.capitalize)(name);
    for(let i = 0; i < prefixes.length; i++){
        const prefixed = prefixes[i] + name;
        if (prefixed in style) return prefixCache[rawName] = prefixed;
    }
    return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance) {
    if (isSVG && key.startsWith("xlink:")) {
        if (value == null) el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        else el.setAttributeNS(xlinkNS, key, value);
    } else {
        const isBoolean = (0, _shared.isSpecialBooleanAttr)(key);
        if (value == null || isBoolean && !(0, _shared.includeBooleanAttr)(value)) el.removeAttribute(key);
        else el.setAttribute(key, isBoolean ? "" : value);
    }
}
function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
    if (key === "innerHTML" || key === "textContent") {
        if (prevChildren) unmountChildren(prevChildren, parentComponent, parentSuspense);
        el[key] = value == null ? "" : value;
        return;
    }
    const tag = el.tagName;
    if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
    !tag.includes("-")) {
        const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
        const newValue = value == null ? "" : value;
        if (oldValue !== newValue || !("_value" in el)) el.value = newValue;
        if (value == null) el.removeAttribute(key);
        el._value = value;
        return;
    }
    let needRemove = false;
    if (value === "" || value == null) {
        const type = typeof el[key];
        if (type === "boolean") value = (0, _shared.includeBooleanAttr)(value);
        else if (value == null && type === "string") {
            value = "";
            needRemove = true;
        } else if (type === "number") {
            value = 0;
            needRemove = true;
        }
    }
    try {
        el[key] = value;
    } catch (e) {
        if (!needRemove) (0, _runtimeCore.warn)(`Failed setting prop "${key}" on <${tag.toLowerCase()}>: value ${value} is invalid.`, e);
    }
    needRemove && el.removeAttribute(key);
}
function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
}
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    const invokers = el[veiKey] || (el[veiKey] = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) existingInvoker.value = sanitizeEventValue(nextValue, rawName);
    else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
            const invoker = invokers[rawName] = createInvoker(sanitizeEventValue(nextValue, rawName), instance);
            addEventListener(el, name, invoker, options);
        } else if (existingInvoker) {
            removeEventListener(el, name, existingInvoker, options);
            invokers[rawName] = void 0;
        }
    }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
        options = {};
        let m;
        while(m = name.match(optionsModifierRE)){
            name = name.slice(0, name.length - m[0].length);
            options[m[0].toLowerCase()] = true;
        }
    }
    const event = name[2] === ":" ? name.slice(3) : (0, _shared.hyphenate)(name.slice(2));
    return [
        event,
        options
    ];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = ()=>cachedNow || (p.then(()=>cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
    const invoker = (e)=>{
        if (!e._vts) e._vts = Date.now();
        else if (e._vts <= invoker.attached) return;
        (0, _runtimeCore.callWithAsyncErrorHandling)(patchStopImmediatePropagation(e, invoker.value), instance, 5, [
            e
        ]);
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
}
function sanitizeEventValue(value, propName) {
    if ((0, _shared.isFunction)(value) || (0, _shared.isArray)(value)) return value;
    (0, _runtimeCore.warn)(`Wrong type passed as event handler to ${propName} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof value}.`);
    return 0, _shared.NOOP;
}
function patchStopImmediatePropagation(e, value) {
    if ((0, _shared.isArray)(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = ()=>{
            originalStop.call(e);
            e._stopped = true;
        };
        return value.map((fn)=>(e2)=>!e2._stopped && fn && fn(e2));
    } else return value;
}
const isNativeOn = (key)=>key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
    key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
const patchProp = (el, key, prevValue, nextValue, namespace, prevChildren, parentComponent, parentSuspense, unmountChildren)=>{
    const isSVG = namespace === "svg";
    if (key === "class") patchClass(el, nextValue, isSVG);
    else if (key === "style") patchStyle(el, prevValue, nextValue);
    else if ((0, _shared.isOn)(key)) {
        if (!(0, _shared.isModelListener)(key)) patchEvent(el, key, prevValue, nextValue, parentComponent);
    } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
    else {
        if (key === "true-value") el._trueValue = nextValue;
        else if (key === "false-value") el._falseValue = nextValue;
        patchAttr(el, key, nextValue, isSVG);
    }
};
function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
        if (key === "innerHTML" || key === "textContent") return true;
        if (key in el && isNativeOn(key) && (0, _shared.isFunction)(value)) return true;
        return false;
    }
    if (key === "spellcheck" || key === "draggable" || key === "translate") return false;
    if (key === "form") return false;
    if (key === "list" && el.tagName === "INPUT") return false;
    if (key === "type" && el.tagName === "TEXTAREA") return false;
    if (key === "width" || key === "height") {
        const tag = el.tagName;
        if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") return false;
    }
    if (isNativeOn(key) && (0, _shared.isString)(value)) return false;
    return key in el;
}
/*! #__NO_SIDE_EFFECTS__ */ // @__NO_SIDE_EFFECTS__
function defineCustomElement(options, hydrate2) {
    const Comp = (0, _runtimeCore.defineComponent)(options);
    class VueCustomElement extends VueElement {
        constructor(initialProps){
            super(Comp, initialProps, hydrate2);
        }
    }
    VueCustomElement.def = Comp;
    return VueCustomElement;
}
/*! #__NO_SIDE_EFFECTS__ */ const defineSSRCustomElement = /* @__NO_SIDE_EFFECTS__ */ (options)=>{
    return /* @__PURE__ */ defineCustomElement(options, hydrate);
};
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
    constructor(_def, _props = {}, hydrate2){
        super();
        this._def = _def;
        this._props = _props;
        /**
     * @internal
     */ this._instance = null;
        this._connected = false;
        this._resolved = false;
        this._numberProps = null;
        this._ob = null;
        if (this.shadowRoot && hydrate2) hydrate2(this._createVNode(), this.shadowRoot);
        else {
            if (0, this.shadowRoot) (0, _runtimeCore.warn)(`Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use \`defineSSRCustomElement\`.`);
            this.attachShadow({
                mode: "open"
            });
            if (!this._def.__asyncLoader) this._resolveProps(this._def);
        }
    }
    connectedCallback() {
        this._connected = true;
        if (!this._instance) {
            if (this._resolved) this._update();
            else this._resolveDef();
        }
    }
    disconnectedCallback() {
        this._connected = false;
        if (this._ob) {
            this._ob.disconnect();
            this._ob = null;
        }
        (0, _runtimeCore.nextTick)(()=>{
            if (!this._connected) {
                render(null, this.shadowRoot);
                this._instance = null;
            }
        });
    }
    /**
   * resolve inner component definition (handle possible async component)
   */ _resolveDef() {
        this._resolved = true;
        for(let i = 0; i < this.attributes.length; i++)this._setAttr(this.attributes[i].name);
        this._ob = new MutationObserver((mutations)=>{
            for (const m of mutations)this._setAttr(m.attributeName);
        });
        this._ob.observe(this, {
            attributes: true
        });
        const resolve = (def, isAsync = false)=>{
            const { props, styles } = def;
            let numberProps;
            if (props && !(0, _shared.isArray)(props)) for(const key in props){
                const opt = props[key];
                if (opt === Number || opt && opt.type === Number) {
                    if (key in this._props) this._props[key] = (0, _shared.toNumber)(this._props[key]);
                    (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[(0, _shared.camelize)(key)] = true;
                }
            }
            this._numberProps = numberProps;
            if (isAsync) this._resolveProps(def);
            this._applyStyles(styles);
            this._update();
        };
        const asyncDef = this._def.__asyncLoader;
        if (asyncDef) asyncDef().then((def)=>resolve(def, true));
        else resolve(this._def);
    }
    _resolveProps(def) {
        const { props } = def;
        const declaredPropKeys = (0, _shared.isArray)(props) ? props : Object.keys(props || {});
        for (const key of Object.keys(this))if (key[0] !== "_" && declaredPropKeys.includes(key)) this._setProp(key, this[key], true, false);
        for (const key of declaredPropKeys.map((0, _shared.camelize)))Object.defineProperty(this, key, {
            get () {
                return this._getProp(key);
            },
            set (val) {
                this._setProp(key, val);
            }
        });
    }
    _setAttr(key) {
        let value = this.hasAttribute(key) ? this.getAttribute(key) : void 0;
        const camelKey = (0, _shared.camelize)(key);
        if (this._numberProps && this._numberProps[camelKey]) value = (0, _shared.toNumber)(value);
        this._setProp(camelKey, value, false);
    }
    /**
   * @internal
   */ _getProp(key) {
        return this._props[key];
    }
    /**
   * @internal
   */ _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
        if (val !== this._props[key]) {
            this._props[key] = val;
            if (shouldUpdate && this._instance) this._update();
            if (shouldReflect) {
                if (val === true) this.setAttribute((0, _shared.hyphenate)(key), "");
                else if (typeof val === "string" || typeof val === "number") this.setAttribute((0, _shared.hyphenate)(key), val + "");
                else if (!val) this.removeAttribute((0, _shared.hyphenate)(key));
            }
        }
    }
    _update() {
        render(this._createVNode(), this.shadowRoot);
    }
    _createVNode() {
        const vnode = (0, _runtimeCore.createVNode)(this._def, (0, _shared.extend)({}, this._props));
        if (!this._instance) vnode.ce = (instance)=>{
            this._instance = instance;
            instance.isCE = true;
            instance.ceReload = (newStyles)=>{
                if (this._styles) {
                    this._styles.forEach((s)=>this.shadowRoot.removeChild(s));
                    this._styles.length = 0;
                }
                this._applyStyles(newStyles);
                this._instance = null;
                this._update();
            };
            const dispatch = (event, args)=>{
                this.dispatchEvent(new CustomEvent(event, {
                    detail: args
                }));
            };
            instance.emit = (event, ...args)=>{
                dispatch(event, args);
                if ((0, _shared.hyphenate)(event) !== event) dispatch((0, _shared.hyphenate)(event), args);
            };
            let parent = this;
            while(parent = parent && (parent.parentNode || parent.host))if (parent instanceof VueElement) {
                instance.parent = parent._instance;
                instance.provides = parent._instance.provides;
                break;
            }
        };
        return vnode;
    }
    _applyStyles(styles) {
        if (styles) styles.forEach((css)=>{
            const s = document.createElement("style");
            s.textContent = css;
            this.shadowRoot.appendChild(s);
            (this._styles || (this._styles = [])).push(s);
        });
    }
}
function useCssModule(name = "$style") {
    {
        const instance = (0, _runtimeCore.getCurrentInstance)();
        if (!instance) {
            (0, _runtimeCore.warn)(`useCssModule must be called inside setup()`);
            return 0, _shared.EMPTY_OBJ;
        }
        const modules = instance.type.__cssModules;
        if (!modules) {
            (0, _runtimeCore.warn)(`Current instance does not have CSS modules injected.`);
            return 0, _shared.EMPTY_OBJ;
        }
        const mod = modules[name];
        if (!mod) {
            (0, _runtimeCore.warn)(`Current instance does not have CSS module named "${name}".`);
            return 0, _shared.EMPTY_OBJ;
        }
        return mod;
    }
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const moveCbKey = Symbol("_moveCb");
const enterCbKey = Symbol("_enterCb");
const TransitionGroupImpl = {
    name: "TransitionGroup",
    props: /* @__PURE__ */ (0, _shared.extend)({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
    }),
    setup (props, { slots }) {
        const instance = (0, _runtimeCore.getCurrentInstance)();
        const state = (0, _runtimeCore.useTransitionState)();
        let prevChildren;
        let children;
        (0, _runtimeCore.onUpdated)(()=>{
            if (!prevChildren.length) return;
            const moveClass = props.moveClass || `${props.name || "v"}-move`;
            if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) return;
            prevChildren.forEach(callPendingCbs);
            prevChildren.forEach(recordPosition);
            const movedChildren = prevChildren.filter(applyTranslation);
            forceReflow();
            movedChildren.forEach((c)=>{
                const el = c.el;
                const style = el.style;
                addTransitionClass(el, moveClass);
                style.transform = style.webkitTransform = style.transitionDuration = "";
                const cb = el[moveCbKey] = (e)=>{
                    if (e && e.target !== el) return;
                    if (!e || /transform$/.test(e.propertyName)) {
                        el.removeEventListener("transitionend", cb);
                        el[moveCbKey] = null;
                        removeTransitionClass(el, moveClass);
                    }
                };
                el.addEventListener("transitionend", cb);
            });
        });
        return ()=>{
            const rawProps = (0, _runtimeCore.toRaw)(props);
            const cssTransitionProps = resolveTransitionProps(rawProps);
            let tag = rawProps.tag || (0, _runtimeCore.Fragment);
            prevChildren = [];
            if (children) for(let i = 0; i < children.length; i++){
                const child = children[i];
                if (child.el && child.el instanceof Element) {
                    prevChildren.push(child);
                    (0, _runtimeCore.setTransitionHooks)(child, (0, _runtimeCore.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
                    positionMap.set(child, child.el.getBoundingClientRect());
                }
            }
            children = slots.default ? (0, _runtimeCore.getTransitionRawChildren)(slots.default()) : [];
            for(let i = 0; i < children.length; i++){
                const child = children[i];
                if (child.key != null) (0, _runtimeCore.setTransitionHooks)(child, (0, _runtimeCore.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
                else (0, _runtimeCore.warn)(`<TransitionGroup> children must be keyed.`);
            }
            return (0, _runtimeCore.createVNode)(tag, null, children);
        };
    }
};
const removeMode = (props)=>delete props.mode;
/* @__PURE__ */ removeMode(TransitionGroupImpl.props);
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
    const el = c.el;
    if (el[moveCbKey]) el[moveCbKey]();
    if (el[enterCbKey]) el[enterCbKey]();
}
function recordPosition(c) {
    newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
    const oldPos = positionMap.get(c);
    const newPos = newPositionMap.get(c);
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    if (dx || dy) {
        const s = c.el.style;
        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = "0s";
        return c;
    }
}
function hasCSSTransform(el, root, moveClass) {
    const clone = el.cloneNode();
    const _vtc = el[vtcKey];
    if (_vtc) _vtc.forEach((cls)=>{
        cls.split(/\s+/).forEach((c)=>c && clone.classList.remove(c));
    });
    moveClass.split(/\s+/).forEach((c)=>c && clone.classList.add(c));
    clone.style.display = "none";
    const container = root.nodeType === 1 ? root : root.parentNode;
    container.appendChild(clone);
    const { hasTransform } = getTransitionInfo(clone);
    container.removeChild(clone);
    return hasTransform;
}
const getModelAssigner = (vnode)=>{
    const fn = vnode.props["onUpdate:modelValue"] || false;
    return (0, _shared.isArray)(fn) ? (value)=>(0, _shared.invokeArrayFns)(fn, value) : fn;
};
function onCompositionStart(e) {
    e.target.composing = true;
}
function onCompositionEnd(e) {
    const target = e.target;
    if (target.composing) {
        target.composing = false;
        target.dispatchEvent(new Event("input"));
    }
}
const assignKey = Symbol("_assign");
const vModelText = {
    created (el, { modifiers: { lazy, trim, number } }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        const castToNumber = number || vnode.props && vnode.props.type === "number";
        addEventListener(el, lazy ? "change" : "input", (e)=>{
            if (e.target.composing) return;
            let domValue = el.value;
            if (trim) domValue = domValue.trim();
            if (castToNumber) domValue = (0, _shared.looseToNumber)(domValue);
            el[assignKey](domValue);
        });
        if (trim) addEventListener(el, "change", ()=>{
            el.value = el.value.trim();
        });
        if (!lazy) {
            addEventListener(el, "compositionstart", onCompositionStart);
            addEventListener(el, "compositionend", onCompositionEnd);
            addEventListener(el, "change", onCompositionEnd);
        }
    },
    // set value on mounted so it's after min/max for type="range"
    mounted (el, { value }) {
        el.value = value == null ? "" : value;
    },
    beforeUpdate (el, { value, modifiers: { lazy, trim, number } }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        if (el.composing) return;
        const elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? (0, _shared.looseToNumber)(el.value) : el.value;
        const newValue = value == null ? "" : value;
        if (elValue === newValue) return;
        if (document.activeElement === el && el.type !== "range") {
            if (lazy) return;
            if (trim && el.value.trim() === newValue) return;
        }
        el.value = newValue;
    }
};
const vModelCheckbox = {
    // #4096 array checkboxes need to be deep traversed
    deep: true,
    created (el, _, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        addEventListener(el, "change", ()=>{
            const modelValue = el._modelValue;
            const elementValue = getValue(el);
            const checked = el.checked;
            const assign = el[assignKey];
            if ((0, _shared.isArray)(modelValue)) {
                const index = (0, _shared.looseIndexOf)(modelValue, elementValue);
                const found = index !== -1;
                if (checked && !found) assign(modelValue.concat(elementValue));
                else if (!checked && found) {
                    const filtered = [
                        ...modelValue
                    ];
                    filtered.splice(index, 1);
                    assign(filtered);
                }
            } else if ((0, _shared.isSet)(modelValue)) {
                const cloned = new Set(modelValue);
                if (checked) cloned.add(elementValue);
                else cloned.delete(elementValue);
                assign(cloned);
            } else assign(getCheckboxValue(el, checked));
        });
    },
    // set initial checked on mount to wait for true-value/false-value
    mounted: setChecked,
    beforeUpdate (el, binding, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        setChecked(el, binding, vnode);
    }
};
function setChecked(el, { value, oldValue }, vnode) {
    el._modelValue = value;
    if ((0, _shared.isArray)(value)) el.checked = (0, _shared.looseIndexOf)(value, vnode.props.value) > -1;
    else if ((0, _shared.isSet)(value)) el.checked = value.has(vnode.props.value);
    else if (value !== oldValue) el.checked = (0, _shared.looseEqual)(value, getCheckboxValue(el, true));
}
const vModelRadio = {
    created (el, { value }, vnode) {
        el.checked = (0, _shared.looseEqual)(value, vnode.props.value);
        el[assignKey] = getModelAssigner(vnode);
        addEventListener(el, "change", ()=>{
            el[assignKey](getValue(el));
        });
    },
    beforeUpdate (el, { value, oldValue }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        if (value !== oldValue) el.checked = (0, _shared.looseEqual)(value, vnode.props.value);
    }
};
const vModelSelect = {
    // <select multiple> value need to be deep traversed
    deep: true,
    created (el, { value, modifiers: { number } }, vnode) {
        const isSetModel = (0, _shared.isSet)(value);
        addEventListener(el, "change", ()=>{
            const selectedVal = Array.prototype.filter.call(el.options, (o)=>o.selected).map((o)=>number ? (0, _shared.looseToNumber)(getValue(o)) : getValue(o));
            el[assignKey](el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
            el._assigning = true;
            (0, _runtimeCore.nextTick)(()=>{
                el._assigning = false;
            });
        });
        el[assignKey] = getModelAssigner(vnode);
    },
    // set value in mounted & updated because <select> relies on its children
    // <option>s.
    mounted (el, { value, modifiers: { number } }) {
        setSelected(el, value);
    },
    beforeUpdate (el, _binding, vnode) {
        el[assignKey] = getModelAssigner(vnode);
    },
    updated (el, { value, modifiers: { number } }) {
        if (!el._assigning) setSelected(el, value);
    }
};
function setSelected(el, value, number) {
    const isMultiple = el.multiple;
    const isArrayValue = (0, _shared.isArray)(value);
    if (isMultiple && !isArrayValue && !(0, _shared.isSet)(value)) {
        (0, _runtimeCore.warn)(`<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);
        return;
    }
    for(let i = 0, l = el.options.length; i < l; i++){
        const option = el.options[i];
        const optionValue = getValue(option);
        if (isMultiple) {
            if (isArrayValue) {
                const optionType = typeof optionValue;
                if (optionType === "string" || optionType === "number") option.selected = value.some((v)=>String(v) === String(optionValue));
                else option.selected = (0, _shared.looseIndexOf)(value, optionValue) > -1;
            } else option.selected = value.has(optionValue);
        } else if ((0, _shared.looseEqual)(getValue(option), value)) {
            if (el.selectedIndex !== i) el.selectedIndex = i;
            return;
        }
    }
    if (!isMultiple && el.selectedIndex !== -1) el.selectedIndex = -1;
}
function getValue(el) {
    return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
    const key = checked ? "_trueValue" : "_falseValue";
    return key in el ? el[key] : checked;
}
const vModelDynamic = {
    created (el, binding, vnode) {
        callModelHook(el, binding, vnode, null, "created");
    },
    mounted (el, binding, vnode) {
        callModelHook(el, binding, vnode, null, "mounted");
    },
    beforeUpdate (el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
    },
    updated (el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, "updated");
    }
};
function resolveDynamicModel(tagName, type) {
    switch(tagName){
        case "SELECT":
            return vModelSelect;
        case "TEXTAREA":
            return vModelText;
        default:
            switch(type){
                case "checkbox":
                    return vModelCheckbox;
                case "radio":
                    return vModelRadio;
                default:
                    return vModelText;
            }
    }
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
    const modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);
    const fn = modelToUse[hook];
    fn && fn(el, binding, vnode, prevVNode);
}
function initVModelForSSR() {
    vModelText.getSSRProps = ({ value })=>({
            value
        });
    vModelRadio.getSSRProps = ({ value }, vnode)=>{
        if (vnode.props && (0, _shared.looseEqual)(vnode.props.value, value)) return {
            checked: true
        };
    };
    vModelCheckbox.getSSRProps = ({ value }, vnode)=>{
        if ((0, _shared.isArray)(value)) {
            if (vnode.props && (0, _shared.looseIndexOf)(value, vnode.props.value) > -1) return {
                checked: true
            };
        } else if ((0, _shared.isSet)(value)) {
            if (vnode.props && value.has(vnode.props.value)) return {
                checked: true
            };
        } else if (value) return {
            checked: true
        };
    };
    vModelDynamic.getSSRProps = (binding, vnode)=>{
        if (typeof vnode.type !== "string") return;
        const modelToUse = resolveDynamicModel(// resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
        vnode.type.toUpperCase(), vnode.props && vnode.props.type);
        if (modelToUse.getSSRProps) return modelToUse.getSSRProps(binding, vnode);
    };
}
const systemModifiers = [
    "ctrl",
    "shift",
    "alt",
    "meta"
];
const modifierGuards = {
    stop: (e)=>e.stopPropagation(),
    prevent: (e)=>e.preventDefault(),
    self: (e)=>e.target !== e.currentTarget,
    ctrl: (e)=>!e.ctrlKey,
    shift: (e)=>!e.shiftKey,
    alt: (e)=>!e.altKey,
    meta: (e)=>!e.metaKey,
    left: (e)=>"button" in e && e.button !== 0,
    middle: (e)=>"button" in e && e.button !== 1,
    right: (e)=>"button" in e && e.button !== 2,
    exact: (e, modifiers)=>systemModifiers.some((m)=>e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers)=>{
    const cache = fn._withMods || (fn._withMods = {});
    const cacheKey = modifiers.join(".");
    return cache[cacheKey] || (cache[cacheKey] = (event, ...args)=>{
        for(let i = 0; i < modifiers.length; i++){
            const guard = modifierGuards[modifiers[i]];
            if (guard && guard(event, modifiers)) return;
        }
        return fn(event, ...args);
    });
};
const keyNames = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
};
const withKeys = (fn, modifiers)=>{
    const cache = fn._withKeys || (fn._withKeys = {});
    const cacheKey = modifiers.join(".");
    return cache[cacheKey] || (cache[cacheKey] = (event)=>{
        if (!("key" in event)) return;
        const eventKey = (0, _shared.hyphenate)(event.key);
        if (modifiers.some((k)=>k === eventKey || keyNames[k] === eventKey)) return fn(event);
    });
};
const rendererOptions = /* @__PURE__ */ (0, _shared.extend)({
    patchProp
}, nodeOps);
let renderer;
let enabledHydration = false;
function ensureRenderer() {
    return renderer || (renderer = (0, _runtimeCore.createRenderer)(rendererOptions));
}
function ensureHydrationRenderer() {
    renderer = enabledHydration ? renderer : (0, _runtimeCore.createHydrationRenderer)(rendererOptions);
    enabledHydration = true;
    return renderer;
}
const render = (...args)=>{
    ensureRenderer().render(...args);
};
const hydrate = (...args)=>{
    ensureHydrationRenderer().hydrate(...args);
};
const createApp = (...args)=>{
    const app = ensureRenderer().createApp(...args);
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
    const { mount } = app;
    app.mount = (containerOrSelector)=>{
        const container = normalizeContainer(containerOrSelector);
        if (!container) return;
        const component = app._component;
        if (!(0, _shared.isFunction)(component) && !component.render && !component.template) component.template = container.innerHTML;
        container.innerHTML = "";
        const proxy = mount(container, false, resolveRootNamespace(container));
        if (container instanceof Element) {
            container.removeAttribute("v-cloak");
            container.setAttribute("data-v-app", "");
        }
        return proxy;
    };
    return app;
};
const createSSRApp = (...args)=>{
    const app = ensureHydrationRenderer().createApp(...args);
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
    const { mount } = app;
    app.mount = (containerOrSelector)=>{
        const container = normalizeContainer(containerOrSelector);
        if (container) return mount(container, true, resolveRootNamespace(container));
    };
    return app;
};
function resolveRootNamespace(container) {
    if (container instanceof SVGElement) return "svg";
    if (typeof MathMLElement === "function" && container instanceof MathMLElement) return "mathml";
}
function injectNativeTagCheck(app) {
    Object.defineProperty(app.config, "isNativeTag", {
        value: (tag)=>(0, _shared.isHTMLTag)(tag) || (0, _shared.isSVGTag)(tag) || (0, _shared.isMathMLTag)(tag),
        writable: false
    });
}
function injectCompilerOptionsCheck(app) {
    if ((0, _runtimeCore.isRuntimeOnly)()) {
        const isCustomElement = app.config.isCustomElement;
        Object.defineProperty(app.config, "isCustomElement", {
            get () {
                return isCustomElement;
            },
            set () {
                (0, _runtimeCore.warn)(`The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`);
            }
        });
        const compilerOptions = app.config.compilerOptions;
        const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;
        Object.defineProperty(app.config, "compilerOptions", {
            get () {
                (0, _runtimeCore.warn)(msg);
                return compilerOptions;
            },
            set () {
                (0, _runtimeCore.warn)(msg);
            }
        });
    }
}
function normalizeContainer(container) {
    if ((0, _shared.isString)(container)) {
        const res = document.querySelector(container);
        if (!res) (0, _runtimeCore.warn)(`Failed to mount app: mount target selector "${container}" returned null.`);
        return res;
    }
    if ((0, window.ShadowRoot) && container instanceof window.ShadowRoot && container.mode === "closed") (0, _runtimeCore.warn)(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
    return container;
}
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = ()=>{
    if (!ssrDirectiveInitialized) {
        ssrDirectiveInitialized = true;
        initVModelForSSR();
        initVShowForSSR();
    }
};

},{"@vue/runtime-core":"lmqBl","@vue/shared":"3SM3y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lmqBl":[function(require,module,exports) {
/**
* @vue/runtime-core v3.4.22
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EffectScope", ()=>(0, _reactivity.EffectScope));
parcelHelpers.export(exports, "ReactiveEffect", ()=>(0, _reactivity.ReactiveEffect));
parcelHelpers.export(exports, "TrackOpTypes", ()=>(0, _reactivity.TrackOpTypes));
parcelHelpers.export(exports, "TriggerOpTypes", ()=>(0, _reactivity.TriggerOpTypes));
parcelHelpers.export(exports, "customRef", ()=>(0, _reactivity.customRef));
parcelHelpers.export(exports, "effect", ()=>(0, _reactivity.effect));
parcelHelpers.export(exports, "effectScope", ()=>(0, _reactivity.effectScope));
parcelHelpers.export(exports, "getCurrentScope", ()=>(0, _reactivity.getCurrentScope));
parcelHelpers.export(exports, "isProxy", ()=>(0, _reactivity.isProxy));
parcelHelpers.export(exports, "isReactive", ()=>(0, _reactivity.isReactive));
parcelHelpers.export(exports, "isReadonly", ()=>(0, _reactivity.isReadonly));
parcelHelpers.export(exports, "isRef", ()=>(0, _reactivity.isRef));
parcelHelpers.export(exports, "isShallow", ()=>(0, _reactivity.isShallow));
parcelHelpers.export(exports, "markRaw", ()=>(0, _reactivity.markRaw));
parcelHelpers.export(exports, "onScopeDispose", ()=>(0, _reactivity.onScopeDispose));
parcelHelpers.export(exports, "proxyRefs", ()=>(0, _reactivity.proxyRefs));
parcelHelpers.export(exports, "reactive", ()=>(0, _reactivity.reactive));
parcelHelpers.export(exports, "readonly", ()=>(0, _reactivity.readonly));
parcelHelpers.export(exports, "ref", ()=>(0, _reactivity.ref));
parcelHelpers.export(exports, "shallowReactive", ()=>(0, _reactivity.shallowReactive));
parcelHelpers.export(exports, "shallowReadonly", ()=>(0, _reactivity.shallowReadonly));
parcelHelpers.export(exports, "shallowRef", ()=>(0, _reactivity.shallowRef));
parcelHelpers.export(exports, "stop", ()=>(0, _reactivity.stop));
parcelHelpers.export(exports, "toRaw", ()=>(0, _reactivity.toRaw));
parcelHelpers.export(exports, "toRef", ()=>(0, _reactivity.toRef));
parcelHelpers.export(exports, "toRefs", ()=>(0, _reactivity.toRefs));
parcelHelpers.export(exports, "toValue", ()=>(0, _reactivity.toValue));
parcelHelpers.export(exports, "triggerRef", ()=>(0, _reactivity.triggerRef));
parcelHelpers.export(exports, "unref", ()=>(0, _reactivity.unref));
parcelHelpers.export(exports, "camelize", ()=>(0, _shared.camelize));
parcelHelpers.export(exports, "capitalize", ()=>(0, _shared.capitalize));
parcelHelpers.export(exports, "normalizeClass", ()=>(0, _shared.normalizeClass));
parcelHelpers.export(exports, "normalizeProps", ()=>(0, _shared.normalizeProps));
parcelHelpers.export(exports, "normalizeStyle", ()=>(0, _shared.normalizeStyle));
parcelHelpers.export(exports, "toDisplayString", ()=>(0, _shared.toDisplayString));
parcelHelpers.export(exports, "toHandlerKey", ()=>(0, _shared.toHandlerKey));
parcelHelpers.export(exports, "BaseTransition", ()=>BaseTransition);
parcelHelpers.export(exports, "BaseTransitionPropsValidators", ()=>BaseTransitionPropsValidators);
parcelHelpers.export(exports, "Comment", ()=>Comment);
parcelHelpers.export(exports, "DeprecationTypes", ()=>DeprecationTypes);
parcelHelpers.export(exports, "ErrorCodes", ()=>ErrorCodes);
parcelHelpers.export(exports, "ErrorTypeStrings", ()=>ErrorTypeStrings);
parcelHelpers.export(exports, "Fragment", ()=>Fragment);
parcelHelpers.export(exports, "KeepAlive", ()=>KeepAlive);
parcelHelpers.export(exports, "Static", ()=>Static);
parcelHelpers.export(exports, "Suspense", ()=>Suspense);
parcelHelpers.export(exports, "Teleport", ()=>Teleport);
parcelHelpers.export(exports, "Text", ()=>Text);
parcelHelpers.export(exports, "assertNumber", ()=>assertNumber);
parcelHelpers.export(exports, "callWithAsyncErrorHandling", ()=>callWithAsyncErrorHandling);
parcelHelpers.export(exports, "callWithErrorHandling", ()=>callWithErrorHandling);
parcelHelpers.export(exports, "cloneVNode", ()=>cloneVNode);
parcelHelpers.export(exports, "compatUtils", ()=>compatUtils);
parcelHelpers.export(exports, "computed", ()=>computed);
parcelHelpers.export(exports, "createBlock", ()=>createBlock);
parcelHelpers.export(exports, "createCommentVNode", ()=>createCommentVNode);
parcelHelpers.export(exports, "createElementBlock", ()=>createElementBlock);
parcelHelpers.export(exports, "createElementVNode", ()=>createBaseVNode);
parcelHelpers.export(exports, "createHydrationRenderer", ()=>createHydrationRenderer);
parcelHelpers.export(exports, "createPropsRestProxy", ()=>createPropsRestProxy);
parcelHelpers.export(exports, "createRenderer", ()=>createRenderer);
parcelHelpers.export(exports, "createSlots", ()=>createSlots);
parcelHelpers.export(exports, "createStaticVNode", ()=>createStaticVNode);
parcelHelpers.export(exports, "createTextVNode", ()=>createTextVNode);
parcelHelpers.export(exports, "createVNode", ()=>createVNode);
parcelHelpers.export(exports, "defineAsyncComponent", ()=>defineAsyncComponent);
parcelHelpers.export(exports, "defineComponent", ()=>defineComponent);
parcelHelpers.export(exports, "defineEmits", ()=>defineEmits);
parcelHelpers.export(exports, "defineExpose", ()=>defineExpose);
parcelHelpers.export(exports, "defineModel", ()=>defineModel);
parcelHelpers.export(exports, "defineOptions", ()=>defineOptions);
parcelHelpers.export(exports, "defineProps", ()=>defineProps);
parcelHelpers.export(exports, "defineSlots", ()=>defineSlots);
parcelHelpers.export(exports, "devtools", ()=>devtools);
parcelHelpers.export(exports, "getCurrentInstance", ()=>getCurrentInstance);
parcelHelpers.export(exports, "getTransitionRawChildren", ()=>getTransitionRawChildren);
parcelHelpers.export(exports, "guardReactiveProps", ()=>guardReactiveProps);
parcelHelpers.export(exports, "h", ()=>h);
parcelHelpers.export(exports, "handleError", ()=>handleError);
parcelHelpers.export(exports, "hasInjectionContext", ()=>hasInjectionContext);
parcelHelpers.export(exports, "initCustomFormatter", ()=>initCustomFormatter);
parcelHelpers.export(exports, "inject", ()=>inject);
parcelHelpers.export(exports, "isMemoSame", ()=>isMemoSame);
parcelHelpers.export(exports, "isRuntimeOnly", ()=>isRuntimeOnly);
parcelHelpers.export(exports, "isVNode", ()=>isVNode);
parcelHelpers.export(exports, "mergeDefaults", ()=>mergeDefaults);
parcelHelpers.export(exports, "mergeModels", ()=>mergeModels);
parcelHelpers.export(exports, "mergeProps", ()=>mergeProps);
parcelHelpers.export(exports, "nextTick", ()=>nextTick);
parcelHelpers.export(exports, "onActivated", ()=>onActivated);
parcelHelpers.export(exports, "onBeforeMount", ()=>onBeforeMount);
parcelHelpers.export(exports, "onBeforeUnmount", ()=>onBeforeUnmount);
parcelHelpers.export(exports, "onBeforeUpdate", ()=>onBeforeUpdate);
parcelHelpers.export(exports, "onDeactivated", ()=>onDeactivated);
parcelHelpers.export(exports, "onErrorCaptured", ()=>onErrorCaptured);
parcelHelpers.export(exports, "onMounted", ()=>onMounted);
parcelHelpers.export(exports, "onRenderTracked", ()=>onRenderTracked);
parcelHelpers.export(exports, "onRenderTriggered", ()=>onRenderTriggered);
parcelHelpers.export(exports, "onServerPrefetch", ()=>onServerPrefetch);
parcelHelpers.export(exports, "onUnmounted", ()=>onUnmounted);
parcelHelpers.export(exports, "onUpdated", ()=>onUpdated);
parcelHelpers.export(exports, "openBlock", ()=>openBlock);
parcelHelpers.export(exports, "popScopeId", ()=>popScopeId);
parcelHelpers.export(exports, "provide", ()=>provide);
parcelHelpers.export(exports, "pushScopeId", ()=>pushScopeId);
parcelHelpers.export(exports, "queuePostFlushCb", ()=>queuePostFlushCb);
parcelHelpers.export(exports, "registerRuntimeCompiler", ()=>registerRuntimeCompiler);
parcelHelpers.export(exports, "renderList", ()=>renderList);
parcelHelpers.export(exports, "renderSlot", ()=>renderSlot);
parcelHelpers.export(exports, "resolveComponent", ()=>resolveComponent);
parcelHelpers.export(exports, "resolveDirective", ()=>resolveDirective);
parcelHelpers.export(exports, "resolveDynamicComponent", ()=>resolveDynamicComponent);
parcelHelpers.export(exports, "resolveFilter", ()=>resolveFilter);
parcelHelpers.export(exports, "resolveTransitionHooks", ()=>resolveTransitionHooks);
parcelHelpers.export(exports, "setBlockTracking", ()=>setBlockTracking);
parcelHelpers.export(exports, "setDevtoolsHook", ()=>setDevtoolsHook);
parcelHelpers.export(exports, "setTransitionHooks", ()=>setTransitionHooks);
parcelHelpers.export(exports, "ssrContextKey", ()=>ssrContextKey);
parcelHelpers.export(exports, "ssrUtils", ()=>ssrUtils);
parcelHelpers.export(exports, "toHandlers", ()=>toHandlers);
parcelHelpers.export(exports, "transformVNodeArgs", ()=>transformVNodeArgs);
parcelHelpers.export(exports, "useAttrs", ()=>useAttrs);
parcelHelpers.export(exports, "useModel", ()=>useModel);
parcelHelpers.export(exports, "useSSRContext", ()=>useSSRContext);
parcelHelpers.export(exports, "useSlots", ()=>useSlots);
parcelHelpers.export(exports, "useTransitionState", ()=>useTransitionState);
parcelHelpers.export(exports, "version", ()=>version);
parcelHelpers.export(exports, "warn", ()=>warn);
parcelHelpers.export(exports, "watch", ()=>watch);
parcelHelpers.export(exports, "watchEffect", ()=>watchEffect);
parcelHelpers.export(exports, "watchPostEffect", ()=>watchPostEffect);
parcelHelpers.export(exports, "watchSyncEffect", ()=>watchSyncEffect);
parcelHelpers.export(exports, "withAsyncContext", ()=>withAsyncContext);
parcelHelpers.export(exports, "withCtx", ()=>withCtx);
parcelHelpers.export(exports, "withDefaults", ()=>withDefaults);
parcelHelpers.export(exports, "withDirectives", ()=>withDirectives);
parcelHelpers.export(exports, "withMemo", ()=>withMemo);
parcelHelpers.export(exports, "withScopeId", ()=>withScopeId);
var _reactivity = require("@vue/reactivity");
var _shared = require("@vue/shared");
const stack = [];
function pushWarningContext(vnode) {
    stack.push(vnode);
}
function popWarningContext() {
    stack.pop();
}
function warn$1(msg, ...args) {
    (0, _reactivity.pauseTracking)();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) callWithErrorHandling(appWarnHandler, instance, 11, [
        msg + args.map((a)=>{
            var _a, _b;
            return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
        }).join(""),
        instance && instance.proxy,
        trace.map(({ vnode })=>`at <${formatComponentName(instance, vnode.type)}>`).join("\n"),
        trace
    ]);
    else {
        const warnArgs = [
            `[Vue warn]: ${msg}`,
            ...args
        ];
        if (trace.length && // avoid spamming console during tests
        true) warnArgs.push(`
`, ...formatTrace(trace));
        console.warn(...warnArgs);
    }
    (0, _reactivity.resetTracking)();
}
function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) return [];
    const normalizedStack = [];
    while(currentVNode){
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) last.recurseCount++;
        else normalizedStack.push({
            vnode: currentVNode,
            recurseCount: 0
        });
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
}
function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i)=>{
        logs.push(...i === 0 ? [] : [
            `
`
        ], ...formatTraceEntry(entry));
    });
    return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
    const close = `>` + postfix;
    return vnode.props ? [
        open,
        ...formatProps(vnode.props),
        close
    ] : [
        open + close
    ];
}
function formatProps(props) {
    const res = [];
    const keys = Object.keys(props);
    keys.slice(0, 3).forEach((key)=>{
        res.push(...formatProp(key, props[key]));
    });
    if (keys.length > 3) res.push(` ...`);
    return res;
}
function formatProp(key, value, raw) {
    if ((0, _shared.isString)(value)) {
        value = JSON.stringify(value);
        return raw ? value : [
            `${key}=${value}`
        ];
    } else if (typeof value === "number" || typeof value === "boolean" || value == null) return raw ? value : [
        `${key}=${value}`
    ];
    else if ((0, _reactivity.isRef)(value)) {
        value = formatProp(key, (0, _reactivity.toRaw)(value.value), true);
        return raw ? value : [
            `${key}=Ref<`,
            value,
            `>`
        ];
    } else if ((0, _shared.isFunction)(value)) return [
        `${key}=fn${value.name ? `<${value.name}>` : ``}`
    ];
    else {
        value = (0, _reactivity.toRaw)(value);
        return raw ? value : [
            `${key}=`,
            value
        ];
    }
}
function assertNumber(val, type) {
    if (val === void 0) return;
    else if (typeof val !== "number") warn$1(`${type} is not a valid number - got ${JSON.stringify(val)}.`);
    else if (isNaN(val)) warn$1(`${type} is NaN - the duration expression might be incorrect.`);
}
const ErrorCodes = {
    "SETUP_FUNCTION": 0,
    "0": "SETUP_FUNCTION",
    "RENDER_FUNCTION": 1,
    "1": "RENDER_FUNCTION",
    "WATCH_GETTER": 2,
    "2": "WATCH_GETTER",
    "WATCH_CALLBACK": 3,
    "3": "WATCH_CALLBACK",
    "WATCH_CLEANUP": 4,
    "4": "WATCH_CLEANUP",
    "NATIVE_EVENT_HANDLER": 5,
    "5": "NATIVE_EVENT_HANDLER",
    "COMPONENT_EVENT_HANDLER": 6,
    "6": "COMPONENT_EVENT_HANDLER",
    "VNODE_HOOK": 7,
    "7": "VNODE_HOOK",
    "DIRECTIVE_HOOK": 8,
    "8": "DIRECTIVE_HOOK",
    "TRANSITION_HOOK": 9,
    "9": "TRANSITION_HOOK",
    "APP_ERROR_HANDLER": 10,
    "10": "APP_ERROR_HANDLER",
    "APP_WARN_HANDLER": 11,
    "11": "APP_WARN_HANDLER",
    "FUNCTION_REF": 12,
    "12": "FUNCTION_REF",
    "ASYNC_COMPONENT_LOADER": 13,
    "13": "ASYNC_COMPONENT_LOADER",
    "SCHEDULER": 14,
    "14": "SCHEDULER"
};
const ErrorTypeStrings$1 = {
    ["sp"]: "serverPrefetch hook",
    ["bc"]: "beforeCreate hook",
    ["c"]: "created hook",
    ["bm"]: "beforeMount hook",
    ["m"]: "mounted hook",
    ["bu"]: "beforeUpdate hook",
    ["u"]: "updated",
    ["bum"]: "beforeUnmount hook",
    ["um"]: "unmounted hook",
    ["a"]: "activated hook",
    ["da"]: "deactivated hook",
    ["ec"]: "errorCaptured hook",
    ["rtc"]: "renderTracked hook",
    ["rtg"]: "renderTriggered hook",
    [0]: "setup function",
    [1]: "render function",
    [2]: "watcher getter",
    [3]: "watcher callback",
    [4]: "watcher cleanup function",
    [5]: "native event handler",
    [6]: "component event handler",
    [7]: "vnode hook",
    [8]: "directive hook",
    [9]: "transition hook",
    [10]: "app errorHandler",
    [11]: "app warnHandler",
    [12]: "ref function",
    [13]: "async component loader",
    [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://github.com/vuejs/core ."
};
function callWithErrorHandling(fn, instance, type, args) {
    try {
        return args ? fn(...args) : fn();
    } catch (err) {
        handleError(err, instance, type);
    }
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
    if ((0, _shared.isFunction)(fn)) {
        const res = callWithErrorHandling(fn, instance, type, args);
        if (res && (0, _shared.isPromise)(res)) res.catch((err)=>{
            handleError(err, instance, type);
        });
        return res;
    }
    if ((0, _shared.isArray)(fn)) {
        const values = [];
        for(let i = 0; i < fn.length; i++)values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
        return values;
    } else warn$1(`Invalid value type passed to callWithAsyncErrorHandling(): ${typeof fn}`);
}
function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    if (instance) {
        let cur = instance.parent;
        const exposedInstance = instance.proxy;
        const errorInfo = (0, ErrorTypeStrings$1[type]);
        while(cur){
            const errorCapturedHooks = cur.ec;
            if (errorCapturedHooks) for(let i = 0; i < errorCapturedHooks.length; i++){
                if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) return;
            }
            cur = cur.parent;
        }
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
            (0, _reactivity.pauseTracking)();
            callWithErrorHandling(appErrorHandler, null, 10, [
                err,
                exposedInstance,
                errorInfo
            ]);
            (0, _reactivity.resetTracking)();
            return;
        }
    }
    logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
    {
        const info = ErrorTypeStrings$1[type];
        if (contextVNode) pushWarningContext(contextVNode);
        warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
        if (contextVNode) popWarningContext();
        if (throwInDev) throw err;
        else console.error(err);
    }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
    const p = currentFlushPromise || resolvedPromise;
    return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
function findInsertionIndex(id) {
    let start = flushIndex + 1;
    let end = queue.length;
    while(start < end){
        const middle = start + end >>> 1;
        const middleJob = queue[middle];
        const middleJobId = getId(middleJob);
        if (middleJobId < id || middleJobId === id && middleJob.pre) start = middle + 1;
        else end = middle;
    }
    return start;
}
function queueJob(job) {
    if (!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {
        if (job.id == null) queue.push(job);
        else queue.splice(findInsertionIndex(job.id), 0, job);
        queueFlush();
    }
}
function queueFlush() {
    if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
    }
}
function invalidateJob(job) {
    const i = queue.indexOf(job);
    if (i > flushIndex) queue.splice(i, 1);
}
function queuePostFlushCb(cb) {
    if (!(0, _shared.isArray)(cb)) {
        if (!activePostFlushCbs || !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) pendingPostFlushCbs.push(cb);
    } else pendingPostFlushCbs.push(...cb);
    queueFlush();
}
function flushPreFlushCbs(instance, seen, i = isFlushing ? flushIndex + 1 : 0) {
    seen = seen || /* @__PURE__ */ new Map();
    for(; i < queue.length; i++){
        const cb = queue[i];
        if (cb && cb.pre) {
            if (instance && cb.id !== instance.uid) continue;
            if (checkRecursiveUpdates(seen, cb)) continue;
            queue.splice(i, 1);
            i--;
            cb();
        }
    }
}
function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
        const deduped = [
            ...new Set(pendingPostFlushCbs)
        ].sort((a, b)=>getId(a) - getId(b));
        pendingPostFlushCbs.length = 0;
        if (activePostFlushCbs) {
            activePostFlushCbs.push(...deduped);
            return;
        }
        activePostFlushCbs = deduped;
        seen = seen || /* @__PURE__ */ new Map();
        for(postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++){
            if (checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) continue;
            activePostFlushCbs[postFlushIndex]();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
    }
}
const getId = (job)=>job.id == null ? Infinity : job.id;
const comparator = (a, b)=>{
    const diff = getId(a) - getId(b);
    if (diff === 0) {
        if (a.pre && !b.pre) return -1;
        if (b.pre && !a.pre) return 1;
    }
    return diff;
};
function flushJobs(seen) {
    isFlushPending = false;
    isFlushing = true;
    seen = seen || /* @__PURE__ */ new Map();
    queue.sort(comparator);
    const check = (job)=>checkRecursiveUpdates(seen, job);
    try {
        for(flushIndex = 0; flushIndex < queue.length; flushIndex++){
            const job = queue[flushIndex];
            if (job && job.active !== false) {
                if (check(job)) continue;
                callWithErrorHandling(job, null, 14);
            }
        }
    } finally{
        flushIndex = 0;
        queue.length = 0;
        flushPostFlushCbs(seen);
        isFlushing = false;
        currentFlushPromise = null;
        if (queue.length || pendingPostFlushCbs.length) flushJobs(seen);
    }
}
function checkRecursiveUpdates(seen, fn) {
    if (!seen.has(fn)) seen.set(fn, 1);
    else {
        const count = seen.get(fn);
        if (count > RECURSION_LIMIT) {
            const instance = fn.ownerInstance;
            const componentName = instance && getComponentName(instance.type);
            handleError(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`, null, 10);
            return true;
        } else seen.set(fn, count + 1);
    }
}
let isHmrUpdating = false;
const hmrDirtyComponents = /* @__PURE__ */ new Set();
(0, _shared.getGlobalThis)().__VUE_HMR_RUNTIME__ = {
    createRecord: tryWrap(createRecord),
    rerender: tryWrap(rerender),
    reload: tryWrap(reload)
};
const map = /* @__PURE__ */ new Map();
function registerHMR(instance) {
    const id = instance.type.__hmrId;
    let record = map.get(id);
    if (!record) {
        createRecord(id, instance.type);
        record = map.get(id);
    }
    record.instances.add(instance);
}
function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).instances.delete(instance);
}
function createRecord(id, initialDef) {
    if (map.has(id)) return false;
    map.set(id, {
        initialDef: normalizeClassComponent(initialDef),
        instances: /* @__PURE__ */ new Set()
    });
    return true;
}
function normalizeClassComponent(component) {
    return isClassComponent(component) ? component.__vccOpts : component;
}
function rerender(id, newRender) {
    const record = map.get(id);
    if (!record) return;
    record.initialDef.render = newRender;
    [
        ...record.instances
    ].forEach((instance)=>{
        if (newRender) {
            instance.render = newRender;
            normalizeClassComponent(instance.type).render = newRender;
        }
        instance.renderCache = [];
        isHmrUpdating = true;
        instance.effect.dirty = true;
        instance.update();
        isHmrUpdating = false;
    });
}
function reload(id, newComp) {
    const record = map.get(id);
    if (!record) return;
    newComp = normalizeClassComponent(newComp);
    updateComponentDef(record.initialDef, newComp);
    const instances = [
        ...record.instances
    ];
    for (const instance of instances){
        const oldComp = normalizeClassComponent(instance.type);
        if (!hmrDirtyComponents.has(oldComp)) {
            if (oldComp !== record.initialDef) updateComponentDef(oldComp, newComp);
            hmrDirtyComponents.add(oldComp);
        }
        instance.appContext.propsCache.delete(instance.type);
        instance.appContext.emitsCache.delete(instance.type);
        instance.appContext.optionsCache.delete(instance.type);
        if (instance.ceReload) {
            hmrDirtyComponents.add(oldComp);
            instance.ceReload(newComp.styles);
            hmrDirtyComponents.delete(oldComp);
        } else if (instance.parent) {
            instance.parent.effect.dirty = true;
            queueJob(instance.parent.update);
        } else if (instance.appContext.reload) instance.appContext.reload();
        else if (typeof window !== "undefined") window.location.reload();
        else console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
    }
    queuePostFlushCb(()=>{
        for (const instance of instances)hmrDirtyComponents.delete(normalizeClassComponent(instance.type));
    });
}
function updateComponentDef(oldComp, newComp) {
    (0, _shared.extend)(oldComp, newComp);
    for(const key in oldComp)if (key !== "__file" && !(key in newComp)) delete oldComp[key];
}
function tryWrap(fn) {
    return (id, arg)=>{
        try {
            return fn(id, arg);
        } catch (e) {
            console.error(e);
            console.warn(`[HMR] Something went wrong during Vue component hot-reload. Full reload required.`);
        }
    };
}
let devtools$1;
let buffer = [];
let devtoolsNotInstalled = false;
function emit$1(event, ...args) {
    if (devtools$1) devtools$1.emit(event, ...args);
    else if (!devtoolsNotInstalled) buffer.push({
        event,
        args
    });
}
function setDevtoolsHook$1(hook, target) {
    var _a, _b;
    devtools$1 = hook;
    if (devtools$1) {
        devtools$1.enabled = true;
        buffer.forEach(({ event, args })=>devtools$1.emit(event, ...args));
        buffer = [];
    } else if (// handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== "undefined" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))) {
        const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
        replay.push((newHook)=>{
            setDevtoolsHook$1(newHook, target);
        });
        setTimeout(()=>{
            if (!devtools$1) {
                target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
                devtoolsNotInstalled = true;
                buffer = [];
            }
        }, 3e3);
    } else {
        devtoolsNotInstalled = true;
        buffer = [];
    }
}
function devtoolsInitApp(app, version) {
    emit$1("app:init" /* APP_INIT */ , app, version, {
        Fragment,
        Text,
        Comment,
        Static
    });
}
function devtoolsUnmountApp(app) {
    emit$1("app:unmount" /* APP_UNMOUNT */ , app);
}
const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook("component:added" /* COMPONENT_ADDED */ );
const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook("component:updated" /* COMPONENT_UPDATED */ );
const _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook("component:removed" /* COMPONENT_REMOVED */ );
const devtoolsComponentRemoved = (component)=>{
    if (devtools$1 && typeof devtools$1.cleanupBuffer === "function" && // remove the component if it wasn't buffered
    !devtools$1.cleanupBuffer(component)) _devtoolsComponentRemoved(component);
};
/*! #__NO_SIDE_EFFECTS__ */ // @__NO_SIDE_EFFECTS__
function createDevtoolsComponentHook(hook) {
    return (component)=>{
        emit$1(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : void 0, component);
    };
}
const devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:start" /* PERFORMANCE_START */ );
const devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:end" /* PERFORMANCE_END */ );
function createDevtoolsPerformanceHook(hook) {
    return (component, type, time)=>{
        emit$1(hook, component.appContext.app, component.uid, component, type, time);
    };
}
function devtoolsComponentEmit(component, event, params) {
    emit$1("component:emit" /* COMPONENT_EMIT */ , component.appContext.app, component, event, params);
}
function emit(instance, event, ...rawArgs) {
    if (instance.isUnmounted) return;
    const props = instance.vnode.props || (0, _shared.EMPTY_OBJ);
    {
        const { emitsOptions, propsOptions: [propsOptions] } = instance;
        if (emitsOptions) {
            if (!(event in emitsOptions) && true) {
                if (!propsOptions || !((0, _shared.toHandlerKey)(event) in propsOptions)) warn$1(`Component emitted event "${event}" but it is neither declared in the emits option nor as an "${(0, _shared.toHandlerKey)(event)}" prop.`);
            } else {
                const validator = emitsOptions[event];
                if ((0, _shared.isFunction)(validator)) {
                    const isValid = validator(...rawArgs);
                    if (!isValid) warn$1(`Invalid event arguments: event validation failed for event "${event}".`);
                }
            }
        }
    }
    let args = rawArgs;
    const isModelListener = event.startsWith("update:");
    const modelArg = isModelListener && event.slice(7);
    if (modelArg && modelArg in props) {
        const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
        const { number, trim } = props[modifiersKey] || (0, _shared.EMPTY_OBJ);
        if (trim) args = rawArgs.map((a)=>(0, _shared.isString)(a) ? a.trim() : a);
        if (number) args = rawArgs.map((0, _shared.looseToNumber));
    }
    devtoolsComponentEmit(instance, event, args);
    {
        const lowerCaseEvent = event.toLowerCase();
        if (lowerCaseEvent !== event && props[(0, _shared.toHandlerKey)(lowerCaseEvent)]) warn$1(`Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(instance, instance.type)} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${(0, _shared.hyphenate)(event)}" instead of "${event}".`);
    }
    let handlerName;
    let handler = props[handlerName = (0, _shared.toHandlerKey)(event)] || // also try camelCase event handler (#2249)
    props[handlerName = (0, _shared.toHandlerKey)((0, _shared.camelize)(event))];
    if (!handler && isModelListener) handler = props[handlerName = (0, _shared.toHandlerKey)((0, _shared.hyphenate)(event))];
    if (handler) callWithAsyncErrorHandling(handler, instance, 6, args);
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
        if (!instance.emitted) instance.emitted = {};
        else if (instance.emitted[handlerName]) return;
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(onceHandler, instance, 6, args);
    }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.emitsCache;
    const cached = cache.get(comp);
    if (cached !== void 0) return cached;
    const raw = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !(0, _shared.isFunction)(comp)) {
        const extendEmits = (raw2)=>{
            const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
            if (normalizedFromExtend) {
                hasExtends = true;
                (0, _shared.extend)(normalized, normalizedFromExtend);
            }
        };
        if (!asMixin && appContext.mixins.length) appContext.mixins.forEach(extendEmits);
        if (comp.extends) extendEmits(comp.extends);
        if (comp.mixins) comp.mixins.forEach(extendEmits);
    }
    if (!raw && !hasExtends) {
        if ((0, _shared.isObject)(comp)) cache.set(comp, null);
        return null;
    }
    if ((0, _shared.isArray)(raw)) raw.forEach((key)=>normalized[key] = null);
    else (0, _shared.extend)(normalized, raw);
    if ((0, _shared.isObject)(comp)) cache.set(comp, normalized);
    return normalized;
}
function isEmitListener(options, key) {
    if (!options || !(0, _shared.isOn)(key)) return false;
    key = key.slice(2).replace(/Once$/, "");
    return (0, _shared.hasOwn)(options, key[0].toLowerCase() + key.slice(1)) || (0, _shared.hasOwn)(options, (0, _shared.hyphenate)(key)) || (0, _shared.hasOwn)(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
}
function pushScopeId(id) {
    currentScopeId = id;
}
function popScopeId() {
    currentScopeId = null;
}
const withScopeId = (_id)=>withCtx;
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx) return fn;
    if (fn._n) return fn;
    const renderFnWithContext = (...args)=>{
        if (renderFnWithContext._d) setBlockTracking(-1);
        const prevInstance = setCurrentRenderingInstance(ctx);
        let res;
        try {
            res = fn(...args);
        } finally{
            setCurrentRenderingInstance(prevInstance);
            if (renderFnWithContext._d) setBlockTracking(1);
        }
        devtoolsComponentUpdated(ctx);
        return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
}
let accessedAttrs = false;
function markAttrsAccessed() {
    accessedAttrs = true;
}
function renderComponentRoot(instance) {
    const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx, inheritAttrs } = instance;
    let result;
    let fallthroughAttrs;
    const prev = setCurrentRenderingInstance(instance);
    accessedAttrs = false;
    try {
        if (vnode.shapeFlag & 4) {
            const proxyToUse = withProxy || proxy;
            const thisProxy = (0, setupState.__isScriptSetup) ? new Proxy(proxyToUse, {
                get (target, key, receiver) {
                    warn$1(`Property '${String(key)}' was accessed via 'this'. Avoid using 'this' in templates.`);
                    return Reflect.get(target, key, receiver);
                }
            }) : proxyToUse;
            result = normalizeVNode(render.call(thisProxy, proxyToUse, renderCache, props, setupState, data, ctx));
            fallthroughAttrs = attrs;
        } else {
            const render2 = Component;
            if (attrs === props) markAttrsAccessed();
            result = normalizeVNode(render2.length > 1 ? render2(props, {
                get attrs () {
                    markAttrsAccessed();
                    return attrs;
                },
                slots,
                emit
            }) : render2(props, null));
            fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
        }
    } catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1);
        result = createVNode(Comment);
    }
    let root = result;
    let setRoot = void 0;
    if (result.patchFlag > 0 && result.patchFlag & 2048) [root, setRoot] = getChildRoot(result);
    if (fallthroughAttrs && inheritAttrs !== false) {
        const keys = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root;
        if (keys.length) {
            if (shapeFlag & 7) {
                if (propsOptions && keys.some((0, _shared.isModelListener))) fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
                root = cloneVNode(root, fallthroughAttrs);
            } else if (!accessedAttrs && root.type !== Comment) {
                const allAttrs = Object.keys(attrs);
                const eventAttrs = [];
                const extraAttrs = [];
                for(let i = 0, l = allAttrs.length; i < l; i++){
                    const key = allAttrs[i];
                    if ((0, _shared.isOn)(key)) {
                        if (!(0, _shared.isModelListener)(key)) eventAttrs.push(key[2].toLowerCase() + key.slice(3));
                    } else extraAttrs.push(key);
                }
                if (extraAttrs.length) warn$1(`Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`);
                if (eventAttrs.length) warn$1(`Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`);
            }
        }
    }
    if (vnode.dirs) {
        if (!isElementRoot(root)) warn$1(`Runtime directive used on component with non-element root node. The directives will not function as intended.`);
        root = cloneVNode(root);
        root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
        if (!isElementRoot(root)) warn$1(`Component inside <Transition> renders non-element root node that cannot be animated.`);
        root.transition = vnode.transition;
    }
    if (setRoot) setRoot(root);
    else result = root;
    setCurrentRenderingInstance(prev);
    return result;
}
const getChildRoot = (vnode)=>{
    const rawChildren = vnode.children;
    const dynamicChildren = vnode.dynamicChildren;
    const childRoot = filterSingleRoot(rawChildren, false);
    if (!childRoot) return [
        vnode,
        void 0
    ];
    else if (childRoot.patchFlag > 0 && childRoot.patchFlag & 2048) return getChildRoot(childRoot);
    const index = rawChildren.indexOf(childRoot);
    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
    const setRoot = (updatedRoot)=>{
        rawChildren[index] = updatedRoot;
        if (dynamicChildren) {
            if (dynamicIndex > -1) dynamicChildren[dynamicIndex] = updatedRoot;
            else if (updatedRoot.patchFlag > 0) vnode.dynamicChildren = [
                ...dynamicChildren,
                updatedRoot
            ];
        }
    };
    return [
        normalizeVNode(childRoot),
        setRoot
    ];
};
function filterSingleRoot(children, recurse = true) {
    let singleRoot;
    for(let i = 0; i < children.length; i++){
        const child = children[i];
        if (isVNode(child)) {
            if (child.type !== Comment || child.children === "v-if") {
                if (singleRoot) return;
                else {
                    singleRoot = child;
                    if (recurse && singleRoot.patchFlag > 0 && singleRoot.patchFlag & 2048) return filterSingleRoot(singleRoot.children);
                }
            }
        } else return;
    }
    return singleRoot;
}
const getFunctionalFallthrough = (attrs)=>{
    let res;
    for(const key in attrs)if (key === "class" || key === "style" || (0, _shared.isOn)(key)) (res || (res = {}))[key] = attrs[key];
    return res;
};
const filterModelListeners = (attrs, props)=>{
    const res = {};
    for(const key in attrs)if (!(0, _shared.isModelListener)(key) || !(key.slice(9) in props)) res[key] = attrs[key];
    return res;
};
const isElementRoot = (vnode)=>{
    return vnode.shapeFlag & 7 || vnode.type === Comment;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    if ((prevChildren || nextChildren) && isHmrUpdating) return true;
    if (nextVNode.dirs || nextVNode.transition) return true;
    if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024) return true;
        if (patchFlag & 16) {
            if (!prevProps) return !!nextProps;
            return hasPropsChanged(prevProps, nextProps, emits);
        } else if (patchFlag & 8) {
            const dynamicProps = nextVNode.dynamicProps;
            for(let i = 0; i < dynamicProps.length; i++){
                const key = dynamicProps[i];
                if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) return true;
            }
        }
    } else {
        if (prevChildren || nextChildren) {
            if (!nextChildren || !nextChildren.$stable) return true;
        }
        if (prevProps === nextProps) return false;
        if (!prevProps) return !!nextProps;
        if (!nextProps) return true;
        return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) return true;
    for(let i = 0; i < nextKeys.length; i++){
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) return true;
    }
    return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
    while(parent){
        const root = parent.subTree;
        if (root.suspense && root.suspense.activeBranch === vnode) root.el = vnode.el;
        if (root === vnode) {
            (vnode = parent.vnode).el = el;
            parent = parent.parent;
        } else break;
    }
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
    if ((0, _shared.isString)(component)) return resolveAsset(COMPONENTS, component, false) || component;
    else return component || NULL_DYNAMIC_COMPONENT;
}
function resolveDirective(name) {
    return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
        const Component = instance.type;
        if (type === COMPONENTS) {
            const selfName = getComponentName(Component, false);
            if (selfName && (selfName === name || selfName === (0, _shared.camelize)(name) || selfName === (0, _shared.capitalize)((0, _shared.camelize)(name)))) return Component;
        }
        const res = // local registration
        // check instance[type] first which is resolved for options API
        resolve(instance[type] || Component[type], name) || // global registration
        resolve(instance.appContext[type], name);
        if (!res && maybeSelfReference) return Component;
        if (warnMissing && !res) {
            const extra = type === COMPONENTS ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
            warn$1(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
        }
        return res;
    } else warn$1(`resolve${(0, _shared.capitalize)(type.slice(0, -1))} can only be used in render() or setup().`);
}
function resolve(registry, name) {
    return registry && (registry[name] || registry[(0, _shared.camelize)(name)] || registry[(0, _shared.capitalize)((0, _shared.camelize)(name))]);
}
const isSuspense = (type)=>type.__isSuspense;
let suspenseId = 0;
const SuspenseImpl = {
    name: "Suspense",
    // In order to make Suspense tree-shakable, we need to avoid importing it
    // directly in the renderer. The renderer checks for the __isSuspense flag
    // on a vnode's type and calls the `process` method, passing in renderer
    // internals.
    __isSuspense: true,
    process (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
        if (n1 == null) mountSuspense(n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals);
        else {
            if (parentSuspense && parentSuspense.deps > 0 && !n1.suspense.isInFallback) {
                n2.suspense = n1.suspense;
                n2.suspense.vnode = n2;
                n2.el = n1.el;
                return;
            }
            patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, rendererInternals);
        }
    },
    hydrate: hydrateSuspense,
    create: createSuspenseBoundary,
    normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl;
function triggerEvent(vnode, name) {
    const eventListener = vnode.props && vnode.props[name];
    if ((0, _shared.isFunction)(eventListener)) eventListener();
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
    const { p: patch, o: { createElement } } = rendererInternals;
    const hiddenContainer = createElement("div");
    const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals);
    patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, namespace, slotScopeIds);
    if (suspense.deps > 0) {
        triggerEvent(vnode, "onPending");
        triggerEvent(vnode, "onFallback");
        patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
        namespace, slotScopeIds);
        setActiveBranch(suspense, vnode.ssFallback);
    } else suspense.resolve(false, true);
}
function patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
    const suspense = n2.suspense = n1.suspense;
    suspense.vnode = n2;
    n2.el = n1.el;
    const newBranch = n2.ssContent;
    const newFallback = n2.ssFallback;
    const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
    if (pendingBranch) {
        suspense.pendingBranch = newBranch;
        if (isSameVNodeType(newBranch, pendingBranch)) {
            patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, namespace, slotScopeIds, optimized);
            if (suspense.deps <= 0) suspense.resolve();
            else if (isInFallback) {
                if (!isHydrating) {
                    patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                    namespace, slotScopeIds, optimized);
                    setActiveBranch(suspense, newFallback);
                }
            }
        } else {
            suspense.pendingId = suspenseId++;
            if (isHydrating) {
                suspense.isHydrating = false;
                suspense.activeBranch = pendingBranch;
            } else unmount(pendingBranch, parentComponent, suspense);
            suspense.deps = 0;
            suspense.effects.length = 0;
            suspense.hiddenContainer = createElement("div");
            if (isInFallback) {
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, namespace, slotScopeIds, optimized);
                if (suspense.deps <= 0) suspense.resolve();
                else {
                    patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                    namespace, slotScopeIds, optimized);
                    setActiveBranch(suspense, newFallback);
                }
            } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
                patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, namespace, slotScopeIds, optimized);
                suspense.resolve(true);
            } else {
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, namespace, slotScopeIds, optimized);
                if (suspense.deps <= 0) suspense.resolve();
            }
        }
    } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, namespace, slotScopeIds, optimized);
        setActiveBranch(suspense, newBranch);
    } else {
        triggerEvent(n2, "onPending");
        suspense.pendingBranch = newBranch;
        if (newBranch.shapeFlag & 512) suspense.pendingId = newBranch.component.suspenseId;
        else suspense.pendingId = suspenseId++;
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, namespace, slotScopeIds, optimized);
        if (suspense.deps <= 0) suspense.resolve();
        else {
            const { timeout, pendingId } = suspense;
            if (timeout > 0) setTimeout(()=>{
                if (suspense.pendingId === pendingId) suspense.fallback(newFallback);
            }, timeout);
            else if (timeout === 0) suspense.fallback(newFallback);
        }
    }
}
let hasWarned = false;
function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
    if (!hasWarned) {
        hasWarned = true;
        console[console.info ? "info" : "log"](`<Suspense> is an experimental feature and its API will likely change.`);
    }
    const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove } } = rendererInternals;
    let parentSuspenseId;
    const isSuspensible = isVNodeSuspensible(vnode);
    if (isSuspensible) {
        if (parentSuspense == null ? void 0 : parentSuspense.pendingBranch) {
            parentSuspenseId = parentSuspense.pendingId;
            parentSuspense.deps++;
        }
    }
    const timeout = vnode.props ? (0, _shared.toNumber)(vnode.props.timeout) : void 0;
    assertNumber(timeout, `Suspense timeout`);
    const initialAnchor = anchor;
    const suspense = {
        vnode,
        parent: parentSuspense,
        parentComponent,
        namespace,
        container,
        hiddenContainer,
        deps: 0,
        pendingId: suspenseId++,
        timeout: typeof timeout === "number" ? timeout : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: !isHydrating,
        isHydrating,
        isUnmounted: false,
        effects: [],
        resolve (resume = false, sync = false) {
            if (!resume && !suspense.pendingBranch) throw new Error(`suspense.resolve() is called without a pending branch.`);
            if (suspense.isUnmounted) throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);
            const { vnode: vnode2, activeBranch, pendingBranch, pendingId, effects, parentComponent: parentComponent2, container: container2 } = suspense;
            let delayEnter = false;
            if (suspense.isHydrating) suspense.isHydrating = false;
            else if (!resume) {
                delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
                if (delayEnter) activeBranch.transition.afterLeave = ()=>{
                    if (pendingId === suspense.pendingId) {
                        move(pendingBranch, container2, anchor === initialAnchor ? next(activeBranch) : anchor, 0);
                        queuePostFlushCb(effects);
                    }
                };
                if (activeBranch) {
                    if (parentNode(activeBranch.el) !== suspense.hiddenContainer) anchor = next(activeBranch);
                    unmount(activeBranch, parentComponent2, suspense, true);
                }
                if (!delayEnter) move(pendingBranch, container2, anchor, 0);
            }
            setActiveBranch(suspense, pendingBranch);
            suspense.pendingBranch = null;
            suspense.isInFallback = false;
            let parent = suspense.parent;
            let hasUnresolvedAncestor = false;
            while(parent){
                if (parent.pendingBranch) {
                    parent.effects.push(...effects);
                    hasUnresolvedAncestor = true;
                    break;
                }
                parent = parent.parent;
            }
            if (!hasUnresolvedAncestor && !delayEnter) queuePostFlushCb(effects);
            suspense.effects = [];
            if (isSuspensible) {
                if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
                    parentSuspense.deps--;
                    if (parentSuspense.deps === 0 && !sync) parentSuspense.resolve();
                }
            }
            triggerEvent(vnode2, "onResolve");
        },
        fallback (fallbackVNode) {
            if (!suspense.pendingBranch) return;
            const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, namespace: namespace2 } = suspense;
            triggerEvent(vnode2, "onFallback");
            const anchor2 = next(activeBranch);
            const mountFallback = ()=>{
                if (!suspense.isInFallback) return;
                patch(null, fallbackVNode, container2, anchor2, parentComponent2, null, // fallback tree will not have suspense context
                namespace2, slotScopeIds, optimized);
                setActiveBranch(suspense, fallbackVNode);
            };
            const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
            if (delayEnter) activeBranch.transition.afterLeave = mountFallback;
            suspense.isInFallback = true;
            unmount(activeBranch, parentComponent2, null, // no suspense so unmount hooks fire now
            true);
            if (!delayEnter) mountFallback();
        },
        move (container2, anchor2, type) {
            suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
            suspense.container = container2;
        },
        next () {
            return suspense.activeBranch && next(suspense.activeBranch);
        },
        registerDep (instance, setupRenderEffect) {
            const isInPendingSuspense = !!suspense.pendingBranch;
            if (isInPendingSuspense) suspense.deps++;
            const hydratedEl = instance.vnode.el;
            instance.asyncDep.catch((err)=>{
                handleError(err, instance, 0);
            }).then((asyncSetupResult)=>{
                if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) return;
                instance.asyncResolved = true;
                const { vnode: vnode2 } = instance;
                pushWarningContext(vnode2);
                handleSetupResult(instance, asyncSetupResult, false);
                if (hydratedEl) vnode2.el = hydratedEl;
                const placeholder = !hydratedEl && instance.subTree.el;
                setupRenderEffect(instance, vnode2, // component may have been moved before resolve.
                // if this is not a hydration, instance.subTree will be the comment
                // placeholder.
                parentNode(hydratedEl || instance.subTree.el), // anchor will not be used if this is hydration, so only need to
                // consider the comment placeholder case.
                hydratedEl ? null : next(instance.subTree), suspense, namespace, optimized);
                if (placeholder) remove(placeholder);
                updateHOCHostEl(instance, vnode2.el);
                popWarningContext();
                if (isInPendingSuspense && --suspense.deps === 0) suspense.resolve();
            });
        },
        unmount (parentSuspense2, doRemove) {
            suspense.isUnmounted = true;
            if (suspense.activeBranch) unmount(suspense.activeBranch, parentComponent, parentSuspense2, doRemove);
            if (suspense.pendingBranch) unmount(suspense.pendingBranch, parentComponent, parentSuspense2, doRemove);
        }
    };
    return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals, hydrateNode) {
    const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, // eslint-disable-next-line no-restricted-globals
    document.createElement("div"), null, namespace, slotScopeIds, optimized, rendererInternals, true);
    const result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);
    if (suspense.deps === 0) suspense.resolve(false, true);
    return result;
}
function normalizeSuspenseChildren(vnode) {
    const { shapeFlag, children } = vnode;
    const isSlotChildren = shapeFlag & 32;
    vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
    vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
    let block;
    if ((0, _shared.isFunction)(s)) {
        const trackBlock = isBlockTreeEnabled && s._c;
        if (trackBlock) {
            s._d = false;
            openBlock();
        }
        s = s();
        if (trackBlock) {
            s._d = true;
            block = currentBlock;
            closeBlock();
        }
    }
    if ((0, _shared.isArray)(s)) {
        const singleChild = filterSingleRoot(s);
        if (!singleChild && s.filter((child)=>child !== NULL_DYNAMIC_COMPONENT).length > 0) warn$1(`<Suspense> slots expect a single root node.`);
        s = singleChild;
    }
    s = normalizeVNode(s);
    if (block && !s.dynamicChildren) s.dynamicChildren = block.filter((c)=>c !== s);
    return s;
}
function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
        if ((0, _shared.isArray)(fn)) suspense.effects.push(...fn);
        else suspense.effects.push(fn);
    } else queuePostFlushCb(fn);
}
function setActiveBranch(suspense, branch) {
    suspense.activeBranch = branch;
    const { vnode, parentComponent } = suspense;
    let el = branch.el;
    while(!el && branch.component){
        branch = branch.component.subTree;
        el = branch.el;
    }
    vnode.el = el;
    if (parentComponent && parentComponent.subTree === vnode) {
        parentComponent.vnode.el = el;
        updateHOCHostEl(parentComponent, el);
    }
}
function isVNodeSuspensible(vnode) {
    var _a;
    return ((_a = vnode.props) == null ? void 0 : _a.suspensible) != null && vnode.props.suspensible !== false;
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = ()=>{
    {
        const ctx = inject(ssrContextKey);
        if (!ctx) warn$1(`Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`);
        return ctx;
    }
};
function watchEffect(effect, options) {
    return doWatch(effect, null, options);
}
function watchPostEffect(effect, options) {
    return doWatch(effect, null, (0, _shared.extend)({}, options, {
        flush: "post"
    }));
}
function watchSyncEffect(effect, options) {
    return doWatch(effect, null, (0, _shared.extend)({}, options, {
        flush: "sync"
    }));
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
    if (!(0, _shared.isFunction)(cb)) warn$1(`\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`);
    return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, once, onTrack, onTrigger } = (0, _shared.EMPTY_OBJ)) {
    if (cb && once) {
        const _cb = cb;
        cb = (...args)=>{
            _cb(...args);
            unwatch();
        };
    }
    if (deep !== void 0 && typeof deep === "number") warn$1(`watch() "deep" option with number value will be used as watch depth in future versions. Please use a boolean instead to avoid potential breakage.`);
    if (!cb) {
        if (immediate !== void 0) warn$1(`watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`);
        if (deep !== void 0) warn$1(`watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`);
        if (once !== void 0) warn$1(`watch() "once" option is only respected when using the watch(source, callback, options?) signature.`);
    }
    const warnInvalidSource = (s)=>{
        warn$1(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`);
    };
    const instance = currentInstance;
    const reactiveGetter = (source2)=>deep === true ? source2 : // for deep: false, only traverse root-level properties
        traverse(source2, deep === false ? 1 : void 0);
    let getter;
    let forceTrigger = false;
    let isMultiSource = false;
    if ((0, _reactivity.isRef)(source)) {
        getter = ()=>source.value;
        forceTrigger = (0, _reactivity.isShallow)(source);
    } else if ((0, _reactivity.isReactive)(source)) {
        getter = ()=>reactiveGetter(source);
        forceTrigger = true;
    } else if ((0, _shared.isArray)(source)) {
        isMultiSource = true;
        forceTrigger = source.some((s)=>(0, _reactivity.isReactive)(s) || (0, _reactivity.isShallow)(s));
        getter = ()=>source.map((s)=>{
                if ((0, _reactivity.isRef)(s)) return s.value;
                else if ((0, _reactivity.isReactive)(s)) return reactiveGetter(s);
                else if ((0, _shared.isFunction)(s)) return callWithErrorHandling(s, instance, 2);
                else warnInvalidSource(s);
            });
    } else if ((0, _shared.isFunction)(source)) {
        if (cb) getter = ()=>callWithErrorHandling(source, instance, 2);
        else getter = ()=>{
            if (cleanup) cleanup();
            return callWithAsyncErrorHandling(source, instance, 3, [
                onCleanup
            ]);
        };
    } else {
        getter = (0, _shared.NOOP);
        warnInvalidSource(source);
    }
    if (cb && deep) {
        const baseGetter = getter;
        getter = ()=>traverse(baseGetter());
    }
    let cleanup;
    let onCleanup = (fn)=>{
        cleanup = effect.onStop = ()=>{
            callWithErrorHandling(fn, instance, 4);
            cleanup = effect.onStop = void 0;
        };
    };
    let ssrCleanup;
    if (isInSSRComponentSetup) {
        onCleanup = (0, _shared.NOOP);
        if (!cb) getter();
        else if (immediate) callWithAsyncErrorHandling(cb, instance, 3, [
            getter(),
            isMultiSource ? [] : void 0,
            onCleanup
        ]);
        if (flush === "sync") {
            const ctx = useSSRContext();
            ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
        } else return 0, _shared.NOOP;
    }
    let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    const job = ()=>{
        if (!effect.active || !effect.dirty) return;
        if (cb) {
            const newValue = effect.run();
            if (deep || forceTrigger || (isMultiSource ? newValue.some((v1, i)=>(0, _shared.hasChanged)(v1, oldValue[i])) : (0, _shared.hasChanged)(newValue, oldValue)) || false) {
                if (cleanup) cleanup();
                callWithAsyncErrorHandling(cb, instance, 3, [
                    newValue,
                    // pass undefined as the old value when it's changed for the first time
                    oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
                    onCleanup
                ]);
                oldValue = newValue;
            }
        } else effect.run();
    };
    job.allowRecurse = !!cb;
    let scheduler;
    if (flush === "sync") scheduler = job;
    else if (flush === "post") scheduler = ()=>queuePostRenderEffect(job, instance && instance.suspense);
    else {
        job.pre = true;
        if (instance) job.id = instance.uid;
        scheduler = ()=>queueJob(job);
    }
    const effect = new (0, _reactivity.ReactiveEffect)(getter, (0, _shared.NOOP), scheduler);
    const scope = (0, _reactivity.getCurrentScope)();
    const unwatch = ()=>{
        effect.stop();
        if (scope) (0, _shared.remove)(scope.effects, effect);
    };
    effect.onTrack = onTrack;
    effect.onTrigger = onTrigger;
    if (cb) {
        if (immediate) job();
        else oldValue = effect.run();
    } else if (flush === "post") queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
    else effect.run();
    if (ssrCleanup) ssrCleanup.push(unwatch);
    return unwatch;
}
function instanceWatch(source, value, options) {
    const publicThis = this.proxy;
    const getter = (0, _shared.isString)(source) ? source.includes(".") ? createPathGetter(publicThis, source) : ()=>publicThis[source] : source.bind(publicThis, publicThis);
    let cb;
    if ((0, _shared.isFunction)(value)) cb = value;
    else {
        cb = value.handler;
        options = value;
    }
    const reset = setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    reset();
    return res;
}
function createPathGetter(ctx, path) {
    const segments = path.split(".");
    return ()=>{
        let cur = ctx;
        for(let i = 0; i < segments.length && cur; i++)cur = cur[segments[i]];
        return cur;
    };
}
function traverse(value, depth, currentDepth = 0, seen) {
    if (!(0, _shared.isObject)(value) || value["__v_skip"]) return value;
    if (depth && depth > 0) {
        if (currentDepth >= depth) return value;
        currentDepth++;
    }
    seen = seen || /* @__PURE__ */ new Set();
    if (seen.has(value)) return value;
    seen.add(value);
    if ((0, _reactivity.isRef)(value)) traverse(value.value, depth, currentDepth, seen);
    else if ((0, _shared.isArray)(value)) for(let i = 0; i < value.length; i++)traverse(value[i], depth, currentDepth, seen);
    else if ((0, _shared.isSet)(value) || (0, _shared.isMap)(value)) value.forEach((v1)=>{
        traverse(v1, depth, currentDepth, seen);
    });
    else if ((0, _shared.isPlainObject)(value)) for(const key in value)traverse(value[key], depth, currentDepth, seen);
    return value;
}
function validateDirectiveName(name) {
    if ((0, _shared.isBuiltInDirective)(name)) warn$1("Do not use built-in directive ids as custom directive id: " + name);
}
function withDirectives(vnode, directives) {
    if (currentRenderingInstance === null) {
        warn$1(`withDirectives can only be used inside render functions.`);
        return vnode;
    }
    const instance = getExposeProxy(currentRenderingInstance) || currentRenderingInstance.proxy;
    const bindings = vnode.dirs || (vnode.dirs = []);
    for(let i = 0; i < directives.length; i++){
        let [dir, value, arg, modifiers = (0, _shared.EMPTY_OBJ)] = directives[i];
        if (dir) {
            if ((0, _shared.isFunction)(dir)) dir = {
                mounted: dir,
                updated: dir
            };
            if (dir.deep) traverse(value);
            bindings.push({
                dir,
                instance,
                value,
                oldValue: void 0,
                arg,
                modifiers
            });
        }
    }
    return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for(let i = 0; i < bindings.length; i++){
        const binding = bindings[i];
        if (oldBindings) binding.oldValue = oldBindings[i].value;
        let hook = binding.dir[name];
        if (hook) {
            (0, _reactivity.pauseTracking)();
            callWithAsyncErrorHandling(hook, instance, 8, [
                vnode.el,
                binding,
                vnode,
                prevVNode
            ]);
            (0, _reactivity.resetTracking)();
        }
    }
}
const leaveCbKey = Symbol("_leaveCb");
const enterCbKey = Symbol("_enterCb");
function useTransitionState() {
    const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: /* @__PURE__ */ new Map()
    };
    onMounted(()=>{
        state.isMounted = true;
    });
    onBeforeUnmount(()=>{
        state.isUnmounting = true;
    });
    return state;
}
const TransitionHookValidator = [
    Function,
    Array
];
const BaseTransitionPropsValidators = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    // enter
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    // leave
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    // appear
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
};
const BaseTransitionImpl = {
    name: `BaseTransition`,
    props: BaseTransitionPropsValidators,
    setup (props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        return ()=>{
            const children = slots.default && getTransitionRawChildren(slots.default(), true);
            if (!children || !children.length) return;
            let child = children[0];
            if (children.length > 1) {
                let hasFound = false;
                for (const c of children)if (c.type !== Comment) {
                    if (hasFound) {
                        warn$1("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
                        break;
                    }
                    child = c;
                    hasFound = true;
                }
            }
            const rawProps = (0, _reactivity.toRaw)(props);
            const { mode } = rawProps;
            if (mode && mode !== "in-out" && mode !== "out-in" && mode !== "default") warn$1(`invalid <transition> mode: ${mode}`);
            if (state.isLeaving) return emptyPlaceholder(child);
            const innerChild = getKeepAliveChild(child);
            if (!innerChild) return emptyPlaceholder(child);
            const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
            setTransitionHooks(innerChild, enterHooks);
            const oldChild = instance.subTree;
            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
            if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild)) {
                const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
                setTransitionHooks(oldInnerChild, leavingHooks);
                if (mode === "out-in") {
                    state.isLeaving = true;
                    leavingHooks.afterLeave = ()=>{
                        state.isLeaving = false;
                        if (instance.update.active !== false) {
                            instance.effect.dirty = true;
                            instance.update();
                        }
                    };
                    return emptyPlaceholder(child);
                } else if (mode === "in-out" && innerChild.type !== Comment) leavingHooks.delayLeave = (el, earlyRemove, delayedLeave)=>{
                    const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
                    leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                    el[leaveCbKey] = ()=>{
                        earlyRemove();
                        el[leaveCbKey] = void 0;
                        delete enterHooks.delayedLeave;
                    };
                    enterHooks.delayedLeave = delayedLeave;
                };
            }
            return child;
        };
    }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
        leavingVNodesCache = /* @__PURE__ */ Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance) {
    const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
    const key = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook = (hook, args)=>{
        hook && callWithAsyncErrorHandling(hook, instance, 9, args);
    };
    const callAsyncHook = (hook, args)=>{
        const done = args[1];
        callHook(hook, args);
        if ((0, _shared.isArray)(hook)) {
            if (hook.every((hook2)=>hook2.length <= 1)) done();
        } else if (hook.length <= 1) done();
    };
    const hooks = {
        mode,
        persisted,
        beforeEnter (el) {
            let hook = onBeforeEnter;
            if (!state.isMounted) {
                if (appear) hook = onBeforeAppear || onBeforeEnter;
                else return;
            }
            if (el[leaveCbKey]) el[leaveCbKey](true);
            const leavingVNode = leavingVNodesCache[key];
            if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) leavingVNode.el[leaveCbKey]();
            callHook(hook, [
                el
            ]);
        },
        enter (el) {
            let hook = onEnter;
            let afterHook = onAfterEnter;
            let cancelHook = onEnterCancelled;
            if (!state.isMounted) {
                if (appear) {
                    hook = onAppear || onEnter;
                    afterHook = onAfterAppear || onAfterEnter;
                    cancelHook = onAppearCancelled || onEnterCancelled;
                } else return;
            }
            let called = false;
            const done = el[enterCbKey] = (cancelled)=>{
                if (called) return;
                called = true;
                if (cancelled) callHook(cancelHook, [
                    el
                ]);
                else callHook(afterHook, [
                    el
                ]);
                if (hooks.delayedLeave) hooks.delayedLeave();
                el[enterCbKey] = void 0;
            };
            if (hook) callAsyncHook(hook, [
                el,
                done
            ]);
            else done();
        },
        leave (el, remove) {
            const key2 = String(vnode.key);
            if (el[enterCbKey]) el[enterCbKey](true);
            if (state.isUnmounting) return remove();
            callHook(onBeforeLeave, [
                el
            ]);
            let called = false;
            const done = el[leaveCbKey] = (cancelled)=>{
                if (called) return;
                called = true;
                remove();
                if (cancelled) callHook(onLeaveCancelled, [
                    el
                ]);
                else callHook(onAfterLeave, [
                    el
                ]);
                el[leaveCbKey] = void 0;
                if (leavingVNodesCache[key2] === vnode) delete leavingVNodesCache[key2];
            };
            leavingVNodesCache[key2] = vnode;
            if (onLeave) callAsyncHook(onLeave, [
                el,
                done
            ]);
            else done();
        },
        clone (vnode2) {
            return resolveTransitionHooks(vnode2, props, state, instance);
        }
    };
    return hooks;
}
function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
    }
}
function getKeepAliveChild(vnode) {
    return isKeepAlive(vnode) ? // #7121 ensure get the child component subtree in case
    // it's been replaced during HMR
    (0, vnode.component) ? vnode.component.subTree : vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) setTransitionHooks(vnode.component.subTree, hooks);
    else if (vnode.shapeFlag & 128) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else vnode.transition = hooks;
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
    let ret = [];
    let keyedFragmentCount = 0;
    for(let i = 0; i < children.length; i++){
        let child = children[i];
        const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
        if (child.type === Fragment) {
            if (child.patchFlag & 128) keyedFragmentCount++;
            ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
        } else if (keepComment || child.type !== Comment) ret.push(key != null ? cloneVNode(child, {
            key
        }) : child);
    }
    if (keyedFragmentCount > 1) for(let i = 0; i < ret.length; i++)ret[i].patchFlag = -2;
    return ret;
}
/*! #__NO_SIDE_EFFECTS__ */ // @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
    return (0, _shared.isFunction)(options) ? // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (()=>(0, _shared.extend)({
            name: options.name
        }, extraOptions, {
            setup: options
        }))() : options;
}
const isAsyncWrapper = (i)=>!!i.type.__asyncLoader;
/*! #__NO_SIDE_EFFECTS__ */ // @__NO_SIDE_EFFECTS__
function defineAsyncComponent(source) {
    if ((0, _shared.isFunction)(source)) source = {
        loader: source
    };
    const { loader, loadingComponent, errorComponent, delay = 200, timeout, // undefined = never times out
    suspensible = true, onError: userOnError } = source;
    let pendingRequest = null;
    let resolvedComp;
    let retries = 0;
    const retry = ()=>{
        retries++;
        pendingRequest = null;
        return load();
    };
    const load = ()=>{
        let thisRequest;
        return pendingRequest || (thisRequest = pendingRequest = loader().catch((err)=>{
            err = err instanceof Error ? err : new Error(String(err));
            if (userOnError) return new Promise((resolve, reject)=>{
                const userRetry = ()=>resolve(retry());
                const userFail = ()=>reject(err);
                userOnError(err, userRetry, userFail, retries + 1);
            });
            else throw err;
        }).then((comp)=>{
            if (thisRequest !== pendingRequest && pendingRequest) return pendingRequest;
            if (!comp) warn$1(`Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.`);
            if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) comp = comp.default;
            if (comp && !(0, _shared.isObject)(comp) && !(0, _shared.isFunction)(comp)) throw new Error(`Invalid async component load result: ${comp}`);
            resolvedComp = comp;
            return comp;
        }));
    };
    return defineComponent({
        name: "AsyncComponentWrapper",
        __asyncLoader: load,
        get __asyncResolved () {
            return resolvedComp;
        },
        setup () {
            const instance = currentInstance;
            if (resolvedComp) return ()=>createInnerComp(resolvedComp, instance);
            const onError = (err)=>{
                pendingRequest = null;
                handleError(err, instance, 13, !errorComponent);
            };
            if (suspensible && instance.suspense || isInSSRComponentSetup) return load().then((comp)=>{
                return ()=>createInnerComp(comp, instance);
            }).catch((err)=>{
                onError(err);
                return ()=>errorComponent ? createVNode(errorComponent, {
                        error: err
                    }) : null;
            });
            const loaded = (0, _reactivity.ref)(false);
            const error = (0, _reactivity.ref)();
            const delayed = (0, _reactivity.ref)(!!delay);
            if (delay) setTimeout(()=>{
                delayed.value = false;
            }, delay);
            if (timeout != null) setTimeout(()=>{
                if (!loaded.value && !error.value) {
                    const err = new Error(`Async component timed out after ${timeout}ms.`);
                    onError(err);
                    error.value = err;
                }
            }, timeout);
            load().then(()=>{
                loaded.value = true;
                if (instance.parent && isKeepAlive(instance.parent.vnode)) {
                    instance.parent.effect.dirty = true;
                    queueJob(instance.parent.update);
                }
            }).catch((err)=>{
                onError(err);
                error.value = err;
            });
            return ()=>{
                if (loaded.value && resolvedComp) return createInnerComp(resolvedComp, instance);
                else if (error.value && errorComponent) return createVNode(errorComponent, {
                    error: error.value
                });
                else if (loadingComponent && !delayed.value) return createVNode(loadingComponent);
            };
        }
    });
}
function createInnerComp(comp, parent) {
    const { ref: ref2, props, children, ce } = parent.vnode;
    const vnode = createVNode(comp, props, children);
    vnode.ref = ref2;
    vnode.ce = ce;
    delete parent.vnode.ce;
    return vnode;
}
const isKeepAlive = (vnode)=>vnode.type.__isKeepAlive;
const KeepAliveImpl = {
    name: `KeepAlive`,
    // Marker for special handling inside the renderer. We are not using a ===
    // check directly on KeepAlive in the renderer, because importing it directly
    // would prevent it from being tree-shaken.
    __isKeepAlive: true,
    props: {
        include: [
            String,
            RegExp,
            Array
        ],
        exclude: [
            String,
            RegExp,
            Array
        ],
        max: [
            String,
            Number
        ]
    },
    setup (props, { slots }) {
        const instance = getCurrentInstance();
        const sharedContext = instance.ctx;
        if (!sharedContext.renderer) return ()=>{
            const children = slots.default && slots.default();
            return children && children.length === 1 ? children[0] : children;
        };
        const cache = /* @__PURE__ */ new Map();
        const keys = /* @__PURE__ */ new Set();
        let current = null;
        instance.__v_cache = cache;
        const parentSuspense = instance.suspense;
        const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;
        const storageContainer = createElement("div");
        sharedContext.activate = (vnode, container, anchor, namespace, optimized)=>{
            const instance2 = vnode.component;
            move(vnode, container, anchor, 0, parentSuspense);
            patch(instance2.vnode, vnode, container, anchor, instance2, parentSuspense, namespace, vnode.slotScopeIds, optimized);
            queuePostRenderEffect(()=>{
                instance2.isDeactivated = false;
                if (instance2.a) (0, _shared.invokeArrayFns)(instance2.a);
                const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
                if (vnodeHook) invokeVNodeHook(vnodeHook, instance2.parent, vnode);
            }, parentSuspense);
            devtoolsComponentAdded(instance2);
        };
        sharedContext.deactivate = (vnode)=>{
            const instance2 = vnode.component;
            move(vnode, storageContainer, null, 1, parentSuspense);
            queuePostRenderEffect(()=>{
                if (instance2.da) (0, _shared.invokeArrayFns)(instance2.da);
                const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
                if (vnodeHook) invokeVNodeHook(vnodeHook, instance2.parent, vnode);
                instance2.isDeactivated = true;
            }, parentSuspense);
            devtoolsComponentAdded(instance2);
        };
        function unmount(vnode) {
            resetShapeFlag(vnode);
            _unmount(vnode, instance, parentSuspense, true);
        }
        function pruneCache(filter) {
            cache.forEach((vnode, key)=>{
                const name = getComponentName(vnode.type);
                if (name && (!filter || !filter(name))) pruneCacheEntry(key);
            });
        }
        function pruneCacheEntry(key) {
            const cached = cache.get(key);
            if (!current || !isSameVNodeType(cached, current)) unmount(cached);
            else if (current) resetShapeFlag(current);
            cache.delete(key);
            keys.delete(key);
        }
        watch(()=>[
                props.include,
                props.exclude
            ], ([include, exclude])=>{
            include && pruneCache((name)=>matches(include, name));
            exclude && pruneCache((name)=>!matches(exclude, name));
        }, // prune post-render after `current` has been updated
        {
            flush: "post",
            deep: true
        });
        let pendingCacheKey = null;
        const cacheSubtree = ()=>{
            if (pendingCacheKey != null) cache.set(pendingCacheKey, getInnerChild(instance.subTree));
        };
        onMounted(cacheSubtree);
        onUpdated(cacheSubtree);
        onBeforeUnmount(()=>{
            cache.forEach((cached)=>{
                const { subTree, suspense } = instance;
                const vnode = getInnerChild(subTree);
                if (cached.type === vnode.type && cached.key === vnode.key) {
                    resetShapeFlag(vnode);
                    const da = vnode.component.da;
                    da && queuePostRenderEffect(da, suspense);
                    return;
                }
                unmount(cached);
            });
        });
        return ()=>{
            pendingCacheKey = null;
            if (!slots.default) return current = null;
            const children = slots.default();
            const rawVNode = children[0];
            if (children.length > 1) {
                warn$1(`KeepAlive should contain exactly one component child.`);
                current = null;
                return children;
            } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
                current = null;
                return rawVNode;
            }
            let vnode = getInnerChild(rawVNode);
            const comp = vnode.type;
            const name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp);
            const { include, exclude, max } = props;
            if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
                current = vnode;
                return rawVNode;
            }
            const key = vnode.key == null ? comp : vnode.key;
            const cachedVNode = cache.get(key);
            if (vnode.el) {
                vnode = cloneVNode(vnode);
                if (rawVNode.shapeFlag & 128) rawVNode.ssContent = vnode;
            }
            pendingCacheKey = key;
            if (cachedVNode) {
                vnode.el = cachedVNode.el;
                vnode.component = cachedVNode.component;
                if (vnode.transition) setTransitionHooks(vnode, vnode.transition);
                vnode.shapeFlag |= 512;
                keys.delete(key);
                keys.add(key);
            } else {
                keys.add(key);
                if (max && keys.size > parseInt(max, 10)) pruneCacheEntry(keys.values().next().value);
            }
            vnode.shapeFlag |= 256;
            current = vnode;
            return isSuspense(rawVNode.type) ? rawVNode : vnode;
        };
    }
};
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
    if ((0, _shared.isArray)(pattern)) return pattern.some((p)=>matches(p, name));
    else if ((0, _shared.isString)(pattern)) return pattern.split(",").includes(name);
    else if ((0, _shared.isRegExp)(pattern)) return pattern.test(name);
    return false;
}
function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = ()=>{
        let current = target;
        while(current){
            if (current.isDeactivated) return;
            current = current.parent;
        }
        return hook();
    });
    injectHook(type, wrappedHook, target);
    if (target) {
        let current = target.parent;
        while(current && current.parent){
            if (isKeepAlive(current.parent.vnode)) injectToKeepAliveRoot(wrappedHook, type, target, current);
            current = current.parent;
        }
    }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    const injected = injectHook(type, hook, keepAliveRoot, true);
    onUnmounted(()=>{
        (0, _shared.remove)(keepAliveRoot[type], injected);
    }, target);
}
function resetShapeFlag(vnode) {
    vnode.shapeFlag &= -257;
    vnode.shapeFlag &= -513;
}
function getInnerChild(vnode) {
    return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
        const hooks = target[type] || (target[type] = []);
        const wrappedHook = hook.__weh || (hook.__weh = (...args)=>{
            if (target.isUnmounted) return;
            (0, _reactivity.pauseTracking)();
            const reset = setCurrentInstance(target);
            const res = callWithAsyncErrorHandling(hook, target, type, args);
            reset();
            (0, _reactivity.resetTracking)();
            return res;
        });
        if (prepend) hooks.unshift(wrappedHook);
        else hooks.push(wrappedHook);
        return wrappedHook;
    } else {
        const apiName = (0, _shared.toHandlerKey)(ErrorTypeStrings$1[type].replace(/ hook$/, ""));
        warn$1(`${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup().` + ` If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`);
    }
}
const createHook = (lifecycle)=>(hook, target = currentInstance)=>// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
        (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args)=>hook(...args), target);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec", hook, target);
}
function renderList(source, renderItem, cache, index) {
    let ret;
    const cached = cache && cache[index];
    if ((0, _shared.isArray)(source) || (0, _shared.isString)(source)) {
        ret = new Array(source.length);
        for(let i = 0, l = source.length; i < l; i++)ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
    } else if (typeof source === "number") {
        if (!Number.isInteger(source)) warn$1(`The v-for range expect an integer value but got ${source}.`);
        ret = new Array(source);
        for(let i = 0; i < source; i++)ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    } else if ((0, _shared.isObject)(source)) {
        if (source[Symbol.iterator]) ret = Array.from(source, (item, i)=>renderItem(item, i, void 0, cached && cached[i]));
        else {
            const keys = Object.keys(source);
            ret = new Array(keys.length);
            for(let i = 0, l = keys.length; i < l; i++){
                const key = keys[i];
                ret[i] = renderItem(source[key], key, i, cached && cached[i]);
            }
        }
    } else ret = [];
    if (cache) cache[index] = ret;
    return ret;
}
function createSlots(slots, dynamicSlots) {
    for(let i = 0; i < dynamicSlots.length; i++){
        const slot = dynamicSlots[i];
        if ((0, _shared.isArray)(slot)) for(let j = 0; j < slot.length; j++)slots[slot[j].name] = slot[j].fn;
        else if (slot) slots[slot.name] = slot.key ? (...args)=>{
            const res = slot.fn(...args);
            if (res) res.key = slot.key;
            return res;
        } : slot.fn;
    }
    return slots;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
    if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
        if (name !== "default") props.name = name;
        return createVNode("slot", props, fallback && fallback());
    }
    let slot = slots[name];
    if (slot && slot.length > 1) {
        warn$1(`SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`);
        slot = ()=>[];
    }
    if (slot && slot._c) slot._d = false;
    openBlock();
    const validSlotContent = slot && ensureValidVNode(slot(props));
    const rendered = createBlock(Fragment, {
        key: props.key || // slot content array of a dynamic conditional slot may have a branch
        // key attached in the `createSlots` helper, respect that
        validSlotContent && validSlotContent.key || `_${name}`
    }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
    if (!noSlotted && rendered.scopeId) rendered.slotScopeIds = [
        rendered.scopeId + "-s"
    ];
    if (slot && slot._c) slot._d = true;
    return rendered;
}
function ensureValidVNode(vnodes) {
    return vnodes.some((child)=>{
        if (!isVNode(child)) return true;
        if (child.type === Comment) return false;
        if (child.type === Fragment && !ensureValidVNode(child.children)) return false;
        return true;
    }) ? vnodes : null;
}
function toHandlers(obj, preserveCaseIfNecessary) {
    const ret = {};
    if (!(0, _shared.isObject)(obj)) {
        warn$1(`v-on with no argument expects an object value.`);
        return ret;
    }
    for(const key in obj)ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : (0, _shared.toHandlerKey)(key)] = obj[key];
    return ret;
}
const getPublicInstance = (i)=>{
    if (!i) return null;
    if (isStatefulComponent(i)) return getExposeProxy(i) || i.proxy;
    return getPublicInstance(i.parent);
};
const publicPropertiesMap = // Move PURE marker to new line to workaround compiler discarding it
// due to type annotation
/* @__PURE__ */ (0, _shared.extend)(/* @__PURE__ */ Object.create(null), {
    $: (i)=>i,
    $el: (i)=>i.vnode.el,
    $data: (i)=>i.data,
    $props: (i)=>(0, _reactivity.shallowReadonly)(i.props),
    $attrs: (i)=>(0, _reactivity.shallowReadonly)(i.attrs),
    $slots: (i)=>(0, _reactivity.shallowReadonly)(i.slots),
    $refs: (i)=>(0, _reactivity.shallowReadonly)(i.refs),
    $parent: (i)=>getPublicInstance(i.parent),
    $root: (i)=>getPublicInstance(i.root),
    $emit: (i)=>i.emit,
    $options: (i)=>__VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type,
    $forceUpdate: (i)=>i.f || (i.f = ()=>{
            i.effect.dirty = true;
            queueJob(i.update);
        }),
    $nextTick: (i)=>i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i)=>__VUE_OPTIONS_API__ ? instanceWatch.bind(i) : (0, _shared.NOOP)
});
const isReservedPrefix = (key)=>key === "_" || key === "$";
const hasSetupBinding = (state, key)=>state !== (0, _shared.EMPTY_OBJ) && !state.__isScriptSetup && (0, _shared.hasOwn)(state, key);
const PublicInstanceProxyHandlers = {
    get ({ _: instance }, key) {
        if (key === "__v_skip") return true;
        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
        if (key === "__isVue") return true;
        let normalizedProps;
        if (key[0] !== "$") {
            const n = accessCache[key];
            if (n !== void 0) switch(n){
                case 1 /* SETUP */ :
                    return setupState[key];
                case 2 /* DATA */ :
                    return data[key];
                case 4 /* CONTEXT */ :
                    return ctx[key];
                case 3 /* PROPS */ :
                    return props[key];
            }
            else if (hasSetupBinding(setupState, key)) {
                accessCache[key] = 1 /* SETUP */ ;
                return setupState[key];
            } else if (data !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(data, key)) {
                accessCache[key] = 2 /* DATA */ ;
                return data[key];
            } else if (// only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) && (0, _shared.hasOwn)(normalizedProps, key)) {
                accessCache[key] = 3 /* PROPS */ ;
                return props[key];
            } else if (ctx !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(ctx, key)) {
                accessCache[key] = 4 /* CONTEXT */ ;
                return ctx[key];
            } else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) accessCache[key] = 0 /* OTHER */ ;
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        if (publicGetter) {
            if (key === "$attrs") {
                (0, _reactivity.track)(instance, "get", key);
                markAttrsAccessed();
            } else if (key === "$slots") (0, _reactivity.track)(instance, "get", key);
            return publicGetter(instance);
        } else if (// css module (injected by vue-loader)
        (cssModule = type.__cssModules) && (cssModule = cssModule[key])) return cssModule;
        else if (ctx !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(ctx, key)) {
            accessCache[key] = 4 /* CONTEXT */ ;
            return ctx[key];
        } else if (// global properties
        globalProperties = appContext.config.globalProperties, (0, _shared.hasOwn)(globalProperties, key)) return globalProperties[key];
        else if (currentRenderingInstance && (!(0, _shared.isString)(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
        // to infinite warning loop
        key.indexOf("__v") !== 0)) {
            if (data !== (0, _shared.EMPTY_OBJ) && isReservedPrefix(key[0]) && (0, _shared.hasOwn)(data, key)) warn$1(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`);
            else if (instance === currentRenderingInstance) warn$1(`Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`);
        }
    },
    set ({ _: instance }, key, value) {
        const { data, setupState, ctx } = instance;
        if (hasSetupBinding(setupState, key)) {
            setupState[key] = value;
            return true;
        } else if ((0, setupState.__isScriptSetup) && (0, _shared.hasOwn)(setupState, key)) {
            warn$1(`Cannot mutate <script setup> binding "${key}" from Options API.`);
            return false;
        } else if (data !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(data, key)) {
            data[key] = value;
            return true;
        } else if ((0, _shared.hasOwn)(instance.props, key)) {
            warn$1(`Attempting to mutate prop "${key}". Props are readonly.`);
            return false;
        }
        if (key[0] === "$" && key.slice(1) in instance) {
            warn$1(`Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`);
            return false;
        } else if (key in instance.appContext.config.globalProperties) Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            value
        });
        else ctx[key] = value;
        return true;
    },
    has ({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
        let normalizedProps;
        return !!accessCache[key] || data !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && (0, _shared.hasOwn)(normalizedProps, key) || (0, _shared.hasOwn)(ctx, key) || (0, _shared.hasOwn)(publicPropertiesMap, key) || (0, _shared.hasOwn)(appContext.config.globalProperties, key);
    },
    defineProperty (target, key, descriptor) {
        if (descriptor.get != null) target._.accessCache[key] = 0;
        else if ((0, _shared.hasOwn)(descriptor, "value")) this.set(target, key, descriptor.value, null);
        return Reflect.defineProperty(target, key, descriptor);
    }
};
PublicInstanceProxyHandlers.ownKeys = (target)=>{
    warn$1(`Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`);
    return Reflect.ownKeys(target);
};
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ (0, _shared.extend)({}, PublicInstanceProxyHandlers, {
    get (target, key) {
        if (key === Symbol.unscopables) return;
        return PublicInstanceProxyHandlers.get(target, key, target);
    },
    has (_, key) {
        const has = key[0] !== "_" && !(0, _shared.isGloballyAllowed)(key);
        if (!has && PublicInstanceProxyHandlers.has(_, key)) warn$1(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);
        return has;
    }
});
function createDevRenderContext(instance) {
    const target = {};
    Object.defineProperty(target, `_`, {
        configurable: true,
        enumerable: false,
        get: ()=>instance
    });
    Object.keys(publicPropertiesMap).forEach((key)=>{
        Object.defineProperty(target, key, {
            configurable: true,
            enumerable: false,
            get: ()=>publicPropertiesMap[key](instance),
            // intercepted by the proxy so no need for implementation,
            // but needed to prevent set errors
            set: (0, _shared.NOOP)
        });
    });
    return target;
}
function exposePropsOnRenderContext(instance) {
    const { ctx, propsOptions: [propsOptions] } = instance;
    if (propsOptions) Object.keys(propsOptions).forEach((key)=>{
        Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: ()=>instance.props[key],
            set: (0, _shared.NOOP)
        });
    });
}
function exposeSetupStateOnRenderContext(instance) {
    const { ctx, setupState } = instance;
    Object.keys((0, _reactivity.toRaw)(setupState)).forEach((key)=>{
        if (!setupState.__isScriptSetup) {
            if (isReservedPrefix(key[0])) {
                warn$1(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
                return;
            }
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: ()=>setupState[key],
                set: (0, _shared.NOOP)
            });
        }
    });
}
const warnRuntimeUsage = (method)=>warn$1(`${method}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`);
function defineProps() {
    warnRuntimeUsage(`defineProps`);
    return null;
}
function defineEmits() {
    warnRuntimeUsage(`defineEmits`);
    return null;
}
function defineExpose(exposed) {
    warnRuntimeUsage(`defineExpose`);
}
function defineOptions(options) {
    warnRuntimeUsage(`defineOptions`);
}
function defineSlots() {
    warnRuntimeUsage(`defineSlots`);
    return null;
}
function defineModel() {
    warnRuntimeUsage("defineModel");
}
function withDefaults(props, defaults) {
    warnRuntimeUsage(`withDefaults`);
    return null;
}
function useSlots() {
    return getContext().slots;
}
function useAttrs() {
    return getContext().attrs;
}
function getContext() {
    const i = getCurrentInstance();
    if (!i) warn$1(`useContext() called without active instance.`);
    return i.setupContext || (i.setupContext = createSetupContext(i));
}
function normalizePropsOrEmits(props) {
    return (0, _shared.isArray)(props) ? props.reduce((normalized, p)=>(normalized[p] = null, normalized), {}) : props;
}
function mergeDefaults(raw, defaults) {
    const props = normalizePropsOrEmits(raw);
    for(const key in defaults){
        if (key.startsWith("__skip")) continue;
        let opt = props[key];
        if (opt) {
            if ((0, _shared.isArray)(opt) || (0, _shared.isFunction)(opt)) opt = props[key] = {
                type: opt,
                default: defaults[key]
            };
            else opt.default = defaults[key];
        } else if (opt === null) opt = props[key] = {
            default: defaults[key]
        };
        else warn$1(`props default key "${key}" has no corresponding declaration.`);
        if (opt && defaults[`__skip_${key}`]) opt.skipFactory = true;
    }
    return props;
}
function mergeModels(a, b) {
    if (!a || !b) return a || b;
    if ((0, _shared.isArray)(a) && (0, _shared.isArray)(b)) return a.concat(b);
    return (0, _shared.extend)({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));
}
function createPropsRestProxy(props, excludedKeys) {
    const ret = {};
    for(const key in props)if (!excludedKeys.includes(key)) Object.defineProperty(ret, key, {
        enumerable: true,
        get: ()=>props[key]
    });
    return ret;
}
function withAsyncContext(getAwaitable) {
    const ctx = getCurrentInstance();
    if (!ctx) warn$1(`withAsyncContext called without active current instance. This is likely a bug.`);
    let awaitable = getAwaitable();
    unsetCurrentInstance();
    if ((0, _shared.isPromise)(awaitable)) awaitable = awaitable.catch((e)=>{
        setCurrentInstance(ctx);
        throw e;
    });
    return [
        awaitable,
        ()=>setCurrentInstance(ctx)
    ];
}
function createDuplicateChecker() {
    const cache = /* @__PURE__ */ Object.create(null);
    return (type, key)=>{
        if (cache[key]) warn$1(`${type} property "${key}" is already defined in ${cache[key]}.`);
        else cache[key] = type;
    };
}
let shouldCacheAccess = true;
function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    shouldCacheAccess = false;
    if (options.beforeCreate) callHook(options.beforeCreate, instance, "bc");
    const { // state
    data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, // lifecycle
    created, beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy, beforeUnmount, destroyed, unmounted, render, renderTracked, renderTriggered, errorCaptured, serverPrefetch, // public API
    expose, inheritAttrs, // assets
    components, directives, filters } = options;
    const checkDuplicateProperties = createDuplicateChecker();
    {
        const [propsOptions] = instance.propsOptions;
        if (propsOptions) for(const key in propsOptions)checkDuplicateProperties("Props" /* PROPS */ , key);
    }
    if (injectOptions) resolveInjections(injectOptions, ctx, checkDuplicateProperties);
    if (methods) for(const key in methods){
        const methodHandler = methods[key];
        if ((0, _shared.isFunction)(methodHandler)) {
            Object.defineProperty(ctx, key, {
                value: methodHandler.bind(publicThis),
                configurable: true,
                enumerable: true,
                writable: true
            });
            checkDuplicateProperties("Methods" /* METHODS */ , key);
        } else warn$1(`Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`);
    }
    if (dataOptions) {
        if (!(0, _shared.isFunction)(dataOptions)) warn$1(`The data option must be a function. Plain object usage is no longer supported.`);
        const data = dataOptions.call(publicThis, publicThis);
        if ((0, _shared.isPromise)(data)) warn$1(`data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`);
        if (!(0, _shared.isObject)(data)) warn$1(`data() should return an object.`);
        else {
            instance.data = (0, _reactivity.reactive)(data);
            for(const key in data){
                checkDuplicateProperties("Data" /* DATA */ , key);
                if (!isReservedPrefix(key[0])) Object.defineProperty(ctx, key, {
                    configurable: true,
                    enumerable: true,
                    get: ()=>data[key],
                    set: (0, _shared.NOOP)
                });
            }
        }
    }
    shouldCacheAccess = true;
    if (computedOptions) for(const key in computedOptions){
        const opt = computedOptions[key];
        const get = (0, _shared.isFunction)(opt) ? opt.bind(publicThis, publicThis) : (0, _shared.isFunction)(opt.get) ? opt.get.bind(publicThis, publicThis) : (0, _shared.NOOP);
        if (get === (0, _shared.NOOP)) warn$1(`Computed property "${key}" has no getter.`);
        const set = !(0, _shared.isFunction)(opt) && (0, _shared.isFunction)(opt.set) ? opt.set.bind(publicThis) : ()=>{
            warn$1(`Write operation failed: computed property "${key}" is readonly.`);
        };
        const c = computed({
            get,
            set
        });
        Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: ()=>c.value,
            set: (v1)=>c.value = v1
        });
        checkDuplicateProperties("Computed" /* COMPUTED */ , key);
    }
    if (watchOptions) for(const key in watchOptions)createWatcher(watchOptions[key], ctx, publicThis, key);
    if (provideOptions) {
        const provides = (0, _shared.isFunction)(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
        Reflect.ownKeys(provides).forEach((key)=>{
            provide(key, provides[key]);
        });
    }
    if (created) callHook(created, instance, "c");
    function registerLifecycleHook(register, hook) {
        if ((0, _shared.isArray)(hook)) hook.forEach((_hook)=>register(_hook.bind(publicThis)));
        else if (hook) register(hook.bind(publicThis));
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if ((0, _shared.isArray)(expose)) {
        if (expose.length) {
            const exposed = instance.exposed || (instance.exposed = {});
            expose.forEach((key)=>{
                Object.defineProperty(exposed, key, {
                    get: ()=>publicThis[key],
                    set: (val)=>publicThis[key] = val
                });
            });
        } else if (!instance.exposed) instance.exposed = {};
    }
    if (render && instance.render === (0, _shared.NOOP)) instance.render = render;
    if (inheritAttrs != null) instance.inheritAttrs = inheritAttrs;
    if (components) instance.components = components;
    if (directives) instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = (0, _shared.NOOP)) {
    if ((0, _shared.isArray)(injectOptions)) injectOptions = normalizeInject(injectOptions);
    for(const key in injectOptions){
        const opt = injectOptions[key];
        let injected;
        if ((0, _shared.isObject)(opt)) {
            if ("default" in opt) injected = inject(opt.from || key, opt.default, true);
            else injected = inject(opt.from || key);
        } else injected = inject(opt);
        if ((0, _reactivity.isRef)(injected)) Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: ()=>injected.value,
            set: (v1)=>injected.value = v1
        });
        else ctx[key] = injected;
        checkDuplicateProperties("Inject" /* INJECT */ , key);
    }
}
function callHook(hook, instance, type) {
    callWithAsyncErrorHandling((0, _shared.isArray)(hook) ? hook.map((h)=>h.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
    const getter = key.includes(".") ? createPathGetter(publicThis, key) : ()=>publicThis[key];
    if ((0, _shared.isString)(raw)) {
        const handler = ctx[raw];
        if ((0, _shared.isFunction)(handler)) watch(getter, handler);
        else warn$1(`Invalid watch handler specified by key "${raw}"`, handler);
    } else if ((0, _shared.isFunction)(raw)) watch(getter, raw.bind(publicThis));
    else if ((0, _shared.isObject)(raw)) {
        if ((0, _shared.isArray)(raw)) raw.forEach((r)=>createWatcher(r, ctx, publicThis, key));
        else {
            const handler = (0, _shared.isFunction)(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
            if ((0, _shared.isFunction)(handler)) watch(getter, handler, raw);
            else warn$1(`Invalid watch handler specified by key "${raw.handler}"`, handler);
        }
    } else warn$1(`Invalid watch option: "${key}"`, raw);
}
function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
    const cached = cache.get(base);
    let resolved;
    if (cached) resolved = cached;
    else if (!globalMixins.length && !mixins && !extendsOptions) resolved = base;
    else {
        resolved = {};
        if (globalMixins.length) globalMixins.forEach((m)=>mergeOptions(resolved, m, optionMergeStrategies, true));
        mergeOptions(resolved, base, optionMergeStrategies);
    }
    if ((0, _shared.isObject)(base)) cache.set(base, resolved);
    return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) mergeOptions(to, extendsOptions, strats, true);
    if (mixins) mixins.forEach((m)=>mergeOptions(to, m, strats, true));
    for(const key in from)if (asMixin && key === "expose") warn$1(`"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`);
    else {
        const strat = internalOptionMergeStrats[key] || strats && strats[key];
        to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
    return to;
}
const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeEmitsOrPropsOptions,
    emits: mergeEmitsOrPropsOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
};
function mergeDataFn(to, from) {
    if (!from) return to;
    if (!to) return from;
    return function mergedDataFn() {
        return (0, _shared.extend)((0, _shared.isFunction)(to) ? to.call(this, this) : to, (0, _shared.isFunction)(from) ? from.call(this, this) : from);
    };
}
function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
    if ((0, _shared.isArray)(raw)) {
        const res = {};
        for(let i = 0; i < raw.length; i++)res[raw[i]] = raw[i];
        return res;
    }
    return raw;
}
function mergeAsArray(to, from) {
    return to ? [
        ...new Set([].concat(to, from))
    ] : from;
}
function mergeObjectOptions(to, from) {
    return to ? (0, _shared.extend)(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
    if (to) {
        if ((0, _shared.isArray)(to) && (0, _shared.isArray)(from)) return [
            .../* @__PURE__ */ new Set([
                ...to,
                ...from
            ])
        ];
        return (0, _shared.extend)(/* @__PURE__ */ Object.create(null), normalizePropsOrEmits(to), normalizePropsOrEmits(from != null ? from : {}));
    } else return from;
}
function mergeWatchOptions(to, from) {
    if (!to) return from;
    if (!from) return to;
    const merged = (0, _shared.extend)(/* @__PURE__ */ Object.create(null), to);
    for(const key in from)merged[key] = mergeAsArray(to[key], from[key]);
    return merged;
}
function createAppContext() {
    return {
        app: null,
        config: {
            isNativeTag: (0, _shared.NO),
            performance: false,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: /* @__PURE__ */ Object.create(null),
        optionsCache: /* @__PURE__ */ new WeakMap(),
        propsCache: /* @__PURE__ */ new WeakMap(),
        emitsCache: /* @__PURE__ */ new WeakMap()
    };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
    return function createApp(rootComponent, rootProps = null) {
        if (!(0, _shared.isFunction)(rootComponent)) rootComponent = (0, _shared.extend)({}, rootComponent);
        if (rootProps != null && !(0, _shared.isObject)(rootProps)) {
            warn$1(`root props passed to app.mount() must be an object.`);
            rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = /* @__PURE__ */ new WeakSet();
        let isMounted = false;
        const app = context.app = {
            _uid: uid$1++,
            _component: rootComponent,
            _props: rootProps,
            _container: null,
            _context: context,
            _instance: null,
            version,
            get config () {
                return context.config;
            },
            set config (v){
                warn$1(`app.config cannot be replaced. Modify individual options instead.`);
            },
            use (plugin, ...options) {
                if (installedPlugins.has(plugin)) warn$1(`Plugin has already been applied to target app.`);
                else if (plugin && (0, _shared.isFunction)(plugin.install)) {
                    installedPlugins.add(plugin);
                    plugin.install(app, ...options);
                } else if ((0, _shared.isFunction)(plugin)) {
                    installedPlugins.add(plugin);
                    plugin(app, ...options);
                } else warn$1(`A plugin must either be a function or an object with an "install" function.`);
                return app;
            },
            mixin (mixin) {
                if (__VUE_OPTIONS_API__) {
                    if (!context.mixins.includes(mixin)) context.mixins.push(mixin);
                    else warn$1("Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : ""));
                } else warn$1("Mixins are only available in builds supporting Options API");
                return app;
            },
            component (name, component) {
                validateComponentName(name, context.config);
                if (!component) return context.components[name];
                if (0, context.components[name]) warn$1(`Component "${name}" has already been registered in target app.`);
                context.components[name] = component;
                return app;
            },
            directive (name, directive) {
                validateDirectiveName(name);
                if (!directive) return context.directives[name];
                if (0, context.directives[name]) warn$1(`Directive "${name}" has already been registered in target app.`);
                context.directives[name] = directive;
                return app;
            },
            mount (rootContainer, isHydrate, namespace) {
                if (!isMounted) {
                    if (0, rootContainer.__vue_app__) warn$1(`There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`);
                    const vnode = createVNode(rootComponent, rootProps);
                    vnode.appContext = context;
                    if (namespace === true) namespace = "svg";
                    else if (namespace === false) namespace = void 0;
                    context.reload = ()=>{
                        render(cloneVNode(vnode), rootContainer, namespace);
                    };
                    if (isHydrate && hydrate) hydrate(vnode, rootContainer);
                    else render(vnode, rootContainer, namespace);
                    isMounted = true;
                    app._container = rootContainer;
                    rootContainer.__vue_app__ = app;
                    app._instance = vnode.component;
                    devtoolsInitApp(app, version);
                    return getExposeProxy(vnode.component) || vnode.component.proxy;
                } else warn$1(`App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``);
            },
            unmount () {
                if (isMounted) {
                    render(null, app._container);
                    app._instance = null;
                    devtoolsUnmountApp(app);
                    delete app._container.__vue_app__;
                } else warn$1(`Cannot unmount an app that is not mounted.`);
            },
            provide (key, value) {
                if (key in context.provides) warn$1(`App already provides property with key "${String(key)}". It will be overwritten with the new value.`);
                context.provides[key] = value;
                return app;
            },
            runWithContext (fn) {
                const lastApp = currentApp;
                currentApp = app;
                try {
                    return fn();
                } finally{
                    currentApp = lastApp;
                }
            }
        };
        return app;
    };
}
let currentApp = null;
function provide(key, value) {
    if (!currentInstance) warn$1(`provide() can only be used inside setup().`);
    else {
        let provides = currentInstance.provides;
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) provides = currentInstance.provides = Object.create(parentProvides);
        provides[key] = value;
    }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
    const instance = currentInstance || currentRenderingInstance;
    if (instance || currentApp) {
        const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
        if (provides && key in provides) return provides[key];
        else if (arguments.length > 1) return treatDefaultAsFactory && (0, _shared.isFunction)(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
        else warn$1(`injection "${String(key)}" not found.`);
    } else warn$1(`inject() can only be used inside setup() or functional components.`);
}
function hasInjectionContext() {
    return !!(currentInstance || currentRenderingInstance || currentApp);
}
const attrsProto = {};
function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props = {};
    const attrs = Object.create(attrsProto);
    instance.propsDefaults = /* @__PURE__ */ Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    for(const key in instance.propsOptions[0])if (!(key in props)) props[key] = void 0;
    validateProps(rawProps || {}, props, instance);
    if (isStateful) instance.props = isSSR ? props : (0, _reactivity.shallowReactive)(props);
    else if (!instance.type.props) instance.props = attrs;
    else instance.props = props;
    instance.attrs = attrs;
}
function isInHmrContext(instance) {
    while(instance){
        if (instance.type.__hmrId) return true;
        instance = instance.parent;
    }
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const { props, attrs, vnode: { patchFlag } } = instance;
    const rawCurrentProps = (0, _reactivity.toRaw)(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (// always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !isInHmrContext(instance) && (optimized || patchFlag > 0) && !(patchFlag & 16)) {
        if (patchFlag & 8) {
            const propsToUpdate = instance.vnode.dynamicProps;
            for(let i = 0; i < propsToUpdate.length; i++){
                let key = propsToUpdate[i];
                if (isEmitListener(instance.emitsOptions, key)) continue;
                const value = rawProps[key];
                if (options) {
                    if ((0, _shared.hasOwn)(attrs, key)) {
                        if (value !== attrs[key]) {
                            attrs[key] = value;
                            hasAttrsChanged = true;
                        }
                    } else {
                        const camelizedKey = (0, _shared.camelize)(key);
                        props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false);
                    }
                } else if (value !== attrs[key]) {
                    attrs[key] = value;
                    hasAttrsChanged = true;
                }
            }
        }
    } else {
        if (setFullProps(instance, rawProps, props, attrs)) hasAttrsChanged = true;
        let kebabKey;
        for(const key in rawCurrentProps)if (!rawProps || // for camelCase
        !(0, _shared.hasOwn)(rawProps, key) && // it's possible the original props was passed in as kebab-case
        // and converted to camelCase (#955)
        ((kebabKey = (0, _shared.hyphenate)(key)) === key || !(0, _shared.hasOwn)(rawProps, kebabKey))) {
            if (options) {
                if (rawPrevProps && // for camelCase
                (rawPrevProps[key] !== void 0 || // for kebab-case
                rawPrevProps[kebabKey] !== void 0)) props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance, true);
            } else delete props[key];
        }
        if (attrs !== rawCurrentProps) {
            for(const key in attrs)if (!rawProps || !(0, _shared.hasOwn)(rawProps, key) && true) {
                delete attrs[key];
                hasAttrsChanged = true;
            }
        }
    }
    if (hasAttrsChanged) (0, _reactivity.trigger)(instance.attrs, "set", "");
    validateProps(rawProps || {}, props, instance);
}
function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) for(let key in rawProps){
        if ((0, _shared.isReservedProp)(key)) continue;
        const value = rawProps[key];
        let camelKey;
        if (options && (0, _shared.hasOwn)(options, camelKey = (0, _shared.camelize)(key))) {
            if (!needCastKeys || !needCastKeys.includes(camelKey)) props[camelKey] = value;
            else (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        } else if (!isEmitListener(instance.emitsOptions, key)) {
            if (!(key in attrs) || value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
            }
        }
    }
    if (needCastKeys) {
        const rawCurrentProps = (0, _reactivity.toRaw)(props);
        const castValues = rawCastValues || (0, _shared.EMPTY_OBJ);
        for(let i = 0; i < needCastKeys.length; i++){
            const key = needCastKeys[i];
            props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !(0, _shared.hasOwn)(castValues, key));
        }
    }
    return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
        const hasDefault = (0, _shared.hasOwn)(opt, "default");
        if (hasDefault && value === void 0) {
            const defaultValue = opt.default;
            if (opt.type !== Function && !opt.skipFactory && (0, _shared.isFunction)(defaultValue)) {
                const { propsDefaults } = instance;
                if (key in propsDefaults) value = propsDefaults[key];
                else {
                    const reset = setCurrentInstance(instance);
                    value = propsDefaults[key] = defaultValue.call(null, props);
                    reset();
                }
            } else value = defaultValue;
        }
        if (opt[0 /* shouldCast */ ]) {
            if (isAbsent && !hasDefault) value = false;
            else if (opt[1 /* shouldCastTrue */ ] && (value === "" || value === (0, _shared.hyphenate)(key))) value = true;
        }
    }
    return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.propsCache;
    const cached = cache.get(comp);
    if (cached) return cached;
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !(0, _shared.isFunction)(comp)) {
        const extendProps = (raw2)=>{
            hasExtends = true;
            const [props, keys] = normalizePropsOptions(raw2, appContext, true);
            (0, _shared.extend)(normalized, props);
            if (keys) needCastKeys.push(...keys);
        };
        if (!asMixin && appContext.mixins.length) appContext.mixins.forEach(extendProps);
        if (comp.extends) extendProps(comp.extends);
        if (comp.mixins) comp.mixins.forEach(extendProps);
    }
    if (!raw && !hasExtends) {
        if ((0, _shared.isObject)(comp)) cache.set(comp, (0, _shared.EMPTY_ARR));
        return 0, _shared.EMPTY_ARR;
    }
    if ((0, _shared.isArray)(raw)) for(let i = 0; i < raw.length; i++){
        if (!(0, _shared.isString)(raw[i])) warn$1(`props must be strings when using array syntax.`, raw[i]);
        const normalizedKey = (0, _shared.camelize)(raw[i]);
        if (validatePropName(normalizedKey)) normalized[normalizedKey] = (0, _shared.EMPTY_OBJ);
    }
    else if (raw) {
        if (!(0, _shared.isObject)(raw)) warn$1(`invalid props options`, raw);
        for(const key in raw){
            const normalizedKey = (0, _shared.camelize)(key);
            if (validatePropName(normalizedKey)) {
                const opt = raw[key];
                const prop = normalized[normalizedKey] = (0, _shared.isArray)(opt) || (0, _shared.isFunction)(opt) ? {
                    type: opt
                } : (0, _shared.extend)({}, opt);
                if (prop) {
                    const booleanIndex = getTypeIndex(Boolean, prop.type);
                    const stringIndex = getTypeIndex(String, prop.type);
                    prop[0 /* shouldCast */ ] = booleanIndex > -1;
                    prop[1 /* shouldCastTrue */ ] = stringIndex < 0 || booleanIndex < stringIndex;
                    if (booleanIndex > -1 || (0, _shared.hasOwn)(prop, "default")) needCastKeys.push(normalizedKey);
                }
            }
        }
    }
    const res = [
        normalized,
        needCastKeys
    ];
    if ((0, _shared.isObject)(comp)) cache.set(comp, res);
    return res;
}
function validatePropName(key) {
    if (key[0] !== "$" && !(0, _shared.isReservedProp)(key)) return true;
    else warn$1(`Invalid prop name: "${key}" is a reserved property.`);
    return false;
}
function getType(ctor) {
    if (ctor === null) return "null";
    if (typeof ctor === "function") return ctor.name || "";
    else if (typeof ctor === "object") {
        const name = ctor.constructor && ctor.constructor.name;
        return name || "";
    }
    return "";
}
function isSameType(a, b) {
    return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
    if ((0, _shared.isArray)(expectedTypes)) return expectedTypes.findIndex((t)=>isSameType(t, type));
    else if ((0, _shared.isFunction)(expectedTypes)) return isSameType(expectedTypes, type) ? 0 : -1;
    return -1;
}
function validateProps(rawProps, props, instance) {
    const resolvedValues = (0, _reactivity.toRaw)(props);
    const options = instance.propsOptions[0];
    for(const key in options){
        let opt = options[key];
        if (opt == null) continue;
        validateProp(key, resolvedValues[key], opt, (0, _reactivity.shallowReadonly)(resolvedValues), !(0, _shared.hasOwn)(rawProps, key) && !(0, _shared.hasOwn)(rawProps, (0, _shared.hyphenate)(key)));
    }
}
function validateProp(name, value, prop, props, isAbsent) {
    const { type, required, validator, skipCheck } = prop;
    if (required && isAbsent) {
        warn$1('Missing required prop: "' + name + '"');
        return;
    }
    if (value == null && !required) return;
    if (type != null && type !== true && !skipCheck) {
        let isValid = false;
        const types = (0, _shared.isArray)(type) ? type : [
            type
        ];
        const expectedTypes = [];
        for(let i = 0; i < types.length && !isValid; i++){
            const { valid, expectedType } = assertType(value, types[i]);
            expectedTypes.push(expectedType || "");
            isValid = valid;
        }
        if (!isValid) {
            warn$1(getInvalidTypeMessage(name, value, expectedTypes));
            return;
        }
    }
    if (validator && !validator(value, props)) warn$1('Invalid prop: custom validator check failed for prop "' + name + '".');
}
const isSimpleType = /* @__PURE__ */ (0, _shared.makeMap)("String,Number,Boolean,Function,Symbol,BigInt");
function assertType(value, type) {
    let valid;
    const expectedType = getType(type);
    if (isSimpleType(expectedType)) {
        const t = typeof value;
        valid = t === expectedType.toLowerCase();
        if (!valid && t === "object") valid = value instanceof type;
    } else if (expectedType === "Object") valid = (0, _shared.isObject)(value);
    else if (expectedType === "Array") valid = (0, _shared.isArray)(value);
    else if (expectedType === "null") valid = value === null;
    else valid = value instanceof type;
    return {
        valid,
        expectedType
    };
}
function getInvalidTypeMessage(name, value, expectedTypes) {
    if (expectedTypes.length === 0) return `Prop type [] for prop "${name}" won't match anything. Did you mean to use type Array instead?`;
    let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map((0, _shared.capitalize)).join(" | ")}`;
    const expectedType = expectedTypes[0];
    const receivedType = (0, _shared.toRawType)(value);
    const expectedValue = styleValue(value, expectedType);
    const receivedValue = styleValue(value, receivedType);
    if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) message += ` with value ${expectedValue}`;
    message += `, got ${receivedType} `;
    if (isExplicable(receivedType)) message += `with value ${receivedValue}.`;
    return message;
}
function styleValue(value, type) {
    if (type === "String") return `"${value}"`;
    else if (type === "Number") return `${Number(value)}`;
    else return `${value}`;
}
function isExplicable(type) {
    const explicitTypes = [
        "string",
        "number",
        "boolean"
    ];
    return explicitTypes.some((elem)=>type.toLowerCase() === elem);
}
function isBoolean(...args) {
    return args.some((elem)=>elem.toLowerCase() === "boolean");
}
const isInternalKey = (key)=>key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value)=>(0, _shared.isArray)(value) ? value.map(normalizeVNode) : [
        normalizeVNode(value)
    ];
const normalizeSlot = (key, rawSlot, ctx)=>{
    if (rawSlot._n) return rawSlot;
    const normalized = withCtx((...args)=>{
        if (currentInstance && (!ctx || ctx.root === currentInstance.root)) warn$1(`Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`);
        return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance)=>{
    const ctx = rawSlots._ctx;
    for(const key in rawSlots){
        if (isInternalKey(key)) continue;
        const value = rawSlots[key];
        if ((0, _shared.isFunction)(value)) slots[key] = normalizeSlot(key, value, ctx);
        else if (value != null) {
            warn$1(`Non-function value encountered for slot "${key}". Prefer function slots for better performance.`);
            const normalized = normalizeSlotValue(value);
            slots[key] = ()=>normalized;
        }
    }
};
const normalizeVNodeSlots = (instance, children)=>{
    if (!isKeepAlive(instance.vnode) && true) warn$1(`Non-function value encountered for default slot. Prefer function slots for better performance.`);
    const normalized = normalizeSlotValue(children);
    instance.slots.default = ()=>normalized;
};
const initSlots = (instance, children)=>{
    if (instance.vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
            instance.slots = (0, _reactivity.toRaw)(children);
            (0, _shared.def)(instance.slots, "_", type);
        } else normalizeObjectSlots(children, instance.slots = {});
    } else {
        instance.slots = {};
        if (children) normalizeVNodeSlots(instance, children);
    }
};
const updateSlots = (instance, children, optimized)=>{
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = (0, _shared.EMPTY_OBJ);
    if (vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
            if (isHmrUpdating) {
                (0, _shared.extend)(slots, children);
                (0, _reactivity.trigger)(instance, "set", "$slots");
            } else if (optimized && type === 1) needDeletionCheck = false;
            else {
                (0, _shared.extend)(slots, children);
                if (!optimized && type === 1) delete slots._;
            }
        } else {
            needDeletionCheck = !children.$stable;
            normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
    } else if (children) {
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = {
            default: 1
        };
    }
    if (needDeletionCheck) {
        for(const key in slots)if (!isInternalKey(key) && deletionComparisonTarget[key] == null) delete slots[key];
    }
};
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if ((0, _shared.isArray)(rawRef)) {
        rawRef.forEach((r, i)=>setRef(r, oldRawRef && ((0, _shared.isArray)(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
        return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) return;
    const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref } = rawRef;
    if (!owner) {
        warn$1(`Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`);
        return;
    }
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === (0, _shared.EMPTY_OBJ) ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    if (oldRef != null && oldRef !== ref) {
        if ((0, _shared.isString)(oldRef)) {
            refs[oldRef] = null;
            if ((0, _shared.hasOwn)(setupState, oldRef)) setupState[oldRef] = null;
        } else if ((0, _reactivity.isRef)(oldRef)) oldRef.value = null;
    }
    if ((0, _shared.isFunction)(ref)) callWithErrorHandling(ref, owner, 12, [
        value,
        refs
    ]);
    else {
        const _isString = (0, _shared.isString)(ref);
        const _isRef = (0, _reactivity.isRef)(ref);
        if (_isString || _isRef) {
            const doSet = ()=>{
                if (rawRef.f) {
                    const existing = _isString ? (0, _shared.hasOwn)(setupState, ref) ? setupState[ref] : refs[ref] : ref.value;
                    if (isUnmount) (0, _shared.isArray)(existing) && (0, _shared.remove)(existing, refValue);
                    else {
                        if (!(0, _shared.isArray)(existing)) {
                            if (_isString) {
                                refs[ref] = [
                                    refValue
                                ];
                                if ((0, _shared.hasOwn)(setupState, ref)) setupState[ref] = refs[ref];
                            } else {
                                ref.value = [
                                    refValue
                                ];
                                if (rawRef.k) refs[rawRef.k] = ref.value;
                            }
                        } else if (!existing.includes(refValue)) existing.push(refValue);
                    }
                } else if (_isString) {
                    refs[ref] = value;
                    if ((0, _shared.hasOwn)(setupState, ref)) setupState[ref] = value;
                } else if (_isRef) {
                    ref.value = value;
                    if (rawRef.k) refs[rawRef.k] = value;
                } else warn$1("Invalid template ref type:", ref, `(${typeof ref})`);
            };
            if (value) {
                doSet.id = -1;
                queuePostRenderEffect(doSet, parentSuspense);
            } else doSet();
        } else warn$1("Invalid template ref type:", ref, `(${typeof ref})`);
    }
}
let hasMismatch = false;
const isSVGContainer = (container)=>container.namespaceURI.includes("svg") && container.tagName !== "foreignObject";
const isMathMLContainer = (container)=>container.namespaceURI.includes("MathML");
const getContainerType = (container)=>{
    if (isSVGContainer(container)) return "svg";
    if (isMathMLContainer(container)) return "mathml";
    return void 0;
};
const isComment = (node)=>node.nodeType === 8 /* COMMENT */ ;
function createHydrationFunctions(rendererInternals) {
    const { mt: mountComponent, p: patch, o: { patchProp, createText, nextSibling, parentNode, remove, insert, createComment } } = rendererInternals;
    const hydrate = (vnode, container)=>{
        if (!container.hasChildNodes()) {
            warn$1(`Attempting to hydrate existing markup but container is empty. Performing full mount instead.`);
            patch(null, vnode, container);
            flushPostFlushCbs();
            container._vnode = vnode;
            return;
        }
        hasMismatch = false;
        hydrateNode(container.firstChild, vnode, null, null, null);
        flushPostFlushCbs();
        container._vnode = vnode;
        if (hasMismatch && true) console.error(`Hydration completed but contains mismatches.`);
    };
    const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false)=>{
        optimized = optimized || !!vnode.dynamicChildren;
        const isFragmentStart = isComment(node) && node.data === "[";
        const onMismatch = ()=>handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
        const { type, ref, shapeFlag, patchFlag } = vnode;
        let domType = node.nodeType;
        vnode.el = node;
        if (!("__vnode" in node)) Object.defineProperty(node, "__vnode", {
            value: vnode,
            enumerable: false
        });
        if (!("__vueParentComponent" in node)) Object.defineProperty(node, "__vueParentComponent", {
            value: parentComponent,
            enumerable: false
        });
        if (patchFlag === -2) {
            optimized = false;
            vnode.dynamicChildren = null;
        }
        let nextNode = null;
        switch(type){
            case Text:
                if (domType !== 3 /* TEXT */ ) {
                    if (vnode.children === "") {
                        insert(vnode.el = createText(""), parentNode(node), node);
                        nextNode = node;
                    } else nextNode = onMismatch();
                } else {
                    if (node.data !== vnode.children) {
                        hasMismatch = true;
                        warn$1(`Hydration text mismatch in`, node.parentNode, `
  - rendered on server: ${JSON.stringify(node.data)}
  - expected on client: ${JSON.stringify(vnode.children)}`);
                        node.data = vnode.children;
                    }
                    nextNode = nextSibling(node);
                }
                break;
            case Comment:
                if (isTemplateNode(node)) {
                    nextNode = nextSibling(node);
                    replaceNode(vnode.el = node.content.firstChild, node, parentComponent);
                } else if (domType !== 8 /* COMMENT */  || isFragmentStart) nextNode = onMismatch();
                else nextNode = nextSibling(node);
                break;
            case Static:
                if (isFragmentStart) {
                    node = nextSibling(node);
                    domType = node.nodeType;
                }
                if (domType === 1 /* ELEMENT */  || domType === 3 /* TEXT */ ) {
                    nextNode = node;
                    const needToAdoptContent = !vnode.children.length;
                    for(let i = 0; i < vnode.staticCount; i++){
                        if (needToAdoptContent) vnode.children += nextNode.nodeType === 1 /* ELEMENT */  ? nextNode.outerHTML : nextNode.data;
                        if (i === vnode.staticCount - 1) vnode.anchor = nextNode;
                        nextNode = nextSibling(nextNode);
                    }
                    return isFragmentStart ? nextSibling(nextNode) : nextNode;
                } else onMismatch();
                break;
            case Fragment:
                if (!isFragmentStart) nextNode = onMismatch();
                else nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                break;
            default:
                if (shapeFlag & 1) {
                    if ((domType !== 1 /* ELEMENT */  || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) && !isTemplateNode(node)) nextNode = onMismatch();
                    else nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                } else if (shapeFlag & 6) {
                    vnode.slotScopeIds = slotScopeIds;
                    const container = parentNode(node);
                    if (isFragmentStart) nextNode = locateClosingAnchor(node);
                    else if (isComment(node) && node.data === "teleport start") nextNode = locateClosingAnchor(node, node.data, "teleport end");
                    else nextNode = nextSibling(node);
                    mountComponent(vnode, container, null, parentComponent, parentSuspense, getContainerType(container), optimized);
                    if (isAsyncWrapper(vnode)) {
                        let subTree;
                        if (isFragmentStart) {
                            subTree = createVNode(Fragment);
                            subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
                        } else subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
                        subTree.el = node;
                        vnode.component.subTree = subTree;
                    }
                } else if (shapeFlag & 64) {
                    if (domType !== 8 /* COMMENT */ ) nextNode = onMismatch();
                    else nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
                } else if (shapeFlag & 128) nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, getContainerType(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
                else warn$1("Invalid HostVNode type:", type, `(${typeof type})`);
        }
        if (ref != null) setRef(ref, null, parentSuspense, vnode);
        return nextNode;
    };
    const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized)=>{
        optimized = optimized || !!vnode.dynamicChildren;
        const { type, props, patchFlag, shapeFlag, dirs, transition } = vnode;
        const forcePatch = type === "input" || type === "option";
        {
            if (dirs) invokeDirectiveHook(vnode, null, parentComponent, "created");
            let needCallTransitionHooks = false;
            if (isTemplateNode(el)) {
                needCallTransitionHooks = needTransition(parentSuspense, transition) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;
                const content = el.content.firstChild;
                if (needCallTransitionHooks) transition.beforeEnter(content);
                replaceNode(content, el, parentComponent);
                vnode.el = el = content;
            }
            if (shapeFlag & 16 && // skip if element has innerHTML / textContent
            !(props && (props.innerHTML || props.textContent))) {
                let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
                let hasWarned = false;
                while(next){
                    hasMismatch = true;
                    if (!hasWarned) {
                        warn$1(`Hydration children mismatch on`, el, `
Server rendered element contains more child nodes than client vdom.`);
                        hasWarned = true;
                    }
                    const cur = next;
                    next = next.nextSibling;
                    remove(cur);
                }
            } else if (shapeFlag & 8) {
                if (el.textContent !== vnode.children) {
                    hasMismatch = true;
                    warn$1(`Hydration text content mismatch on`, el, `
  - rendered on server: ${el.textContent}
  - expected on client: ${vnode.children}`);
                    el.textContent = vnode.children;
                }
            }
            if (props) for(const key in props){
                if (propHasMismatch(el, key, props[key], vnode, parentComponent)) hasMismatch = true;
                if (forcePatch && (key.endsWith("value") || key === "indeterminate") || (0, _shared.isOn)(key) && !(0, _shared.isReservedProp)(key) || // force hydrate v-bind with .prop modifiers
                key[0] === ".") patchProp(el, key, null, props[key], void 0, void 0, parentComponent);
            }
            let vnodeHooks;
            if (vnodeHooks = props && props.onVnodeBeforeMount) invokeVNodeHook(vnodeHooks, parentComponent, vnode);
            if (dirs) invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
            if ((vnodeHooks = props && props.onVnodeMounted) || dirs || needCallTransitionHooks) queueEffectWithSuspense(()=>{
                vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
                needCallTransitionHooks && transition.enter(el);
                dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
            }, parentSuspense);
        }
        return el.nextSibling;
    };
    const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized)=>{
        optimized = optimized || !!parentVNode.dynamicChildren;
        const children = parentVNode.children;
        const l = children.length;
        let hasWarned = false;
        for(let i = 0; i < l; i++){
            const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);
            if (node) node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
            else if (vnode.type === Text && !vnode.children) continue;
            else {
                hasMismatch = true;
                if (!hasWarned) {
                    warn$1(`Hydration children mismatch on`, container, `
Server rendered element contains fewer child nodes than client vdom.`);
                    hasWarned = true;
                }
                patch(null, vnode, container, null, parentComponent, parentSuspense, getContainerType(container), slotScopeIds);
            }
        }
        return node;
    };
    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized)=>{
        const { slotScopeIds: fragmentSlotScopeIds } = vnode;
        if (fragmentSlotScopeIds) slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        const container = parentNode(node);
        const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
        if (next && isComment(next) && next.data === "]") return nextSibling(vnode.anchor = next);
        else {
            hasMismatch = true;
            insert(vnode.anchor = createComment(`]`), container, next);
            return next;
        }
    };
    const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment)=>{
        hasMismatch = true;
        warn$1(`Hydration node mismatch:
- rendered on server:`, node, node.nodeType === 3 /* TEXT */  ? `(text)` : isComment(node) && node.data === "[" ? `(start of fragment)` : ``, `
- expected on client:`, vnode.type);
        vnode.el = null;
        if (isFragment) {
            const end = locateClosingAnchor(node);
            while(true){
                const next2 = nextSibling(node);
                if (next2 && next2 !== end) remove(next2);
                else break;
            }
        }
        const next = nextSibling(node);
        const container = parentNode(node);
        remove(node);
        patch(null, vnode, container, next, parentComponent, parentSuspense, getContainerType(container), slotScopeIds);
        return next;
    };
    const locateClosingAnchor = (node, open = "[", close = "]")=>{
        let match = 0;
        while(node){
            node = nextSibling(node);
            if (node && isComment(node)) {
                if (node.data === open) match++;
                if (node.data === close) {
                    if (match === 0) return nextSibling(node);
                    else match--;
                }
            }
        }
        return node;
    };
    const replaceNode = (newNode, oldNode, parentComponent)=>{
        const parentNode2 = oldNode.parentNode;
        if (parentNode2) parentNode2.replaceChild(newNode, oldNode);
        let parent = parentComponent;
        while(parent){
            if (parent.vnode.el === oldNode) parent.vnode.el = parent.subTree.el = newNode;
            parent = parent.parent;
        }
    };
    const isTemplateNode = (node)=>{
        return node.nodeType === 1 /* ELEMENT */  && node.tagName.toLowerCase() === "template";
    };
    return [
        hydrate,
        hydrateNode
    ];
}
function propHasMismatch(el, key, clientValue, vnode, instance) {
    var _a;
    let mismatchType;
    let mismatchKey;
    let actual;
    let expected;
    if (key === "class") {
        actual = el.getAttribute("class");
        expected = (0, _shared.normalizeClass)(clientValue);
        if (!isSetEqual(toClassSet(actual || ""), toClassSet(expected))) mismatchType = mismatchKey = `class`;
    } else if (key === "style") {
        actual = el.getAttribute("style");
        expected = (0, _shared.isString)(clientValue) ? clientValue : (0, _shared.stringifyStyle)((0, _shared.normalizeStyle)(clientValue));
        const actualMap = toStyleMap(actual);
        const expectedMap = toStyleMap(expected);
        if (vnode.dirs) {
            for (const { dir, value } of vnode.dirs)if (dir.name === "show" && !value) expectedMap.set("display", "none");
        }
        const root = instance == null ? void 0 : instance.subTree;
        if (vnode === root || (root == null ? void 0 : root.type) === Fragment && root.children.includes(vnode)) {
            const cssVars = (_a = instance == null ? void 0 : instance.getCssVars) == null ? void 0 : _a.call(instance);
            for(const key2 in cssVars)expectedMap.set(`--${key2}`, String(cssVars[key2]));
        }
        if (!isMapEqual(actualMap, expectedMap)) mismatchType = mismatchKey = "style";
    } else if (el instanceof SVGElement && (0, _shared.isKnownSvgAttr)(key) || el instanceof HTMLElement && ((0, _shared.isBooleanAttr)(key) || (0, _shared.isKnownHtmlAttr)(key))) {
        if ((0, _shared.isBooleanAttr)(key)) {
            actual = el.hasAttribute(key);
            expected = (0, _shared.includeBooleanAttr)(clientValue);
        } else if (clientValue == null) {
            actual = el.hasAttribute(key);
            expected = false;
        } else {
            if (el.hasAttribute(key)) actual = el.getAttribute(key);
            else if (key === "value" && el.tagName === "TEXTAREA") actual = el.value;
            else actual = false;
            expected = (0, _shared.isRenderableAttrValue)(clientValue) ? String(clientValue) : false;
        }
        if (actual !== expected) {
            mismatchType = `attribute`;
            mismatchKey = key;
        }
    }
    if (mismatchType) {
        const format = (v1)=>v1 === false ? `(not rendered)` : `${mismatchKey}="${v1}"`;
        const preSegment = `Hydration ${mismatchType} mismatch on`;
        const postSegment = `
  - rendered on server: ${format(actual)}
  - expected on client: ${format(expected)}
  Note: this mismatch is check-only. The DOM will not be rectified in production due to performance overhead.
  You should fix the source of the mismatch.`;
        warn$1(preSegment, el, postSegment);
        return true;
    }
    return false;
}
function toClassSet(str) {
    return new Set(str.trim().split(/\s+/));
}
function isSetEqual(a, b) {
    if (a.size !== b.size) return false;
    for (const s of a){
        if (!b.has(s)) return false;
    }
    return true;
}
function toStyleMap(str) {
    const styleMap = /* @__PURE__ */ new Map();
    for (const item of str.split(";")){
        let [key, value] = item.split(":");
        key = key == null ? void 0 : key.trim();
        value = value == null ? void 0 : value.trim();
        if (key && value) styleMap.set(key, value);
    }
    return styleMap;
}
function isMapEqual(a, b) {
    if (a.size !== b.size) return false;
    for (const [key, value] of a){
        if (value !== b.get(key)) return false;
    }
    return true;
}
let supported;
let perf;
function startMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) perf.mark(`vue-${type}-${instance.uid}`);
    devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());
}
function endMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
        const startTag = `vue-${type}-${instance.uid}`;
        const endTag = startTag + `:end`;
        perf.mark(endTag);
        perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
    }
    devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());
}
function isSupported() {
    if (supported !== void 0) return supported;
    if (typeof window !== "undefined" && window.performance) {
        supported = true;
        perf = window.performance;
    } else supported = false;
    return supported;
}
function initFeatureFlags() {
    const needWarn = [];
    if (typeof __VUE_OPTIONS_API__ !== "boolean") {
        needWarn.push(`__VUE_OPTIONS_API__`);
        (0, _shared.getGlobalThis)().__VUE_OPTIONS_API__ = true;
    }
    if (typeof __VUE_PROD_DEVTOOLS__ !== "boolean") {
        needWarn.push(`__VUE_PROD_DEVTOOLS__`);
        (0, _shared.getGlobalThis)().__VUE_PROD_DEVTOOLS__ = false;
    }
    if (typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ !== "boolean") {
        needWarn.push(`__VUE_PROD_HYDRATION_MISMATCH_DETAILS__`);
        (0, _shared.getGlobalThis)().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = false;
    }
    if (0, needWarn.length) {
        const multi = needWarn.length > 1;
        console.warn(`Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`);
    }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
    return baseCreateRenderer(options);
}
function createHydrationRenderer(options) {
    return baseCreateRenderer(options, createHydrationFunctions);
}
function baseCreateRenderer(options, createHydrationFns) {
    initFeatureFlags();
    const target = (0, _shared.getGlobalThis)();
    target.__VUE__ = true;
    setDevtoolsHook$1(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = (0, _shared.NOOP), insertStaticContent: hostInsertStaticContent } = options;
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren)=>{
        if (n1 === n2) return;
        if (n1 && !isSameVNodeType(n1, n2)) {
            anchor = getNextHostNode(n1);
            unmount(n1, parentComponent, parentSuspense, true);
            n1 = null;
        }
        if (n2.patchFlag === -2) {
            optimized = false;
            n2.dynamicChildren = null;
        }
        const { type, ref, shapeFlag } = n2;
        switch(type){
            case Text:
                processText(n1, n2, container, anchor);
                break;
            case Comment:
                processCommentNode(n1, n2, container, anchor);
                break;
            case Static:
                if (n1 == null) mountStaticNode(n2, container, anchor, namespace);
                else patchStaticNode(n1, n2, container, namespace);
                break;
            case Fragment:
                processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                break;
            default:
                if (shapeFlag & 1) processElement(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                else if (shapeFlag & 6) processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                else if (shapeFlag & 64) type.process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals);
                else if (shapeFlag & 128) type.process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals);
                else warn$1("Invalid VNode type:", type, `(${typeof type})`);
        }
        if (ref != null && parentComponent) setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    };
    const processText = (n1, n2, container, anchor)=>{
        if (n1 == null) hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
        else {
            const el = n2.el = n1.el;
            if (n2.children !== n1.children) hostSetText(el, n2.children);
        }
    };
    const processCommentNode = (n1, n2, container, anchor)=>{
        if (n1 == null) hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
        else n2.el = n1.el;
    };
    const mountStaticNode = (n2, container, anchor, namespace)=>{
        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, namespace, n2.el, n2.anchor);
    };
    const patchStaticNode = (n1, n2, container, namespace)=>{
        if (n2.children !== n1.children) {
            const anchor = hostNextSibling(n1.anchor);
            removeStaticNode(n1);
            [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, namespace);
        } else {
            n2.el = n1.el;
            n2.anchor = n1.anchor;
        }
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling)=>{
        let next;
        while(el && el !== anchor){
            next = hostNextSibling(el);
            hostInsert(el, container, nextSibling);
            el = next;
        }
        hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor })=>{
        let next;
        while(el && el !== anchor){
            next = hostNextSibling(el);
            hostRemove(el);
            el = next;
        }
        hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)=>{
        if (n2.type === "svg") namespace = "svg";
        else if (n2.type === "math") namespace = "mathml";
        if (n1 == null) mountElement(n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
        else patchElement(n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)=>{
        let el;
        let vnodeHook;
        const { props, shapeFlag, transition, dirs } = vnode;
        el = vnode.el = hostCreateElement(vnode.type, namespace, props && props.is, props);
        if (shapeFlag & 8) hostSetElementText(el, vnode.children);
        else if (shapeFlag & 16) mountChildren(vnode.children, el, null, parentComponent, parentSuspense, resolveChildrenNamespace(vnode, namespace), slotScopeIds, optimized);
        if (dirs) invokeDirectiveHook(vnode, null, parentComponent, "created");
        setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        if (props) {
            for(const key in props)if (key !== "value" && !(0, _shared.isReservedProp)(key)) hostPatchProp(el, key, null, props[key], namespace, vnode.children, parentComponent, parentSuspense, unmountChildren);
            if ("value" in props) hostPatchProp(el, "value", null, props.value, namespace);
            if (vnodeHook = props.onVnodeBeforeMount) invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        Object.defineProperty(el, "__vnode", {
            value: vnode,
            enumerable: false
        });
        Object.defineProperty(el, "__vueParentComponent", {
            value: parentComponent,
            enumerable: false
        });
        if (dirs) invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        const needCallTransitionHooks = needTransition(parentSuspense, transition);
        if (needCallTransitionHooks) transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) queuePostRenderEffect(()=>{
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent)=>{
        if (scopeId) hostSetScopeId(el, scopeId);
        if (slotScopeIds) for(let i = 0; i < slotScopeIds.length; i++)hostSetScopeId(el, slotScopeIds[i]);
        if (parentComponent) {
            let subTree = parentComponent.subTree;
            if (subTree.patchFlag > 0 && subTree.patchFlag & 2048) subTree = filterSingleRoot(subTree.children) || subTree;
            if (vnode === subTree) {
                const parentVNode = parentComponent.vnode;
                setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
            }
        }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0)=>{
        for(let i = start; i < children.length; i++){
            const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
            patch(null, child, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
        }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)=>{
        const el = n2.el = n1.el;
        let { patchFlag, dynamicChildren, dirs } = n2;
        patchFlag |= n1.patchFlag & 16;
        const oldProps = n1.props || (0, _shared.EMPTY_OBJ);
        const newProps = n2.props || (0, _shared.EMPTY_OBJ);
        let vnodeHook;
        parentComponent && toggleRecurse(parentComponent, false);
        if (vnodeHook = newProps.onVnodeBeforeUpdate) invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        if (dirs) invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
        parentComponent && toggleRecurse(parentComponent, true);
        if (isHmrUpdating) {
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
        }
        if (dynamicChildren) {
            patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, resolveChildrenNamespace(n2, namespace), slotScopeIds);
            traverseStaticChildren(n1, n2);
        } else if (!optimized) patchChildren(n1, n2, el, null, parentComponent, parentSuspense, resolveChildrenNamespace(n2, namespace), slotScopeIds, false);
        if (patchFlag > 0) {
            if (patchFlag & 16) patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, namespace);
            else {
                if (patchFlag & 2) {
                    if (oldProps.class !== newProps.class) hostPatchProp(el, "class", null, newProps.class, namespace);
                }
                if (patchFlag & 4) hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
                if (patchFlag & 8) {
                    const propsToUpdate = n2.dynamicProps;
                    for(let i = 0; i < propsToUpdate.length; i++){
                        const key = propsToUpdate[i];
                        const prev = oldProps[key];
                        const next = newProps[key];
                        if (next !== prev || key === "value") hostPatchProp(el, key, prev, next, namespace, n1.children, parentComponent, parentSuspense, unmountChildren);
                    }
                }
            }
            if (patchFlag & 1) {
                if (n1.children !== n2.children) hostSetElementText(el, n2.children);
            }
        } else if (!optimized && dynamicChildren == null) patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, namespace);
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) queuePostRenderEffect(()=>{
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
            dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
        }, parentSuspense);
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds)=>{
        for(let i = 0; i < newChildren.length; i++){
            const oldVNode = oldChildren[i];
            const newVNode = newChildren[i];
            const container = // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
            // of the Fragment itself so it can move its children.
            (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
            // which also requires the correct parent container
            !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
            oldVNode.shapeFlag & 70) ? hostParentNode(oldVNode.el) : // In other cases, the parent container is not actually used so we
            // just pass the block element here to avoid a DOM parentNode call.
            fallbackContainer;
            patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, true);
        }
    };
    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, namespace)=>{
        if (oldProps !== newProps) {
            if (oldProps !== (0, _shared.EMPTY_OBJ)) {
                for(const key in oldProps)if (!(0, _shared.isReservedProp)(key) && !(key in newProps)) hostPatchProp(el, key, oldProps[key], null, namespace, vnode.children, parentComponent, parentSuspense, unmountChildren);
            }
            for(const key in newProps){
                if ((0, _shared.isReservedProp)(key)) continue;
                const next = newProps[key];
                const prev = oldProps[key];
                if (next !== prev && key !== "value") hostPatchProp(el, key, prev, next, namespace, vnode.children, parentComponent, parentSuspense, unmountChildren);
            }
            if ("value" in newProps) hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
        }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)=>{
        const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
        const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (// #5523 dev root fragment may inherit directives
        isHmrUpdating || patchFlag & 2048) {
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
        }
        if (fragmentSlotScopeIds) slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        if (n1 == null) {
            hostInsert(fragmentStartAnchor, container, anchor);
            hostInsert(fragmentEndAnchor, container, anchor);
            mountChildren(// #10007
            // such fragment like `<></>` will be compiled into
            // a fragment which doesn't have a children.
            // In this case fallback to an empty array
            n2.children || [], container, fragmentEndAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
        } else if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
        // of renderSlot() with no valid children
        n1.dynamicChildren) {
            patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, namespace, slotScopeIds);
            traverseStaticChildren(n1, n2);
        } else patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)=>{
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
            if (n2.shapeFlag & 512) parentComponent.ctx.activate(n2, container, anchor, namespace, optimized);
            else mountComponent(n2, container, anchor, parentComponent, parentSuspense, namespace, optimized);
        } else updateComponent(n1, n2, optimized);
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized)=>{
        const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
        if (0, instance.type.__hmrId) registerHMR(instance);
        pushWarningContext(initialVNode);
        startMeasure(instance, `mount`);
        if (isKeepAlive(initialVNode)) instance.ctx.renderer = internals;
        startMeasure(instance, `init`);
        setupComponent(instance);
        endMeasure(instance, `init`);
        if (instance.asyncDep) {
            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
            if (!initialVNode.el) {
                const placeholder = instance.subTree = createVNode(Comment);
                processCommentNode(null, placeholder, container, anchor);
            }
        } else setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, namespace, optimized);
        popWarningContext();
        endMeasure(instance, `mount`);
    };
    const updateComponent = (n1, n2, optimized)=>{
        const instance = n2.component = n1.component;
        if (shouldUpdateComponent(n1, n2, optimized)) {
            if (instance.asyncDep && !instance.asyncResolved) {
                pushWarningContext(n2);
                updateComponentPreRender(instance, n2, optimized);
                popWarningContext();
                return;
            } else {
                instance.next = n2;
                invalidateJob(instance.update);
                instance.effect.dirty = true;
                instance.update();
            }
        } else {
            n2.el = n1.el;
            instance.vnode = n2;
        }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized)=>{
        const componentUpdateFn = ()=>{
            if (!instance.isMounted) {
                let vnodeHook;
                const { el, props } = initialVNode;
                const { bm, m, parent } = instance;
                const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
                toggleRecurse(instance, false);
                if (bm) (0, _shared.invokeArrayFns)(bm);
                if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) invokeVNodeHook(vnodeHook, parent, initialVNode);
                toggleRecurse(instance, true);
                if (el && hydrateNode) {
                    const hydrateSubTree = ()=>{
                        startMeasure(instance, `render`);
                        instance.subTree = renderComponentRoot(instance);
                        endMeasure(instance, `render`);
                        startMeasure(instance, `hydrate`);
                        hydrateNode(el, instance.subTree, instance, parentSuspense, null);
                        endMeasure(instance, `hydrate`);
                    };
                    if (isAsyncWrapperVNode) initialVNode.type.__asyncLoader().then(// note: we are moving the render call into an async callback,
                    // which means it won't track dependencies - but it's ok because
                    // a server-rendered async wrapper is already in resolved state
                    // and it will never need to change.
                    ()=>!instance.isUnmounted && hydrateSubTree());
                    else hydrateSubTree();
                } else {
                    startMeasure(instance, `render`);
                    const subTree = instance.subTree = renderComponentRoot(instance);
                    endMeasure(instance, `render`);
                    startMeasure(instance, `patch`);
                    patch(null, subTree, container, anchor, instance, parentSuspense, namespace);
                    endMeasure(instance, `patch`);
                    initialVNode.el = subTree.el;
                }
                if (m) queuePostRenderEffect(m, parentSuspense);
                if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
                    const scopedInitialVNode = initialVNode;
                    queuePostRenderEffect(()=>invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
                }
                if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) instance.a && queuePostRenderEffect(instance.a, parentSuspense);
                instance.isMounted = true;
                devtoolsComponentAdded(instance);
                initialVNode = container = anchor = null;
            } else {
                let { next, bu, u, parent, vnode } = instance;
                {
                    const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
                    if (nonHydratedAsyncRoot) {
                        if (next) {
                            next.el = vnode.el;
                            updateComponentPreRender(instance, next, optimized);
                        }
                        nonHydratedAsyncRoot.asyncDep.then(()=>{
                            if (!instance.isUnmounted) componentUpdateFn();
                        });
                        return;
                    }
                }
                let originNext = next;
                let vnodeHook;
                pushWarningContext(next || instance.vnode);
                toggleRecurse(instance, false);
                if (next) {
                    next.el = vnode.el;
                    updateComponentPreRender(instance, next, optimized);
                } else next = vnode;
                if (bu) (0, _shared.invokeArrayFns)(bu);
                if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) invokeVNodeHook(vnodeHook, parent, next, vnode);
                toggleRecurse(instance, true);
                startMeasure(instance, `render`);
                const nextTree = renderComponentRoot(instance);
                endMeasure(instance, `render`);
                const prevTree = instance.subTree;
                instance.subTree = nextTree;
                startMeasure(instance, `patch`);
                patch(prevTree, nextTree, // parent may have changed if it's in a teleport
                hostParentNode(prevTree.el), // anchor may have changed if it's in a fragment
                getNextHostNode(prevTree), instance, parentSuspense, namespace);
                endMeasure(instance, `patch`);
                next.el = nextTree.el;
                if (originNext === null) updateHOCHostEl(instance, nextTree.el);
                if (u) queuePostRenderEffect(u, parentSuspense);
                if (vnodeHook = next.props && next.props.onVnodeUpdated) queuePostRenderEffect(()=>invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
                devtoolsComponentUpdated(instance);
                popWarningContext();
            }
        };
        const effect = instance.effect = new (0, _reactivity.ReactiveEffect)(componentUpdateFn, (0, _shared.NOOP), ()=>queueJob(update), instance.scope);
        const update = instance.update = ()=>{
            if (effect.dirty) effect.run();
        };
        update.id = instance.uid;
        toggleRecurse(instance, true);
        effect.onTrack = instance.rtc ? (e)=>(0, _shared.invokeArrayFns)(instance.rtc, e) : void 0;
        effect.onTrigger = instance.rtg ? (e)=>(0, _shared.invokeArrayFns)(instance.rtg, e) : void 0;
        update.ownerInstance = instance;
        update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized)=>{
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        (0, _reactivity.pauseTracking)();
        flushPreFlushCbs(instance);
        (0, _reactivity.resetTracking)();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false)=>{
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        if (patchFlag > 0) {
            if (patchFlag & 128) {
                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                return;
            } else if (patchFlag & 256) {
                patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                return;
            }
        }
        if (shapeFlag & 8) {
            if (prevShapeFlag & 16) unmountChildren(c1, parentComponent, parentSuspense);
            if (c2 !== c1) hostSetElementText(container, c2);
        } else if (prevShapeFlag & 16) {
            if (shapeFlag & 16) patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
            else unmountChildren(c1, parentComponent, parentSuspense, true);
        } else {
            if (prevShapeFlag & 8) hostSetElementText(container, "");
            if (shapeFlag & 16) mountChildren(c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
        }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)=>{
        c1 = c1 || (0, _shared.EMPTY_ARR);
        c2 = c2 || (0, _shared.EMPTY_ARR);
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for(i = 0; i < commonLength; i++){
            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
        }
        if (oldLength > newLength) unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
        else mountChildren(c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, commonLength);
    };
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)=>{
        let i = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1;
        let e2 = l2 - 1;
        while(i <= e1 && i <= e2){
            const n1 = c1[i];
            const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            if (isSameVNodeType(n1, n2)) patch(n1, n2, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
            else break;
            i++;
        }
        while(i <= e1 && i <= e2){
            const n1 = c1[e1];
            const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
            if (isSameVNodeType(n1, n2)) patch(n1, n2, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
            else break;
            e1--;
            e2--;
        }
        if (i > e1) {
            if (i <= e2) {
                const nextPos = e2 + 1;
                const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
                while(i <= e2){
                    patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                    i++;
                }
            }
        } else if (i > e2) while(i <= e1){
            unmount(c1[i], parentComponent, parentSuspense, true);
            i++;
        }
        else {
            const s1 = i;
            const s2 = i;
            const keyToNewIndexMap = /* @__PURE__ */ new Map();
            for(i = s2; i <= e2; i++){
                const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
                if (nextChild.key != null) {
                    if (keyToNewIndexMap.has(nextChild.key)) warn$1(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
                    keyToNewIndexMap.set(nextChild.key, i);
                }
            }
            let j;
            let patched = 0;
            const toBePatched = e2 - s2 + 1;
            let moved = false;
            let maxNewIndexSoFar = 0;
            const newIndexToOldIndexMap = new Array(toBePatched);
            for(i = 0; i < toBePatched; i++)newIndexToOldIndexMap[i] = 0;
            for(i = s1; i <= e1; i++){
                const prevChild = c1[i];
                if (patched >= toBePatched) {
                    unmount(prevChild, parentComponent, parentSuspense, true);
                    continue;
                }
                let newIndex;
                if (prevChild.key != null) newIndex = keyToNewIndexMap.get(prevChild.key);
                else {
                    for(j = s2; j <= e2; j++)if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                        newIndex = j;
                        break;
                    }
                }
                if (newIndex === void 0) unmount(prevChild, parentComponent, parentSuspense, true);
                else {
                    newIndexToOldIndexMap[newIndex - s2] = i + 1;
                    if (newIndex >= maxNewIndexSoFar) maxNewIndexSoFar = newIndex;
                    else moved = true;
                    patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                    patched++;
                }
            }
            const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : (0, _shared.EMPTY_ARR);
            j = increasingNewIndexSequence.length - 1;
            for(i = toBePatched - 1; i >= 0; i--){
                const nextIndex = s2 + i;
                const nextChild = c2[nextIndex];
                const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
                if (newIndexToOldIndexMap[i] === 0) patch(null, nextChild, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                else if (moved) {
                    if (j < 0 || i !== increasingNewIndexSequence[j]) move(nextChild, container, anchor, 2);
                    else j--;
                }
            }
        }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null)=>{
        const { el, type, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6) {
            move(vnode.component.subTree, container, anchor, moveType);
            return;
        }
        if (shapeFlag & 128) {
            vnode.suspense.move(container, anchor, moveType);
            return;
        }
        if (shapeFlag & 64) {
            type.move(vnode, container, anchor, internals);
            return;
        }
        if (type === Fragment) {
            hostInsert(el, container, anchor);
            for(let i = 0; i < children.length; i++)move(children[i], container, anchor, moveType);
            hostInsert(vnode.anchor, container, anchor);
            return;
        }
        if (type === Static) {
            moveStaticNode(vnode, container, anchor);
            return;
        }
        const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
        if (needTransition2) {
            if (moveType === 0) {
                transition.beforeEnter(el);
                hostInsert(el, container, anchor);
                queuePostRenderEffect(()=>transition.enter(el), parentSuspense);
            } else {
                const { leave, delayLeave, afterLeave } = transition;
                const remove2 = ()=>hostInsert(el, container, anchor);
                const performLeave = ()=>{
                    leave(el, ()=>{
                        remove2();
                        afterLeave && afterLeave();
                    });
                };
                if (delayLeave) delayLeave(el, remove2, performLeave);
                else performLeave();
            }
        } else hostInsert(el, container, anchor);
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false)=>{
        const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
        if (ref != null) setRef(ref, null, parentSuspense, vnode, true);
        if (shapeFlag & 256) {
            parentComponent.ctx.deactivate(vnode);
            return;
        }
        const shouldInvokeDirs = shapeFlag & 1 && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) invokeVNodeHook(vnodeHook, parentComponent, vnode);
        if (shapeFlag & 6) unmountComponent(vnode.component, parentSuspense, doRemove);
        else {
            if (shapeFlag & 128) {
                vnode.suspense.unmount(parentSuspense, doRemove);
                return;
            }
            if (shouldInvokeDirs) invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
            if (shapeFlag & 64) vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
            else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
            (type !== Fragment || patchFlag > 0 && patchFlag & 64)) unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
            else if (type === Fragment && patchFlag & 384 || !optimized && shapeFlag & 16) unmountChildren(children, parentComponent, parentSuspense);
            if (doRemove) remove(vnode);
        }
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) queuePostRenderEffect(()=>{
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
    };
    const remove = (vnode)=>{
        const { type, el, anchor, transition } = vnode;
        if (type === Fragment) {
            if (vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) vnode.children.forEach((child)=>{
                if (child.type === Comment) hostRemove(child.el);
                else remove(child);
            });
            else removeFragment(el, anchor);
            return;
        }
        if (type === Static) {
            removeStaticNode(vnode);
            return;
        }
        const performRemove = ()=>{
            hostRemove(el);
            if (transition && !transition.persisted && transition.afterLeave) transition.afterLeave();
        };
        if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
            const { leave, delayLeave } = transition;
            const performLeave = ()=>leave(el, performRemove);
            if (delayLeave) delayLeave(vnode.el, performRemove, performLeave);
            else performLeave();
        } else performRemove();
    };
    const removeFragment = (cur, end)=>{
        let next;
        while(cur !== end){
            next = hostNextSibling(cur);
            hostRemove(cur);
            cur = next;
        }
        hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove)=>{
        if (0, instance.type.__hmrId) unregisterHMR(instance);
        const { bum, scope, update, subTree, um } = instance;
        if (bum) (0, _shared.invokeArrayFns)(bum);
        scope.stop();
        if (update) {
            update.active = false;
            unmount(subTree, instance, parentSuspense, doRemove);
        }
        if (um) queuePostRenderEffect(um, parentSuspense);
        queuePostRenderEffect(()=>{
            instance.isUnmounted = true;
        }, parentSuspense);
        if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
            parentSuspense.deps--;
            if (parentSuspense.deps === 0) parentSuspense.resolve();
        }
        devtoolsComponentRemoved(instance);
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0)=>{
        for(let i = start; i < children.length; i++)unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    };
    const getNextHostNode = (vnode)=>{
        if (vnode.shapeFlag & 6) return getNextHostNode(vnode.component.subTree);
        if (vnode.shapeFlag & 128) return vnode.suspense.next();
        return hostNextSibling(vnode.anchor || vnode.el);
    };
    let isFlushing = false;
    const render = (vnode, container, namespace)=>{
        if (vnode == null) {
            if (container._vnode) unmount(container._vnode, null, null, true);
        } else patch(container._vnode || null, vnode, container, null, null, null, namespace);
        if (!isFlushing) {
            isFlushing = true;
            flushPreFlushCbs();
            flushPostFlushCbs();
            isFlushing = false;
        }
        container._vnode = vnode;
    };
    const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
    };
    let hydrate;
    let hydrateNode;
    if (createHydrationFns) [hydrate, hydrateNode] = createHydrationFns(internals);
    return {
        render,
        hydrate,
        createApp: createAppAPI(render, hydrate)
    };
}
function resolveChildrenNamespace({ type, props }, currentNamespace) {
    return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect, update }, allowed) {
    effect.allowRecurse = update.allowRecurse = allowed;
}
function needTransition(parentSuspense, transition) {
    return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if ((0, _shared.isArray)(ch1) && (0, _shared.isArray)(ch2)) for(let i = 0; i < ch1.length; i++){
        const c1 = ch1[i];
        let c2 = ch2[i];
        if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
            if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
                c2 = ch2[i] = cloneIfMounted(ch2[i]);
                c2.el = c1.el;
            }
            if (!shallow) traverseStaticChildren(c1, c2);
        }
        if (c2.type === Text) c2.el = c1.el;
        if (c2.type === Comment && !c2.el) c2.el = c1.el;
    }
}
function getSequence(arr) {
    const p = arr.slice();
    const result = [
        0
    ];
    let i, j, u, v1, c;
    const len = arr.length;
    for(i = 0; i < len; i++){
        const arrI = arr[i];
        if (arrI !== 0) {
            j = result[result.length - 1];
            if (arr[j] < arrI) {
                p[i] = j;
                result.push(i);
                continue;
            }
            u = 0;
            v1 = result.length - 1;
            while(u < v1){
                c = u + v1 >> 1;
                if (arr[result[c]] < arrI) u = c + 1;
                else v1 = c;
            }
            if (arrI < arr[result[u]]) {
                if (u > 0) p[i] = result[u - 1];
                result[u] = i;
            }
        }
    }
    u = result.length;
    v1 = result[u - 1];
    while(u-- > 0){
        result[u] = v1;
        v1 = p[v1];
    }
    return result;
}
function locateNonHydratedAsyncRoot(instance) {
    const subComponent = instance.subTree.component;
    if (subComponent) {
        if (subComponent.asyncDep && !subComponent.asyncResolved) return subComponent;
        else return locateNonHydratedAsyncRoot(subComponent);
    }
}
const isTeleport = (type)=>type.__isTeleport;
const isTeleportDisabled = (props)=>props && (props.disabled || props.disabled === "");
const isTargetSVG = (target)=>typeof SVGElement !== "undefined" && target instanceof SVGElement;
const isTargetMathML = (target)=>typeof MathMLElement === "function" && target instanceof MathMLElement;
const resolveTarget = (props, select)=>{
    const targetSelector = props && props.to;
    if ((0, _shared.isString)(targetSelector)) {
        if (!select) {
            warn$1(`Current renderer does not support string target for Teleports. (missing querySelector renderer option)`);
            return null;
        } else {
            const target = select(targetSelector);
            if (!target) warn$1(`Failed to locate Teleport target with selector "${targetSelector}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`);
            return target;
        }
    } else {
        if (!targetSelector && !isTeleportDisabled(props)) warn$1(`Invalid Teleport target: ${targetSelector}`);
        return targetSelector;
    }
};
const TeleportImpl = {
    name: "Teleport",
    __isTeleport: true,
    process (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
        const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        if (isHmrUpdating) {
            optimized = false;
            dynamicChildren = null;
        }
        if (n1 == null) {
            const placeholder = n2.el = createComment("teleport start");
            const mainAnchor = n2.anchor = createComment("teleport end");
            insert(placeholder, container, anchor);
            insert(mainAnchor, container, anchor);
            const target = n2.target = resolveTarget(n2.props, querySelector);
            const targetAnchor = n2.targetAnchor = createText("");
            if (target) {
                insert(targetAnchor, target);
                if (namespace === "svg" || isTargetSVG(target)) namespace = "svg";
                else if (namespace === "mathml" || isTargetMathML(target)) namespace = "mathml";
            } else if (!disabled) warn$1("Invalid Teleport target on mount:", target, `(${typeof target})`);
            const mount = (container2, anchor2)=>{
                if (shapeFlag & 16) mountChildren(children, container2, anchor2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
            };
            if (disabled) mount(container, mainAnchor);
            else if (target) mount(target, targetAnchor);
        } else {
            n2.el = n1.el;
            const mainAnchor = n2.anchor = n1.anchor;
            const target = n2.target = n1.target;
            const targetAnchor = n2.targetAnchor = n1.targetAnchor;
            const wasDisabled = isTeleportDisabled(n1.props);
            const currentContainer = wasDisabled ? container : target;
            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
            if (namespace === "svg" || isTargetSVG(target)) namespace = "svg";
            else if (namespace === "mathml" || isTargetMathML(target)) namespace = "mathml";
            if (dynamicChildren) {
                patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, namespace, slotScopeIds);
                traverseStaticChildren(n1, n2, true);
            } else if (!optimized) patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, false);
            if (disabled) {
                if (!wasDisabled) moveTeleport(n2, container, mainAnchor, internals, 1);
                else if (n2.props && n1.props && n2.props.to !== n1.props.to) n2.props.to = n1.props.to;
            } else {
                if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                    const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
                    if (nextTarget) moveTeleport(n2, nextTarget, null, internals, 0);
                    else warn$1("Invalid Teleport target on update:", target, `(${typeof target})`);
                } else if (wasDisabled) moveTeleport(n2, target, targetAnchor, internals, 1);
            }
        }
        updateCssVars(n2);
    },
    remove (vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
        const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
        if (target) hostRemove(targetAnchor);
        doRemove && hostRemove(anchor);
        if (shapeFlag & 16) {
            const shouldRemove = doRemove || !isTeleportDisabled(props);
            for(let i = 0; i < children.length; i++){
                const child = children[i];
                unmount(child, parentComponent, parentSuspense, shouldRemove, !!child.dynamicChildren);
            }
        }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
    if (moveType === 0) insert(vnode.targetAnchor, container, parentAnchor);
    const { el, anchor, shapeFlag, children, props } = vnode;
    const isReorder = moveType === 2;
    if (isReorder) insert(el, container, parentAnchor);
    if (!isReorder || isTeleportDisabled(props)) {
        if (shapeFlag & 16) for(let i = 0; i < children.length; i++)move(children[i], container, parentAnchor, 2);
    }
    if (isReorder) insert(anchor, container, parentAnchor);
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
    const target = vnode.target = resolveTarget(vnode.props, querySelector);
    if (target) {
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16) {
            if (isTeleportDisabled(vnode.props)) {
                vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
                vnode.targetAnchor = targetNode;
            } else {
                vnode.anchor = nextSibling(node);
                let targetAnchor = targetNode;
                while(targetAnchor){
                    targetAnchor = nextSibling(targetAnchor);
                    if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
                        vnode.targetAnchor = targetAnchor;
                        target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                        break;
                    }
                }
                hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
            }
        }
        updateCssVars(vnode);
    }
    return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode) {
    const ctx = vnode.ctx;
    if (ctx && ctx.ut) {
        let node = vnode.children[0].el;
        while(node && node !== vnode.targetAnchor){
            if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
            node = node.nextSibling;
        }
        ctx.ut();
    }
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
    blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
    isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || (0, _shared.EMPTY_ARR) : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) currentBlock.push(vnode);
    return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true));
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
    return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true));
}
function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
    if (n2.shapeFlag & 6 && hmrDirtyComponents.has(n2.type)) {
        n1.shapeFlag &= -257;
        n2.shapeFlag &= -513;
        return false;
    }
    return n1.type === n2.type && n1.key === n2.key;
}
let vnodeArgsTransformer;
function transformVNodeArgs(transformer) {
    vnodeArgsTransformer = transformer;
}
const createVNodeWithArgsTransform = (...args)=>{
    return _createVNode(...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args);
};
const normalizeKey = ({ key })=>key != null ? key : null;
const normalizeRef = ({ ref, ref_key, ref_for })=>{
    if (typeof ref === "number") ref = "" + ref;
    return ref != null ? (0, _shared.isString)(ref) || (0, _reactivity.isRef)(ref) || (0, _shared.isFunction)(ref) ? {
        i: currentRenderingInstance,
        r: ref,
        k: ref_key,
        f: !!ref_for
    } : ref : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null,
        ctx: currentRenderingInstance
    };
    if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        if (shapeFlag & 128) type.normalize(vnode);
    } else if (children) vnode.shapeFlag |= (0, _shared.isString)(children) ? 8 : 16;
    if (vnode.key !== vnode.key) warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
    if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
    !isBlockNode && // has current parent block
    currentBlock && // presence of a patch flag indicates this node needs patching on updates.
    // component nodes also should always be patched, because even if the
    // component doesn't need to update, it needs to persist the instance on to
    // the next vnode so that it can be properly unmounted later.
    (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
    // vnode should not be considered dynamic due to handler caching.
    vnode.patchFlag !== 32) currentBlock.push(vnode);
    return vnode;
}
const createVNode = createVNodeWithArgsTransform;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
        if (!type) warn$1(`Invalid vnode type when creating vnode: ${type}.`);
        type = Comment;
    }
    if (isVNode(type)) {
        const cloned = cloneVNode(type, props, true);
        if (children) normalizeChildren(cloned, children);
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
            if (cloned.shapeFlag & 6) currentBlock[currentBlock.indexOf(type)] = cloned;
            else currentBlock.push(cloned);
        }
        cloned.patchFlag |= -2;
        return cloned;
    }
    if (isClassComponent(type)) type = type.__vccOpts;
    if (props) {
        props = guardReactiveProps(props);
        let { class: klass, style } = props;
        if (klass && !(0, _shared.isString)(klass)) props.class = (0, _shared.normalizeClass)(klass);
        if ((0, _shared.isObject)(style)) {
            if ((0, _reactivity.isProxy)(style) && !(0, _shared.isArray)(style)) style = (0, _shared.extend)({}, style);
            props.style = (0, _shared.normalizeStyle)(style);
        }
    }
    const shapeFlag = (0, _shared.isString)(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : (0, _shared.isObject)(type) ? 4 : (0, _shared.isFunction)(type) ? 2 : 0;
    if (shapeFlag & 4 && (0, _reactivity.isProxy)(type)) {
        type = (0, _reactivity.toRaw)(type);
        warn$1(`Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`, `
Component that was made reactive: `, type);
    }
    return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
    if (!props) return null;
    return (0, _reactivity.isProxy)(props) || Object.getPrototypeOf(props) === attrsProto ? (0, _shared.extend)({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
    const { props, ref, patchFlag, children } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref ? // #2078 in the case of <component :is="vnode" ref="extra"/>
        // if the vnode itself already has a ref, cloneVNode will need to merge
        // the refs so the single vnode can be set on multiple refs
        mergeRef && ref ? (0, _shared.isArray)(ref) ? ref.concat(normalizeRef(extraProps)) : [
            ref,
            normalizeRef(extraProps)
        ] : normalizeRef(extraProps) : ref,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children: patchFlag === -1 && (0, _shared.isArray)(children) ? children.map(deepCloneVNode) : children,
        target: vnode.target,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition: vnode.transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor,
        ctx: vnode.ctx,
        ce: vnode.ce
    };
    return cloned;
}
function deepCloneVNode(vnode) {
    const cloned = cloneVNode(vnode);
    if ((0, _shared.isArray)(vnode.children)) cloned.children = vnode.children.map(deepCloneVNode);
    return cloned;
}
function createTextVNode(text = " ", flag = 0) {
    return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
    const vnode = createVNode(Static, null, content);
    vnode.staticCount = numberOfNodes;
    return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
    return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") return createVNode(Comment);
    else if ((0, _shared.isArray)(child)) return createVNode(Fragment, null, // #3666, avoid reference pollution when reusing vnode
    child.slice());
    else if (typeof child === "object") return cloneIfMounted(child);
    else return createVNode(Text, null, String(child));
}
function cloneIfMounted(child) {
    return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) children = null;
    else if ((0, _shared.isArray)(children)) type = 16;
    else if (typeof children === "object") {
        if (shapeFlag & 65) {
            const slot = children.default;
            if (slot) {
                slot._c && (slot._d = false);
                normalizeChildren(vnode, slot());
                slot._c && (slot._d = true);
            }
            return;
        } else {
            type = 32;
            const slotFlag = children._;
            if (!slotFlag) children._ctx = currentRenderingInstance;
            else if (slotFlag === 3 && currentRenderingInstance) {
                if (currentRenderingInstance.slots._ === 1) children._ = 1;
                else {
                    children._ = 2;
                    vnode.patchFlag |= 1024;
                }
            }
        }
    } else if ((0, _shared.isFunction)(children)) {
        children = {
            default: children,
            _ctx: currentRenderingInstance
        };
        type = 32;
    } else {
        children = String(children);
        if (shapeFlag & 64) {
            type = 16;
            children = [
                createTextVNode(children)
            ];
        } else type = 8;
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
}
function mergeProps(...args) {
    const ret = {};
    for(let i = 0; i < args.length; i++){
        const toMerge = args[i];
        for(const key in toMerge){
            if (key === "class") {
                if (ret.class !== toMerge.class) ret.class = (0, _shared.normalizeClass)([
                    ret.class,
                    toMerge.class
                ]);
            } else if (key === "style") ret.style = (0, _shared.normalizeStyle)([
                ret.style,
                toMerge.style
            ]);
            else if ((0, _shared.isOn)(key)) {
                const existing = ret[key];
                const incoming = toMerge[key];
                if (incoming && existing !== incoming && !((0, _shared.isArray)(existing) && existing.includes(incoming))) ret[key] = existing ? [].concat(existing, incoming) : incoming;
            } else if (key !== "") ret[key] = toMerge[key];
        }
    }
    return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
        vnode,
        prevVNode
    ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
    const type = vnode.type;
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
        uid: uid++,
        vnode,
        type,
        parent,
        appContext,
        root: null,
        // to be immediately set
        next: null,
        subTree: null,
        // will be set synchronously right after creation
        effect: null,
        update: null,
        // will be set synchronously right after creation
        scope: new (0, _reactivity.EffectScope)(true),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        // local resolved assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        // emit
        emit: null,
        // to be set immediately
        emitted: null,
        // props default value
        propsDefaults: (0, _shared.EMPTY_OBJ),
        // inheritAttrs
        inheritAttrs: type.inheritAttrs,
        // state
        ctx: (0, _shared.EMPTY_OBJ),
        data: (0, _shared.EMPTY_OBJ),
        props: (0, _shared.EMPTY_OBJ),
        attrs: (0, _shared.EMPTY_OBJ),
        slots: (0, _shared.EMPTY_OBJ),
        refs: (0, _shared.EMPTY_OBJ),
        setupState: (0, _shared.EMPTY_OBJ),
        setupContext: null,
        attrsProxy: null,
        slotsProxy: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    instance.ctx = createDevRenderContext(instance);
    instance.root = parent ? parent.root : instance;
    instance.emit = emit.bind(null, instance);
    if (vnode.ce) vnode.ce(instance);
    return instance;
}
let currentInstance = null;
const getCurrentInstance = ()=>currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
    const g = (0, _shared.getGlobalThis)();
    const registerGlobalSetter = (key, setter)=>{
        let setters;
        if (!(setters = g[key])) setters = g[key] = [];
        setters.push(setter);
        return (v1)=>{
            if (setters.length > 1) setters.forEach((set)=>set(v1));
            else setters[0](v1);
        };
    };
    internalSetCurrentInstance = registerGlobalSetter(`__VUE_INSTANCE_SETTERS__`, (v1)=>currentInstance = v1);
    setInSSRSetupState = registerGlobalSetter(`__VUE_SSR_SETTERS__`, (v1)=>isInSSRComponentSetup = v1);
}const setCurrentInstance = (instance)=>{
    const prev = currentInstance;
    internalSetCurrentInstance(instance);
    instance.scope.on();
    return ()=>{
        instance.scope.off();
        internalSetCurrentInstance(prev);
    };
};
const unsetCurrentInstance = ()=>{
    currentInstance && currentInstance.scope.off();
    internalSetCurrentInstance(null);
};
const isBuiltInTag = /* @__PURE__ */ (0, _shared.makeMap)("slot,component");
function validateComponentName(name, { isNativeTag }) {
    if (isBuiltInTag(name) || isNativeTag(name)) warn$1("Do not use built-in or reserved HTML elements as component id: " + name);
}
function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
    isSSR && setInSSRSetupState(isSSR);
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isSSR && setInSSRSetupState(false);
    return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
    var _a;
    const Component = instance.type;
    if (Component.name) validateComponentName(Component.name, instance.appContext.config);
    if (Component.components) {
        const names = Object.keys(Component.components);
        for(let i = 0; i < names.length; i++)validateComponentName(names[i], instance.appContext.config);
    }
    if (Component.directives) {
        const names = Object.keys(Component.directives);
        for(let i = 0; i < names.length; i++)validateDirectiveName(names[i]);
    }
    if (Component.compilerOptions && isRuntimeOnly()) warn$1(`"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`);
    instance.accessCache = /* @__PURE__ */ Object.create(null);
    instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
    exposePropsOnRenderContext(instance);
    const { setup } = Component;
    if (setup) {
        const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
        const reset = setCurrentInstance(instance);
        (0, _reactivity.pauseTracking)();
        const setupResult = callWithErrorHandling(setup, instance, 0, [
            (0, _reactivity.shallowReadonly)(instance.props),
            setupContext
        ]);
        (0, _reactivity.resetTracking)();
        reset();
        if ((0, _shared.isPromise)(setupResult)) {
            setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
            if (isSSR) return setupResult.then((resolvedResult)=>{
                handleSetupResult(instance, resolvedResult, isSSR);
            }).catch((e)=>{
                handleError(e, instance, 0);
            });
            else {
                instance.asyncDep = setupResult;
                if (!instance.suspense) {
                    const name = (_a = Component.name) != null ? _a : "Anonymous";
                    warn$1(`Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`);
                }
            }
        } else handleSetupResult(instance, setupResult, isSSR);
    } else finishComponentSetup(instance, isSSR);
}
function handleSetupResult(instance, setupResult, isSSR) {
    if ((0, _shared.isFunction)(setupResult)) {
        if (instance.type.__ssrInlineRender) instance.ssrRender = setupResult;
        else instance.render = setupResult;
    } else if ((0, _shared.isObject)(setupResult)) {
        if (isVNode(setupResult)) warn$1(`setup() should not return VNodes directly - return a render function instead.`);
        instance.devtoolsRawSetupState = setupResult;
        instance.setupState = (0, _reactivity.proxyRefs)(setupResult);
        exposeSetupStateOnRenderContext(instance);
    } else if (setupResult !== void 0) warn$1(`setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`);
    finishComponentSetup(instance, isSSR);
}
let compile;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
    compile = _compile;
    installWithProxy = (i)=>{
        if (i.render._rc) i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    };
}
const isRuntimeOnly = ()=>!compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    if (!instance.render) {
        if (!isSSR && compile && !Component.render) {
            const template = Component.template || resolveMergedOptions(instance).template;
            if (template) {
                startMeasure(instance, `compile`);
                const { isCustomElement, compilerOptions } = instance.appContext.config;
                const { delimiters, compilerOptions: componentCompilerOptions } = Component;
                const finalCompilerOptions = (0, _shared.extend)((0, _shared.extend)({
                    isCustomElement,
                    delimiters
                }, compilerOptions), componentCompilerOptions);
                Component.render = compile(template, finalCompilerOptions);
                endMeasure(instance, `compile`);
            }
        }
        instance.render = Component.render || (0, _shared.NOOP);
        if (installWithProxy) installWithProxy(instance);
    }
    if (__VUE_OPTIONS_API__ && true) {
        const reset = setCurrentInstance(instance);
        (0, _reactivity.pauseTracking)();
        try {
            applyOptions(instance);
        } finally{
            (0, _reactivity.resetTracking)();
            reset();
        }
    }
    if (!Component.render && instance.render === (0, _shared.NOOP) && !isSSR) {
        if (!compile && Component.template) warn$1(`Component provided template option but runtime compilation is not supported in this build of Vue.` + ` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`);
        else warn$1(`Component is missing template or render function.`);
    }
}
const attrsProxyHandlers = {
    get (target, key) {
        markAttrsAccessed();
        (0, _reactivity.track)(target, "get", "");
        return target[key];
    },
    set () {
        warn$1(`setupContext.attrs is readonly.`);
        return false;
    },
    deleteProperty () {
        warn$1(`setupContext.attrs is readonly.`);
        return false;
    }
};
function getSlotsProxy(instance) {
    return instance.slotsProxy || (instance.slotsProxy = new Proxy(instance.slots, {
        get (target, key) {
            (0, _reactivity.track)(instance, "get", "$slots");
            return target[key];
        }
    }));
}
function createSetupContext(instance) {
    const expose = (exposed)=>{
        if (instance.exposed) warn$1(`expose() should be called only once per setup().`);
        if (exposed != null) {
            let exposedType = typeof exposed;
            if (exposedType === "object") {
                if ((0, _shared.isArray)(exposed)) exposedType = "array";
                else if ((0, _reactivity.isRef)(exposed)) exposedType = "ref";
            }
            if (exposedType !== "object") warn$1(`expose() should be passed a plain object, received ${exposedType}.`);
        }
        instance.exposed = exposed || {};
    };
    {
        let attrsProxy;
        return Object.freeze({
            get attrs () {
                return attrsProxy || (attrsProxy = new Proxy(instance.attrs, attrsProxyHandlers));
            },
            get slots () {
                return getSlotsProxy(instance);
            },
            get emit () {
                return (event, ...args)=>instance.emit(event, ...args);
            },
            expose
        });
    }
}
function getExposeProxy(instance) {
    if (instance.exposed) return instance.exposeProxy || (instance.exposeProxy = new Proxy((0, _reactivity.proxyRefs)((0, _reactivity.markRaw)(instance.exposed)), {
        get (target, key) {
            if (key in target) return target[key];
            else if (key in publicPropertiesMap) return publicPropertiesMap[key](instance);
        },
        has (target, key) {
            return key in target || key in publicPropertiesMap;
        }
    }));
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str)=>str.replace(classifyRE, (c)=>c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
    return (0, _shared.isFunction)(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) name = match[1];
    }
    if (!name && instance && instance.parent) {
        const inferFromRegistry = (registry)=>{
            for(const key in registry){
                if (registry[key] === Component) return key;
            }
        };
        name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
    return (0, _shared.isFunction)(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions)=>{
    const c = (0, _reactivity.computed)(getterOrOptions, debugOptions, isInSSRComponentSetup);
    {
        const i = getCurrentInstance();
        if (i && i.appContext.config.warnRecursiveComputed) c._warnRecursive = true;
    }
    return c;
};
function useModel(props, name, options = (0, _shared.EMPTY_OBJ)) {
    const i = getCurrentInstance();
    if (!i) {
        warn$1(`useModel() called without active instance.`);
        return (0, _reactivity.ref)();
    }
    if (!i.propsOptions[0][name]) {
        warn$1(`useModel() called with prop "${name}" which is not declared.`);
        return (0, _reactivity.ref)();
    }
    const camelizedName = (0, _shared.camelize)(name);
    const hyphenatedName = (0, _shared.hyphenate)(name);
    const res = (0, _reactivity.customRef)((track, trigger)=>{
        let localValue;
        watchSyncEffect(()=>{
            const propValue = props[name];
            if ((0, _shared.hasChanged)(localValue, propValue)) {
                localValue = propValue;
                trigger();
            }
        });
        return {
            get () {
                track();
                return options.get ? options.get(localValue) : localValue;
            },
            set (value) {
                const rawProps = i.vnode.props;
                if (!(rawProps && // check if parent has passed v-model
                (name in rawProps || camelizedName in rawProps || hyphenatedName in rawProps) && (`onUpdate:${name}` in rawProps || `onUpdate:${camelizedName}` in rawProps || `onUpdate:${hyphenatedName}` in rawProps)) && (0, _shared.hasChanged)(value, localValue)) {
                    localValue = value;
                    trigger();
                }
                i.emit(`update:${name}`, options.set ? options.set(value) : value);
            }
        };
    });
    const modifierKey = name === "modelValue" ? "modelModifiers" : `${name}Modifiers`;
    res[Symbol.iterator] = ()=>{
        let i2 = 0;
        return {
            next () {
                if (i2 < 2) return {
                    value: i2++ ? props[modifierKey] || {} : res,
                    done: false
                };
                else return {
                    done: true
                };
            }
        };
    };
    return res;
}
function h(type, propsOrChildren, children) {
    const l = arguments.length;
    if (l === 2) {
        if ((0, _shared.isObject)(propsOrChildren) && !(0, _shared.isArray)(propsOrChildren)) {
            if (isVNode(propsOrChildren)) return createVNode(type, null, [
                propsOrChildren
            ]);
            return createVNode(type, propsOrChildren);
        } else return createVNode(type, null, propsOrChildren);
    } else {
        if (l > 3) children = Array.prototype.slice.call(arguments, 2);
        else if (l === 3 && isVNode(children)) children = [
            children
        ];
        return createVNode(type, propsOrChildren, children);
    }
}
function initCustomFormatter() {
    if (typeof window === "undefined") return;
    const vueStyle = {
        style: "color:#3ba776"
    };
    const numberStyle = {
        style: "color:#1677ff"
    };
    const stringStyle = {
        style: "color:#f5222d"
    };
    const keywordStyle = {
        style: "color:#eb2f96"
    };
    const formatter = {
        header (obj) {
            if (!(0, _shared.isObject)(obj)) return null;
            if (obj.__isVue) return [
                "div",
                vueStyle,
                `VueInstance`
            ];
            else if ((0, _reactivity.isRef)(obj)) return [
                "div",
                {},
                [
                    "span",
                    vueStyle,
                    genRefFlag(obj)
                ],
                "<",
                formatValue(obj.value),
                `>`
            ];
            else if ((0, _reactivity.isReactive)(obj)) return [
                "div",
                {},
                [
                    "span",
                    vueStyle,
                    (0, _reactivity.isShallow)(obj) ? "ShallowReactive" : "Reactive"
                ],
                "<",
                formatValue(obj),
                `>${(0, _reactivity.isReadonly)(obj) ? ` (readonly)` : ``}`
            ];
            else if ((0, _reactivity.isReadonly)(obj)) return [
                "div",
                {},
                [
                    "span",
                    vueStyle,
                    (0, _reactivity.isShallow)(obj) ? "ShallowReadonly" : "Readonly"
                ],
                "<",
                formatValue(obj),
                ">"
            ];
            return null;
        },
        hasBody (obj) {
            return obj && obj.__isVue;
        },
        body (obj) {
            if (obj && obj.__isVue) return [
                "div",
                {},
                ...formatInstance(obj.$)
            ];
        }
    };
    function formatInstance(instance) {
        const blocks = [];
        if (instance.type.props && instance.props) blocks.push(createInstanceBlock("props", (0, _reactivity.toRaw)(instance.props)));
        if (instance.setupState !== (0, _shared.EMPTY_OBJ)) blocks.push(createInstanceBlock("setup", instance.setupState));
        if (instance.data !== (0, _shared.EMPTY_OBJ)) blocks.push(createInstanceBlock("data", (0, _reactivity.toRaw)(instance.data)));
        const computed = extractKeys(instance, "computed");
        if (computed) blocks.push(createInstanceBlock("computed", computed));
        const injected = extractKeys(instance, "inject");
        if (injected) blocks.push(createInstanceBlock("injected", injected));
        blocks.push([
            "div",
            {},
            [
                "span",
                {
                    style: keywordStyle.style + ";opacity:0.66"
                },
                "$ (internal): "
            ],
            [
                "object",
                {
                    object: instance
                }
            ]
        ]);
        return blocks;
    }
    function createInstanceBlock(type, target) {
        target = (0, _shared.extend)({}, target);
        if (!Object.keys(target).length) return [
            "span",
            {}
        ];
        return [
            "div",
            {
                style: "line-height:1.25em;margin-bottom:0.6em"
            },
            [
                "div",
                {
                    style: "color:#476582"
                },
                type
            ],
            [
                "div",
                {
                    style: "padding-left:1.25em"
                },
                ...Object.keys(target).map((key)=>{
                    return [
                        "div",
                        {},
                        [
                            "span",
                            keywordStyle,
                            key + ": "
                        ],
                        formatValue(target[key], false)
                    ];
                })
            ]
        ];
    }
    function formatValue(v1, asRaw = true) {
        if (typeof v1 === "number") return [
            "span",
            numberStyle,
            v1
        ];
        else if (typeof v1 === "string") return [
            "span",
            stringStyle,
            JSON.stringify(v1)
        ];
        else if (typeof v1 === "boolean") return [
            "span",
            keywordStyle,
            v1
        ];
        else if ((0, _shared.isObject)(v1)) return [
            "object",
            {
                object: asRaw ? (0, _reactivity.toRaw)(v1) : v1
            }
        ];
        else return [
            "span",
            stringStyle,
            String(v1)
        ];
    }
    function extractKeys(instance, type) {
        const Comp = instance.type;
        if ((0, _shared.isFunction)(Comp)) return;
        const extracted = {};
        for(const key in instance.ctx)if (isKeyOfType(Comp, key, type)) extracted[key] = instance.ctx[key];
        return extracted;
    }
    function isKeyOfType(Comp, key, type) {
        const opts = Comp[type];
        if ((0, _shared.isArray)(opts) && opts.includes(key) || (0, _shared.isObject)(opts) && key in opts) return true;
        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) return true;
        if (Comp.mixins && Comp.mixins.some((m)=>isKeyOfType(m, key, type))) return true;
    }
    function genRefFlag(v1) {
        if ((0, _reactivity.isShallow)(v1)) return `ShallowRef`;
        if (v1.effect) return `ComputedRef`;
        return `Ref`;
    }
    if (window.devtoolsFormatters) window.devtoolsFormatters.push(formatter);
    else window.devtoolsFormatters = [
        formatter
    ];
}
function withMemo(memo, render, cache, index) {
    const cached = cache[index];
    if (cached && isMemoSame(cached, memo)) return cached;
    const ret = render();
    ret.memo = memo.slice();
    return cache[index] = ret;
}
function isMemoSame(cached, memo) {
    const prev = cached.memo;
    if (prev.length != memo.length) return false;
    for(let i = 0; i < prev.length; i++){
        if ((0, _shared.hasChanged)(prev[i], memo[i])) return false;
    }
    if (isBlockTreeEnabled > 0 && currentBlock) currentBlock.push(cached);
    return true;
}
const version = "3.4.22";
const warn = warn$1;
const ErrorTypeStrings = ErrorTypeStrings$1;
const devtools = devtools$1;
const setDevtoolsHook = setDevtoolsHook$1;
const _ssrUtils = {
    createComponentInstance,
    setupComponent,
    renderComponentRoot,
    setCurrentRenderingInstance,
    isVNode: isVNode,
    normalizeVNode
};
const ssrUtils = _ssrUtils;
const resolveFilter = null;
const compatUtils = null;
const DeprecationTypes = null;

},{"@vue/reactivity":"d7UXQ","@vue/shared":"3SM3y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d7UXQ":[function(require,module,exports) {
/**
* @vue/reactivity v3.4.22
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EffectScope", ()=>EffectScope);
parcelHelpers.export(exports, "ITERATE_KEY", ()=>ITERATE_KEY);
parcelHelpers.export(exports, "ReactiveEffect", ()=>ReactiveEffect);
parcelHelpers.export(exports, "ReactiveFlags", ()=>ReactiveFlags);
parcelHelpers.export(exports, "TrackOpTypes", ()=>TrackOpTypes);
parcelHelpers.export(exports, "TriggerOpTypes", ()=>TriggerOpTypes);
parcelHelpers.export(exports, "computed", ()=>computed);
parcelHelpers.export(exports, "customRef", ()=>customRef);
parcelHelpers.export(exports, "deferredComputed", ()=>deferredComputed);
parcelHelpers.export(exports, "effect", ()=>effect);
parcelHelpers.export(exports, "effectScope", ()=>effectScope);
parcelHelpers.export(exports, "enableTracking", ()=>enableTracking);
parcelHelpers.export(exports, "getCurrentScope", ()=>getCurrentScope);
parcelHelpers.export(exports, "isProxy", ()=>isProxy);
parcelHelpers.export(exports, "isReactive", ()=>isReactive);
parcelHelpers.export(exports, "isReadonly", ()=>isReadonly);
parcelHelpers.export(exports, "isRef", ()=>isRef);
parcelHelpers.export(exports, "isShallow", ()=>isShallow);
parcelHelpers.export(exports, "markRaw", ()=>markRaw);
parcelHelpers.export(exports, "onScopeDispose", ()=>onScopeDispose);
parcelHelpers.export(exports, "pauseScheduling", ()=>pauseScheduling);
parcelHelpers.export(exports, "pauseTracking", ()=>pauseTracking);
parcelHelpers.export(exports, "proxyRefs", ()=>proxyRefs);
parcelHelpers.export(exports, "reactive", ()=>reactive);
parcelHelpers.export(exports, "readonly", ()=>readonly);
parcelHelpers.export(exports, "ref", ()=>ref);
parcelHelpers.export(exports, "resetScheduling", ()=>resetScheduling);
parcelHelpers.export(exports, "resetTracking", ()=>resetTracking);
parcelHelpers.export(exports, "shallowReactive", ()=>shallowReactive);
parcelHelpers.export(exports, "shallowReadonly", ()=>shallowReadonly);
parcelHelpers.export(exports, "shallowRef", ()=>shallowRef);
parcelHelpers.export(exports, "stop", ()=>stop);
parcelHelpers.export(exports, "toRaw", ()=>toRaw);
parcelHelpers.export(exports, "toRef", ()=>toRef);
parcelHelpers.export(exports, "toRefs", ()=>toRefs);
parcelHelpers.export(exports, "toValue", ()=>toValue);
parcelHelpers.export(exports, "track", ()=>track);
parcelHelpers.export(exports, "trigger", ()=>trigger);
parcelHelpers.export(exports, "triggerRef", ()=>triggerRef);
parcelHelpers.export(exports, "unref", ()=>unref);
var _shared = require("@vue/shared");
function warn(msg, ...args) {
    console.warn(`[Vue warn] ${msg}`, ...args);
}
let activeEffectScope;
class EffectScope {
    constructor(detached = false){
        this.detached = detached;
        /**
     * @internal
     */ this._active = true;
        /**
     * @internal
     */ this.effects = [];
        /**
     * @internal
     */ this.cleanups = [];
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
    get active() {
        return this._active;
    }
    run(fn) {
        if (this._active) {
            const currentEffectScope = activeEffectScope;
            try {
                activeEffectScope = this;
                return fn();
            } finally{
                activeEffectScope = currentEffectScope;
            }
        } else warn(`cannot run an inactive effect scope.`);
    }
    /**
   * This should only be called on non-detached scopes
   * @internal
   */ on() {
        activeEffectScope = this;
    }
    /**
   * This should only be called on non-detached scopes
   * @internal
   */ off() {
        activeEffectScope = this.parent;
    }
    stop(fromParent) {
        if (this._active) {
            let i, l;
            for(i = 0, l = this.effects.length; i < l; i++)this.effects[i].stop();
            for(i = 0, l = this.cleanups.length; i < l; i++)this.cleanups[i]();
            if (this.scopes) for(i = 0, l = this.scopes.length; i < l; i++)this.scopes[i].stop(true);
            if (!this.detached && this.parent && !fromParent) {
                const last = this.parent.scopes.pop();
                if (last && last !== this) {
                    this.parent.scopes[this.index] = last;
                    last.index = this.index;
                }
            }
            this.parent = void 0;
            this._active = false;
        }
    }
}
function effectScope(detached) {
    return new EffectScope(detached);
}
function recordEffectScope(effect, scope = activeEffectScope) {
    if (scope && scope.active) scope.effects.push(effect);
}
function getCurrentScope() {
    return activeEffectScope;
}
function onScopeDispose(fn) {
    if (activeEffectScope) activeEffectScope.cleanups.push(fn);
    else warn(`onScopeDispose() is called when there is no active effect scope to be associated with.`);
}
let activeEffect;
class ReactiveEffect {
    constructor(fn, trigger, scheduler, scope){
        this.fn = fn;
        this.trigger = trigger;
        this.scheduler = scheduler;
        this.active = true;
        this.deps = [];
        /**
     * @internal
     */ this._dirtyLevel = 4;
        /**
     * @internal
     */ this._trackId = 0;
        /**
     * @internal
     */ this._runnings = 0;
        /**
     * @internal
     */ this._shouldSchedule = false;
        /**
     * @internal
     */ this._depsLength = 0;
        recordEffectScope(this, scope);
    }
    get dirty() {
        if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
            this._dirtyLevel = 1;
            pauseTracking();
            for(let i = 0; i < this._depsLength; i++){
                const dep = this.deps[i];
                if (dep.computed) {
                    triggerComputed(dep.computed);
                    if (this._dirtyLevel >= 4) break;
                }
            }
            if (this._dirtyLevel === 1) this._dirtyLevel = 0;
            resetTracking();
        }
        return this._dirtyLevel >= 4;
    }
    set dirty(v) {
        this._dirtyLevel = v ? 4 : 0;
    }
    run() {
        this._dirtyLevel = 0;
        if (!this.active) return this.fn();
        let lastShouldTrack = shouldTrack;
        let lastEffect = activeEffect;
        try {
            shouldTrack = true;
            activeEffect = this;
            this._runnings++;
            preCleanupEffect(this);
            return this.fn();
        } finally{
            postCleanupEffect(this);
            this._runnings--;
            activeEffect = lastEffect;
            shouldTrack = lastShouldTrack;
        }
    }
    stop() {
        var _a;
        if (this.active) {
            preCleanupEffect(this);
            postCleanupEffect(this);
            (_a = this.onStop) == null || _a.call(this);
            this.active = false;
        }
    }
}
function triggerComputed(computed) {
    return computed.value;
}
function preCleanupEffect(effect2) {
    effect2._trackId++;
    effect2._depsLength = 0;
}
function postCleanupEffect(effect2) {
    if (effect2.deps.length > effect2._depsLength) {
        for(let i = effect2._depsLength; i < effect2.deps.length; i++)cleanupDepEffect(effect2.deps[i], effect2);
        effect2.deps.length = effect2._depsLength;
    }
}
function cleanupDepEffect(dep, effect2) {
    const trackId = dep.get(effect2);
    if (trackId !== void 0 && effect2._trackId !== trackId) {
        dep.delete(effect2);
        if (dep.size === 0) dep.cleanup();
    }
}
function effect(fn, options) {
    if (fn.effect instanceof ReactiveEffect) fn = fn.effect.fn;
    const _effect = new ReactiveEffect(fn, (0, _shared.NOOP), ()=>{
        if (_effect.dirty) _effect.run();
    });
    if (options) {
        (0, _shared.extend)(_effect, options);
        if (options.scope) recordEffectScope(_effect, options.scope);
    }
    if (!options || !options.lazy) _effect.run();
    const runner = _effect.run.bind(_effect);
    runner.effect = _effect;
    return runner;
}
function stop(runner) {
    runner.effect.stop();
}
let shouldTrack = true;
let pauseScheduleStack = 0;
const trackStack = [];
function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
}
function enableTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = true;
}
function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
}
function pauseScheduling() {
    pauseScheduleStack++;
}
function resetScheduling() {
    pauseScheduleStack--;
    while(!pauseScheduleStack && queueEffectSchedulers.length)queueEffectSchedulers.shift()();
}
function trackEffect(effect2, dep, debuggerEventExtraInfo) {
    var _a;
    if (dep.get(effect2) !== effect2._trackId) {
        dep.set(effect2, effect2._trackId);
        const oldDep = effect2.deps[effect2._depsLength];
        if (oldDep !== dep) {
            if (oldDep) cleanupDepEffect(oldDep, effect2);
            effect2.deps[effect2._depsLength++] = dep;
        } else effect2._depsLength++;
        (_a = effect2.onTrack) == null || _a.call(effect2, (0, _shared.extend)({
            effect: effect2
        }, debuggerEventExtraInfo));
    }
}
const queueEffectSchedulers = [];
function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
    var _a;
    pauseScheduling();
    for (const effect2 of dep.keys()){
        let tracking;
        if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
            effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);
            effect2._dirtyLevel = dirtyLevel;
        }
        if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
            (_a = effect2.onTrigger) == null || _a.call(effect2, (0, _shared.extend)({
                effect: effect2
            }, debuggerEventExtraInfo));
            effect2.trigger();
            if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 2) {
                effect2._shouldSchedule = false;
                if (effect2.scheduler) queueEffectSchedulers.push(effect2.scheduler);
            }
        }
    }
    resetScheduling();
}
const createDep = (cleanup, computed)=>{
    const dep = /* @__PURE__ */ new Map();
    dep.cleanup = cleanup;
    dep.computed = computed;
    return dep;
};
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol("iterate");
const MAP_KEY_ITERATE_KEY = Symbol("Map key iterate");
function track(target, type, key) {
    if (shouldTrack && activeEffect) {
        let depsMap = targetMap.get(target);
        if (!depsMap) targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
        let dep = depsMap.get(key);
        if (!dep) depsMap.set(key, dep = createDep(()=>depsMap.delete(key)));
        trackEffect(activeEffect, dep, {
            target,
            type,
            key
        });
    }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) return;
    let deps = [];
    if (type === "clear") deps = [
        ...depsMap.values()
    ];
    else if (key === "length" && (0, _shared.isArray)(target)) {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key2)=>{
            if (key2 === "length" || !(0, _shared.isSymbol)(key2) && key2 >= newLength) deps.push(dep);
        });
    } else {
        if (key !== void 0) deps.push(depsMap.get(key));
        switch(type){
            case "add":
                if (!(0, _shared.isArray)(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                    if ((0, _shared.isMap)(target)) deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                } else if ((0, _shared.isIntegerKey)(key)) deps.push(depsMap.get("length"));
                break;
            case "delete":
                if (!(0, _shared.isArray)(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                    if ((0, _shared.isMap)(target)) deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
                break;
            case "set":
                if ((0, _shared.isMap)(target)) deps.push(depsMap.get(ITERATE_KEY));
                break;
        }
    }
    pauseScheduling();
    for (const dep of deps)if (dep) triggerEffects(dep, 4, {
        target,
        type,
        key,
        newValue,
        oldValue,
        oldTarget
    });
    resetScheduling();
}
function getDepFromReactive(object, key) {
    var _a;
    return (_a = targetMap.get(object)) == null ? void 0 : _a.get(key);
}
const isNonTrackableKeys = /* @__PURE__ */ (0, _shared.makeMap)(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(/* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key)=>key !== "arguments" && key !== "caller").map((key)=>Symbol[key]).filter((0, _shared.isSymbol)));
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
    const instrumentations = {};
    [
        "includes",
        "indexOf",
        "lastIndexOf"
    ].forEach((key)=>{
        instrumentations[key] = function(...args) {
            const arr = toRaw(this);
            for(let i = 0, l = this.length; i < l; i++)track(arr, "get", i + "");
            const res = arr[key](...args);
            if (res === -1 || res === false) return arr[key](...args.map(toRaw));
            else return res;
        };
    });
    [
        "push",
        "pop",
        "shift",
        "unshift",
        "splice"
    ].forEach((key)=>{
        instrumentations[key] = function(...args) {
            pauseTracking();
            pauseScheduling();
            const res = toRaw(this)[key].apply(this, args);
            resetScheduling();
            resetTracking();
            return res;
        };
    });
    return instrumentations;
}
function hasOwnProperty(key) {
    if (!(0, _shared.isSymbol)(key)) key = String(key);
    const obj = toRaw(this);
    track(obj, "has", key);
    return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
    constructor(_isReadonly = false, _isShallow = false){
        this._isReadonly = _isReadonly;
        this._isShallow = _isShallow;
    }
    get(target, key, receiver) {
        const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
        if (key === "__v_isReactive") return !isReadonly2;
        else if (key === "__v_isReadonly") return isReadonly2;
        else if (key === "__v_isShallow") return isShallow2;
        else if (key === "__v_raw") {
            if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
            // this means the reciever is a user proxy of the reactive proxy
            Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) return target;
            return;
        }
        const targetIsArray = (0, _shared.isArray)(target);
        if (!isReadonly2) {
            if (targetIsArray && (0, _shared.hasOwn)(arrayInstrumentations, key)) return Reflect.get(arrayInstrumentations, key, receiver);
            if (key === "hasOwnProperty") return hasOwnProperty;
        }
        const res = Reflect.get(target, key, receiver);
        if ((0, _shared.isSymbol)(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) return res;
        if (!isReadonly2) track(target, "get", key);
        if (isShallow2) return res;
        if (isRef(res)) return targetIsArray && (0, _shared.isIntegerKey)(key) ? res : res.value;
        if ((0, _shared.isObject)(res)) return isReadonly2 ? readonly(res) : reactive(res);
        return res;
    }
}
class MutableReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false){
        super(false, isShallow2);
    }
    set(target, key, value, receiver) {
        let oldValue = target[key];
        if (!this._isShallow) {
            const isOldValueReadonly = isReadonly(oldValue);
            if (!isShallow(value) && !isReadonly(value)) {
                oldValue = toRaw(oldValue);
                value = toRaw(value);
            }
            if (!(0, _shared.isArray)(target) && isRef(oldValue) && !isRef(value)) {
                if (isOldValueReadonly) return false;
                else {
                    oldValue.value = value;
                    return true;
                }
            }
        }
        const hadKey = (0, _shared.isArray)(target) && (0, _shared.isIntegerKey)(key) ? Number(key) < target.length : (0, _shared.hasOwn)(target, key);
        const result = Reflect.set(target, key, value, receiver);
        if (target === toRaw(receiver)) {
            if (!hadKey) trigger(target, "add", key, value);
            else if ((0, _shared.hasChanged)(value, oldValue)) trigger(target, "set", key, value, oldValue);
        }
        return result;
    }
    deleteProperty(target, key) {
        const hadKey = (0, _shared.hasOwn)(target, key);
        const oldValue = target[key];
        const result = Reflect.deleteProperty(target, key);
        if (result && hadKey) trigger(target, "delete", key, void 0, oldValue);
        return result;
    }
    has(target, key) {
        const result = Reflect.has(target, key);
        if (!(0, _shared.isSymbol)(key) || !builtInSymbols.has(key)) track(target, "has", key);
        return result;
    }
    ownKeys(target) {
        track(target, "iterate", (0, _shared.isArray)(target) ? "length" : ITERATE_KEY);
        return Reflect.ownKeys(target);
    }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false){
        super(true, isShallow2);
    }
    set(target, key) {
        warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
        return true;
    }
    deleteProperty(target, key) {
        warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
        return true;
    }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
const toShallow = (value)=>value;
const getProto = (v)=>Reflect.getPrototypeOf(v);
function get(target, key, isReadonly = false, isShallow = false) {
    target = target["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly) {
        if ((0, _shared.hasChanged)(key, rawKey)) track(rawTarget, "get", key);
        track(rawTarget, "get", rawKey);
    }
    const { has: has2 } = getProto(rawTarget);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    if (has2.call(rawTarget, key)) return wrap(target.get(key));
    else if (has2.call(rawTarget, rawKey)) return wrap(target.get(rawKey));
    else if (target !== rawTarget) target.get(key);
}
function has(key, isReadonly = false) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly) {
        if ((0, _shared.hasChanged)(key, rawKey)) track(rawTarget, "has", key);
        track(rawTarget, "has", rawKey);
    }
    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly = false) {
    target = target["__v_raw"];
    !isReadonly && track(toRaw(target), "iterate", ITERATE_KEY);
    return Reflect.get(target, "size", target);
}
function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
        target.add(value);
        trigger(target, "add", value, value);
    }
    return this;
}
function set(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
    } else checkIdentityKeys(target, has2, key);
    const oldValue = get2.call(target, key);
    target.set(key, value);
    if (!hadKey) trigger(target, "add", key, value);
    else if ((0, _shared.hasChanged)(value, oldValue)) trigger(target, "set", key, value, oldValue);
    return this;
}
function deleteEntry(key) {
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
    } else checkIdentityKeys(target, has2, key);
    const oldValue = get2 ? get2.call(target, key) : void 0;
    const result = target.delete(key);
    if (hadKey) trigger(target, "delete", key, void 0, oldValue);
    return result;
}
function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = (0, _shared.isMap)(target) ? new Map(target) : new Set(target);
    const result = target.clear();
    if (hadItems) trigger(target, "clear", void 0, void 0, oldTarget);
    return result;
}
function createForEach(isReadonly, isShallow) {
    return function forEach(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw"];
        const rawTarget = toRaw(target);
        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
        !isReadonly && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key)=>{
            return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
    };
}
function createIterableMethod(method, isReadonly, isShallow) {
    return function(...args) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const targetIsMap = (0, _shared.isMap)(rawTarget);
        const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
        const isKeyOnly = method === "keys" && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
        !isReadonly && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
        return {
            // iterator protocol
            next () {
                const { value, done } = innerIterator.next();
                return done ? {
                    value,
                    done
                } : {
                    value: isPair ? [
                        wrap(value[0]),
                        wrap(value[1])
                    ] : wrap(value),
                    done
                };
            },
            // iterable protocol
            [Symbol.iterator] () {
                return this;
            }
        };
    };
}
function createReadonlyMethod(type) {
    return function(...args) {
        {
            const key = args[0] ? `on key "${args[0]}" ` : ``;
            warn(`${(0, _shared.capitalize)(type)} operation ${key}failed: target is readonly.`, toRaw(this));
        }
        return type === "delete" ? false : type === "clear" ? void 0 : this;
    };
}
function createInstrumentations() {
    const mutableInstrumentations2 = {
        get (key) {
            return get(this, key);
        },
        get size () {
            return size(this);
        },
        has,
        add,
        set,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
    };
    const shallowInstrumentations2 = {
        get (key) {
            return get(this, key, false, true);
        },
        get size () {
            return size(this);
        },
        has,
        add,
        set,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
    };
    const readonlyInstrumentations2 = {
        get (key) {
            return get(this, key, true);
        },
        get size () {
            return size(this, true);
        },
        has (key) {
            return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations2 = {
        get (key) {
            return get(this, key, true, true);
        },
        get size () {
            return size(this, true);
        },
        has (key) {
            return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, true)
    };
    const iteratorMethods = [
        "keys",
        "values",
        "entries",
        Symbol.iterator
    ];
    iteratorMethods.forEach((method)=>{
        mutableInstrumentations2[method] = createIterableMethod(method, false, false);
        readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
        shallowInstrumentations2[method] = createIterableMethod(method, false, true);
        shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
    });
    return [
        mutableInstrumentations2,
        readonlyInstrumentations2,
        shallowInstrumentations2,
        shallowReadonlyInstrumentations2
    ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly, shallow) {
    const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;
    return (target, key, receiver)=>{
        if (key === "__v_isReactive") return !isReadonly;
        else if (key === "__v_isReadonly") return isReadonly;
        else if (key === "__v_raw") return target;
        return Reflect.get((0, _shared.hasOwn)(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
    };
}
const mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has2, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has2.call(target, rawKey)) {
        const type = (0, _shared.toRawType)(target);
        warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
    }
}
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
    switch(rawType){
        case "Object":
        case "Array":
            return 1 /* COMMON */ ;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
            return 2 /* COLLECTION */ ;
        default:
            return 0 /* INVALID */ ;
    }
}
function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 /* INVALID */  : targetTypeMap((0, _shared.toRawType)(value));
}
function reactive(target) {
    if (isReadonly(target)) return target;
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target) {
    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function shallowReadonly(target) {
    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!(0, _shared.isObject)(target)) {
        warn(`value cannot be made reactive: ${String(target)}`);
        return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) return target;
    const existingProxy = proxyMap.get(target);
    if (existingProxy) return existingProxy;
    const targetType = getTargetType(target);
    if (targetType === 0 /* INVALID */ ) return target;
    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */  ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
}
function isReactive(value) {
    if (isReadonly(value)) return isReactive(value["__v_raw"]);
    return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
    return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
    return value ? !!value["__v_raw"] : false;
}
function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
    if (Object.isExtensible(value)) (0, _shared.def)(value, "__v_skip", true);
    return value;
}
const toReactive = (value)=>(0, _shared.isObject)(value) ? reactive(value) : value;
const toReadonly = (value)=>(0, _shared.isObject)(value) ? readonly(value) : value;
const COMPUTED_SIDE_EFFECT_WARN = `Computed is still dirty after getter evaluation, likely because a computed is mutating its own dependency in its getter. State mutations in computed getters should be avoided.  Check the docs for more details: https://vuejs.org/guide/essentials/computed.html#getters-should-be-side-effect-free`;
class ComputedRefImpl {
    constructor(getter, _setter, isReadonly, isSSR){
        this.getter = getter;
        this._setter = _setter;
        this.dep = void 0;
        this.__v_isRef = true;
        this["__v_isReadonly"] = false;
        this.effect = new ReactiveEffect(()=>getter(this._value), ()=>triggerRefValue(this, this.effect._dirtyLevel === 2 ? 2 : 3));
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this["__v_isReadonly"] = isReadonly;
    }
    get value() {
        const self = toRaw(this);
        if ((!self._cacheable || self.effect.dirty) && (0, _shared.hasChanged)(self._value, self._value = self.effect.run())) triggerRefValue(self, 4);
        trackRefValue(self);
        if (self.effect._dirtyLevel >= 2) {
            if (0, this._warnRecursive) warn(COMPUTED_SIDE_EFFECT_WARN, `

getter: `, this.getter);
            triggerRefValue(self, 2);
        }
        return self._value;
    }
    set value(newValue) {
        this._setter(newValue);
    }
    // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
    get _dirty() {
        return this.effect.dirty;
    }
    set _dirty(v) {
        this.effect.dirty = v;
    }
}
function computed(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    const onlyGetter = (0, _shared.isFunction)(getterOrOptions);
    if (onlyGetter) {
        getter = getterOrOptions;
        setter = ()=>{
            warn("Write operation failed: computed value is readonly");
        };
    } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
    if (debugOptions && !isSSR) {
        cRef.effect.onTrack = debugOptions.onTrack;
        cRef.effect.onTrigger = debugOptions.onTrigger;
    }
    return cRef;
}
function trackRefValue(ref2) {
    var _a;
    if (shouldTrack && activeEffect) {
        ref2 = toRaw(ref2);
        trackEffect(activeEffect, (_a = ref2.dep) != null ? _a : ref2.dep = createDep(()=>ref2.dep = void 0, ref2 instanceof ComputedRefImpl ? ref2 : void 0), {
            target: ref2,
            type: "get",
            key: "value"
        });
    }
}
function triggerRefValue(ref2, dirtyLevel = 4, newVal) {
    ref2 = toRaw(ref2);
    const dep = ref2.dep;
    if (dep) triggerEffects(dep, dirtyLevel, {
        target: ref2,
        type: "set",
        key: "value",
        newValue: newVal
    });
}
function isRef(r) {
    return !!(r && r.__v_isRef === true);
}
function ref(value) {
    return createRef(value, false);
}
function shallowRef(value) {
    return createRef(value, true);
}
function createRef(rawValue, shallow) {
    if (isRef(rawValue)) return rawValue;
    return new RefImpl(rawValue, shallow);
}
class RefImpl {
    constructor(value, __v_isShallow){
        this.__v_isShallow = __v_isShallow;
        this.dep = void 0;
        this.__v_isRef = true;
        this._rawValue = __v_isShallow ? value : toRaw(value);
        this._value = __v_isShallow ? value : toReactive(value);
    }
    get value() {
        trackRefValue(this);
        return this._value;
    }
    set value(newVal) {
        const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
        newVal = useDirectValue ? newVal : toRaw(newVal);
        if ((0, _shared.hasChanged)(newVal, this._rawValue)) {
            this._rawValue = newVal;
            this._value = useDirectValue ? newVal : toReactive(newVal);
            triggerRefValue(this, 4, newVal);
        }
    }
}
function triggerRef(ref2) {
    triggerRefValue(ref2, 4, (0, ref2.value));
}
function unref(ref2) {
    return isRef(ref2) ? ref2.value : ref2;
}
function toValue(source) {
    return (0, _shared.isFunction)(source) ? source() : unref(source);
}
const shallowUnwrapHandlers = {
    get: (target, key, receiver)=>unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver)=>{
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
        } else return Reflect.set(target, key, value, receiver);
    }
};
function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
    constructor(factory){
        this.dep = void 0;
        this.__v_isRef = true;
        const { get, set } = factory(()=>trackRefValue(this), ()=>triggerRefValue(this));
        this._get = get;
        this._set = set;
    }
    get value() {
        return this._get();
    }
    set value(newVal) {
        this._set(newVal);
    }
}
function customRef(factory) {
    return new CustomRefImpl(factory);
}
function toRefs(object) {
    if (!isProxy(object)) warn(`toRefs() expects a reactive object but received a plain one.`);
    const ret = (0, _shared.isArray)(object) ? new Array(object.length) : {};
    for(const key in object)ret[key] = propertyToRef(object, key);
    return ret;
}
class ObjectRefImpl {
    constructor(_object, _key, _defaultValue){
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this.__v_isRef = true;
    }
    get value() {
        const val = this._object[this._key];
        return val === void 0 ? this._defaultValue : val;
    }
    set value(newVal) {
        this._object[this._key] = newVal;
    }
    get dep() {
        return getDepFromReactive(toRaw(this._object), this._key);
    }
}
class GetterRefImpl {
    constructor(_getter){
        this._getter = _getter;
        this.__v_isRef = true;
        this.__v_isReadonly = true;
    }
    get value() {
        return this._getter();
    }
}
function toRef(source, key, defaultValue) {
    if (isRef(source)) return source;
    else if ((0, _shared.isFunction)(source)) return new GetterRefImpl(source);
    else if ((0, _shared.isObject)(source) && arguments.length > 1) return propertyToRef(source, key, defaultValue);
    else return ref(source);
}
function propertyToRef(source, key, defaultValue) {
    const val = source[key];
    return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}
const deferredComputed = computed;
const TrackOpTypes = {
    "GET": "get",
    "HAS": "has",
    "ITERATE": "iterate"
};
const TriggerOpTypes = {
    "SET": "set",
    "ADD": "add",
    "DELETE": "delete",
    "CLEAR": "clear"
};
const ReactiveFlags = {
    "SKIP": "__v_skip",
    "IS_REACTIVE": "__v_isReactive",
    "IS_READONLY": "__v_isReadonly",
    "IS_SHALLOW": "__v_isShallow",
    "RAW": "__v_raw"
};

},{"@vue/shared":"3SM3y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3SM3y":[function(require,module,exports) {
/**
* @vue/shared v3.4.22
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/ /*! #__NO_SIDE_EFFECTS__ */ // @__NO_SIDE_EFFECTS__
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EMPTY_ARR", ()=>EMPTY_ARR);
parcelHelpers.export(exports, "EMPTY_OBJ", ()=>EMPTY_OBJ);
parcelHelpers.export(exports, "NO", ()=>NO);
parcelHelpers.export(exports, "NOOP", ()=>NOOP);
parcelHelpers.export(exports, "PatchFlagNames", ()=>PatchFlagNames);
parcelHelpers.export(exports, "PatchFlags", ()=>PatchFlags);
parcelHelpers.export(exports, "ShapeFlags", ()=>ShapeFlags);
parcelHelpers.export(exports, "SlotFlags", ()=>SlotFlags);
parcelHelpers.export(exports, "camelize", ()=>camelize);
parcelHelpers.export(exports, "capitalize", ()=>capitalize);
parcelHelpers.export(exports, "def", ()=>def);
parcelHelpers.export(exports, "escapeHtml", ()=>escapeHtml);
parcelHelpers.export(exports, "escapeHtmlComment", ()=>escapeHtmlComment);
parcelHelpers.export(exports, "extend", ()=>extend);
parcelHelpers.export(exports, "genPropsAccessExp", ()=>genPropsAccessExp);
parcelHelpers.export(exports, "generateCodeFrame", ()=>generateCodeFrame);
parcelHelpers.export(exports, "getGlobalThis", ()=>getGlobalThis);
parcelHelpers.export(exports, "hasChanged", ()=>hasChanged);
parcelHelpers.export(exports, "hasOwn", ()=>hasOwn);
parcelHelpers.export(exports, "hyphenate", ()=>hyphenate);
parcelHelpers.export(exports, "includeBooleanAttr", ()=>includeBooleanAttr);
parcelHelpers.export(exports, "invokeArrayFns", ()=>invokeArrayFns);
parcelHelpers.export(exports, "isArray", ()=>isArray);
parcelHelpers.export(exports, "isBooleanAttr", ()=>isBooleanAttr);
parcelHelpers.export(exports, "isBuiltInDirective", ()=>isBuiltInDirective);
parcelHelpers.export(exports, "isDate", ()=>isDate);
parcelHelpers.export(exports, "isFunction", ()=>isFunction);
parcelHelpers.export(exports, "isGloballyAllowed", ()=>isGloballyAllowed);
parcelHelpers.export(exports, "isGloballyWhitelisted", ()=>isGloballyWhitelisted);
parcelHelpers.export(exports, "isHTMLTag", ()=>isHTMLTag);
parcelHelpers.export(exports, "isIntegerKey", ()=>isIntegerKey);
parcelHelpers.export(exports, "isKnownHtmlAttr", ()=>isKnownHtmlAttr);
parcelHelpers.export(exports, "isKnownSvgAttr", ()=>isKnownSvgAttr);
parcelHelpers.export(exports, "isMap", ()=>isMap);
parcelHelpers.export(exports, "isMathMLTag", ()=>isMathMLTag);
parcelHelpers.export(exports, "isModelListener", ()=>isModelListener);
parcelHelpers.export(exports, "isObject", ()=>isObject);
parcelHelpers.export(exports, "isOn", ()=>isOn);
parcelHelpers.export(exports, "isPlainObject", ()=>isPlainObject);
parcelHelpers.export(exports, "isPromise", ()=>isPromise);
parcelHelpers.export(exports, "isRegExp", ()=>isRegExp);
parcelHelpers.export(exports, "isRenderableAttrValue", ()=>isRenderableAttrValue);
parcelHelpers.export(exports, "isReservedProp", ()=>isReservedProp);
parcelHelpers.export(exports, "isSSRSafeAttrName", ()=>isSSRSafeAttrName);
parcelHelpers.export(exports, "isSVGTag", ()=>isSVGTag);
parcelHelpers.export(exports, "isSet", ()=>isSet);
parcelHelpers.export(exports, "isSpecialBooleanAttr", ()=>isSpecialBooleanAttr);
parcelHelpers.export(exports, "isString", ()=>isString);
parcelHelpers.export(exports, "isSymbol", ()=>isSymbol);
parcelHelpers.export(exports, "isVoidTag", ()=>isVoidTag);
parcelHelpers.export(exports, "looseEqual", ()=>looseEqual);
parcelHelpers.export(exports, "looseIndexOf", ()=>looseIndexOf);
parcelHelpers.export(exports, "looseToNumber", ()=>looseToNumber);
parcelHelpers.export(exports, "makeMap", ()=>makeMap);
parcelHelpers.export(exports, "normalizeClass", ()=>normalizeClass);
parcelHelpers.export(exports, "normalizeProps", ()=>normalizeProps);
parcelHelpers.export(exports, "normalizeStyle", ()=>normalizeStyle);
parcelHelpers.export(exports, "objectToString", ()=>objectToString);
parcelHelpers.export(exports, "parseStringStyle", ()=>parseStringStyle);
parcelHelpers.export(exports, "propsToAttrMap", ()=>propsToAttrMap);
parcelHelpers.export(exports, "remove", ()=>remove);
parcelHelpers.export(exports, "slotFlagsText", ()=>slotFlagsText);
parcelHelpers.export(exports, "stringifyStyle", ()=>stringifyStyle);
parcelHelpers.export(exports, "toDisplayString", ()=>toDisplayString);
parcelHelpers.export(exports, "toHandlerKey", ()=>toHandlerKey);
parcelHelpers.export(exports, "toNumber", ()=>toNumber);
parcelHelpers.export(exports, "toRawType", ()=>toRawType);
parcelHelpers.export(exports, "toTypeString", ()=>toTypeString);
var global = arguments[3];
function makeMap(str, expectsLowerCase) {
    const set = new Set(str.split(","));
    return expectsLowerCase ? (val)=>set.has(val.toLowerCase()) : (val)=>set.has(val);
}
const EMPTY_OBJ = Object.freeze({});
const EMPTY_ARR = Object.freeze([]);
const NOOP = ()=>{};
const NO = ()=>false;
const isOn = (key)=>key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
    (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key)=>key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el)=>{
    const i = arr.indexOf(el);
    if (i > -1) arr.splice(i, 1);
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key)=>hasOwnProperty.call(val, key);
const isArray = Array.isArray;
const isMap = (val)=>toTypeString(val) === "[object Map]";
const isSet = (val)=>toTypeString(val) === "[object Set]";
const isDate = (val)=>toTypeString(val) === "[object Date]";
const isRegExp = (val)=>toTypeString(val) === "[object RegExp]";
const isFunction = (val)=>typeof val === "function";
const isString = (val)=>typeof val === "string";
const isSymbol = (val)=>typeof val === "symbol";
const isObject = (val)=>val !== null && typeof val === "object";
const isPromise = (val)=>{
    return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value)=>objectToString.call(value);
const toRawType = (value)=>{
    return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val)=>toTypeString(val) === "[object Object]";
const isIntegerKey = (key)=>isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(// the leading comma is intentional so empty string "" is also included
",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
const isBuiltInDirective = /* @__PURE__ */ makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");
const cacheStringFunction = (fn)=>{
    const cache = /* @__PURE__ */ Object.create(null);
    return (str)=>{
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str)=>{
    return str.replace(camelizeRE, (_, c)=>c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str)=>str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction((str)=>{
    return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction((str)=>{
    const s = str ? `on${capitalize(str)}` : ``;
    return s;
});
const hasChanged = (value, oldValue)=>!Object.is(value, oldValue);
const invokeArrayFns = (fns, arg)=>{
    for(let i = 0; i < fns.length; i++)fns[i](arg);
};
const def = (obj, key, value)=>{
    Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
    });
};
const looseToNumber = (val)=>{
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
};
const toNumber = (val)=>{
    const n = isString(val) ? Number(val) : NaN;
    return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = ()=>{
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
const identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function genPropsAccessExp(name) {
    return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;
}
const PatchFlags = {
    "TEXT": 1,
    "1": "TEXT",
    "CLASS": 2,
    "2": "CLASS",
    "STYLE": 4,
    "4": "STYLE",
    "PROPS": 8,
    "8": "PROPS",
    "FULL_PROPS": 16,
    "16": "FULL_PROPS",
    "NEED_HYDRATION": 32,
    "32": "NEED_HYDRATION",
    "STABLE_FRAGMENT": 64,
    "64": "STABLE_FRAGMENT",
    "KEYED_FRAGMENT": 128,
    "128": "KEYED_FRAGMENT",
    "UNKEYED_FRAGMENT": 256,
    "256": "UNKEYED_FRAGMENT",
    "NEED_PATCH": 512,
    "512": "NEED_PATCH",
    "DYNAMIC_SLOTS": 1024,
    "1024": "DYNAMIC_SLOTS",
    "DEV_ROOT_FRAGMENT": 2048,
    "2048": "DEV_ROOT_FRAGMENT",
    "HOISTED": -1,
    "-1": "HOISTED",
    "BAIL": -2,
    "-2": "BAIL"
};
const PatchFlagNames = {
    [1]: `TEXT`,
    [2]: `CLASS`,
    [4]: `STYLE`,
    [8]: `PROPS`,
    [16]: `FULL_PROPS`,
    [32]: `NEED_HYDRATION`,
    [64]: `STABLE_FRAGMENT`,
    [128]: `KEYED_FRAGMENT`,
    [256]: `UNKEYED_FRAGMENT`,
    [512]: `NEED_PATCH`,
    [1024]: `DYNAMIC_SLOTS`,
    [2048]: `DEV_ROOT_FRAGMENT`,
    [-1]: `HOISTED`,
    [-2]: `BAIL`
};
const ShapeFlags = {
    "ELEMENT": 1,
    "1": "ELEMENT",
    "FUNCTIONAL_COMPONENT": 2,
    "2": "FUNCTIONAL_COMPONENT",
    "STATEFUL_COMPONENT": 4,
    "4": "STATEFUL_COMPONENT",
    "TEXT_CHILDREN": 8,
    "8": "TEXT_CHILDREN",
    "ARRAY_CHILDREN": 16,
    "16": "ARRAY_CHILDREN",
    "SLOTS_CHILDREN": 32,
    "32": "SLOTS_CHILDREN",
    "TELEPORT": 64,
    "64": "TELEPORT",
    "SUSPENSE": 128,
    "128": "SUSPENSE",
    "COMPONENT_SHOULD_KEEP_ALIVE": 256,
    "256": "COMPONENT_SHOULD_KEEP_ALIVE",
    "COMPONENT_KEPT_ALIVE": 512,
    "512": "COMPONENT_KEPT_ALIVE",
    "COMPONENT": 6,
    "6": "COMPONENT"
};
const SlotFlags = {
    "STABLE": 1,
    "1": "STABLE",
    "DYNAMIC": 2,
    "2": "DYNAMIC",
    "FORWARDED": 3,
    "3": "FORWARDED"
};
const slotFlagsText = {
    [1]: "STABLE",
    [2]: "DYNAMIC",
    [3]: "FORWARDED"
};
const GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error";
const isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);
const isGloballyWhitelisted = isGloballyAllowed;
const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
    let lines = source.split(/(\r?\n)/);
    const newlineSequences = lines.filter((_, idx)=>idx % 2 === 1);
    lines = lines.filter((_, idx)=>idx % 2 === 0);
    let count = 0;
    const res = [];
    for(let i = 0; i < lines.length; i++){
        count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
        if (count >= start) {
            for(let j = i - range; j <= i + range || end > count; j++){
                if (j < 0 || j >= lines.length) continue;
                const line = j + 1;
                res.push(`${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
                const lineLength = lines[j].length;
                const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
                if (j === i) {
                    const pad = start - (count - (lineLength + newLineSeqLength));
                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
                    res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
                } else if (j > i) {
                    if (end > count) {
                        const length = Math.max(Math.min(end - count, lineLength), 1);
                        res.push(`   |  ` + "^".repeat(length));
                    }
                    count += lineLength + newLineSeqLength;
                }
            }
            break;
        }
    }
    return res.join("\n");
}
function normalizeStyle(value) {
    if (isArray(value)) {
        const res = {};
        for(let i = 0; i < value.length; i++){
            const item = value[i];
            const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
            if (normalized) for(const key in normalized)res[key] = normalized[key];
        }
        return res;
    } else if (isString(value) || isObject(value)) return value;
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item)=>{
        if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return ret;
}
function stringifyStyle(styles) {
    let ret = "";
    if (!styles || isString(styles)) return ret;
    for(const key in styles){
        const value = styles[key];
        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
        if (isString(value) || typeof value === "number") ret += `${normalizedKey}:${value};`;
    }
    return ret;
}
function normalizeClass(value) {
    let res = "";
    if (isString(value)) res = value;
    else if (isArray(value)) for(let i = 0; i < value.length; i++){
        const normalized = normalizeClass(value[i]);
        if (normalized) res += normalized + " ";
    }
    else if (isObject(value)) {
        for(const name in value)if (value[name]) res += name + " ";
    }
    return res.trim();
}
function normalizeProps(props) {
    if (!props) return null;
    let { class: klass, style } = props;
    if (klass && !isString(klass)) props.class = normalizeClass(klass);
    if (style) props.style = normalizeStyle(style);
    return props;
}
const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
const isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
const isBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
function includeBooleanAttr(value) {
    return !!value || value === "";
}
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
    if (attrValidationCache.hasOwnProperty(name)) return attrValidationCache[name];
    const isUnsafe = unsafeAttrCharRE.test(name);
    if (isUnsafe) console.error(`unsafe attribute name: ${name}`);
    return attrValidationCache[name] = !isUnsafe;
}
const propsToAttrMap = {
    acceptCharset: "accept-charset",
    className: "class",
    htmlFor: "for",
    httpEquiv: "http-equiv"
};
const isKnownHtmlAttr = /* @__PURE__ */ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`);
const isKnownSvgAttr = /* @__PURE__ */ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);
function isRenderableAttrValue(value) {
    if (value == null) return false;
    const type = typeof value;
    return type === "string" || type === "number" || type === "boolean";
}
const escapeRE = /["'&<>]/;
function escapeHtml(string) {
    const str = "" + string;
    const match = escapeRE.exec(str);
    if (!match) return str;
    let html = "";
    let escaped;
    let index;
    let lastIndex = 0;
    for(index = match.index; index < str.length; index++){
        switch(str.charCodeAt(index)){
            case 34:
                escaped = "&quot;";
                break;
            case 38:
                escaped = "&amp;";
                break;
            case 39:
                escaped = "&#39;";
                break;
            case 60:
                escaped = "&lt;";
                break;
            case 62:
                escaped = "&gt;";
                break;
            default:
                continue;
        }
        if (lastIndex !== index) html += str.slice(lastIndex, index);
        lastIndex = index + 1;
        html += escaped;
    }
    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
    return src.replace(commentStripRE, "");
}
function looseCompareArrays(a, b) {
    if (a.length !== b.length) return false;
    let equal = true;
    for(let i = 0; equal && i < a.length; i++)equal = looseEqual(a[i], b[i]);
    return equal;
}
function looseEqual(a, b) {
    if (a === b) return true;
    let aValidType = isDate(a);
    let bValidType = isDate(b);
    if (aValidType || bValidType) return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    aValidType = isSymbol(a);
    bValidType = isSymbol(b);
    if (aValidType || bValidType) return a === b;
    aValidType = isArray(a);
    bValidType = isArray(b);
    if (aValidType || bValidType) return aValidType && bValidType ? looseCompareArrays(a, b) : false;
    aValidType = isObject(a);
    bValidType = isObject(b);
    if (aValidType || bValidType) {
        if (!aValidType || !bValidType) return false;
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) return false;
        for(const key in a){
            const aHasKey = a.hasOwnProperty(key);
            const bHasKey = b.hasOwnProperty(key);
            if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) return false;
        }
    }
    return String(a) === String(b);
}
function looseIndexOf(arr, val) {
    return arr.findIndex((item)=>looseEqual(item, val));
}
const toDisplayString = (val)=>{
    return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val)=>{
    if (val && val.__v_isRef) return replacer(_key, val.value);
    else if (isMap(val)) return {
        [`Map(${val.size})`]: [
            ...val.entries()
        ].reduce((entries, [key, val2], i)=>{
            entries[stringifySymbol(key, i) + " =>"] = val2;
            return entries;
        }, {})
    };
    else if (isSet(val)) return {
        [`Set(${val.size})`]: [
            ...val.values()
        ].map((v)=>stringifySymbol(v))
    };
    else if (isSymbol(val)) return stringifySymbol(val);
    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) return String(val);
    return val;
};
const stringifySymbol = (v, i = "")=>{
    var _a;
    return(// Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || Object.prototype.hasOwnProperty.call(dest, key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"lOLHi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>xn);
var _vue = require("vue");
var _dateFns = require("date-fns");
const ot = (e, n)=>{
    const a = e.__vccOpts || e;
    for (const [t, r] of n)a[t] = r;
    return a;
}, sa = {}, ia = {
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    width: "32",
    height: "32",
    viewBox: "0 0 32 32",
    class: "dp__icon"
}, ua = /* @__PURE__ */ (0, _vue.createElementVNode)("path", {
    d: "M29.333 8c0-2.208-1.792-4-4-4h-18.667c-2.208 0-4 1.792-4 4v18.667c0 2.208 1.792 4 4 4h18.667c2.208 0 4-1.792 4-4v-18.667zM26.667 8v18.667c0 0.736-0.597 1.333-1.333 1.333 0 0-18.667 0-18.667 0-0.736 0-1.333-0.597-1.333-1.333 0 0 0-18.667 0-18.667 0-0.736 0.597-1.333 1.333-1.333 0 0 18.667 0 18.667 0 0.736 0 1.333 0.597 1.333 1.333z"
}, null, -1), ca = /* @__PURE__ */ (0, _vue.createElementVNode)("path", {
    d: "M20 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
}, null, -1), da = /* @__PURE__ */ (0, _vue.createElementVNode)("path", {
    d: "M9.333 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
}, null, -1), fa = /* @__PURE__ */ (0, _vue.createElementVNode)("path", {
    d: "M4 14.667h24c0.736 0 1.333-0.597 1.333-1.333s-0.597-1.333-1.333-1.333h-24c-0.736 0-1.333 0.597-1.333 1.333s0.597 1.333 1.333 1.333z"
}, null, -1), va = [
    ua,
    ca,
    da,
    fa
];
function ma(e, n) {
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("svg", ia, va);
}
const It = /* @__PURE__ */ ot(sa, [
    [
        "render",
        ma
    ]
]), ya = {}, ha = {
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    width: "32",
    height: "32",
    viewBox: "0 0 32 32",
    class: "dp__icon"
}, ga = /* @__PURE__ */ (0, _vue.createElementVNode)("path", {
    d: "M23.057 7.057l-16 16c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l16-16c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0z"
}, null, -1), pa = /* @__PURE__ */ (0, _vue.createElementVNode)("path", {
    d: "M7.057 8.943l16 16c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885l-16-16c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
}, null, -1), ka = [
    ga,
    pa
];
function wa(e, n) {
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("svg", ha, ka);
}
const ba = /* @__PURE__ */ ot(ya, [
    [
        "render",
        wa
    ]
]), Da = {}, $a = {
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    width: "32",
    height: "32",
    viewBox: "0 0 32 32",
    class: "dp__icon"
}, Ma = /* @__PURE__ */ (0, _vue.createElementVNode)("path", {
    d: "M20.943 23.057l-7.057-7.057c0 0 7.057-7.057 7.057-7.057 0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-8 8c-0.521 0.521-0.521 1.365 0 1.885l8 8c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
}, null, -1), _a = [
    Ma
];
function Aa(e, n) {
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("svg", $a, _a);
}
const pn = /* @__PURE__ */ ot(Da, [
    [
        "render",
        Aa
    ]
]), Ta = {}, Ca = {
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    width: "32",
    height: "32",
    viewBox: "0 0 32 32",
    class: "dp__icon"
}, Sa = /* @__PURE__ */ (0, _vue.createElementVNode)("path", {
    d: "M12.943 24.943l8-8c0.521-0.521 0.521-1.365 0-1.885l-8-8c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885l7.057 7.057c0 0-7.057 7.057-7.057 7.057-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0z"
}, null, -1), Pa = [
    Sa
];
function Na(e, n) {
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("svg", Ca, Pa);
}
const kn = /* @__PURE__ */ ot(Ta, [
    [
        "render",
        Na
    ]
]), Ra = {}, Ia = {
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    width: "32",
    height: "32",
    viewBox: "0 0 32 32",
    class: "dp__icon"
}, Oa = /* @__PURE__ */ (0, _vue.createElementVNode)("path", {
    d: "M16 1.333c-8.095 0-14.667 6.572-14.667 14.667s6.572 14.667 14.667 14.667c8.095 0 14.667-6.572 14.667-14.667s-6.572-14.667-14.667-14.667zM16 4c6.623 0 12 5.377 12 12s-5.377 12-12 12c-6.623 0-12-5.377-12-12s5.377-12 12-12z"
}, null, -1), Ba = /* @__PURE__ */ (0, _vue.createElementVNode)("path", {
    d: "M14.667 8v8c0 0.505 0.285 0.967 0.737 1.193l5.333 2.667c0.658 0.329 1.46 0.062 1.789-0.596s0.062-1.46-0.596-1.789l-4.596-2.298c0 0 0-7.176 0-7.176 0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
}, null, -1), Ya = [
    Oa,
    Ba
];
function Va(e, n) {
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("svg", Ia, Ya);
}
const Ln = /* @__PURE__ */ ot(Ra, [
    [
        "render",
        Va
    ]
]), La = {}, Ea = {
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    width: "32",
    height: "32",
    viewBox: "0 0 32 32",
    class: "dp__icon"
}, Fa = /* @__PURE__ */ (0, _vue.createElementVNode)("path", {
    d: "M24.943 19.057l-8-8c-0.521-0.521-1.365-0.521-1.885 0l-8 8c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l7.057-7.057c0 0 7.057 7.057 7.057 7.057 0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
}, null, -1), Ua = [
    Fa
];
function Ha(e, n) {
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("svg", Ea, Ua);
}
const En = /* @__PURE__ */ ot(La, [
    [
        "render",
        Ha
    ]
]), Wa = {}, za = {
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    width: "32",
    height: "32",
    viewBox: "0 0 32 32",
    class: "dp__icon"
}, ja = /* @__PURE__ */ (0, _vue.createElementVNode)("path", {
    d: "M7.057 12.943l8 8c0.521 0.521 1.365 0.521 1.885 0l8-8c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-7.057 7.057c0 0-7.057-7.057-7.057-7.057-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
}, null, -1), xa = [
    ja
];
function Ka(e, n) {
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("svg", za, xa);
}
const Fn = /* @__PURE__ */ ot(Wa, [
    [
        "render",
        Ka
    ]
]), wn = (e, n)=>{
    const a = (0, _dateFns.parse)(e, n.slice(0, e.length), new Date());
    return (0, _dateFns.isValid)(a) && (0, _dateFns.isDate)(a) ? a : null;
}, Ga = (e, n)=>{
    if (typeof n == "string") return wn(e, n);
    if (Array.isArray(n)) {
        let a = null;
        for (const t of n)if (a = wn(e, t), a) break;
        return a;
    }
    return typeof n == "function" ? n(e) : null;
}, w = (e)=>e ? new Date(e) : new Date(), Za = (e, n)=>{
    if (n) {
        const t = (e.getMonth() + 1).toString().padStart(2, "0"), r = e.getDate().toString().padStart(2, "0"), i = e.getHours().toString().padStart(2, "0"), p = e.getMinutes().toString().padStart(2, "0");
        return `${e.getFullYear()}-${t}-${r}T${i}:${p}:00.000Z`;
    }
    const a = Date.UTC(e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes(), e.getUTCSeconds());
    return new Date(a).toISOString();
}, He = (e)=>{
    let n = w(JSON.parse(JSON.stringify(e)));
    return n = (0, _dateFns.setHours)(n, 0), n = (0, _dateFns.setMinutes)(n, 0), n = (0, _dateFns.setSeconds)(n, 0), n = (0, _dateFns.setMilliseconds)(n, 0), n;
}, Ye = (e, n, a, t)=>{
    let r = e ? w(e) : w();
    return (n || n === 0) && (r = (0, _dateFns.setHours)(r, +n)), (a || a === 0) && (r = (0, _dateFns.setMinutes)(r, +a)), (t || t === 0) && (r = (0, _dateFns.setSeconds)(r, +t)), (0, _dateFns.setMilliseconds)(r, 0);
}, Se = (e, n)=>!e || !n ? !1 : (0, _dateFns.isBefore)(He(e), He(n)), ve = (e, n)=>!e || !n ? !1 : (0, _dateFns.isEqual)(He(e), He(n)), Ie = (e, n)=>!e || !n ? !1 : (0, _dateFns.isAfter)(He(e), He(n)), Un = (e, n, a)=>e && e[0] && e[1] ? Ie(a, e[0]) && Se(a, e[1]) : e && e[0] && n ? Ie(a, e[0]) && Se(a, n) || Se(a, e[0]) && Ie(a, n) : !1, yt = (0, _vue.reactive)({
    menuFocused: !1,
    shiftKeyInMenu: !1
}), Hn = ()=>{
    const e = (t)=>{
        yt.menuFocused = t;
    }, n = (t)=>{
        yt.shiftKeyInMenu !== t && (yt.shiftKeyInMenu = t);
    };
    return {
        control: (0, _vue.computed)(()=>({
                shiftKeyInMenu: yt.shiftKeyInMenu,
                menuFocused: yt.menuFocused
            })),
        setMenuFocused: e,
        setShiftKey: n
    };
};
function dn(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Qt = {
    exports: {}
};
(function(e, n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.default = a;
    function a(t) {
        if (t === null || t === !0 || t === !1) return NaN;
        var r = Number(t);
        return isNaN(r) ? r : r < 0 ? Math.ceil(r) : Math.floor(r);
    }
    e.exports = n.default;
})(Qt, Qt.exports);
const Xa = /* @__PURE__ */ dn(Qt.exports);
var en = {
    exports: {}
};
(function(e, n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.default = a;
    function a(t) {
        var r = new Date(Date.UTC(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours(), t.getMinutes(), t.getSeconds(), t.getMilliseconds()));
        return r.setUTCFullYear(t.getFullYear()), t.getTime() - r.getTime();
    }
    e.exports = n.default;
})(en, en.exports);
const bn = /* @__PURE__ */ dn(en.exports);
function qa(e, n) {
    var a = tl(n);
    return a.formatToParts ? Qa(a, e) : el(a, e);
}
var Ja = {
    year: 0,
    month: 1,
    day: 2,
    hour: 3,
    minute: 4,
    second: 5
};
function Qa(e, n) {
    try {
        for(var a = e.formatToParts(n), t = [], r = 0; r < a.length; r++){
            var i = Ja[a[r].type];
            i >= 0 && (t[i] = parseInt(a[r].value, 10));
        }
        return t;
    } catch (p) {
        if (p instanceof RangeError) return [
            NaN
        ];
        throw p;
    }
}
function el(e, n) {
    var a = e.format(n).replace(/\u200E/g, ""), t = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(a);
    return [
        t[3],
        t[1],
        t[2],
        t[4],
        t[5],
        t[6]
    ];
}
var Ut = {};
function tl(e) {
    if (!Ut[e]) {
        var n = new Intl.DateTimeFormat("en-US", {
            hour12: !1,
            timeZone: "America/New_York",
            year: "numeric",
            month: "numeric",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit"
        }).format(new Date("2014-06-25T04:00:00.123Z")), a = n === "06/25/2014, 00:00:00" || n === "\u200E06\u200E/\u200E25\u200E/\u200E2014\u200E \u200E00\u200E:\u200E00\u200E:\u200E00";
        Ut[e] = a ? new Intl.DateTimeFormat("en-US", {
            hour12: !1,
            timeZone: e,
            year: "numeric",
            month: "numeric",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit"
        }) : new Intl.DateTimeFormat("en-US", {
            hourCycle: "h23",
            timeZone: e,
            year: "numeric",
            month: "numeric",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit"
        });
    }
    return Ut[e];
}
function fn(e, n, a, t, r, i, p) {
    var b = new Date(0);
    return b.setUTCFullYear(e, n, a), b.setUTCHours(t, r, i, p), b;
}
var Dn = 36e5, nl = 6e4, Ht = {
    timezone: /([Z+-].*)$/,
    timezoneZ: /^(Z)$/,
    timezoneHH: /^([+-]\d{2})$/,
    timezoneHHMM: /^([+-]\d{2}):?(\d{2})$/
};
function vn(e, n, a) {
    var t, r;
    if (e === "" || (t = Ht.timezoneZ.exec(e), t)) return 0;
    var i;
    if (t = Ht.timezoneHH.exec(e), t) return i = parseInt(t[1], 10), $n(i) ? -(i * Dn) : NaN;
    if (t = Ht.timezoneHHMM.exec(e), t) {
        i = parseInt(t[1], 10);
        var p = parseInt(t[2], 10);
        return $n(i, p) ? (r = Math.abs(i) * Dn + p * nl, i > 0 ? -r : r) : NaN;
    }
    if (rl(e)) {
        n = new Date(n || Date.now());
        var b = a ? n : al(n), B = tn(b, e), E = a ? B : ll(n, B, e);
        return -E;
    }
    return NaN;
}
function al(e) {
    return fn(e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds());
}
function tn(e, n) {
    var a = qa(e, n), t = fn(a[0], a[1] - 1, a[2], a[3] % 24, a[4], a[5], 0).getTime(), r = e.getTime(), i = r % 1e3;
    return r -= i >= 0 ? i : 1e3 + i, t - r;
}
function ll(e, n, a) {
    var t = e.getTime(), r = t - n, i = tn(new Date(r), a);
    if (n === i) return n;
    r -= i - n;
    var p = tn(new Date(r), a);
    return i === p ? i : Math.max(i, p);
}
function $n(e, n) {
    return -23 <= e && e <= 23 && (n == null || 0 <= n && n <= 59);
}
var Mn = {};
function rl(e) {
    if (Mn[e]) return !0;
    try {
        return new Intl.DateTimeFormat(void 0, {
            timeZone: e
        }), Mn[e] = !0, !0;
    } catch  {
        return !1;
    }
}
var Wn = /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/, Wt = 36e5, _n = 6e4, ol = 2, Re = {
    dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,
    datePattern: /^([0-9W+-]+)(.*)/,
    plainTime: /:/,
    YY: /^(\d{2})$/,
    YYY: [
        /^([+-]\d{2})$/,
        /^([+-]\d{3})$/,
        /^([+-]\d{4})$/
    ],
    YYYY: /^(\d{4})/,
    YYYYY: [
        /^([+-]\d{4})/,
        /^([+-]\d{5})/,
        /^([+-]\d{6})/
    ],
    MM: /^-(\d{2})$/,
    DDD: /^-?(\d{3})$/,
    MMDD: /^-?(\d{2})-?(\d{2})$/,
    Www: /^-?W(\d{2})$/,
    WwwD: /^-?W(\d{2})-?(\d{1})$/,
    HH: /^(\d{2}([.,]\d*)?)$/,
    HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
    HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
    timeZone: Wn
};
function nn(e, n) {
    if (arguments.length < 1) throw new TypeError("1 argument required, but only " + arguments.length + " present");
    if (e === null) return new Date(NaN);
    var a = n || {}, t = a.additionalDigits == null ? ol : Xa(a.additionalDigits);
    if (t !== 2 && t !== 1 && t !== 0) throw new RangeError("additionalDigits must be 0, 1 or 2");
    if (e instanceof Date || typeof e == "object" && Object.prototype.toString.call(e) === "[object Date]") return new Date(e.getTime());
    if (typeof e == "number" || Object.prototype.toString.call(e) === "[object Number]") return new Date(e);
    if (!(typeof e == "string" || Object.prototype.toString.call(e) === "[object String]")) return new Date(NaN);
    var r = sl(e), i = il(r.date, t), p = i.year, b = i.restDateString, B = ul(b, p);
    if (isNaN(B)) return new Date(NaN);
    if (B) {
        var E = B.getTime(), L = 0, s;
        if (r.time && (L = cl(r.time), isNaN(L))) return new Date(NaN);
        if (r.timeZone || a.timeZone) {
            if (s = vn(r.timeZone || a.timeZone, new Date(E + L)), isNaN(s)) return new Date(NaN);
        } else s = bn(new Date(E + L)), s = bn(new Date(E + L + s));
        return new Date(E + L + s);
    } else return new Date(NaN);
}
function sl(e) {
    var n = {}, a = Re.dateTimePattern.exec(e), t;
    if (a ? (n.date = a[1], t = a[3]) : (a = Re.datePattern.exec(e), a ? (n.date = a[1], t = a[2]) : (n.date = null, t = e)), t) {
        var r = Re.timeZone.exec(t);
        r ? (n.time = t.replace(r[1], ""), n.timeZone = r[1].trim()) : n.time = t;
    }
    return n;
}
function il(e, n) {
    var a = Re.YYY[n], t = Re.YYYYY[n], r;
    if (r = Re.YYYY.exec(e) || t.exec(e), r) {
        var i = r[1];
        return {
            year: parseInt(i, 10),
            restDateString: e.slice(i.length)
        };
    }
    if (r = Re.YY.exec(e) || a.exec(e), r) {
        var p = r[1];
        return {
            year: parseInt(p, 10) * 100,
            restDateString: e.slice(p.length)
        };
    }
    return {
        year: null
    };
}
function ul(e, n) {
    if (n === null) return null;
    var a, t, r, i;
    if (e.length === 0) return t = new Date(0), t.setUTCFullYear(n), t;
    if (a = Re.MM.exec(e), a) return t = new Date(0), r = parseInt(a[1], 10) - 1, Tn(n, r) ? (t.setUTCFullYear(n, r), t) : new Date(NaN);
    if (a = Re.DDD.exec(e), a) {
        t = new Date(0);
        var p = parseInt(a[1], 10);
        return vl(n, p) ? (t.setUTCFullYear(n, 0, p), t) : new Date(NaN);
    }
    if (a = Re.MMDD.exec(e), a) {
        t = new Date(0), r = parseInt(a[1], 10) - 1;
        var b = parseInt(a[2], 10);
        return Tn(n, r, b) ? (t.setUTCFullYear(n, r, b), t) : new Date(NaN);
    }
    if (a = Re.Www.exec(e), a) return i = parseInt(a[1], 10) - 1, Cn(n, i) ? An(n, i) : new Date(NaN);
    if (a = Re.WwwD.exec(e), a) {
        i = parseInt(a[1], 10) - 1;
        var B = parseInt(a[2], 10) - 1;
        return Cn(n, i, B) ? An(n, i, B) : new Date(NaN);
    }
    return null;
}
function cl(e) {
    var n, a, t;
    if (n = Re.HH.exec(e), n) return a = parseFloat(n[1].replace(",", ".")), zt(a) ? a % 24 * Wt : NaN;
    if (n = Re.HHMM.exec(e), n) return a = parseInt(n[1], 10), t = parseFloat(n[2].replace(",", ".")), zt(a, t) ? a % 24 * Wt + t * _n : NaN;
    if (n = Re.HHMMSS.exec(e), n) {
        a = parseInt(n[1], 10), t = parseInt(n[2], 10);
        var r = parseFloat(n[3].replace(",", "."));
        return zt(a, t, r) ? a % 24 * Wt + t * _n + r * 1e3 : NaN;
    }
    return null;
}
function An(e, n, a) {
    n = n || 0, a = a || 0;
    var t = new Date(0);
    t.setUTCFullYear(e, 0, 4);
    var r = t.getUTCDay() || 7, i = n * 7 + a + 1 - r;
    return t.setUTCDate(t.getUTCDate() + i), t;
}
var dl = [
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
], fl = [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
];
function zn(e) {
    return e % 400 === 0 || e % 4 === 0 && e % 100 !== 0;
}
function Tn(e, n, a) {
    if (n < 0 || n > 11) return !1;
    if (a != null) {
        if (a < 1) return !1;
        var t = zn(e);
        if (t && a > fl[n] || !t && a > dl[n]) return !1;
    }
    return !0;
}
function vl(e, n) {
    if (n < 1) return !1;
    var a = zn(e);
    return !(a && n > 366 || !a && n > 365);
}
function Cn(e, n, a) {
    return !(n < 0 || n > 52 || a != null && (a < 0 || a > 6));
}
function zt(e, n, a) {
    return !(e != null && (e < 0 || e >= 25) || n != null && (n < 0 || n >= 60) || a != null && (a < 0 || a >= 60));
}
var an = {
    exports: {}
}, ln = {
    exports: {}
};
(function(e, n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.default = a;
    function a(t, r) {
        if (t == null) throw new TypeError("assign requires that input parameter not be null or undefined");
        for(var i in r)Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i]);
        return t;
    }
    e.exports = n.default;
})(ln, ln.exports);
(function(e, n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }), n.default = r;
    var a = t(ln.exports);
    function t(i) {
        return i && i.__esModule ? i : {
            default: i
        };
    }
    function r(i) {
        return (0, a.default)({}, i);
    }
    e.exports = n.default;
})(an, an.exports);
const ml = /* @__PURE__ */ dn(an.exports);
function yl(e, n, a) {
    var t = nn(e, a), r = vn(n, t, !0), i = new Date(t.getTime() - r), p = new Date(0);
    return p.setFullYear(i.getUTCFullYear(), i.getUTCMonth(), i.getUTCDate()), p.setHours(i.getUTCHours(), i.getUTCMinutes(), i.getUTCSeconds(), i.getUTCMilliseconds()), p;
}
function hl(e, n, a) {
    if (typeof e == "string" && !e.match(Wn)) {
        var t = ml(a);
        return t.timeZone = n, nn(e, t);
    }
    var r = nn(e, a), i = fn(r.getFullYear(), r.getMonth(), r.getDate(), r.getHours(), r.getMinutes(), r.getSeconds(), r.getMilliseconds()).getTime(), p = vn(n, new Date(i));
    return new Date(i + p);
}
const gl = (e, n = 3)=>{
    const a = [];
    for(let t = 0; t < e.length; t += n)a.push([
        e[t],
        e[t + 1],
        e[t + 2]
    ]);
    return a;
}, pl = (e, n)=>{
    const a = [
        1,
        2,
        3,
        4,
        5,
        6,
        7
    ].map((i)=>new Intl.DateTimeFormat(e, {
            weekday: "short",
            timeZone: "UTC"
        }).format(new Date(`2017-01-0${i}T00:00:00+00:00`)).slice(0, 2)), t = a.slice(0, n), r = a.slice(n + 1, a.length);
    return [
        a[n]
    ].concat(...r).concat(...t);
}, kl = (e)=>{
    const n = [];
    for(let a = +e[0]; a <= +e[1]; a++)n.push({
        value: +a,
        text: `${a}`
    });
    return n;
}, wl = (e, n)=>{
    const a = new Intl.DateTimeFormat(e, {
        month: n,
        timeZone: "UTC"
    });
    return [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12
    ].map((r)=>{
        const i = r < 10 ? `0${r}` : r;
        return new Date(`2017-${i}-01T00:00:00+00:00`);
    }).map((r, i)=>({
            text: a.format(r),
            value: i
        }));
}, bl = (e)=>[
        12,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11
    ][e], Te = (e)=>{
    var a;
    const n = (0, _vue.unref)(e);
    return (a = n == null ? void 0 : n.$el) != null ? a : n;
}, Dl = (e)=>Object.assign({
        type: "dot"
    }, e), jn = (e)=>Array.isArray(e) ? !!e[0] && !!e[1] : !1, Rt = {
    prop: (e)=>`"${e}" prop must be enabled!`,
    dateArr: (e)=>`You need to use array as "model-value" binding in order to support "${e}"`
}, be = (e)=>e, Sn = (e)=>Object.assign({
        menuAppear: "dp-menu-appear",
        open: "dp-slide-down",
        close: "dp-slide-up",
        next: "calendar-next",
        previous: "calendar-prev",
        vNext: "dp-slide-up",
        vPrevious: "dp-slide-down"
    }, e), $l = (e)=>Object.assign({
        toggleOverlay: "Toggle overlay",
        menu: "Datepicker menu",
        input: "Datepicker input",
        calendarWrap: "Calendar wrapper",
        calendarDays: "Calendar days",
        openTimePicker: "Open time picker",
        closeTimePicker: "Close time Picker",
        incrementValue: (n)=>`Increment ${n}`,
        decrementValue: (n)=>`Decrement ${n}`,
        openTpOverlay: (n)=>`Open ${n} overlay`,
        amPmButton: "Switch AM/PM mode",
        openYearsOverlay: "Open years overlay",
        openMonthsOverlay: "Open months overlay",
        nextMonth: "Next month",
        prevMonth: "Previous month",
        day: ()=>""
    }, e), Ml = (e)=>e === null ? 0 : typeof e == "boolean" ? e ? 2 : 0 : +e >= 2 ? +e : 2, _l = (e, n, a)=>e || (typeof a == "string" ? a : n), Al = (e)=>typeof e == "boolean" ? e ? Sn({}) : !1 : Sn(e), Tl = ()=>({
        enterSubmit: !0,
        tabSubmit: !0,
        openMenu: !0,
        rangeSeparator: " - "
    }), Cl = (e)=>Object.assign({
        months: [],
        years: [],
        times: {
            hours: [],
            minutes: [],
            seconds: []
        }
    }, e), Be = (e)=>{
    const n = ()=>{
        if (e.partialRange) return null;
        throw new Error(Rt.prop("partial-range"));
    }, a = (0, _vue.computed)(()=>({
            ariaLabels: $l(e.ariaLabels),
            textInputOptions: Object.assign(Tl(), e.textInputOptions),
            multiCalendars: Ml(e.multiCalendars),
            previewFormat: _l(e.previewFormat, e.format, i()),
            filters: Cl(e.filters),
            transitions: Al(e.transitions),
            startTime: _()
        })), t = (l)=>{
        if (e.range) return l();
        throw new Error(Rt.prop("range"));
    }, r = ()=>{
        const l = e.enableSeconds ? ":ss" : "";
        return e.is24 ? `HH:mm${l}` : `hh:mm${l} aa`;
    }, i = ()=>e.format ? e.format : e.monthPicker ? "MM/yyyy" : e.timePicker ? r() : e.weekPicker ? "MM/dd/yyyy" : e.yearPicker ? "yyyy" : e.enableTimePicker ? `MM/dd/yyyy, ${r()}` : "MM/dd/yyyy", p = (l, d)=>{
        if (typeof e.format == "function") return e.format(l);
        const k = d || i(), V = e.formatLocale ? {
            locale: e.formatLocale
        } : void 0;
        return Array.isArray(l) ? `${(0, _dateFns.format)(l[0], k, V)} ${e.modelAuto && !l[1] ? "" : a.value.textInputOptions.rangeSeparator || "-"} ${l[1] ? (0, _dateFns.format)(l[1], k, V) : ""}` : (0, _dateFns.format)(l, k, V);
    }, b = (l)=>e.timezone ? yl(l, e.timezone) : l, B = (l)=>e.timezone ? hl(l, e.timezone) : l, E = (0, _vue.computed)(()=>(l)=>{
            var d;
            return (d = e.hideNavigation) == null ? void 0 : d.includes(l);
        }), L = (l)=>{
        const d = e.maxDate ? Ie(b(l), b(w(e.maxDate))) : !1, k = e.minDate ? Se(b(l), b(w(e.minDate))) : !1, V = P(l, e.disabledDates), C = a.value.filters.months.map((Ce)=>+Ce).includes((0, _dateFns.getMonth)(l)), v = e.disabledWeekDays.length ? e.disabledWeekDays.some((Ce)=>+Ce === (0, _dateFns.getDay)(l)) : !1, q = e.allowedDates.length ? !e.allowedDates.some((Ce)=>ve(b(w(Ce)), b(l))) : !1, se = (0, _dateFns.getYear)(l), ge = se < +e.yearRange[0] || se > +e.yearRange[1];
        return !(d || k || V || C || ge || v || q);
    }, s = (l)=>{
        const d = {
            hours: (0, _dateFns.getHours)(w()),
            minutes: (0, _dateFns.getMinutes)(w()),
            seconds: (0, _dateFns.getSeconds)(w())
        };
        return Object.assign(d, l);
    }, _ = ()=>e.range ? e.startTime && Array.isArray(e.startTime) ? [
            s(e.startTime[0]),
            s(e.startTime[1])
        ] : null : e.startTime && !Array.isArray(e.startTime) ? s(e.startTime) : null, I = (l)=>!L(l), Y = (l)=>Array.isArray(l) ? (0, _dateFns.isValid)(l[0]) && (l[1] ? (0, _dateFns.isValid)(l[1]) : !0) : l ? (0, _dateFns.isValid)(l) : !1, Z = (l)=>l instanceof Date ? l : (0, _dateFns.parseISO)(l), ae = (l)=>{
        const d = (0, _dateFns.startOfWeek)(b(l), {
            weekStartsOn: +e.weekStart
        }), k = (0, _dateFns.endOfWeek)(b(l), {
            weekStartsOn: +e.weekStart
        });
        return [
            d,
            k
        ];
    }, P = (l, d)=>Array.isArray(d) ? d.some((k)=>ve(b(w(k)), b(l))) : d(l), M = (l, d, k)=>{
        let V = l ? w(l) : w();
        return (d || d === 0) && (V = (0, _dateFns.setMonth)(V, d)), k && (V = (0, _dateFns.setYear)(V, k)), V;
    }, G = (l)=>(0, _dateFns.set)(w(), {
            hours: (0, _dateFns.getHours)(l),
            minutes: (0, _dateFns.getMinutes)(l),
            seconds: (0, _dateFns.getSeconds)(l)
        }), J = (l)=>(0, _dateFns.set)(w(), {
            hours: +l.hours || 0,
            minutes: +l.minutes || 0,
            seconds: +l.seconds || 0
        }), Q = (l, d, k, V)=>{
        if (!l) return !0;
        if (V) {
            const y = k === "max" ? (0, _dateFns.isBefore)(l, d) : (0, _dateFns.isAfter)(l, d), C = {
                seconds: 0,
                milliseconds: 0
            };
            return y || (0, _dateFns.isEqual)((0, _dateFns.set)(l, C), (0, _dateFns.set)(d, C));
        }
        return k === "max" ? l.getTime() <= d.getTime() : l.getTime() >= d.getTime();
    }, N = ()=>!e.enableTimePicker || e.monthPicker || e.yearPicker || e.ignoreTimeValidation, m = (l)=>Array.isArray(l) ? [
            l[0] ? G(l[0]) : null,
            l[1] ? G(l[1]) : null
        ] : G(l), O = (l)=>{
        const d = e.maxTime ? J(e.maxTime) : w(e.maxDate);
        return Array.isArray(l) ? Q(l[0], d, "max", !!e.maxDate) && Q(l[1], d, "max", !!e.maxDate) : Q(l, d, "max", !!e.maxDate);
    }, j = (l, d)=>{
        const k = e.minTime ? J(e.minTime) : w(e.minDate);
        return Array.isArray(l) ? Q(l[0], k, "min", !!e.minDate) && Q(l[1], k, "min", !!e.minDate) && d : Q(l, k, "min", !!e.minDate) && d;
    }, le = (l)=>{
        let d = !0;
        if (!l || N()) return !0;
        const k = !e.minDate && !e.maxDate ? m(l) : l;
        return (e.maxTime || e.maxDate) && (d = O(be(k))), (e.minTime || e.minDate) && (d = j(be(k), d)), d;
    }, R = (l, d)=>{
        const k = w(JSON.parse(JSON.stringify(l))), V = [];
        for(let y = 0; y < 7; y++){
            const C = (0, _dateFns.addDays)(k, y), v = (0, _dateFns.getMonth)(C) !== d;
            V.push({
                text: e.hideOffsetDates && v ? "" : C.getDate(),
                value: C,
                current: !v,
                classData: {}
            });
        }
        return V;
    }, H = (l, d)=>{
        const k = [], V = w(b(new Date(d, l))), y = w(b(new Date(d, l + 1, 0))), C = (0, _dateFns.startOfWeek)(V, {
            weekStartsOn: e.weekStart
        }), v = (q)=>{
            const se = R(q, l);
            if (k.push({
                days: se
            }), !k[k.length - 1].days.some((ge)=>ve(He(ge.value), He(y)))) {
                const ge = (0, _dateFns.addDays)(q, 7);
                v(ge);
            }
        };
        if (v(C), e.sixWeeks && k.length < 6) {
            const q = 6 - k.length;
            for(let se = 1; se <= q; se++){
                const ge = k[k.length - 1], Ce = ge.days[ge.days.length - 1], ee = R((0, _dateFns.addDays)(Ce.value, 1), (0, _dateFns.getMonth)(V));
                k.push({
                    days: ee
                });
            }
        }
        return k;
    }, g = (l, d, k)=>[
            (0, _dateFns.set)(w(l), {
                date: 1
            }),
            (0, _dateFns.set)(w(), {
                month: d,
                year: k,
                date: 1
            })
        ], c = (l, d)=>Se(...g(e.minDate, l, d)) || ve(...g(e.minDate, l, d)), T = (l, d)=>Ie(...g(e.maxDate, l, d)) || ve(...g(e.maxDate, l, d)), A = (l, d, k)=>{
        let V = !1;
        return e.maxDate && k && T(l, d) && (V = !0), e.minDate && !k && c(l, d) && (V = !0), V;
    };
    return {
        checkPartialRangeValue: n,
        checkRangeEnabled: t,
        getZonedDate: b,
        getZonedToUtc: B,
        formatDate: p,
        getDefaultPattern: i,
        validateDate: L,
        getDefaultStartTime: _,
        isDisabled: I,
        isValidDate: Y,
        sanitizeDate: Z,
        getWeekFromDate: ae,
        matchDate: P,
        setDateMonthOrYear: M,
        isValidTime: le,
        getCalendarDays: H,
        validateMonthYearInRange: (l, d, k, V)=>{
            let y = !1;
            return V ? e.minDate && e.maxDate ? y = A(l, d, k) : (e.minDate && c(l, d) || e.maxDate && T(l, d)) && (y = !0) : y = !0, y;
        },
        validateMaxDate: T,
        validateMinDate: c,
        defaults: a,
        hideNavigationButtons: E
    };
}, fe = (0, _vue.reactive)({
    monthYear: [],
    calendar: [],
    time: [],
    actionRow: [],
    selectionGrid: [],
    timePicker: {
        0: [],
        1: []
    },
    monthPicker: []
}), jt = (0, _vue.ref)(null), _t = (0, _vue.ref)(!1), xt = (0, _vue.ref)(!1), Kt = (0, _vue.ref)(!1), Gt = (0, _vue.ref)(!1), Pe = (0, _vue.ref)(0), Me = (0, _vue.ref)(0), Xe = ()=>{
    const e = (0, _vue.computed)(()=>_t.value ? [
            ...fe.selectionGrid,
            fe.actionRow
        ].filter((P)=>P.length) : xt.value ? [
            ...fe.timePicker[0],
            ...fe.timePicker[1],
            Gt.value ? [] : [
                jt.value
            ],
            fe.actionRow
        ].filter((P)=>P.length) : Kt.value ? [
            ...fe.monthPicker,
            fe.actionRow
        ] : [
            fe.monthYear,
            ...fe.calendar,
            fe.time,
            fe.actionRow
        ].filter((P)=>P.length)), n = (P)=>{
        Pe.value = P ? Pe.value + 1 : Pe.value - 1;
        let M = null;
        e.value[Me.value] && (M = e.value[Me.value][Pe.value]), M || (Pe.value = P ? Pe.value - 1 : Pe.value + 1);
    }, a = (P)=>{
        if (Me.value === 0 && !P || Me.value === e.value.length && P) return;
        Me.value = P ? Me.value + 1 : Me.value - 1, e.value[Me.value] ? e.value[Me.value] && !e.value[Me.value][Pe.value] && Pe.value !== 0 && (Pe.value = e.value[Me.value].length - 1) : Me.value = P ? Me.value - 1 : Me.value + 1;
    }, t = (P)=>{
        let M = null;
        e.value[Me.value] && (M = e.value[Me.value][Pe.value]), M ? M.focus({
            preventScroll: !_t.value
        }) : Pe.value = P ? Pe.value - 1 : Pe.value + 1;
    }, r = ()=>{
        n(!0), t(!0);
    }, i = ()=>{
        n(!1), t(!1);
    }, p = ()=>{
        a(!1), t(!0);
    }, b = ()=>{
        a(!0), t(!0);
    }, B = (P, M)=>{
        fe[M] = P;
    }, E = (P, M)=>{
        fe[M] = P;
    }, L = ()=>{
        Pe.value = 0, Me.value = 0;
    };
    return {
        buildMatrix: B,
        buildMultiLevelMatrix: E,
        setTimePickerBackRef: (P)=>{
            jt.value = P;
        },
        setSelectionGrid: (P)=>{
            _t.value = P, L(), P || (fe.selectionGrid = []);
        },
        setTimePicker: (P, M = !1)=>{
            xt.value = P, Gt.value = M, L(), P || (fe.timePicker[0] = [], fe.timePicker[1] = []);
        },
        setTimePickerElements: (P, M = 0)=>{
            fe.timePicker[M] = P;
        },
        arrowRight: r,
        arrowLeft: i,
        arrowUp: p,
        arrowDown: b,
        clearArrowNav: ()=>{
            fe.monthYear = [], fe.calendar = [], fe.time = [], fe.actionRow = [], fe.selectionGrid = [], fe.timePicker[0] = [], fe.timePicker[1] = [], _t.value = !1, xt.value = !1, Gt.value = !1, Kt.value = !1, L(), jt.value = null;
        },
        setMonthPicker: (P)=>{
            Kt.value = P, L();
        },
        refSets: fe
    };
}, Pn = (e)=>Array.isArray(e), et = (e)=>Array.isArray(e), Nn = (e)=>Array.isArray(e) && e.length === 2, Sl = (e, n, a, t)=>{
    const { getDefaultStartTime: r, isDisabled: i, sanitizeDate: p, getWeekFromDate: b, setDateMonthOrYear: B, validateMonthYearInRange: E, defaults: L } = Be(e), s = (0, _vue.computed)({
        get: ()=>e.internalModelValue,
        set: (o)=>{
            !e.readonly && !e.disabled && n("update:internal-model-value", o);
        }
    }), _ = (0, _vue.ref)([]);
    (0, _vue.watch)(s, ()=>G());
    const I = (0, _vue.ref)([
        {
            month: (0, _dateFns.getMonth)(w()),
            year: (0, _dateFns.getYear)(w())
        }
    ]), Y = (0, _vue.reactive)({
        hours: e.range ? [
            (0, _dateFns.getHours)(w()),
            (0, _dateFns.getHours)(w())
        ] : (0, _dateFns.getHours)(w()),
        minutes: e.range ? [
            (0, _dateFns.getMinutes)(w()),
            (0, _dateFns.getMinutes)(w())
        ] : (0, _dateFns.getMinutes)(w()),
        seconds: e.range ? [
            0,
            0
        ] : 0
    }), Z = (0, _vue.computed)(()=>(o)=>I.value[o] ? I.value[o].month : 0), ae = (0, _vue.computed)(()=>(o)=>I.value[o] ? I.value[o].year : 0), P = (o, D, z)=>{
        I.value[o].month = D === null ? I.value[o].month : D, I.value[o].year = z === null ? I.value[o].year : z;
    }, M = (o, D)=>{
        Y[o] = D;
    };
    (0, _vue.onMounted)(()=>{
        s.value || (e.startDate && (P(0, (0, _dateFns.getMonth)(w(e.startDate)), (0, _dateFns.getYear)(w(e.startDate))), L.value.multiCalendars && We(0)), L.value.startTime && g()), G(!0);
    });
    const G = (o = !1)=>{
        if (s.value) return Array.isArray(s.value) ? O(o) : Q(s.value);
        if (e.timePicker) return j();
        if (e.monthPicker && !e.range) return le();
        if (e.yearPicker && !e.range) return R();
        if (L.value.multiCalendars) return J(w(), o);
    }, J = (o, D = !1)=>{
        if ((!L.value.multiCalendars || !e.multiStatic || D) && P(0, (0, _dateFns.getMonth)(o), (0, _dateFns.getYear)(o)), L.value.multiCalendars) for(let z = 1; z <= L.value.multiCalendars; z++){
            const re = (0, _dateFns.set)(w(), {
                month: Z.value(z - 1),
                year: ae.value(z - 1)
            }), f = (0, _dateFns.add)(re, {
                months: 1
            });
            I.value[z] = {
                month: (0, _dateFns.getMonth)(f),
                year: (0, _dateFns.getYear)(f)
            };
        }
    }, Q = (o)=>{
        J(o), M("hours", (0, _dateFns.getHours)(o)), M("minutes", (0, _dateFns.getMinutes)(o)), M("seconds", (0, _dateFns.getSeconds)(o));
    }, N = (o, D)=>{
        J(o[0], D);
        const z = (re)=>[
                re(o[0]),
                o[1] ? re(o[1]) : re(w())
            ];
        M("hours", z((0, _dateFns.getHours))), M("minutes", z((0, _dateFns.getMinutes))), M("seconds", z((0, _dateFns.getSeconds)));
    }, m = (o, D)=>{
        if (e.range && !e.multiDates) return N(o, D);
        if (e.multiDates) {
            const z = o[o.length - 1];
            return Q(z);
        }
    }, O = (o)=>{
        const D = s.value;
        m(D, o), L.value.multiCalendars && e.multiCalendarsSolo && T();
    }, j = ()=>{
        if (g(), !e.range) s.value = Ye(w(), Y.hours, Y.minutes, H());
        else {
            const o = Y.hours, D = Y.minutes;
            s.value = [
                Ye(w(), o[0], D[0], H()),
                Ye(w(), o[1], D[1], H(!1))
            ];
        }
    }, le = ()=>{
        s.value = B(w(), Z.value(0), ae.value(0));
    }, R = ()=>{
        s.value = w();
    }, H = (o = !0)=>e.enableSeconds ? Array.isArray(Y.seconds) ? o ? Y.seconds[0] : Y.seconds[1] : Y.seconds : 0, g = ()=>{
        const o = r();
        if (o) {
            const D = Array.isArray(o), z = D ? [
                +o[0].hours,
                +o[1].hours
            ] : +o.hours, re = D ? [
                +o[0].minutes,
                +o[1].minutes
            ] : +o.minutes, f = D ? [
                +o[0].seconds,
                +o[1].seconds
            ] : +o.seconds;
            M("hours", z), M("minutes", re), e.enableSeconds && M("seconds", f);
        }
    }, c = ()=>Array.isArray(s.value) && s.value.length ? s.value[s.value.length - 1] : null, T = ()=>{
        if (Array.isArray(s.value) && s.value.length === 2) {
            const o = w(w(s.value[1] ? s.value[1] : (0, _dateFns.addMonths)(s.value[0], 1))), [D, z] = [
                (0, _dateFns.getMonth)(s.value[0]),
                (0, _dateFns.getYear)(s.value[0])
            ], [re, f] = [
                (0, _dateFns.getMonth)(s.value[1]),
                (0, _dateFns.getYear)(s.value[1])
            ];
            (D !== re || D === re && z !== f) && e.multiCalendarsSolo && P(1, (0, _dateFns.getMonth)(o), (0, _dateFns.getYear)(o));
        }
    }, A = (o)=>{
        const D = (0, _dateFns.addMonths)(o, 1);
        return {
            month: (0, _dateFns.getMonth)(D),
            year: (0, _dateFns.getYear)(D)
        };
    }, W = (o)=>{
        const D = (0, _dateFns.getMonth)(w(o)), z = (0, _dateFns.getYear)(w(o));
        if (P(0, D, z), L.value.multiCalendars > 0) for(let re = 1; re < L.value.multiCalendars; re++){
            const f = A((0, _dateFns.set)(w(o), {
                year: Z.value(re - 1),
                month: ae.value(re - 1)
            }));
            P(re, f.month, f.year);
        }
    }, l = (o)=>{
        if (s.value && Array.isArray(s.value)) {
            if (s.value.some((D)=>ve(o, D))) {
                const D = s.value.filter((z)=>!ve(z, o));
                s.value = D.length ? D : null;
            } else (e.multiDatesLimit && +e.multiDatesLimit > s.value.length || !e.multiDatesLimit) && s.value.push(o);
        } else s.value = [
            o
        ];
    }, d = (o, D)=>{
        const z = Ie(o, D) ? D : o, re = Ie(D, o) ? D : o;
        return (0, _dateFns.eachDayOfInterval)({
            start: z,
            end: re
        });
    }, k = (o)=>{
        if (Array.isArray(s.value) && s.value[0]) {
            const D = (0, _dateFns.differenceInCalendarDays)(o, s.value[0]), z = d(s.value[0], o), re = z.length === 1 ? 0 : z.filter((x)=>i(x)).length, f = Math.abs(D) - re;
            if (e.minRange && e.maxRange) return f >= +e.minRange && f <= +e.maxRange;
            if (e.minRange) return f >= +e.minRange;
            if (e.maxRange) return f <= +e.maxRange;
        }
        return !0;
    }, V = (o)=>Array.isArray(s.value) && s.value.length === 2 ? e.fixedStart && (Ie(o, s.value[0]) || ve(o, s.value[0])) ? [
            s.value[0],
            o
        ] : e.fixedEnd && (Se(o, s.value[1]) || ve(o, s.value[1])) ? [
            o,
            s.value[1]
        ] : s.value : [], y = ()=>{
        e.autoApply && n("auto-apply");
    }, C = ()=>{
        e.autoApply && n("select-date");
    }, v = (o)=>!(0, _dateFns.eachDayOfInterval)({
            start: o[0],
            end: o[1]
        }).some((z)=>i(z)), q = (o)=>(s.value = b(w(o.value)), y()), se = (o)=>{
        const D = Ye(w(o.value), Y.hours, Y.minutes, H());
        e.multiDates ? l(D) : s.value = D, a(), y();
    }, ge = ()=>{
        _.value = s.value ? s.value.slice() : [], _.value.length === 2 && !(e.fixedStart || e.fixedEnd) && (_.value = []);
    }, Ce = (o, D)=>{
        const z = [
            w(o.value),
            (0, _dateFns.addDays)(w(o.value), +e.autoRange)
        ];
        v(z) && (D && W(o.value), _.value = z);
    }, ee = (o)=>{
        _.value = V(w(o.value));
    }, Ke = (o)=>e.noDisabledRange ? d(_.value[0], o).some((z)=>i(z)) : !1, Ge = (o, D)=>{
        if (ge(), e.autoRange) return Ce(o, D);
        if (e.fixedStart || e.fixedEnd) return ee(o);
        _.value[0] ? k(w(o.value)) && !Ke(o.value) && (Se(w(o.value), w(_.value[0])) ? _.value.unshift(w(o.value)) : _.value[1] = w(o.value)) : _.value[0] = w(o.value);
    }, te = (o)=>{
        _.value[o] = Ye(_.value[o], Y.hours[o], Y.minutes[o], H(o !== 1));
    }, De = ()=>{
        _.value.length && (_.value[0] && !_.value[1] ? te(0) : (te(0), te(1), a()), s.value = _.value.slice(), _.value[0] && _.value[1] && e.autoApply && n("auto-apply"), _.value[0] && !_.value[1] && e.modelAuto && e.autoApply && n("auto-apply"));
    }, we = (o, D = !1)=>{
        if (!(i(o.value) || !o.current && e.hideOffsetDates)) {
            if (e.weekPicker) return q(o);
            if (!e.range) return se(o);
            et(Y.hours) && et(Y.minutes) && !e.multiDates && (Ge(o, D), De());
        }
    }, Je = (o)=>{
        const D = o.find((z)=>z.current);
        return D ? (0, _dateFns.getISOWeek)(D.value) : "";
    }, We = (o)=>{
        for(let D = o - 1; D >= 0; D--){
            const z = (0, _dateFns.subMonths)((0, _dateFns.set)(w(), {
                month: Z.value(D + 1),
                year: ae.value(D + 1)
            }), 1);
            P(D, (0, _dateFns.getMonth)(z), (0, _dateFns.getYear)(z));
        }
        for(let D = o + 1; D <= L.value.multiCalendars - 1; D++){
            const z = (0, _dateFns.addMonths)((0, _dateFns.set)(w(), {
                month: Z.value(D - 1),
                year: ae.value(D - 1)
            }), 1);
            P(D, (0, _dateFns.getMonth)(z), (0, _dateFns.getYear)(z));
        }
    }, Qe = (o)=>B(w(), Z.value(o), ae.value(o)), vt = (o)=>Ye(o, Y.hours, Y.minutes, H()), Bt = (o, D)=>{
        const z = e.monthPicker ? Z.value(o) !== D.month || !D.fromNav : ae.value(o) !== D.year;
        if (P(o, D.month, D.year), L.value.multiCalendars && !e.multiCalendarsSolo && We(o), e.monthPicker || e.yearPicker) {
            if (e.range) {
                if (z) {
                    let re = s.value ? s.value.slice() : [];
                    re.length === 2 && re[1] !== null && (re = []), re.length ? Se(Qe(o), re[0]) ? re.unshift(Qe(o)) : re[1] = Qe(o) : re = [
                        Qe(o)
                    ], s.value = re;
                }
            } else s.value = Qe(o);
        }
        n("update-month-year", {
            instance: o,
            month: D.month,
            year: D.year
        }), t(e.multiCalendarsSolo ? o : void 0);
    }, Yt = async (o = !1)=>{
        if (e.autoApply && (e.monthPicker || e.yearPicker)) {
            await (0, _vue.nextTick)();
            const D = e.monthPicker ? o : !1;
            e.range ? n("auto-apply", D || !s.value || s.value.length === 1) : n("auto-apply", D);
        }
        a();
    }, Dt = (o, D)=>{
        const z = (0, _dateFns.set)(w(), {
            month: Z.value(D),
            year: ae.value(D)
        }), re = o < 0 ? (0, _dateFns.addMonths)(z, 1) : (0, _dateFns.subMonths)(z, 1);
        E((0, _dateFns.getMonth)(re), (0, _dateFns.getYear)(re), o < 0, e.preventMinMaxNavigation) && (P(D, (0, _dateFns.getMonth)(re), (0, _dateFns.getYear)(re)), L.value.multiCalendars && !e.multiCalendarsSolo && We(D), t());
    }, mt = (o)=>{
        Pn(o) && Pn(s.value) && et(Y.hours) && et(Y.minutes) ? (o[0] && s.value[0] && (s.value[0] = Ye(o[0], Y.hours[0], Y.minutes[0], H())), o[1] && s.value[1] && (s.value[1] = Ye(o[1], Y.hours[1], Y.minutes[1], H(!1)))) : e.multiDates && Array.isArray(s.value) ? s.value[s.value.length - 1] = vt(o) : !e.range && !Nn(o) && (s.value = vt(o)), n("time-update");
    }, Vt = (o, D = !0, z = !1)=>{
        const re = D ? o : Y.hours, f = !D && !z ? o : Y.minutes, x = z ? o : Y.seconds;
        if (e.range && Nn(s.value) && et(re) && et(f) && et(x) && !e.disableTimeRangeValidation) {
            const pe = (Ve)=>Ye(s.value[Ve], re[Ve], f[Ve], x[Ve]), $e = (Ve)=>(0, _dateFns.setMilliseconds)(s.value[Ve], 0);
            if (ve(s.value[0], s.value[1]) && ((0, _dateFns.isAfter)(pe(0), $e(1)) || (0, _dateFns.isBefore)(pe(1), $e(0)))) return;
        }
        if (M("hours", re), M("minutes", f), M("seconds", x), s.value) {
            if (e.multiDates) {
                const pe = c();
                pe && mt(pe);
            } else mt(s.value);
        } else e.timePicker && mt(e.range ? [
            w(),
            w()
        ] : w());
        a();
    }, Lt = (o, D)=>{
        e.monthChangeOnScroll && Dt(e.monthChangeOnScroll !== "inverse" ? -o.deltaY : o.deltaY, D);
    }, Et = (o, D, z = !1)=>{
        e.monthChangeOnArrows && e.vertical === z && $t(o, D);
    }, $t = (o, D)=>{
        Dt(o === "right" ? -1 : 1, D);
    };
    return {
        time: Y,
        month: Z,
        year: ae,
        modelValue: s,
        monthYearSelect: Yt,
        isDisabled: i,
        updateTime: Vt,
        getWeekNum: Je,
        selectDate: we,
        updateMonthYear: Bt,
        handleScroll: Lt,
        getMarker: (o)=>e.markers.find((D)=>ve(p(o.value), p(D.date))),
        handleArrow: Et,
        handleSwipe: $t,
        selectCurrentDate: ()=>{
            e.range ? s.value && Array.isArray(s.value) && s.value[0] ? s.value = Se(w(), s.value[0]) ? [
                w(),
                s.value[0]
            ] : [
                s.value[0],
                w()
            ] : s.value = [
                w()
            ] : s.value = w(), C();
        },
        presetDateRange: (o, D)=>{
            D || o.length && o.length <= 2 && e.range && (s.value = o.map((z)=>w(z)), C());
        }
    };
}, Pl = (e, n, a)=>{
    const t = (0, _vue.ref)(), { getZonedToUtc: r, getZonedDate: i, formatDate: p, getDefaultPattern: b, checkRangeEnabled: B, checkPartialRangeValue: E, isValidDate: L, setDateMonthOrYear: s, defaults: _ } = Be(n), I = (0, _vue.ref)("");
    (0, _vue.watch)(t, ()=>{
        e("internal-model-change", t.value);
    });
    const Y = (v)=>{
        const q = v || w(), se = {
            hours: (0, _dateFns.getHours)(q),
            minutes: (0, _dateFns.getMinutes)(q)
        };
        return n.enableSeconds && (se.seconds = (0, _dateFns.getSeconds)(q)), se;
    }, Z = (v)=>({
            month: (0, _dateFns.getMonth)(v),
            year: (0, _dateFns.getYear)(v)
        }), ae = (v)=>Array.isArray(v) ? B(()=>[
                (0, _dateFns.setYear)(w(), v[0]),
                v[1] ? (0, _dateFns.setYear)(w(), v[1]) : E()
            ]) : (0, _dateFns.setYear)(w(), +v), P = (v)=>Array.isArray(v) ? [
            Ye(null, +v[0].hours, +v[0].minutes, v[0].seconds),
            Ye(null, +v[1].hours, +v[1].minutes, v[1].seconds)
        ] : Ye(null, v.hours, v.minutes, v == null ? void 0 : v.seconds), M = (v)=>Array.isArray(v) ? B(()=>[
                s(null, +v[0].month, +v[0].year),
                v[1] ? s(null, +v[1].month, +v[1].year) : E()
            ]) : s(null, +v.month, +v.year), G = (v)=>{
        if (Array.isArray(v)) return v.map((q)=>W(q));
        throw new Error(Rt.dateArr("multi-dates"));
    }, J = (v)=>{
        if (Array.isArray(v)) return [
            w(v[0]),
            w(v[1])
        ];
        throw new Error(Rt.dateArr("week-picker"));
    }, Q = (v)=>n.modelAuto ? Array.isArray(v) ? [
            W(v[0]),
            W(v[1])
        ] : n.autoApply ? [
            W(v)
        ] : [
            W(v),
            null
        ] : Array.isArray(v) ? B(()=>[
                W(v[0]),
                v[1] ? W(v[1]) : E()
            ]) : W(v), N = ()=>{
        Array.isArray(t.value) && n.range && t.value.length === 1 && t.value.push(E());
    }, m = ()=>{
        const v = t.value;
        return [
            l(v[0]),
            v[1] ? l(v[1]) : E()
        ];
    }, O = ()=>t.value[1] ? m() : l(be(t.value[0])), j = ()=>t.value.map((v)=>l(v)), le = ()=>(N(), n.modelAuto ? O() : n.multiDates ? j() : Array.isArray(t.value) ? B(()=>m()) : l(be(t.value))), R = (v)=>v ? n.timePicker ? P(be(v)) : n.monthPicker ? M(be(v)) : n.yearPicker ? ae(be(v)) : n.multiDates ? G(be(v)) : n.weekPicker ? J(be(v)) : Q(be(v)) : null, H = (v)=>{
        const q = R(v);
        L(be(q)) ? (t.value = be(q), A()) : (t.value = null, I.value = "");
    }, g = ()=>{
        var q;
        const v = (se)=>{
            var ge;
            return (0, _dateFns.format)(se, (ge = _.value.textInputOptions) == null ? void 0 : ge.format);
        };
        return `${v(t.value[0])} ${(q = _.value.textInputOptions) == null ? void 0 : q.rangeSeparator} ${t.value[1] ? v(t.value[1]) : ""}`;
    }, c = ()=>{
        var v;
        return a.value && t.value ? Array.isArray(t.value) ? g() : (0, _dateFns.format)(t.value, (v = _.value.textInputOptions) == null ? void 0 : v.format) : p(t.value);
    }, T = ()=>{
        var v;
        return t.value ? n.multiDates ? t.value.map((q)=>p(q)).join("; ") : n.textInput && typeof ((v = _.value.textInputOptions) == null ? void 0 : v.format) == "string" ? c() : p(t.value) : "";
    }, A = ()=>{
        !n.format || typeof n.format == "string" ? I.value = T() : I.value = n.format(t.value);
    }, W = (v)=>{
        if (n.utc) {
            const q = new Date(v);
            return n.utc === "preserve" ? new Date(q.getTime() + q.getTimezoneOffset() * 6e4) : q;
        }
        return n.modelType ? n.modelType === "date" || n.modelType === "timestamp" ? i(new Date(v)) : n.modelType === "format" && (typeof n.format == "string" || !n.format) ? (0, _dateFns.parse)(v, b(), new Date()) : i((0, _dateFns.parse)(v, n.modelType, new Date())) : i(new Date(v));
    }, l = (v)=>n.utc ? Za(v, n.utc === "preserve") : n.modelType ? n.modelType === "timestamp" ? +r(v) : n.modelType === "format" && (typeof n.format == "string" || !n.format) ? p(r(v)) : p(r(v), n.modelType) : r(v), d = (v)=>{
        e("update:model-value", v);
    }, k = (v)=>Array.isArray(t.value) ? [
            v(t.value[0]),
            t.value[1] ? v(t.value[1]) : E()
        ] : v(be(t.value)), V = (v)=>d(be(k(v)));
    return {
        inputValue: I,
        internalModelValue: t,
        checkBeforeEmit: ()=>t.value ? n.range ? n.partialRange ? t.value.length >= 1 : t.value.length === 2 : !!t.value : !1,
        parseExternalModelValue: H,
        formatInputValue: A,
        emitModelValue: ()=>(A(), n.monthPicker ? V(Z) : n.timePicker ? V(Y) : n.yearPicker ? V((0, _dateFns.getYear)) : n.weekPicker ? d(t.value) : d(le()))
    };
}, Nl = (e, n)=>{
    const { validateMonthYearInRange: a, validateMaxDate: t, validateMinDate: r, defaults: i } = Be(e), p = (s, _)=>{
        let I = s;
        return i.value.filters.months.includes((0, _dateFns.getMonth)(I)) ? (I = _ ? (0, _dateFns.addMonths)(s, 1) : (0, _dateFns.subMonths)(s, 1), p(I, _)) : I;
    }, b = (s, _)=>{
        let I = s;
        return i.value.filters.years.includes((0, _dateFns.getYear)(I)) ? (I = _ ? (0, _dateFns.addYears)(s, 1) : (0, _dateFns.subYears)(s, 1), b(I, _)) : I;
    }, B = (s)=>{
        const _ = (0, _dateFns.set)(new Date(), {
            month: e.month,
            year: e.year
        });
        let I = s ? (0, _dateFns.addMonths)(_, 1) : (0, _dateFns.subMonths)(_, 1), Y = (0, _dateFns.getMonth)(I), Z = (0, _dateFns.getYear)(I);
        i.value.filters.months.includes(Y) && (I = p(I, s), Y = (0, _dateFns.getMonth)(I), Z = (0, _dateFns.getYear)(I)), i.value.filters.years.includes(Z) && (I = b(I, s), Z = (0, _dateFns.getYear)(I)), a(Y, Z, s, e.preventMinMaxNavigation) && E(Y, Z);
    }, E = (s, _)=>{
        n("update-month-year", {
            month: s,
            year: _
        });
    }, L = (0, _vue.computed)(()=>(s)=>{
            if (!e.preventMinMaxNavigation || s && !e.maxDate || !s && !e.minDate) return !1;
            const _ = (0, _dateFns.set)(new Date(), {
                month: e.month,
                year: e.year
            }), I = s ? (0, _dateFns.addMonths)(_, 1) : (0, _dateFns.subMonths)(_, 1), Y = [
                (0, _dateFns.getMonth)(I),
                (0, _dateFns.getYear)(I)
            ];
            return s ? !t(...Y) : !r(...Y);
        });
    return {
        handleMonthYearChange: B,
        isDisabled: L,
        updateMonthYear: E
    };
};
var Nt = /* @__PURE__ */ ((e)=>(e.center = "center", e.left = "left", e.right = "right", e))(Nt || {});
const Rl = (e, n, a, t)=>{
    const r = (0, _vue.ref)({
        top: "0",
        left: "0",
        transform: "none"
    }), i = (0, _vue.ref)(!1), p = (0, _vue.toRef)(t, "teleportCenter");
    (0, _vue.watch)(p, ()=>{
        ae();
    });
    const b = (N)=>{
        const m = N.getBoundingClientRect();
        return {
            left: m.left + window.scrollX,
            top: m.top + window.scrollY
        };
    }, B = (N)=>{
        const m = N.getBoundingClientRect();
        let O = 0, j = 0;
        for(; N && !isNaN(N.offsetLeft) && !isNaN(N.offsetTop);)O += N.offsetLeft - N.scrollLeft, j = m.top + N.scrollTop, N = N.offsetParent;
        return {
            top: j,
            left: O
        };
    }, E = (N, m)=>{
        r.value.left = `${N + m}px`, r.value.transform = "translateX(-100%)";
    }, L = (N)=>{
        r.value.left = `${N}px`, r.value.transform = "translateX(0)";
    }, s = (N, m, O = !1)=>{
        t.position === Nt.left && L(N), t.position === Nt.right && E(N, m), t.position === Nt.center && (r.value.left = `${N + m / 2}px`, r.value.transform = O ? "translate(-50%, -50%)" : "translateX(-50%)");
    }, _ = (N)=>{
        const { width: m, height: O } = N.getBoundingClientRect(), { top: j, left: le } = t.altPosition ? B(N) : b(N);
        return {
            top: j,
            left: le,
            width: m,
            height: O
        };
    }, I = ()=>{
        const N = Te(n);
        if (N) {
            const { top: m, left: O, width: j, height: le } = _(N);
            r.value.top = `${m + le / 2}px`, r.value.transform = "translateY(-50%)", s(O, j, !0);
        }
    }, Y = ()=>{
        r.value.left = "50%", r.value.top = "50%", r.value.transform = "translate(-50%, -50%)", r.value.position = "fixed";
    }, Z = ()=>{
        const N = Te(n);
        r.value = t.altPosition(N);
    }, ae = (N = !0)=>{
        if (!t.inline) return p.value ? Y() : t.altPosition && typeof t.altPosition != "boolean" ? Z() : (N && a("recalculate-position"), Q());
    }, P = (N, m)=>{
        const { top: O, left: j, height: le, width: R } = _(N);
        r.value.top = `${le + O + +t.offset}px`, s(j, R), G(N, m), i.value = !1;
    }, M = (N, m)=>{
        const { top: O, left: j, width: le } = _(N), { height: R } = m.getBoundingClientRect();
        r.value.top = `${O - R - +t.offset}px`, s(j, le), G(N, m), i.value = !0;
    }, G = (N, m)=>{
        if (t.autoPosition) {
            const { left: O, width: j } = _(N), { left: le, right: R } = m.getBoundingClientRect();
            if (le < 0) return L(O);
            if (R > document.documentElement.clientWidth) return E(O, j);
        }
    }, J = (N, m)=>{
        const { height: O } = m.getBoundingClientRect(), { top: j, height: le } = N.getBoundingClientRect(), H = window.innerHeight - j - le, g = j;
        return O <= H ? P(N, m) : O > H && O <= g ? M(N, m) : H >= g ? P(N, m) : M(N, m);
    }, Q = ()=>{
        const N = Te(n), m = Te(e);
        if (N && m) return t.autoPosition ? J(N, m) : P(N, m);
    };
    return {
        openOnTop: i,
        menuPosition: r,
        setMenuPosition: ae,
        setInitialPosition: I
    };
}, it = [
    {
        name: "clock-icon",
        use: [
            "time",
            "calendar"
        ]
    },
    {
        name: "arrow-left",
        use: [
            "month-year",
            "calendar"
        ]
    },
    {
        name: "arrow-right",
        use: [
            "month-year",
            "calendar"
        ]
    },
    {
        name: "arrow-up",
        use: [
            "time",
            "calendar"
        ]
    },
    {
        name: "arrow-down",
        use: [
            "time",
            "calendar"
        ]
    },
    {
        name: "calendar-icon",
        use: [
            "month-year",
            "time",
            "calendar"
        ]
    },
    {
        name: "day",
        use: [
            "calendar"
        ]
    },
    {
        name: "month-overlay-value",
        use: [
            "calendar",
            "month-year"
        ]
    },
    {
        name: "year-overlay-value",
        use: [
            "calendar",
            "month-year"
        ]
    },
    {
        name: "hours-overlay-value",
        use: [
            "calendar",
            "time"
        ]
    },
    {
        name: "minutes-overlay-value",
        use: [
            "calendar",
            "time"
        ]
    },
    {
        name: "seconds-overlay-value",
        use: [
            "calendar",
            "time"
        ]
    },
    {
        name: "hours",
        use: [
            "calendar",
            "time"
        ]
    },
    {
        name: "minutes",
        use: [
            "calendar",
            "time"
        ]
    },
    {
        name: "month",
        use: [
            "calendar",
            "month-year"
        ]
    },
    {
        name: "year",
        use: [
            "calendar",
            "month-year"
        ]
    },
    {
        name: "action-select",
        use: [
            "action"
        ]
    },
    {
        name: "action-preview",
        use: [
            "action"
        ]
    },
    {
        name: "calendar-header",
        use: [
            "calendar"
        ]
    },
    {
        name: "marker-tooltip",
        use: [
            "calendar"
        ]
    },
    {
        name: "now-button",
        use: []
    },
    {
        name: "time-picker-overlay",
        use: [
            "calendar",
            "time"
        ]
    },
    {
        name: "am-pm-button",
        use: [
            "calendar",
            "time"
        ]
    },
    {
        name: "left-sidebar",
        use: [
            "menu"
        ]
    },
    {
        name: "right-sidebar",
        use: [
            "menu"
        ]
    },
    {
        name: "month-year",
        use: [
            "month-year"
        ]
    },
    {
        name: "time-picker",
        use: [
            "menu"
        ]
    },
    {
        name: "action-row",
        use: [
            "menu"
        ]
    }
], Il = [
    {
        name: "trigger"
    },
    {
        name: "input-icon"
    },
    {
        name: "clear-icon"
    },
    {
        name: "dp-input"
    }
], Ol = {
    all: ()=>it,
    monthYear: ()=>it.filter((e)=>e.use.includes("month-year")),
    input: ()=>Il,
    timePicker: ()=>it.filter((e)=>e.use.includes("time")),
    action: ()=>it.filter((e)=>e.use.includes("action")),
    calendar: ()=>it.filter((e)=>e.use.includes("calendar")),
    menu: ()=>it.filter((e)=>e.use.includes("menu"))
}, lt = (e, n, a)=>{
    const t = [];
    return Ol[n]().forEach((r)=>{
        e[r.name] && t.push(r.name);
    }), a && a.length && a.forEach((r)=>{
        r.slot && t.push(r.slot);
    }), t;
}, Ot = (e)=>({
        transitionName: (0, _vue.computed)(()=>(a)=>e && typeof e != "boolean" ? a ? e.open : e.close : ""),
        showTransition: !!e
    }), qe = {
    multiCalendars: {
        type: [
            Boolean,
            Number,
            String
        ],
        default: null
    },
    modelValue: {
        type: [
            String,
            Date,
            Array,
            Object,
            Number
        ],
        default: null
    },
    modelType: {
        type: String,
        default: null
    },
    position: {
        type: String,
        default: "center"
    },
    dark: {
        type: Boolean,
        default: !1
    },
    format: {
        type: [
            String,
            Function
        ],
        default: ()=>null
    },
    closeOnScroll: {
        type: Boolean,
        default: !1
    },
    autoPosition: {
        type: Boolean,
        default: !0
    },
    closeOnAutoApply: {
        type: Boolean,
        default: !0
    },
    teleport: {
        type: [
            String,
            Object
        ],
        default: "body"
    },
    altPosition: {
        type: [
            Boolean,
            Function
        ],
        default: !1
    },
    transitions: {
        type: [
            Boolean,
            Object
        ],
        default: !0
    },
    formatLocale: {
        type: Object,
        default: null
    },
    utc: {
        type: [
            Boolean,
            String
        ],
        default: !1
    },
    ariaLabels: {
        type: Object,
        default: ()=>({})
    },
    offset: {
        type: [
            Number,
            String
        ],
        default: 10
    },
    hideNavigation: {
        type: Array,
        default: ()=>[]
    },
    timezone: {
        type: String,
        default: null
    },
    vertical: {
        type: Boolean,
        default: !1
    },
    disableMonthYearSelect: {
        type: Boolean,
        default: !1
    },
    menuClassName: {
        type: String,
        default: null
    },
    dayClass: {
        type: Function,
        default: null
    },
    yearRange: {
        type: Array,
        default: ()=>[
                1900,
                2100
            ]
    },
    multiCalendarsSolo: {
        type: Boolean,
        default: !1
    },
    calendarCellClassName: {
        type: String,
        default: null
    },
    enableTimePicker: {
        type: Boolean,
        default: !0
    },
    autoApply: {
        type: Boolean,
        default: !1
    },
    disabledDates: {
        type: [
            Array,
            Function
        ],
        default: ()=>[]
    },
    monthNameFormat: {
        type: String,
        default: "short"
    },
    startDate: {
        type: [
            Date,
            String
        ],
        default: null
    },
    startTime: {
        type: [
            Object,
            Array
        ],
        default: null
    },
    monthYearComponent: {
        type: Object,
        default: null
    },
    timePickerComponent: {
        type: Object,
        default: null
    },
    actionRowComponent: {
        type: Object,
        default: null
    },
    hideOffsetDates: {
        type: Boolean,
        default: !1
    },
    autoRange: {
        type: [
            Number,
            String
        ],
        default: null
    },
    noToday: {
        type: Boolean,
        default: !1
    },
    disabledWeekDays: {
        type: Array,
        default: ()=>[]
    },
    allowedDates: {
        type: Array,
        default: ()=>[]
    },
    showNowButton: {
        type: Boolean,
        default: !1
    },
    nowButtonLabel: {
        type: String,
        default: "Now"
    },
    markers: {
        type: Array,
        default: ()=>[]
    },
    modeHeight: {
        type: [
            Number,
            String
        ],
        default: 255
    },
    escClose: {
        type: Boolean,
        default: !0
    },
    spaceConfirm: {
        type: Boolean,
        default: !0
    },
    monthChangeOnArrows: {
        type: Boolean,
        default: !0
    },
    presetRanges: {
        type: Array,
        default: ()=>[]
    },
    flow: {
        type: Array,
        default: ()=>[]
    },
    preventMinMaxNavigation: {
        type: Boolean,
        default: !1
    },
    minRange: {
        type: [
            Number,
            String
        ],
        default: null
    },
    maxRange: {
        type: [
            Number,
            String
        ],
        default: null
    },
    multiDatesLimit: {
        type: [
            Number,
            String
        ],
        default: null
    },
    reverseYears: {
        type: Boolean,
        default: !1
    },
    keepActionRow: {
        type: Boolean,
        default: !1
    },
    weekPicker: {
        type: Boolean,
        default: !1
    },
    filters: {
        type: Object,
        default: ()=>({})
    },
    arrowNavigation: {
        type: Boolean,
        default: !1
    },
    multiStatic: {
        type: Boolean,
        default: !0
    },
    disableTimeRangeValidation: {
        type: Boolean,
        default: !1
    },
    highlight: {
        type: [
            Array,
            Function
        ],
        default: null
    },
    highlightWeekDays: {
        type: Array,
        default: null
    },
    highlightDisabledDays: {
        type: Boolean,
        default: !1
    },
    teleportCenter: {
        type: Boolean,
        default: !1
    },
    locale: {
        type: String,
        default: "en-Us"
    },
    weekNumName: {
        type: String,
        default: "W"
    },
    weekStart: {
        type: [
            Number,
            String
        ],
        default: 1
    },
    weekNumbers: {
        type: Boolean,
        default: !1
    },
    calendarClassName: {
        type: String,
        default: null
    },
    noSwipe: {
        type: Boolean,
        default: !1
    },
    monthChangeOnScroll: {
        type: [
            Boolean,
            String
        ],
        default: !0
    },
    dayNames: {
        type: [
            Function,
            Array
        ],
        default: null
    },
    monthPicker: {
        type: Boolean,
        default: !1
    },
    customProps: {
        type: Object,
        default: null
    },
    yearPicker: {
        type: Boolean,
        default: !1
    },
    modelAuto: {
        type: Boolean,
        default: !1
    },
    selectText: {
        type: String,
        default: "Select"
    },
    cancelText: {
        type: String,
        default: "Cancel"
    },
    previewFormat: {
        type: [
            String,
            Function
        ],
        default: ()=>""
    },
    multiDates: {
        type: Boolean,
        default: !1
    },
    partialRange: {
        type: Boolean,
        default: !0
    },
    ignoreTimeValidation: {
        type: Boolean,
        default: !1
    },
    minDate: {
        type: [
            Date,
            String
        ],
        default: null
    },
    maxDate: {
        type: [
            Date,
            String
        ],
        default: null
    },
    minTime: {
        type: Object,
        default: null
    },
    maxTime: {
        type: Object,
        default: null
    },
    name: {
        type: String,
        default: null
    },
    placeholder: {
        type: String,
        default: ""
    },
    hideInputIcon: {
        type: Boolean,
        default: !1
    },
    clearable: {
        type: Boolean,
        default: !0
    },
    state: {
        type: Boolean,
        default: null
    },
    required: {
        type: Boolean,
        default: !1
    },
    autocomplete: {
        type: String,
        default: "off"
    },
    inputClassName: {
        type: String,
        default: null
    },
    inlineWithInput: {
        type: Boolean,
        default: !1
    },
    textInputOptions: {
        type: Object,
        default: ()=>null
    },
    fixedStart: {
        type: Boolean,
        default: !1
    },
    fixedEnd: {
        type: Boolean,
        default: !1
    },
    timePicker: {
        type: Boolean,
        default: !1
    },
    enableSeconds: {
        type: Boolean,
        default: !1
    },
    is24: {
        type: Boolean,
        default: !0
    },
    noHoursOverlay: {
        type: Boolean,
        default: !1
    },
    noMinutesOverlay: {
        type: Boolean,
        default: !1
    },
    noSecondsOverlay: {
        type: Boolean,
        default: !1
    },
    hoursGridIncrement: {
        type: [
            String,
            Number
        ],
        default: 1
    },
    minutesGridIncrement: {
        type: [
            String,
            Number
        ],
        default: 5
    },
    secondsGridIncrement: {
        type: [
            String,
            Number
        ],
        default: 5
    },
    hoursIncrement: {
        type: [
            Number,
            String
        ],
        default: 1
    },
    minutesIncrement: {
        type: [
            Number,
            String
        ],
        default: 1
    },
    secondsIncrement: {
        type: [
            Number,
            String
        ],
        default: 1
    },
    range: {
        type: Boolean,
        default: !1
    },
    uid: {
        type: String,
        default: null
    },
    disabled: {
        type: Boolean,
        default: !1
    },
    readonly: {
        type: Boolean,
        default: !1
    },
    inline: {
        type: Boolean,
        default: !1
    },
    textInput: {
        type: Boolean,
        default: !1
    },
    onClickOutside: {
        type: Function,
        default: null
    },
    noDisabledRange: {
        type: Boolean,
        default: !1
    },
    sixWeeks: {
        type: Boolean,
        default: !1
    }
}, Bl = [
    "aria-label",
    "aria-disabled",
    "aria-readonly"
], Yl = {
    key: 1,
    class: "dp__input_wrap"
}, Vl = [
    "id",
    "name",
    "inputmode",
    "placeholder",
    "disabled",
    "readonly",
    "required",
    "value",
    "autocomplete",
    "onKeydown"
], Ll = {
    key: 2,
    class: "dp__input_icon"
}, El = {
    key: 4,
    class: "dp__clear_icon"
}, Fl = /* @__PURE__ */ (0, _vue.defineComponent)({
    __name: "DatepickerInput",
    props: {
        isMenuOpen: {
            type: Boolean,
            default: !1
        },
        inputValue: {
            type: String,
            default: ""
        },
        ...qe
    },
    emits: [
        "clear",
        "open",
        "update:input-value",
        "set-input-date",
        "close",
        "select-date",
        "set-empty-date",
        "toggle",
        "focus-prev",
        "focus",
        "blur"
    ],
    setup (e, { expose: n, emit: a }) {
        const t = e, { getDefaultPattern: r, isValidDate: i, defaults: p } = Be(t), b = (0, _vue.ref)(), B = (0, _vue.ref)(null), E = (0, _vue.ref)(!1), L = (0, _vue.computed)(()=>({
                dp__pointer: !t.disabled && !t.readonly && !t.textInput,
                dp__disabled: t.disabled,
                dp__input_readonly: !t.textInput,
                dp__input: !0,
                dp__input_icon_pad: !t.hideInputIcon,
                dp__input_valid: t.state,
                dp__input_invalid: t.state === !1,
                dp__input_focus: E.value || t.isMenuOpen,
                dp__input_reg: !t.textInput,
                [t.inputClassName]: !!t.inputClassName
            })), s = ()=>{
            a("set-input-date", null), t.autoApply && (a("set-empty-date"), b.value = null);
        }, _ = (m)=>{
            var O;
            return Ga(m, ((O = p.value.textInputOptions) == null ? void 0 : O.format) || r());
        }, I = (m)=>{
            const { rangeSeparator: O } = p.value.textInputOptions;
            if (t.range) {
                const [j, le] = m.split(`${O}`);
                if (j && le) {
                    const R = _(j.trim()), H = _(le.trim());
                    b.value = R && H ? [
                        R,
                        H
                    ] : null;
                }
            } else b.value = _(m);
        }, Y = (m)=>{
            var j;
            const { value: O } = m.target;
            O !== "" ? (((j = p.value.textInputOptions) == null ? void 0 : j.openMenu) && !t.isMenuOpen && a("open"), I(O), a("set-input-date", b.value)) : s(), a("update:input-value", O);
        }, Z = ()=>{
            var m, O;
            ((m = p.value.textInputOptions) == null ? void 0 : m.enterSubmit) && i(b.value) && t.inputValue !== "" ? (a("set-input-date", b.value, !0), b.value = null) : ((O = p.value.textInputOptions) == null ? void 0 : O.enterSubmit) && t.inputValue === "" && (b.value = null, a("clear"));
        }, ae = ()=>{
            var m, O;
            ((m = p.value.textInputOptions) == null ? void 0 : m.tabSubmit) && i(b.value) && t.inputValue !== "" ? (a("set-input-date", b.value, !0), b.value = null) : ((O = p.value.textInputOptions) == null ? void 0 : O.tabSubmit) && t.inputValue === "" && (b.value = null, a("clear"));
        }, P = ()=>{
            E.value = !0, a("focus");
        }, M = (m)=>{
            var O;
            m.preventDefault(), m.stopImmediatePropagation(), m.stopPropagation(), t.textInput && ((O = p.value.textInputOptions) == null ? void 0 : O.openMenu) && !t.inlineWithInput ? t.isMenuOpen ? p.value.textInputOptions.enterSubmit && a("select-date") : a("open") : t.textInput || a("toggle");
        }, G = ()=>{
            E.value = !1, t.isMenuOpen || a("blur"), t.autoApply && t.textInput && b.value && (a("set-input-date", b.value), a("select-date"), b.value = null);
        }, J = ()=>{
            a("clear");
        }, Q = (m)=>{
            t.textInput || m.preventDefault();
        };
        return n({
            focusInput: ()=>{
                B.value && B.value.focus({
                    preventScroll: !0
                });
            }
        }), (m, O)=>{
            var j;
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                onClick: M,
                "aria-label": (j = (0, _vue.unref)(p).ariaLabels) == null ? void 0 : j.input,
                role: "textbox",
                "aria-multiline": "false",
                "aria-disabled": m.disabled,
                "aria-readonly": m.readonly
            }, [
                m.$slots.trigger && !m.$slots["dp-input"] && !m.inline ? (0, _vue.renderSlot)(m.$slots, "trigger", {
                    key: 0
                }) : (0, _vue.createCommentVNode)("", !0),
                !m.$slots.trigger && (!m.inline || m.inlineWithInput) ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", Yl, [
                    m.$slots["dp-input"] && !m.$slots.trigger && !m.inline ? (0, _vue.renderSlot)(m.$slots, "dp-input", {
                        key: 0,
                        value: e.inputValue,
                        onInput: Y,
                        onEnter: Z,
                        onTab: ae,
                        onClear: J
                    }) : (0, _vue.createCommentVNode)("", !0),
                    m.$slots["dp-input"] ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("input", {
                        key: 1,
                        ref_key: "inputRef",
                        ref: B,
                        id: m.uid ? `dp-input-${m.uid}` : void 0,
                        name: m.name,
                        class: (0, _vue.normalizeClass)((0, _vue.unref)(L)),
                        inputmode: m.textInput ? "text" : "none",
                        placeholder: m.placeholder,
                        disabled: m.disabled,
                        readonly: m.readonly,
                        required: m.required,
                        value: e.inputValue,
                        autocomplete: m.autocomplete,
                        onInput: Y,
                        onKeydown: [
                            (0, _vue.withKeys)(M, [
                                "enter"
                            ]),
                            (0, _vue.withKeys)(ae, [
                                "tab"
                            ])
                        ],
                        onBlur: G,
                        onFocus: P,
                        onKeypress: Q
                    }, null, 42, Vl)),
                    m.$slots["input-icon"] && !m.hideInputIcon ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("span", Ll, [
                        (0, _vue.renderSlot)(m.$slots, "input-icon")
                    ])) : (0, _vue.createCommentVNode)("", !0),
                    !m.$slots["input-icon"] && !m.hideInputIcon && !m.$slots["dp-input"] ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)(It), {
                        key: 3,
                        class: "dp__input_icon dp__input_icons"
                    })) : (0, _vue.createCommentVNode)("", !0),
                    m.$slots["clear-icon"] && e.inputValue && m.clearable && !m.disabled && !m.readonly ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("span", El, [
                        (0, _vue.renderSlot)(m.$slots, "clear-icon", {
                            clear: J
                        })
                    ])) : (0, _vue.createCommentVNode)("", !0),
                    m.clearable && !m.$slots["clear-icon"] && e.inputValue && !m.disabled && !m.readonly ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)(ba), {
                        key: 5,
                        class: "dp__clear_icon dp__input_icons",
                        "data-test": "clear-icon",
                        onClick: (0, _vue.withModifiers)(J, [
                            "stop",
                            "prevent"
                        ])
                    }, null, 8, [
                        "onClick"
                    ])) : (0, _vue.createCommentVNode)("", !0)
                ])) : (0, _vue.createCommentVNode)("", !0)
            ], 8, Bl);
        };
    }
}), Ul = {
    class: "dp__selection_preview"
}, Hl = {
    class: "dp__action_buttons"
}, Wl = [
    "onKeydown"
], zl = /* @__PURE__ */ (0, _vue.defineComponent)({
    __name: "ActionRow",
    props: {
        calendarWidth: {
            type: Number,
            default: 0
        },
        menuMount: {
            type: Boolean,
            default: !1
        },
        internalModelValue: {
            type: [
                Date,
                Array
            ],
            default: null
        },
        ...qe
    },
    emits: [
        "close-picker",
        "select-date",
        "invalid-select"
    ],
    setup (e, { emit: n }) {
        const a = e, { formatDate: t, isValidTime: r, defaults: i } = Be(a), { buildMatrix: p } = Xe(), b = (0, _vue.ref)(null), B = (0, _vue.ref)(null);
        (0, _vue.onMounted)(()=>{
            a.arrowNavigation && p([
                Te(b),
                Te(B)
            ], "actionRow");
        });
        const E = (0, _vue.computed)(()=>a.range && !a.partialRange && a.internalModelValue ? a.internalModelValue.length === 2 : !0), L = (0, _vue.computed)(()=>({
                dp__action: !0,
                dp__select: !0,
                dp__action_disabled: !s.value || !_.value || !E.value
            })), s = (0, _vue.computed)(()=>!a.enableTimePicker || a.ignoreTimeValidation ? !0 : r(a.internalModelValue)), _ = (0, _vue.computed)(()=>a.monthPicker ? ae(a.internalModelValue) : !0), I = ()=>{
            const M = i.value.previewFormat;
            return a.timePicker || a.monthPicker, M(be(a.internalModelValue));
        }, Y = ()=>{
            const M = a.internalModelValue;
            return i.value.multiCalendars > 0 ? `${t(M[0])} - ${t(M[1])}` : [
                t(M[0]),
                t(M[1])
            ];
        }, Z = (0, _vue.computed)(()=>!a.internalModelValue || !a.menuMount ? "" : typeof i.value.previewFormat == "string" ? Array.isArray(a.internalModelValue) ? a.internalModelValue.length === 2 && a.internalModelValue[1] ? Y() : a.multiDates ? a.internalModelValue.map((M)=>`${t(M)}`) : a.modelAuto ? `${t(a.internalModelValue[0])}` : `${t(a.internalModelValue[0])} -` : t(a.internalModelValue) : I()), ae = (M)=>{
            if (!a.monthPicker) return !0;
            let G = !0;
            return a.minDate && a.maxDate ? Ie(w(M), w(a.minDate)) && Se(w(M), w(a.maxDate)) : (a.minDate && (G = Ie(w(M), w(a.minDate))), a.maxDate && (G = Se(w(M), w(a.maxDate))), G);
        }, P = ()=>{
            s.value && _.value && E.value ? n("select-date") : n("invalid-select");
        };
        return (M, G)=>((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: "dp__action_row",
                style: (0, _vue.normalizeStyle)(e.calendarWidth ? {
                    width: `${e.calendarWidth}px`
                } : {})
            }, [
                (0, _vue.createElementVNode)("div", Ul, [
                    M.$slots["action-preview"] ? (0, _vue.renderSlot)(M.$slots, "action-preview", {
                        key: 0,
                        value: e.internalModelValue
                    }) : (0, _vue.createCommentVNode)("", !0),
                    M.$slots["action-preview"] ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                        key: 1
                    }, [
                        Array.isArray((0, _vue.unref)(Z)) ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                            key: 0
                        }, [
                            (0, _vue.createTextVNode)((0, _vue.toDisplayString)((0, _vue.unref)(Z)), 1)
                        ], 64)),
                        Array.isArray((0, _vue.unref)(Z)) ? ((0, _vue.openBlock)(!0), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                            key: 1
                        }, (0, _vue.renderList)((0, _vue.unref)(Z), (J, Q)=>((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                key: Q
                            }, (0, _vue.toDisplayString)(J), 1))), 128)) : (0, _vue.createCommentVNode)("", !0)
                    ], 64))
                ]),
                (0, _vue.createElementVNode)("div", Hl, [
                    M.$slots["action-select"] ? (0, _vue.renderSlot)(M.$slots, "action-select", {
                        key: 0,
                        value: e.internalModelValue
                    }) : (0, _vue.createCommentVNode)("", !0),
                    M.$slots["action-select"] ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                        key: 1
                    }, [
                        M.inline ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("span", {
                            key: 0,
                            class: "dp__action dp__cancel",
                            ref_key: "cancelButtonRef",
                            ref: b,
                            tabindex: "0",
                            onClick: G[0] || (G[0] = (J)=>M.$emit("close-picker")),
                            onKeydown: [
                                G[1] || (G[1] = (0, _vue.withKeys)((J)=>M.$emit("close-picker"), [
                                    "enter"
                                ])),
                                G[2] || (G[2] = (0, _vue.withKeys)((J)=>M.$emit("close-picker"), [
                                    "space"
                                ]))
                            ]
                        }, (0, _vue.toDisplayString)(M.cancelText), 545)),
                        (0, _vue.createElementVNode)("span", {
                            class: (0, _vue.normalizeClass)((0, _vue.unref)(L)),
                            tabindex: "0",
                            onKeydown: [
                                (0, _vue.withKeys)(P, [
                                    "enter"
                                ]),
                                (0, _vue.withKeys)(P, [
                                    "space"
                                ])
                            ],
                            onClick: P,
                            "data-test": "select-button",
                            ref_key: "selectButtonRef",
                            ref: B
                        }, (0, _vue.toDisplayString)(M.selectText), 43, Wl)
                    ], 64))
                ])
            ], 4));
    }
}), jl = [
    "aria-label"
], xl = {
    class: "dp__calendar_header",
    role: "row"
}, Kl = {
    key: 0,
    class: "dp__calendar_header_item",
    role: "gridcell"
}, Gl = /* @__PURE__ */ (0, _vue.createElementVNode)("div", {
    class: "dp__calendar_header_separator"
}, null, -1), Zl = [
    "aria-label"
], Xl = {
    key: 0,
    role: "gridcell",
    class: "dp__calendar_item dp__week_num"
}, ql = {
    class: "dp__cell_inner"
}, Jl = [
    "aria-selected",
    "aria-disabled",
    "aria-label",
    "data-test",
    "onClick",
    "onKeydown",
    "onMouseover"
], Ql = /* @__PURE__ */ (0, _vue.createElementVNode)("div", {
    class: "dp__arrow_bottom_tp"
}, null, -1), er = /* @__PURE__ */ (0, _vue.defineComponent)({
    __name: "Calendar",
    props: {
        mappedDates: {
            type: Array,
            default: ()=>[]
        },
        getWeekNum: {
            type: Function,
            default: ()=>""
        },
        specificMode: {
            type: Boolean,
            default: !1
        },
        instance: {
            type: Number,
            default: 0
        },
        month: {
            type: Number,
            default: 0
        },
        year: {
            type: Number,
            default: 0
        },
        ...qe
    },
    emits: [
        "select-date",
        "set-hover-date",
        "handle-scroll",
        "mount",
        "handle-swipe",
        "handle-space"
    ],
    setup (e, { expose: n, emit: a }) {
        const t = e, { buildMultiLevelMatrix: r } = Xe(), { setDateMonthOrYear: i, defaults: p } = Be(t), b = (0, _vue.ref)(null), B = (0, _vue.ref)({
            bottom: "",
            left: "",
            transform: ""
        }), E = (0, _vue.ref)([]), L = (0, _vue.ref)(null), s = (0, _vue.ref)(!0), _ = (0, _vue.ref)(""), I = (0, _vue.ref)({
            startX: 0,
            endX: 0,
            startY: 0,
            endY: 0
        }), Y = (0, _vue.computed)(()=>t.dayNames ? Array.isArray(t.dayNames) ? t.dayNames : t.dayNames(t.locale, +t.weekStart) : pl(t.locale, +t.weekStart));
        (0, _vue.onMounted)(()=>{
            a("mount", {
                cmp: "calendar",
                refs: E
            }), t.noSwipe || L.value && (L.value.addEventListener("touchstart", O, {
                passive: !1
            }), L.value.addEventListener("touchend", j, {
                passive: !1
            }), L.value.addEventListener("touchmove", le, {
                passive: !1
            })), t.monthChangeOnScroll && L.value && L.value.addEventListener("wheel", g, {
                passive: !1
            });
        });
        const Z = (c)=>c ? t.vertical ? "vNext" : "next" : t.vertical ? "vPrevious" : "previous", ae = (c, T)=>{
            if (t.transitions) {
                const A = He(i(w(), t.month, t.year));
                _.value = Ie(He(i(w(), c, T)), A) ? p.value.transitions[Z(!0)] : p.value.transitions[Z(!1)], s.value = !1, (0, _vue.nextTick)(()=>{
                    s.value = !0;
                });
            }
        }, P = (0, _vue.computed)(()=>({
                dp__calendar_wrap: !0,
                [t.calendarClassName]: !!t.calendarClassName
            })), M = (0, _vue.computed)(()=>(c)=>{
                const T = Dl(c);
                return {
                    dp__marker_dot: T.type === "dot",
                    dp__marker_line: T.type === "line"
                };
            }), G = (0, _vue.computed)(()=>(c)=>ve(c, b.value)), J = (0, _vue.computed)(()=>({
                dp__calendar: !0,
                dp__calendar_next: p.value.multiCalendars > 0 && t.instance !== 0
            })), Q = (0, _vue.computed)(()=>t.specificMode ? {
                height: `${t.modeHeight}px`
            } : void 0), N = (c, T, A)=>{
            var W, l;
            if (a("set-hover-date", c), (l = (W = c.marker) == null ? void 0 : W.tooltip) != null && l.length) {
                const d = Te(E.value[T][A]);
                if (d) {
                    const { width: k, height: V } = d.getBoundingClientRect();
                    B.value = {
                        bottom: `${V}px`,
                        left: `${k / 2}px`,
                        transform: "translateX(-50%)"
                    }, b.value = c.value;
                }
            }
        }, m = ()=>{
            b.value = null;
        }, O = (c)=>{
            I.value.startX = c.changedTouches[0].screenX, I.value.startY = c.changedTouches[0].screenY;
        }, j = (c)=>{
            I.value.endX = c.changedTouches[0].screenX, I.value.endY = c.changedTouches[0].screenY, R();
        }, le = (c)=>{
            t.vertical && !t.inline && c.preventDefault();
        }, R = ()=>{
            const c = t.vertical ? "Y" : "X";
            Math.abs(I.value[`start${c}`] - I.value[`end${c}`]) > 10 && a("handle-swipe", I.value[`start${c}`] > I.value[`end${c}`] ? "right" : "left");
        }, H = (c, T, A)=>{
            c && (Array.isArray(E.value[T]) ? E.value[T][A] = c : E.value[T] = [
                c
            ]), t.arrowNavigation && r(E.value, "calendar");
        }, g = (c)=>{
            t.monthChangeOnScroll && (c.preventDefault(), a("handle-scroll", c));
        };
        return n({
            triggerTransition: ae
        }), (c, T)=>{
            var A;
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: (0, _vue.normalizeClass)((0, _vue.unref)(J))
            }, [
                (0, _vue.createElementVNode)("div", {
                    style: (0, _vue.normalizeStyle)((0, _vue.unref)(Q))
                }, [
                    e.specificMode ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                        key: 0,
                        ref_key: "calendarWrapRef",
                        ref: L,
                        class: (0, _vue.normalizeClass)((0, _vue.unref)(P)),
                        role: "grid",
                        "aria-label": (A = (0, _vue.unref)(p).ariaLabels) == null ? void 0 : A.calendarWrap
                    }, [
                        (0, _vue.createElementVNode)("div", xl, [
                            c.weekNumbers ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", Kl, (0, _vue.toDisplayString)(c.weekNumName), 1)) : (0, _vue.createCommentVNode)("", !0),
                            ((0, _vue.openBlock)(!0), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)((0, _vue.unref)(Y), (W, l)=>((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                    class: "dp__calendar_header_item",
                                    role: "gridcell",
                                    key: l,
                                    "data-test": "calendar-header"
                                }, [
                                    c.$slots["calendar-header"] ? (0, _vue.renderSlot)(c.$slots, "calendar-header", {
                                        key: 0,
                                        day: W,
                                        index: l
                                    }) : (0, _vue.createCommentVNode)("", !0),
                                    c.$slots["calendar-header"] ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                                        key: 1
                                    }, [
                                        (0, _vue.createTextVNode)((0, _vue.toDisplayString)(W), 1)
                                    ], 64))
                                ]))), 128))
                        ]),
                        Gl,
                        (0, _vue.createVNode)((0, _vue.Transition), {
                            name: _.value,
                            css: !!c.transitions
                        }, {
                            default: (0, _vue.withCtx)(()=>{
                                var W;
                                return [
                                    s.value ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                        key: 0,
                                        class: "dp__calendar",
                                        role: "grid",
                                        "aria-label": (W = (0, _vue.unref)(p).ariaLabels) == null ? void 0 : W.calendarDays
                                    }, [
                                        ((0, _vue.openBlock)(!0), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)(e.mappedDates, (l, d)=>((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                                class: "dp__calendar_row",
                                                role: "row",
                                                key: d
                                            }, [
                                                c.weekNumbers ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", Xl, [
                                                    (0, _vue.createElementVNode)("div", ql, (0, _vue.toDisplayString)(e.getWeekNum(l.days)), 1)
                                                ])) : (0, _vue.createCommentVNode)("", !0),
                                                ((0, _vue.openBlock)(!0), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)(l.days, (k, V)=>{
                                                    var y, C, v;
                                                    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                                        role: "gridcell",
                                                        class: "dp__calendar_item",
                                                        ref_for: !0,
                                                        ref: (q)=>H(q, d, V),
                                                        key: V + d,
                                                        "aria-selected": k.classData.dp__active_date || k.classData.dp__range_start || k.classData.dp__range_start,
                                                        "aria-disabled": k.classData.dp__cell_disabled,
                                                        "aria-label": (C = (y = (0, _vue.unref)(p).ariaLabels) == null ? void 0 : y.day) == null ? void 0 : C.call(y, k),
                                                        tabindex: "0",
                                                        "data-test": k.value,
                                                        onClick: (0, _vue.withModifiers)((q)=>c.$emit("select-date", k), [
                                                            "stop",
                                                            "prevent"
                                                        ]),
                                                        onKeydown: [
                                                            (0, _vue.withKeys)((q)=>c.$emit("select-date", k), [
                                                                "enter"
                                                            ]),
                                                            (0, _vue.withKeys)((q)=>c.$emit("handle-space", k), [
                                                                "space"
                                                            ])
                                                        ],
                                                        onMouseover: (q)=>N(k, d, V),
                                                        onMouseleave: m
                                                    }, [
                                                        (0, _vue.createElementVNode)("div", {
                                                            class: (0, _vue.normalizeClass)([
                                                                "dp__cell_inner",
                                                                k.classData
                                                            ])
                                                        }, [
                                                            c.$slots.day ? (0, _vue.renderSlot)(c.$slots, "day", {
                                                                key: 0,
                                                                day: +k.text,
                                                                date: k.value
                                                            }) : (0, _vue.createCommentVNode)("", !0),
                                                            c.$slots.day ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                                                                key: 1
                                                            }, [
                                                                (0, _vue.createTextVNode)((0, _vue.toDisplayString)(k.text), 1)
                                                            ], 64)),
                                                            k.marker ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                                                key: 2,
                                                                class: (0, _vue.normalizeClass)((0, _vue.unref)(M)(k.marker)),
                                                                style: (0, _vue.normalizeStyle)(k.marker.color ? {
                                                                    backgroundColor: k.marker.color
                                                                } : {})
                                                            }, null, 6)) : (0, _vue.createCommentVNode)("", !0),
                                                            (0, _vue.unref)(G)(k.value) ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                                                key: 3,
                                                                class: "dp__marker_tooltip",
                                                                style: (0, _vue.normalizeStyle)(B.value)
                                                            }, [
                                                                (v = k.marker) != null && v.tooltip ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                                                    key: 0,
                                                                    class: "dp__tooltip_content",
                                                                    onClick: T[0] || (T[0] = (0, _vue.withModifiers)(()=>{}, [
                                                                        "stop"
                                                                    ]))
                                                                }, [
                                                                    ((0, _vue.openBlock)(!0), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)(k.marker.tooltip, (q, se)=>((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                                                            key: se,
                                                                            class: "dp__tooltip_text"
                                                                        }, [
                                                                            c.$slots["marker-tooltip"] ? (0, _vue.renderSlot)(c.$slots, "marker-tooltip", {
                                                                                key: 0,
                                                                                tooltop: q,
                                                                                day: k.value
                                                                            }) : (0, _vue.createCommentVNode)("", !0),
                                                                            c.$slots["marker-tooltip"] ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                                                                                key: 1
                                                                            }, [
                                                                                (0, _vue.createElementVNode)("div", {
                                                                                    class: "dp__tooltip_mark",
                                                                                    style: (0, _vue.normalizeStyle)(q.color ? {
                                                                                        backgroundColor: q.color
                                                                                    } : {})
                                                                                }, null, 4),
                                                                                (0, _vue.createElementVNode)("div", null, (0, _vue.toDisplayString)(q.text), 1)
                                                                            ], 64))
                                                                        ]))), 128)),
                                                                    Ql
                                                                ])) : (0, _vue.createCommentVNode)("", !0)
                                                            ], 4)) : (0, _vue.createCommentVNode)("", !0)
                                                        ], 2)
                                                    ], 40, Jl);
                                                }), 128))
                                            ]))), 128))
                                    ], 8, Zl)) : (0, _vue.createCommentVNode)("", !0)
                                ];
                            }),
                            _: 3
                        }, 8, [
                            "name",
                            "css"
                        ])
                    ], 10, jl))
                ], 4)
            ], 2);
        };
    }
}), tr = [
    "aria-label",
    "aria-disabled"
], Zt = /* @__PURE__ */ (0, _vue.defineComponent)({
    __name: "ActionIcon",
    props: {
        ariaLabel: {
            type: String,
            default: ""
        },
        disabled: {
            type: Boolean,
            default: !1
        }
    },
    emits: [
        "activate",
        "set-ref"
    ],
    setup (e, { emit: n }) {
        const a = (0, _vue.ref)(null);
        return (0, _vue.onMounted)(()=>n("set-ref", a)), (t, r)=>((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: "dp__month_year_col_nav",
                onClick: r[0] || (r[0] = (i)=>t.$emit("activate")),
                onKeydown: [
                    r[1] || (r[1] = (0, _vue.withKeys)((i)=>t.$emit("activate"), [
                        "enter"
                    ])),
                    r[2] || (r[2] = (0, _vue.withKeys)((i)=>t.$emit("activate"), [
                        "space"
                    ]))
                ],
                tabindex: "0",
                role: "button",
                "aria-label": e.ariaLabel,
                "aria-disabled": e.disabled,
                ref_key: "elRef",
                ref: a
            }, [
                (0, _vue.createElementVNode)("div", {
                    class: (0, _vue.normalizeClass)([
                        "dp__inner_nav",
                        {
                            dp__inner_nav_disabled: e.disabled
                        }
                    ])
                }, [
                    (0, _vue.renderSlot)(t.$slots, "default")
                ], 2)
            ], 40, tr));
    }
}), nr = [
    "onKeydown"
], ar = {
    class: "dp__selection_grid_header"
}, lr = [
    "aria-selected",
    "aria-disabled",
    "data-test",
    "onClick",
    "onKeydown",
    "onMouseover"
], rr = [
    "aria-label",
    "onKeydown"
], pt = /* @__PURE__ */ (0, _vue.defineComponent)({
    __name: "SelectionGrid",
    props: {
        items: {
            type: Array,
            default: ()=>[]
        },
        modelValue: {
            type: [
                String,
                Number
            ],
            default: null
        },
        multiModelValue: {
            type: Array,
            default: ()=>[]
        },
        disabledValues: {
            type: Array,
            default: ()=>[]
        },
        minValue: {
            type: [
                Number,
                String
            ],
            default: null
        },
        maxValue: {
            type: [
                Number,
                String
            ],
            default: null
        },
        year: {
            type: Number,
            default: 0
        },
        skipActive: {
            type: Boolean,
            default: !1
        },
        headerRefs: {
            type: Array,
            default: ()=>[]
        },
        skipButtonRef: {
            type: Boolean,
            default: !1
        },
        monthPicker: {
            type: Boolean,
            default: !1
        },
        yearPicker: {
            type: Boolean,
            default: !1
        },
        escClose: {
            type: Boolean,
            default: !0
        },
        type: {
            type: String,
            default: null
        },
        arrowNavigation: {
            type: Boolean,
            default: !1
        },
        autoApply: {
            type: Boolean,
            default: !1
        },
        textInput: {
            type: Boolean,
            default: !1
        },
        ariaLabels: {
            type: Object,
            default: ()=>({})
        },
        hideNavigation: {
            type: Array,
            default: ()=>[]
        }
    },
    emits: [
        "update:model-value",
        "selected",
        "toggle",
        "reset-flow"
    ],
    setup (e, { expose: n, emit: a }) {
        const t = e, { setSelectionGrid: r, buildMultiLevelMatrix: i, setMonthPicker: p } = Xe(), { hideNavigationButtons: b } = Be(t), B = (0, _vue.ref)(!1), E = (0, _vue.ref)(null), L = (0, _vue.ref)(null), s = (0, _vue.ref)([]), _ = (0, _vue.ref)(), I = (0, _vue.ref)();
        (0, _vue.onBeforeUpdate)(()=>{
            E.value = null;
        }), (0, _vue.onMounted)(()=>{
            (0, _vue.nextTick)().then(()=>m()), Z(), Y(!0);
        }), (0, _vue.onUnmounted)(()=>Y(!1));
        const Y = (c)=>{
            var T;
            t.arrowNavigation && ((T = t.headerRefs) != null && T.length ? p(c) : r(c));
        }, Z = ()=>{
            const c = Te(L);
            c && (t.textInput || c.focus({
                preventScroll: !0
            }), B.value = c.clientHeight < c.scrollHeight);
        }, ae = (0, _vue.computed)(()=>({
                dp__overlay: !0
            })), P = (0, _vue.computed)(()=>({
                dp__overlay_col: !0
            })), M = (c)=>t.skipActive ? !1 : c.value === t.modelValue, G = (0, _vue.computed)(()=>t.items.map((c)=>c.filter((T)=>T).map((T)=>{
                    var l, d, k;
                    const A = t.disabledValues.some((V)=>V === T.value) || N(T.value), W = (l = t.multiModelValue) != null && l.length ? (d = t.multiModelValue) == null ? void 0 : d.some((V)=>ve(V, (0, _dateFns.setYear)(t.monthPicker ? (0, _dateFns.setMonth)(new Date(), T.value) : new Date(), t.monthPicker ? t.year : T.value))) : M(T);
                    return {
                        ...T,
                        className: {
                            dp__overlay_cell_active: W,
                            dp__overlay_cell: !W,
                            dp__overlay_cell_disabled: A,
                            dp__overlay_cell_active_disabled: A && W,
                            dp__overlay_cell_pad: !0,
                            dp__cell_in_between: (k = t.multiModelValue) != null && k.length ? j(T.value) : !1
                        }
                    };
                }))), J = (0, _vue.computed)(()=>({
                dp__button: !0,
                dp__overlay_action: !0,
                dp__over_action_scroll: B.value,
                dp__button_bottom: t.autoApply
            })), Q = (0, _vue.computed)(()=>{
            var c, T;
            return {
                dp__overlay_container: !0,
                dp__container_flex: ((c = t.items) == null ? void 0 : c.length) <= 6,
                dp__container_block: ((T = t.items) == null ? void 0 : T.length) > 6
            };
        }), N = (c)=>{
            const T = t.maxValue || t.maxValue === 0, A = t.minValue || t.minValue === 0;
            return !T && !A ? !1 : T && A ? +c > +t.maxValue || +c < +t.minValue : T ? +c > +t.maxValue : A ? +c < +t.minValue : !1;
        }, m = ()=>{
            const c = Te(E);
            if (c) {
                const T = Te(L);
                T && (T.scrollTop = c.offsetTop - T.offsetTop - (T.getBoundingClientRect().height / 2 - c.getBoundingClientRect().height));
            }
        }, O = (c)=>{
            !t.disabledValues.some((T)=>T === c) && !N(c) && (a("update:model-value", c), a("selected"));
        }, j = (c)=>{
            const T = t.monthPicker ? t.year : c;
            return Un(t.multiModelValue, (0, _dateFns.setYear)(t.monthPicker ? (0, _dateFns.setMonth)(new Date(), _.value || 0) : new Date(), t.monthPicker ? T : _.value || T), (0, _dateFns.setYear)(t.monthPicker ? (0, _dateFns.setMonth)(new Date(), c) : new Date(), T));
        }, le = ()=>{
            a("toggle"), a("reset-flow");
        }, R = ()=>{
            t.escClose && le();
        }, H = (c, T, A, W)=>{
            c && (T.value === +t.modelValue && !t.disabledValues.includes(T.value) && (E.value = c), t.arrowNavigation && (Array.isArray(s.value[A]) ? s.value[A][W] = c : s.value[A] = [
                c
            ], g()));
        }, g = ()=>{
            var T, A;
            const c = (T = t.headerRefs) != null && T.length ? [
                t.headerRefs
            ].concat(s.value) : s.value.concat([
                t.skipButtonRef ? [] : [
                    I.value
                ]
            ]);
            i(be(c), (A = t.headerRefs) != null && A.length ? "monthPicker" : "selectionGrid");
        };
        return n({
            focusGrid: Z
        }), (c, T)=>{
            var A;
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                ref_key: "gridWrapRef",
                ref: L,
                class: (0, _vue.normalizeClass)((0, _vue.unref)(ae)),
                role: "dialog",
                tabindex: "0",
                onKeydown: (0, _vue.withKeys)(R, [
                    "esc"
                ])
            }, [
                (0, _vue.createElementVNode)("div", {
                    class: (0, _vue.normalizeClass)((0, _vue.unref)(Q)),
                    role: "grid"
                }, [
                    (0, _vue.createElementVNode)("div", ar, [
                        (0, _vue.renderSlot)(c.$slots, "header")
                    ]),
                    ((0, _vue.openBlock)(!0), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)((0, _vue.unref)(G), (W, l)=>((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                            class: "dp__overlay_row",
                            key: l,
                            role: "row"
                        }, [
                            ((0, _vue.openBlock)(!0), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)(W, (d, k)=>((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                    role: "gridcell",
                                    class: (0, _vue.normalizeClass)((0, _vue.unref)(P)),
                                    key: d.value,
                                    "aria-selected": d.value === e.modelValue && !e.disabledValues.includes(d.value),
                                    "aria-disabled": d.className.dp__overlay_cell_disabled,
                                    ref_for: !0,
                                    ref: (V)=>H(V, d, l, k),
                                    tabindex: "0",
                                    "data-test": d.text,
                                    onClick: (V)=>O(d.value),
                                    onKeydown: [
                                        (0, _vue.withKeys)((V)=>O(d.value), [
                                            "enter"
                                        ]),
                                        (0, _vue.withKeys)((V)=>O(d.value), [
                                            "space"
                                        ])
                                    ],
                                    onMouseover: (V)=>_.value = d.value
                                }, [
                                    (0, _vue.createElementVNode)("div", {
                                        class: (0, _vue.normalizeClass)(d.className)
                                    }, [
                                        c.$slots.item ? (0, _vue.renderSlot)(c.$slots, "item", {
                                            key: 0,
                                            item: d
                                        }) : (0, _vue.createCommentVNode)("", !0),
                                        c.$slots.item ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                                            key: 1
                                        }, [
                                            (0, _vue.createTextVNode)((0, _vue.toDisplayString)(d.text), 1)
                                        ], 64))
                                    ], 2)
                                ], 42, lr))), 128))
                        ]))), 128)),
                    c.$slots["button-icon"] ? (0, _vue.withDirectives)(((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                        key: 0,
                        role: "button",
                        "aria-label": (A = e.ariaLabels) == null ? void 0 : A.toggleOverlay,
                        class: (0, _vue.normalizeClass)((0, _vue.unref)(J)),
                        tabindex: "0",
                        ref_key: "toggleButton",
                        ref: I,
                        onClick: le,
                        onKeydown: (0, _vue.withKeys)(le, [
                            "enter"
                        ])
                    }, [
                        (0, _vue.renderSlot)(c.$slots, "button-icon")
                    ], 42, rr)), [
                        [
                            (0, _vue.vShow),
                            !(0, _vue.unref)(b)(e.type)
                        ]
                    ]) : (0, _vue.createCommentVNode)("", !0)
                ], 2)
            ], 42, nr);
        };
    }
}), or = [
    "aria-label"
], Rn = /* @__PURE__ */ (0, _vue.defineComponent)({
    __name: "RegularPicker",
    props: {
        ariaLabel: {
            type: String,
            default: ""
        },
        showSelectionGrid: {
            type: Boolean,
            default: !1
        },
        modelValue: {
            type: Number,
            default: null
        },
        items: {
            type: Array,
            default: ()=>[]
        },
        disabledValues: {
            type: Array,
            default: ()=>[]
        },
        minValue: {
            type: Number,
            default: null
        },
        maxValue: {
            type: Number,
            default: null
        },
        slotName: {
            type: String,
            default: ""
        },
        headerRefs: {
            type: Array,
            default: ()=>[]
        },
        escClose: {
            type: Boolean,
            default: !0
        },
        type: {
            type: String,
            default: null
        },
        transitions: {
            type: [
                Object,
                Boolean
            ],
            default: !1
        },
        arrowNavigation: {
            type: Boolean,
            default: !1
        },
        autoApply: {
            type: Boolean,
            default: !1
        },
        textInput: {
            type: Boolean,
            default: !1
        },
        ariaLabels: {
            type: Object,
            default: ()=>({})
        },
        hideNavigation: {
            type: Array,
            default: ()=>[]
        }
    },
    emits: [
        "update:model-value",
        "toggle",
        "set-ref"
    ],
    setup (e, { emit: n }) {
        const a = e, { transitionName: t, showTransition: r } = Ot(a.transitions), i = (0, _vue.ref)(null);
        return (0, _vue.onMounted)(()=>n("set-ref", i)), (p, b)=>((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), null, [
                (0, _vue.createElementVNode)("div", {
                    class: "dp__month_year_select",
                    onClick: b[0] || (b[0] = (B)=>p.$emit("toggle")),
                    onKeydown: [
                        b[1] || (b[1] = (0, _vue.withKeys)((B)=>p.$emit("toggle"), [
                            "enter"
                        ])),
                        b[2] || (b[2] = (0, _vue.withKeys)((B)=>p.$emit("toggle"), [
                            "space"
                        ]))
                    ],
                    role: "button",
                    "aria-label": e.ariaLabel,
                    tabindex: "0",
                    ref_key: "elRef",
                    ref: i
                }, [
                    (0, _vue.renderSlot)(p.$slots, "default")
                ], 40, or),
                (0, _vue.createVNode)((0, _vue.Transition), {
                    name: (0, _vue.unref)(t)(e.showSelectionGrid),
                    css: (0, _vue.unref)(r)
                }, {
                    default: (0, _vue.withCtx)(()=>[
                            e.showSelectionGrid ? ((0, _vue.openBlock)(), (0, _vue.createBlock)(pt, (0, _vue.mergeProps)({
                                key: 0
                            }, {
                                modelValue: e.modelValue,
                                items: e.items,
                                disabledValues: e.disabledValues,
                                minValue: e.minValue,
                                maxValue: e.maxValue,
                                escClose: e.escClose,
                                type: e.type,
                                arrowNavigation: e.arrowNavigation,
                                textInput: e.textInput,
                                autoApply: e.autoApply,
                                ariaLabels: e.ariaLabels,
                                hideNavigation: e.hideNavigation
                            }, {
                                "header-refs": [],
                                "onUpdate:modelValue": b[3] || (b[3] = (B)=>p.$emit("update:model-value", B)),
                                onToggle: b[4] || (b[4] = (B)=>p.$emit("toggle"))
                            }), (0, _vue.createSlots)({
                                "button-icon": (0, _vue.withCtx)(()=>[
                                        p.$slots["calendar-icon"] ? (0, _vue.renderSlot)(p.$slots, "calendar-icon", {
                                            key: 0
                                        }) : (0, _vue.createCommentVNode)("", !0),
                                        p.$slots["calendar-icon"] ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)(It), {
                                            key: 1
                                        }))
                                    ]),
                                _: 2
                            }, [
                                p.$slots[e.slotName] ? {
                                    name: "item",
                                    fn: (0, _vue.withCtx)(({ item: B })=>[
                                            (0, _vue.renderSlot)(p.$slots, e.slotName, {
                                                item: B
                                            })
                                        ]),
                                    key: "0"
                                } : void 0
                            ]), 1040)) : (0, _vue.createCommentVNode)("", !0)
                        ]),
                    _: 3
                }, 8, [
                    "name",
                    "css"
                ])
            ], 64));
    }
}), sr = {
    class: "dp__month_year_row"
}, ir = {
    class: "dp__month_year_wrap"
}, ur = {
    class: "dp__month_picker_header"
}, cr = [
    "aria-label"
], dr = [
    "aria-label"
], fr = [
    "aria-label"
], vr = /* @__PURE__ */ (0, _vue.defineComponent)({
    __name: "MonthYearPicker",
    props: {
        month: {
            type: Number,
            default: 0
        },
        year: {
            type: Number,
            default: 0
        },
        instance: {
            type: Number,
            default: 0
        },
        years: {
            type: Array,
            default: ()=>[]
        },
        months: {
            type: Array,
            default: ()=>[]
        },
        internalModelValue: {
            type: [
                Date,
                Array
            ],
            default: null
        },
        ...qe
    },
    emits: [
        "update-month-year",
        "month-year-select",
        "mount",
        "reset-flow",
        "overlay-closed"
    ],
    setup (e, { expose: n, emit: a }) {
        const t = e, { defaults: r } = Be(t), { transitionName: i, showTransition: p } = Ot(r.value.transitions), { buildMatrix: b } = Xe(), { handleMonthYearChange: B, isDisabled: E, updateMonthYear: L } = Nl(t, a), s = (0, _vue.ref)(!1), _ = (0, _vue.ref)(!1), I = (0, _vue.ref)([
            null,
            null,
            null,
            null
        ]), Y = (0, _vue.ref)(null), Z = (0, _vue.ref)(null), ae = (0, _vue.ref)(null);
        (0, _vue.onMounted)(()=>{
            a("mount");
        });
        const P = (y)=>({
                get: ()=>t[y],
                set: (C)=>{
                    const v = y === "month" ? "year" : "month";
                    a("update-month-year", {
                        [y]: C,
                        [v]: t[v]
                    }), a("month-year-select", y === "year"), y === "month" ? W(!0) : l(!0);
                }
            }), M = (0, _vue.computed)(P("month")), G = (0, _vue.computed)(P("year")), J = (0, _vue.computed)(()=>(y)=>{
                const C = y === "month";
                return {
                    showSelectionGrid: (C ? s : _).value,
                    items: (C ? g : c).value,
                    disabledValues: r.value.filters[C ? "months" : "years"],
                    minValue: (C ? m : Q).value,
                    maxValue: (C ? O : N).value,
                    headerRefs: C && t.monthPicker ? [
                        Y.value,
                        Z.value,
                        ae.value
                    ] : [],
                    escClose: t.escClose,
                    transitions: r.value.transitions,
                    ariaLabels: r.value.ariaLabels,
                    textInput: t.textInput,
                    autoApply: t.autoApply,
                    arrowNavigation: t.arrowNavigation,
                    hideNavigation: t.hideNavigation
                };
            }), Q = (0, _vue.computed)(()=>t.minDate ? (0, _dateFns.getYear)(w(t.minDate)) : null), N = (0, _vue.computed)(()=>t.maxDate ? (0, _dateFns.getYear)(w(t.maxDate)) : null), m = (0, _vue.computed)(()=>{
            if (t.minDate && Q.value) {
                if (Q.value > t.year) return 12;
                if (Q.value === t.year) return (0, _dateFns.getMonth)(w(t.minDate));
            }
            return null;
        }), O = (0, _vue.computed)(()=>t.maxDate && N.value ? N.value < t.year ? -1 : N.value === t.year ? (0, _dateFns.getMonth)(w(t.maxDate)) : null : null), j = (0, _vue.computed)(()=>t.range && t.internalModelValue && (t.monthPicker || t.yearPicker) ? t.internalModelValue : []), le = (y)=>y.reverse(), R = (y, C = !1)=>{
            const v = [], q = (se)=>C ? le(se) : se;
            for(let se = 0; se < y.length; se += 3){
                const ge = [
                    y[se],
                    y[se + 1],
                    y[se + 2]
                ];
                v.push(q(ge));
            }
            return C ? v.reverse() : v;
        }, H = (0, _vue.computed)(()=>{
            const y = t.months.find((C)=>C.value === t.month);
            return y || {
                text: "",
                value: 0
            };
        }), g = (0, _vue.computed)(()=>R(t.months)), c = (0, _vue.computed)(()=>R(t.years, t.reverseYears)), T = (0, _vue.computed)(()=>r.value.multiCalendars ? t.multiCalendarsSolo ? !0 : t.instance === 0 : !0), A = (0, _vue.computed)(()=>r.value.multiCalendars ? t.multiCalendarsSolo ? !0 : t.instance === r.value.multiCalendars - 1 : !0), W = (y = !1)=>{
            d(y), s.value = !s.value, s.value || a("overlay-closed");
        }, l = (y = !1)=>{
            d(y), _.value = !_.value, _.value || a("overlay-closed");
        }, d = (y)=>{
            y || a("reset-flow");
        }, k = (y = !1)=>{
            a("update-month-year", {
                year: y ? t.year + 1 : t.year - 1,
                month: t.month,
                fromNav: !0
            });
        }, V = (y, C)=>{
            t.arrowNavigation && (I.value[C] = Te(y), b(I.value, "monthYear"));
        };
        return n({
            toggleMonthPicker: W,
            toggleYearPicker: l
        }), (y, C)=>{
            var v, q, se, ge, Ce;
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", sr, [
                y.$slots["month-year"] ? (0, _vue.renderSlot)(y.$slots, "month-year", (0, _vue.normalizeProps)((0, _vue.mergeProps)({
                    key: 0
                }, {
                    month: e.month,
                    year: e.year,
                    months: e.months,
                    years: e.years,
                    updateMonthYear: (0, _vue.unref)(L),
                    handleMonthYearChange: (0, _vue.unref)(B),
                    instance: e.instance
                }))) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                    key: 1
                }, [
                    !y.monthPicker && !y.yearPicker ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                        key: 0
                    }, [
                        (0, _vue.unref)(T) && !y.vertical ? ((0, _vue.openBlock)(), (0, _vue.createBlock)(Zt, {
                            key: 0,
                            "aria-label": (v = (0, _vue.unref)(r).ariaLabels) == null ? void 0 : v.prevMonth,
                            disabled: (0, _vue.unref)(E)(!1),
                            onActivate: C[0] || (C[0] = (ee)=>(0, _vue.unref)(B)(!1)),
                            onSetRef: C[1] || (C[1] = (ee)=>V(ee, 0))
                        }, {
                            default: (0, _vue.withCtx)(()=>[
                                    y.$slots["arrow-left"] ? (0, _vue.renderSlot)(y.$slots, "arrow-left", {
                                        key: 0
                                    }) : (0, _vue.createCommentVNode)("", !0),
                                    y.$slots["arrow-left"] ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)(pn), {
                                        key: 1
                                    }))
                                ]),
                            _: 3
                        }, 8, [
                            "aria-label",
                            "disabled"
                        ])) : (0, _vue.createCommentVNode)("", !0),
                        (0, _vue.createElementVNode)("div", ir, [
                            (0, _vue.createVNode)(Rn, (0, _vue.mergeProps)({
                                type: "month",
                                "slot-name": "month-overlay",
                                "aria-label": (q = (0, _vue.unref)(r).ariaLabels) == null ? void 0 : q.openMonthsOverlay,
                                modelValue: (0, _vue.unref)(M),
                                "onUpdate:modelValue": C[2] || (C[2] = (ee)=>(0, _vue.isRef)(M) ? M.value = ee : null)
                            }, (0, _vue.unref)(J)("month"), {
                                onToggle: W,
                                onSetRef: C[3] || (C[3] = (ee)=>V(ee, 1))
                            }), (0, _vue.createSlots)({
                                default: (0, _vue.withCtx)(()=>[
                                        y.$slots.month ? (0, _vue.renderSlot)(y.$slots, "month", (0, _vue.normalizeProps)((0, _vue.mergeProps)({
                                            key: 0
                                        }, (0, _vue.unref)(H)))) : (0, _vue.createCommentVNode)("", !0),
                                        y.$slots.month ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                                            key: 1
                                        }, [
                                            (0, _vue.createTextVNode)((0, _vue.toDisplayString)((0, _vue.unref)(H).text), 1)
                                        ], 64))
                                    ]),
                                _: 2
                            }, [
                                y.$slots["calendar-icon"] ? {
                                    name: "calendar-icon",
                                    fn: (0, _vue.withCtx)(()=>[
                                            (0, _vue.renderSlot)(y.$slots, "calendar-icon")
                                        ]),
                                    key: "0"
                                } : void 0,
                                y.$slots["month-overlay-value"] ? {
                                    name: "month-overlay",
                                    fn: (0, _vue.withCtx)(({ item: ee })=>[
                                            (0, _vue.renderSlot)(y.$slots, "month-overlay-value", {
                                                text: ee.text,
                                                value: ee.value
                                            })
                                        ]),
                                    key: "1"
                                } : void 0
                            ]), 1040, [
                                "aria-label",
                                "modelValue"
                            ]),
                            (0, _vue.createVNode)(Rn, (0, _vue.mergeProps)({
                                type: "year",
                                "slot-name": "year-overlay",
                                "aria-label": (se = (0, _vue.unref)(r).ariaLabels) == null ? void 0 : se.openYearsOverlay,
                                modelValue: (0, _vue.unref)(G),
                                "onUpdate:modelValue": C[4] || (C[4] = (ee)=>(0, _vue.isRef)(G) ? G.value = ee : null)
                            }, (0, _vue.unref)(J)("year"), {
                                onToggle: l,
                                onSetRef: C[5] || (C[5] = (ee)=>V(ee, 2))
                            }), (0, _vue.createSlots)({
                                default: (0, _vue.withCtx)(()=>[
                                        y.$slots.year ? (0, _vue.renderSlot)(y.$slots, "year", {
                                            key: 0,
                                            year: e.year
                                        }) : (0, _vue.createCommentVNode)("", !0),
                                        y.$slots.year ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                                            key: 1
                                        }, [
                                            (0, _vue.createTextVNode)((0, _vue.toDisplayString)(e.year), 1)
                                        ], 64))
                                    ]),
                                _: 2
                            }, [
                                y.$slots["calendar-icon"] ? {
                                    name: "calendar-icon",
                                    fn: (0, _vue.withCtx)(()=>[
                                            (0, _vue.renderSlot)(y.$slots, "calendar-icon")
                                        ]),
                                    key: "0"
                                } : void 0,
                                y.$slots["year-overlay-value"] ? {
                                    name: "year-overlay",
                                    fn: (0, _vue.withCtx)(({ item: ee })=>[
                                            (0, _vue.renderSlot)(y.$slots, "year-overlay-value", {
                                                text: ee.text,
                                                value: ee.value
                                            })
                                        ]),
                                    key: "1"
                                } : void 0
                            ]), 1040, [
                                "aria-label",
                                "modelValue"
                            ])
                        ]),
                        (0, _vue.unref)(T) && y.vertical ? ((0, _vue.openBlock)(), (0, _vue.createBlock)(Zt, {
                            key: 1,
                            "aria-label": (ge = (0, _vue.unref)(r).ariaLabels) == null ? void 0 : ge.prevMonth,
                            disabled: (0, _vue.unref)(E)(!1),
                            onActivate: C[6] || (C[6] = (ee)=>(0, _vue.unref)(B)(!1))
                        }, {
                            default: (0, _vue.withCtx)(()=>[
                                    y.$slots["arrow-up"] ? (0, _vue.renderSlot)(y.$slots, "arrow-up", {
                                        key: 0
                                    }) : (0, _vue.createCommentVNode)("", !0),
                                    y.$slots["arrow-up"] ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)(En), {
                                        key: 1
                                    }))
                                ]),
                            _: 3
                        }, 8, [
                            "aria-label",
                            "disabled"
                        ])) : (0, _vue.createCommentVNode)("", !0),
                        (0, _vue.unref)(A) ? ((0, _vue.openBlock)(), (0, _vue.createBlock)(Zt, {
                            key: 2,
                            ref: "rightIcon",
                            disabled: (0, _vue.unref)(E)(!0),
                            "aria-label": (Ce = (0, _vue.unref)(r).ariaLabels) == null ? void 0 : Ce.nextMonth,
                            onActivate: C[7] || (C[7] = (ee)=>(0, _vue.unref)(B)(!0)),
                            onSetRef: C[8] || (C[8] = (ee)=>V(ee, 3))
                        }, {
                            default: (0, _vue.withCtx)(()=>[
                                    y.$slots[y.vertical ? "arrow-down" : "arrow-right"] ? (0, _vue.renderSlot)(y.$slots, y.vertical ? "arrow-down" : "arrow-right", {
                                        key: 0
                                    }) : (0, _vue.createCommentVNode)("", !0),
                                    y.$slots[y.vertical ? "arrow-down" : "arrow-right"] ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.resolveDynamicComponent)(y.vertical ? (0, _vue.unref)(Fn) : (0, _vue.unref)(kn)), {
                                        key: 1
                                    }))
                                ]),
                            _: 3
                        }, 8, [
                            "disabled",
                            "aria-label"
                        ])) : (0, _vue.createCommentVNode)("", !0)
                    ], 64)) : (0, _vue.createCommentVNode)("", !0),
                    y.monthPicker ? ((0, _vue.openBlock)(), (0, _vue.createBlock)(pt, (0, _vue.mergeProps)({
                        key: 1
                    }, (0, _vue.unref)(J)("month"), {
                        "skip-active": y.range,
                        year: e.year,
                        "multi-model-value": (0, _vue.unref)(j),
                        "month-picker": "",
                        modelValue: (0, _vue.unref)(M),
                        "onUpdate:modelValue": C[17] || (C[17] = (ee)=>(0, _vue.isRef)(M) ? M.value = ee : null),
                        onToggle: W,
                        onSelected: C[18] || (C[18] = (ee)=>y.$emit("overlay-closed"))
                    }), (0, _vue.createSlots)({
                        header: (0, _vue.withCtx)(()=>{
                            var ee, Ke, Ge;
                            return [
                                (0, _vue.createElementVNode)("div", ur, [
                                    (0, _vue.createElementVNode)("div", {
                                        class: "dp__month_year_col_nav",
                                        tabindex: "0",
                                        ref_key: "mpPrevIconRef",
                                        ref: Y,
                                        onClick: C[9] || (C[9] = (te)=>k(!1)),
                                        onKeydown: C[10] || (C[10] = (0, _vue.withKeys)((te)=>k(!1), [
                                            "enter"
                                        ]))
                                    }, [
                                        (0, _vue.createElementVNode)("div", {
                                            class: "dp__inner_nav",
                                            role: "button",
                                            "aria-label": (ee = (0, _vue.unref)(r).ariaLabels) == null ? void 0 : ee.prevMonth
                                        }, [
                                            y.$slots["arrow-left"] ? (0, _vue.renderSlot)(y.$slots, "arrow-left", {
                                                key: 0
                                            }) : (0, _vue.createCommentVNode)("", !0),
                                            y.$slots["arrow-left"] ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)(pn), {
                                                key: 1
                                            }))
                                        ], 8, cr)
                                    ], 544),
                                    (0, _vue.createElementVNode)("div", {
                                        class: "dp__pointer",
                                        role: "button",
                                        ref_key: "mpYearButtonRef",
                                        ref: Z,
                                        "aria-label": (Ke = (0, _vue.unref)(r).ariaLabels) == null ? void 0 : Ke.openYearsOverlay,
                                        tabindex: "0",
                                        onClick: C[11] || (C[11] = ()=>l(!1)),
                                        onKeydown: C[12] || (C[12] = (0, _vue.withKeys)(()=>l(!1), [
                                            "enter"
                                        ]))
                                    }, [
                                        y.$slots.year ? (0, _vue.renderSlot)(y.$slots, "year", {
                                            key: 0,
                                            year: e.year
                                        }) : (0, _vue.createCommentVNode)("", !0),
                                        y.$slots.year ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                                            key: 1
                                        }, [
                                            (0, _vue.createTextVNode)((0, _vue.toDisplayString)(e.year), 1)
                                        ], 64))
                                    ], 40, dr),
                                    (0, _vue.createElementVNode)("div", {
                                        class: "dp__month_year_col_nav",
                                        tabindex: "0",
                                        ref_key: "mpNextIconRef",
                                        ref: ae,
                                        onClick: C[13] || (C[13] = (te)=>k(!0)),
                                        onKeydown: C[14] || (C[14] = (0, _vue.withKeys)((te)=>k(!0), [
                                            "enter"
                                        ]))
                                    }, [
                                        (0, _vue.createElementVNode)("div", {
                                            class: "dp__inner_nav",
                                            role: "button",
                                            "aria-label": (Ge = (0, _vue.unref)(r).ariaLabels) == null ? void 0 : Ge.nextMonth
                                        }, [
                                            y.$slots["arrow-right"] ? (0, _vue.renderSlot)(y.$slots, "arrow-right", {
                                                key: 0
                                            }) : (0, _vue.createCommentVNode)("", !0),
                                            y.$slots["arrow-right"] ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)(kn), {
                                                key: 1
                                            }))
                                        ], 8, fr)
                                    ], 544)
                                ]),
                                (0, _vue.createVNode)((0, _vue.Transition), {
                                    name: (0, _vue.unref)(i)(_.value),
                                    css: (0, _vue.unref)(p)
                                }, {
                                    default: (0, _vue.withCtx)(()=>[
                                            _.value ? ((0, _vue.openBlock)(), (0, _vue.createBlock)(pt, (0, _vue.mergeProps)({
                                                key: 0
                                            }, (0, _vue.unref)(J)("year"), {
                                                modelValue: (0, _vue.unref)(G),
                                                "onUpdate:modelValue": C[15] || (C[15] = (te)=>(0, _vue.isRef)(G) ? G.value = te : null),
                                                onToggle: l,
                                                onSelected: C[16] || (C[16] = (te)=>y.$emit("overlay-closed"))
                                            }), (0, _vue.createSlots)({
                                                "button-icon": (0, _vue.withCtx)(()=>[
                                                        y.$slots["calendar-icon"] ? (0, _vue.renderSlot)(y.$slots, "calendar-icon", {
                                                            key: 0
                                                        }) : (0, _vue.createCommentVNode)("", !0),
                                                        y.$slots["calendar-icon"] ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)(It), {
                                                            key: 1
                                                        }))
                                                    ]),
                                                _: 2
                                            }, [
                                                y.$slots["year-overlay-value"] ? {
                                                    name: "item",
                                                    fn: (0, _vue.withCtx)(({ item: te })=>[
                                                            (0, _vue.renderSlot)(y.$slots, "year-overlay-value", {
                                                                text: te.text,
                                                                value: te.value
                                                            })
                                                        ]),
                                                    key: "0"
                                                } : void 0
                                            ]), 1040, [
                                                "modelValue"
                                            ])) : (0, _vue.createCommentVNode)("", !0)
                                        ]),
                                    _: 3
                                }, 8, [
                                    "name",
                                    "css"
                                ])
                            ];
                        }),
                        _: 2
                    }, [
                        y.$slots["month-overlay-value"] ? {
                            name: "item",
                            fn: (0, _vue.withCtx)(({ item: ee })=>[
                                    (0, _vue.renderSlot)(y.$slots, "month-overlay-value", {
                                        text: ee.text,
                                        value: ee.value
                                    })
                                ]),
                            key: "0"
                        } : void 0
                    ]), 1040, [
                        "skip-active",
                        "year",
                        "multi-model-value",
                        "modelValue"
                    ])) : (0, _vue.createCommentVNode)("", !0),
                    y.yearPicker ? ((0, _vue.openBlock)(), (0, _vue.createBlock)(pt, (0, _vue.mergeProps)({
                        key: 2
                    }, (0, _vue.unref)(J)("year"), {
                        modelValue: (0, _vue.unref)(G),
                        "onUpdate:modelValue": C[19] || (C[19] = (ee)=>(0, _vue.isRef)(G) ? G.value = ee : null),
                        "multi-model-value": (0, _vue.unref)(j),
                        "skip-active": y.range,
                        "skip-button-ref": "",
                        "year-picker": "",
                        onToggle: l,
                        onSelected: C[20] || (C[20] = (ee)=>y.$emit("overlay-closed"))
                    }), (0, _vue.createSlots)({
                        _: 2
                    }, [
                        y.$slots["year-overlay-value"] ? {
                            name: "item",
                            fn: (0, _vue.withCtx)(({ item: ee })=>[
                                    (0, _vue.renderSlot)(y.$slots, "year-overlay-value", {
                                        text: ee.text,
                                        value: ee.value
                                    })
                                ]),
                            key: "0"
                        } : void 0
                    ]), 1040, [
                        "modelValue",
                        "multi-model-value",
                        "skip-active"
                    ])) : (0, _vue.createCommentVNode)("", !0)
                ], 64))
            ]);
        };
    }
}), mr = {
    key: 0,
    class: "dp__time_input"
}, yr = [
    "aria-label",
    "onKeydown",
    "onClick"
], hr = [
    "aria-label",
    "onKeydown",
    "onClick"
], gr = [
    "aria-label",
    "onKeydown",
    "onClick"
], pr = {
    key: 0
}, kr = [
    "aria-label",
    "onKeydown"
], wr = /* @__PURE__ */ (0, _vue.defineComponent)({
    __name: "TimeInput",
    props: {
        hours: {
            type: Number,
            default: 0
        },
        minutes: {
            type: Number,
            default: 0
        },
        seconds: {
            type: Number,
            default: 0
        },
        closeTimePickerBtn: {
            type: Object,
            default: null
        },
        order: {
            type: Number,
            default: 0
        },
        ...qe
    },
    emits: [
        "set-hours",
        "set-minutes",
        "update:hours",
        "update:minutes",
        "update:seconds",
        "reset-flow",
        "mounted",
        "overlay-closed"
    ],
    setup (e, { expose: n, emit: a }) {
        const t = e, { setTimePickerElements: r, setTimePickerBackRef: i } = Xe(), { defaults: p } = Be(t), { transitionName: b, showTransition: B } = Ot(p.value.transitions), E = (0, _vue.reactive)({
            hours: !1,
            minutes: !1,
            seconds: !1
        }), L = (0, _vue.ref)("AM"), s = (0, _vue.ref)(null), _ = (0, _vue.ref)([]);
        (0, _vue.onMounted)(()=>{
            a("mounted");
        });
        const I = (g, c)=>(0, _dateFns.add)((0, _dateFns.set)(w(), g), c), Y = (g, c)=>(0, _dateFns.sub)((0, _dateFns.set)(w(), g), c), Z = (0, _vue.computed)(()=>({
                dp__time_col: !0,
                dp__time_col_reg: !t.enableSeconds && t.is24,
                dp__time_col_reg_with_button: !t.enableSeconds && !t.is24,
                dp__time_col_sec: t.enableSeconds && t.is24,
                dp__time_col_sec_with_button: t.enableSeconds && !t.is24
            })), ae = (0, _vue.computed)(()=>{
            const g = [
                {
                    type: "hours"
                },
                {
                    type: "",
                    separator: !0
                },
                {
                    type: "minutes"
                }
            ];
            return t.enableSeconds ? g.concat([
                {
                    type: "",
                    separator: !0
                },
                {
                    type: "seconds"
                }
            ]) : g;
        }), P = (0, _vue.computed)(()=>ae.value.filter((g)=>!g.separator)), M = (0, _vue.computed)(()=>(g)=>{
                if (g === "hours") {
                    const c = O(t.hours);
                    return {
                        text: c < 10 ? `0${c}` : `${c}`,
                        value: c
                    };
                }
                return {
                    text: t[g] < 10 ? `0${t[g]}` : `${t[g]}`,
                    value: t[g]
                };
            }), G = (g)=>{
            const c = t.is24 ? 24 : 12, T = g === "hours" ? c : 60, A = +t[`${g}GridIncrement`], W = g === "hours" && !t.is24 ? A : 0, l = [];
            for(let d = W; d < T; d += A)l.push({
                value: d,
                text: d < 10 ? `0${d}` : `${d}`
            });
            return g === "hours" && !t.is24 && l.push({
                value: 0,
                text: "12"
            }), gl(l);
        }, J = (g)=>t[`no${g[0].toUpperCase() + g.slice(1)}Overlay`], Q = (g)=>{
            J(g) || (E[g] = !E[g], E[g] || a("overlay-closed"));
        }, N = (g)=>g === "hours" ? (0, _dateFns.getHours) : g === "minutes" ? (0, _dateFns.getMinutes) : (0, _dateFns.getSeconds), m = (g, c = !0)=>{
            const T = c ? I : Y;
            a(`update:${g}`, N(g)(T({
                [g]: +t[g]
            }, {
                [g]: +t[`${g}Increment`]
            })));
        }, O = (g)=>t.is24 ? g : (g >= 12 ? L.value = "PM" : L.value = "AM", bl(g)), j = ()=>{
            L.value === "PM" ? (L.value = "AM", a("update:hours", t.hours - 12)) : (L.value = "PM", a("update:hours", t.hours + 12));
        }, le = (g)=>{
            E[g] = !0;
        }, R = (g, c, T)=>{
            if (g && t.arrowNavigation) {
                Array.isArray(_.value[c]) ? _.value[c][T] = g : _.value[c] = [
                    g
                ];
                const A = _.value.reduce((W, l)=>l.map((d, k)=>[
                            ...W[k] || [],
                            l[k]
                        ]), []);
                i(t.closeTimePickerBtn), s.value && (A[1] = A[1].concat(s.value)), r(A, t.order);
            }
        }, H = (g, c)=>g === "hours" && !t.is24 ? a(`update:${g}`, L.value === "PM" ? c + 12 : c) : a(`update:${g}`, c);
        return n({
            openChildCmp: le
        }), (g, c)=>{
            var T;
            return g.disabled ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", mr, [
                ((0, _vue.openBlock)(!0), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)((0, _vue.unref)(ae), (A, W)=>{
                    var l, d, k;
                    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                        key: W,
                        class: (0, _vue.normalizeClass)((0, _vue.unref)(Z))
                    }, [
                        A.separator ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                            key: 0
                        }, [
                            (0, _vue.createTextVNode)(" : ")
                        ], 64)) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                            key: 1
                        }, [
                            (0, _vue.createElementVNode)("div", {
                                class: "dp__inc_dec_button",
                                role: "button",
                                "aria-label": (l = (0, _vue.unref)(p).ariaLabels) == null ? void 0 : l.incrementValue(A.type),
                                tabindex: "0",
                                onKeydown: [
                                    (0, _vue.withKeys)((V)=>m(A.type), [
                                        "enter"
                                    ]),
                                    (0, _vue.withKeys)((V)=>m(A.type), [
                                        "space"
                                    ])
                                ],
                                onClick: (V)=>m(A.type),
                                ref_for: !0,
                                ref: (V)=>R(V, W, 0)
                            }, [
                                g.$slots["arrow-up"] ? (0, _vue.renderSlot)(g.$slots, "arrow-up", {
                                    key: 0
                                }) : (0, _vue.createCommentVNode)("", !0),
                                g.$slots["arrow-up"] ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)(En), {
                                    key: 1
                                }))
                            ], 40, yr),
                            (0, _vue.createElementVNode)("div", {
                                role: "button",
                                "aria-label": (d = (0, _vue.unref)(p).ariaLabels) == null ? void 0 : d.openTpOverlay(A.type),
                                class: (0, _vue.normalizeClass)(J(A.type) ? "" : "dp__time_display"),
                                tabindex: "0",
                                onKeydown: [
                                    (0, _vue.withKeys)((V)=>Q(A.type), [
                                        "enter"
                                    ]),
                                    (0, _vue.withKeys)((V)=>Q(A.type), [
                                        "space"
                                    ])
                                ],
                                onClick: (V)=>Q(A.type),
                                ref_for: !0,
                                ref: (V)=>R(V, W, 1)
                            }, [
                                g.$slots[A.type] ? (0, _vue.renderSlot)(g.$slots, A.type, {
                                    key: 0,
                                    text: (0, _vue.unref)(M)(A.type).text,
                                    value: (0, _vue.unref)(M)(A.type).value
                                }) : (0, _vue.createCommentVNode)("", !0),
                                g.$slots[A.type] ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                                    key: 1
                                }, [
                                    (0, _vue.createTextVNode)((0, _vue.toDisplayString)((0, _vue.unref)(M)(A.type).text), 1)
                                ], 64))
                            ], 42, hr),
                            (0, _vue.createElementVNode)("div", {
                                class: "dp__inc_dec_button",
                                role: "button",
                                "aria-label": (k = (0, _vue.unref)(p).ariaLabels) == null ? void 0 : k.decrementValue(A.type),
                                tabindex: "0",
                                onKeydown: [
                                    (0, _vue.withKeys)((V)=>m(A.type, !1), [
                                        "enter"
                                    ]),
                                    (0, _vue.withKeys)((V)=>m(A.type, !1), [
                                        "space"
                                    ])
                                ],
                                onClick: (V)=>m(A.type, !1),
                                ref_for: !0,
                                ref: (V)=>R(V, W, 2)
                            }, [
                                g.$slots["arrow-down"] ? (0, _vue.renderSlot)(g.$slots, "arrow-down", {
                                    key: 0
                                }) : (0, _vue.createCommentVNode)("", !0),
                                g.$slots["arrow-down"] ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)(Fn), {
                                    key: 1
                                }))
                            ], 40, gr)
                        ], 64))
                    ], 2);
                }), 128)),
                g.is24 ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", pr, [
                    g.$slots["am-pm-button"] ? (0, _vue.renderSlot)(g.$slots, "am-pm-button", {
                        key: 0,
                        toggle: j,
                        value: L.value
                    }) : (0, _vue.createCommentVNode)("", !0),
                    g.$slots["am-pm-button"] ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("button", {
                        key: 1,
                        ref_key: "amPmButton",
                        ref: s,
                        type: "button",
                        class: "dp__pm_am_button",
                        role: "button",
                        "aria-label": (T = (0, _vue.unref)(p).ariaLabels) == null ? void 0 : T.amPmButton,
                        tabindex: "0",
                        onClick: j,
                        onKeydown: [
                            (0, _vue.withKeys)((0, _vue.withModifiers)(j, [
                                "prevent"
                            ]), [
                                "enter"
                            ]),
                            (0, _vue.withKeys)((0, _vue.withModifiers)(j, [
                                "prevent"
                            ]), [
                                "space"
                            ])
                        ]
                    }, (0, _vue.toDisplayString)(L.value), 41, kr))
                ])),
                ((0, _vue.openBlock)(!0), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)((0, _vue.unref)(P), (A, W)=>((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.Transition), {
                        key: W,
                        name: (0, _vue.unref)(b)(E[A.type]),
                        css: (0, _vue.unref)(B)
                    }, {
                        default: (0, _vue.withCtx)(()=>[
                                E[A.type] ? ((0, _vue.openBlock)(), (0, _vue.createBlock)(pt, {
                                    key: 0,
                                    items: G(A.type),
                                    "disabled-values": (0, _vue.unref)(p).filters.times[A.type],
                                    "esc-close": g.escClose,
                                    "aria-labels": (0, _vue.unref)(p).ariaLabels,
                                    "hide-navigation": g.hideNavigation,
                                    "onUpdate:modelValue": (l)=>H(A.type, l),
                                    onSelected: (l)=>Q(A.type),
                                    onToggle: (l)=>Q(A.type),
                                    onResetFlow: c[0] || (c[0] = (l)=>g.$emit("reset-flow")),
                                    type: A.type
                                }, (0, _vue.createSlots)({
                                    "button-icon": (0, _vue.withCtx)(()=>[
                                            g.$slots["clock-icon"] ? (0, _vue.renderSlot)(g.$slots, "clock-icon", {
                                                key: 0
                                            }) : (0, _vue.createCommentVNode)("", !0),
                                            g.$slots["clock-icon"] ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)(Ln), {
                                                key: 1
                                            }))
                                        ]),
                                    _: 2
                                }, [
                                    g.$slots[`${A.type}-overlay-value`] ? {
                                        name: "item",
                                        fn: (0, _vue.withCtx)(({ item: l })=>[
                                                (0, _vue.renderSlot)(g.$slots, `${A.type}-overlay-value`, {
                                                    text: l.text,
                                                    value: l.value
                                                })
                                            ]),
                                        key: "0"
                                    } : void 0
                                ]), 1032, [
                                    "items",
                                    "disabled-values",
                                    "esc-close",
                                    "aria-labels",
                                    "hide-navigation",
                                    "onUpdate:modelValue",
                                    "onSelected",
                                    "onToggle",
                                    "type"
                                ])) : (0, _vue.createCommentVNode)("", !0)
                            ]),
                        _: 2
                    }, 1032, [
                        "name",
                        "css"
                    ]))), 128))
            ]));
        };
    }
}), br = [
    "aria-label"
], Dr = {
    class: "dp__overlay_container dp__container_flex"
}, $r = {
    key: 1,
    class: "dp__overlay_row"
}, Mr = [
    "aria-label"
], _r = /* @__PURE__ */ (0, _vue.defineComponent)({
    __name: "TimePicker",
    props: {
        hours: {
            type: [
                Number,
                Array
            ],
            default: 0
        },
        minutes: {
            type: [
                Number,
                Array
            ],
            default: 0
        },
        seconds: {
            type: [
                Number,
                Array
            ],
            default: 0
        },
        internalModelValue: {
            type: [
                Date,
                Array
            ],
            default: null
        },
        ...qe
    },
    emits: [
        "update:hours",
        "update:minutes",
        "update:seconds",
        "mount",
        "reset-flow",
        "overlay-closed"
    ],
    setup (e, { expose: n, emit: a }) {
        const t = e, { buildMatrix: r, setTimePicker: i } = Xe(), p = (0, _vue.useSlots)(), { hideNavigationButtons: b, defaults: B } = Be(t), { transitionName: E, showTransition: L } = Ot(B.value.transitions), s = (0, _vue.ref)(null), _ = (0, _vue.ref)(null), I = (0, _vue.ref)([]), Y = (0, _vue.ref)(null);
        (0, _vue.onMounted)(()=>{
            a("mount"), !t.timePicker && t.arrowNavigation ? r([
                Te(s.value)
            ], "time") : i(!0, t.timePicker);
        });
        const Z = (0, _vue.computed)(()=>t.range && t.modelAuto ? jn(t.internalModelValue) : !0), ae = (0, _vue.ref)(!1), P = (R)=>({
                hours: Array.isArray(t.hours) ? t.hours[R] : t.hours,
                minutes: Array.isArray(t.minutes) ? t.minutes[R] : t.minutes,
                seconds: Array.isArray(t.seconds) ? t.seconds[R] : t.seconds
            }), M = (0, _vue.computed)(()=>{
            const R = [];
            if (t.range) for(let H = 0; H < 2; H++)R.push(P(H));
            else R.push(P(0));
            return R;
        }), G = (R, H = !1, g = "")=>{
            H || a("reset-flow"), ae.value = R, t.arrowNavigation && (i(R), R || a("overlay-closed")), (0, _vue.nextTick)(()=>{
                g !== "" && I.value[0] && I.value[0].openChildCmp(g);
            });
        }, J = (0, _vue.computed)(()=>({
                dp__button: !0,
                dp__button_bottom: t.autoApply
            })), Q = lt(p, "timePicker"), N = (R, H, g)=>t.range ? H === 0 ? [
                R,
                M.value[1][g]
            ] : [
                M.value[0][g],
                R
            ] : R, m = (R)=>{
            a("update:hours", R);
        }, O = (R)=>{
            a("update:minutes", R);
        }, j = (R)=>{
            a("update:seconds", R);
        }, le = ()=>{
            Y.value && t.arrowNavigation && Y.value.focus({
                preventScroll: !0
            });
        };
        return n({
            toggleTimePicker: G
        }), (R, H)=>{
            var g;
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", null, [
                R.timePicker ? (0, _vue.createCommentVNode)("", !0) : (0, _vue.withDirectives)(((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                    key: 0,
                    class: (0, _vue.normalizeClass)((0, _vue.unref)(J)),
                    role: "button",
                    "aria-label": (g = (0, _vue.unref)(B).ariaLabels) == null ? void 0 : g.openTimePicker,
                    tabindex: "0",
                    ref_key: "openTimePickerBtn",
                    ref: s,
                    onKeydown: [
                        H[0] || (H[0] = (0, _vue.withKeys)((c)=>G(!0), [
                            "enter"
                        ])),
                        H[1] || (H[1] = (0, _vue.withKeys)((c)=>G(!0), [
                            "space"
                        ]))
                    ],
                    onClick: H[2] || (H[2] = (c)=>G(!0))
                }, [
                    R.$slots["clock-icon"] ? (0, _vue.renderSlot)(R.$slots, "clock-icon", {
                        key: 0
                    }) : (0, _vue.createCommentVNode)("", !0),
                    R.$slots["clock-icon"] ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)(Ln), {
                        key: 1
                    }))
                ], 42, br)), [
                    [
                        (0, _vue.vShow),
                        !(0, _vue.unref)(b)("time")
                    ]
                ]),
                (0, _vue.createVNode)((0, _vue.Transition), {
                    name: (0, _vue.unref)(E)(ae.value),
                    css: (0, _vue.unref)(L)
                }, {
                    default: (0, _vue.withCtx)(()=>{
                        var c;
                        return [
                            ae.value || R.timePicker ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                key: 0,
                                class: "dp__overlay",
                                ref_key: "overlayRef",
                                ref: Y,
                                tabindex: "0"
                            }, [
                                (0, _vue.createElementVNode)("div", Dr, [
                                    R.$slots["time-picker-overlay"] ? (0, _vue.renderSlot)(R.$slots, "time-picker-overlay", {
                                        key: 0,
                                        hours: e.hours,
                                        minutes: e.minutes,
                                        seconds: e.seconds,
                                        setHours: m,
                                        setMinutes: O,
                                        setSeconds: j
                                    }) : (0, _vue.createCommentVNode)("", !0),
                                    R.$slots["time-picker-overlay"] ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", $r, [
                                        ((0, _vue.openBlock)(!0), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)((0, _vue.unref)(M), (T, A)=>(0, _vue.withDirectives)(((0, _vue.openBlock)(), (0, _vue.createBlock)(wr, (0, _vue.mergeProps)({
                                                key: A
                                            }, {
                                                ...R.$props,
                                                order: A,
                                                hours: T.hours,
                                                minutes: T.minutes,
                                                seconds: T.seconds,
                                                closeTimePickerBtn: _.value,
                                                disabled: A === 0 ? R.fixedStart : R.fixedEnd
                                            }, {
                                                ref_for: !0,
                                                ref_key: "timeInputRefs",
                                                ref: I,
                                                "onUpdate:hours": (W)=>m(N(W, A, "hours")),
                                                "onUpdate:minutes": (W)=>O(N(W, A, "minutes")),
                                                "onUpdate:seconds": (W)=>j(N(W, A, "seconds")),
                                                onMounted: le,
                                                onOverlayClosed: le
                                            }), (0, _vue.createSlots)({
                                                _: 2
                                            }, [
                                                (0, _vue.renderList)((0, _vue.unref)(Q), (W, l)=>({
                                                        name: W,
                                                        fn: (0, _vue.withCtx)((d)=>[
                                                                (0, _vue.renderSlot)(R.$slots, W, (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(d)))
                                                            ])
                                                    }))
                                            ]), 1040, [
                                                "onUpdate:hours",
                                                "onUpdate:minutes",
                                                "onUpdate:seconds"
                                            ])), [
                                                [
                                                    (0, _vue.vShow),
                                                    A === 0 ? !0 : (0, _vue.unref)(Z)
                                                ]
                                            ])), 128))
                                    ])),
                                    R.timePicker ? (0, _vue.createCommentVNode)("", !0) : (0, _vue.withDirectives)(((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                        key: 2,
                                        ref_key: "closeTimePickerBtn",
                                        ref: _,
                                        class: (0, _vue.normalizeClass)((0, _vue.unref)(J)),
                                        role: "button",
                                        "aria-label": (c = (0, _vue.unref)(B).ariaLabels) == null ? void 0 : c.closeTimePicker,
                                        tabindex: "0",
                                        onKeydown: [
                                            H[3] || (H[3] = (0, _vue.withKeys)((T)=>G(!1), [
                                                "enter"
                                            ])),
                                            H[4] || (H[4] = (0, _vue.withKeys)((T)=>G(!1), [
                                                "space"
                                            ]))
                                        ],
                                        onClick: H[5] || (H[5] = (T)=>G(!1))
                                    }, [
                                        R.$slots["calendar-icon"] ? (0, _vue.renderSlot)(R.$slots, "calendar-icon", {
                                            key: 0
                                        }) : (0, _vue.createCommentVNode)("", !0),
                                        R.$slots["calendar-icon"] ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)(It), {
                                            key: 1
                                        }))
                                    ], 42, Mr)), [
                                        [
                                            (0, _vue.vShow),
                                            !(0, _vue.unref)(b)("time")
                                        ]
                                    ])
                                ])
                            ], 512)) : (0, _vue.createCommentVNode)("", !0)
                        ];
                    }),
                    _: 3
                }, 8, [
                    "name",
                    "css"
                ])
            ]);
        };
    }
}), Ar = (e, n)=>{
    const { isDisabled: a, matchDate: t, getWeekFromDate: r } = Be(n), i = (0, _vue.ref)(), p = (0, _vue.ref)(w()), b = (l)=>{
        !l.current && n.hideOffsetDates || (i.value = l.value);
    }, B = ()=>{
        i.value = null;
    }, E = (l)=>Array.isArray(e.value) && n.range && e.value[0] && i.value ? l ? Ie(i.value, e.value[0]) : Se(i.value, e.value[0]) : !0, L = (l, d)=>{
        const k = ()=>e.value ? d ? e.value[0] || null : e.value[1] : null, V = e.value && Array.isArray(e.value) ? k() : null;
        return ve(w(l.value), V);
    }, s = (l)=>{
        const d = Array.isArray(e.value) ? e.value[0] : null;
        return l ? !Se(i.value || null, d) : !0;
    }, _ = (l, d = !0)=>(n.range || n.weekPicker) && Array.isArray(e.value) ? n.hideOffsetDates && !l.current ? !1 : ve(w(l.value), e.value[d ? 0 : 1]) : n.range ? L(l, d) && s(d) || ve(l.value, Array.isArray(e.value) ? e.value[0] : null) && E(d) : !1, I = (l, d, k)=>Array.isArray(e.value) && e.value[0] && e.value.length === 1 ? l ? !1 : k ? Ie(e.value[0], d.value) : Se(e.value[0], d.value) : !1, Y = (l)=>!e.value || n.hideOffsetDates && !l.current ? !1 : n.range ? n.modelAuto && Array.isArray(e.value) ? ve(l.value, e.value[0] ? e.value[0] : p.value) : !1 : n.multiDates && Array.isArray(e.value) ? e.value.some((d)=>ve(d, l.value)) : ve(l.value, e.value ? e.value : p.value), Z = (l)=>{
        if (n.autoRange || n.weekPicker) {
            if (i.value) {
                if (n.hideOffsetDates && !l.current) return !1;
                const d = (0, _dateFns.addDays)(i.value, +n.autoRange), k = r(w(i.value));
                return n.weekPicker ? ve(k[1], w(l.value)) : ve(d, w(l.value));
            }
            return !1;
        }
        return !1;
    }, ae = (l)=>{
        if (n.autoRange || n.weekPicker) {
            if (i.value) {
                const d = (0, _dateFns.addDays)(i.value, +n.autoRange);
                if (n.hideOffsetDates && !l.current) return !1;
                const k = r(w(i.value));
                return n.weekPicker ? Ie(l.value, k[0]) && Se(l.value, k[1]) : Ie(l.value, i.value) && Se(l.value, d);
            }
            return !1;
        }
        return !1;
    }, P = (l)=>{
        if (n.autoRange || n.weekPicker) {
            if (i.value) {
                if (n.hideOffsetDates && !l.current) return !1;
                const d = r(w(i.value));
                return n.weekPicker ? ve(d[0], l.value) : ve(i.value, l.value);
            }
            return !1;
        }
        return !1;
    }, M = (l)=>Un(e.value, i.value, l.value), G = ()=>n.modelAuto && Array.isArray(n.internalModelValue) ? !!n.internalModelValue[0] : !1, J = ()=>n.modelAuto ? jn(n.internalModelValue) : !0, Q = (l)=>{
        if (Array.isArray(e.value) && e.value.length || n.weekPicker) return !1;
        const d = n.range ? !_(l) && !_(l, !1) : !0;
        return !a(l.value) && !Y(l) && !(!l.current && n.hideOffsetDates) && d;
    }, N = (l)=>n.range ? n.modelAuto ? G() && Y(l) : !1 : Y(l), m = (l)=>n.highlight ? t(l.value, n.highlight) : !1, O = (l)=>a(l.value) && n.highlightDisabledDays === !1, j = (l)=>n.highlightWeekDays && n.highlightWeekDays.includes(l.value.getDay()), le = (l)=>(n.range || n.weekPicker) && (n.multiCalendars > 0 ? l.current : !0) && J() && !(!l.current && n.hideOffsetDates) && !Y(l) ? M(l) : !1, R = (l)=>({
            dp__cell_offset: !l.current,
            dp__pointer: !n.disabled && !(!l.current && n.hideOffsetDates) && !a(l.value),
            dp__cell_disabled: a(l.value),
            dp__cell_highlight: !O(l) && (m(l) || j(l)) && !N(l),
            dp__cell_highlight_active: !O && (m(l) || j(l)) && N(l),
            dp__today: !n.noToday && ve(l.value, p.value) && l.current
        }), H = (l)=>({
            dp__active_date: N(l),
            dp__date_hover: Q(l)
        }), g = (l)=>({
            ...c(l),
            ...T(l),
            dp__range_between_week: le(l) && n.weekPicker
        }), c = (l)=>({
            dp__range_start: n.multiCalendars > 0 ? l.current && _(l) && J() : _(l) && J(),
            dp__range_end: n.multiCalendars > 0 ? l.current && _(l, !1) && J() : _(l, !1) && J(),
            dp__range_between: le(l) && !n.weekPicker,
            dp__date_hover_start: I(Q(l), l, !0),
            dp__date_hover_end: I(Q(l), l, !1)
        }), T = (l)=>({
            ...c(l),
            dp__cell_auto_range: ae(l),
            dp__cell_auto_range_start: P(l),
            dp__cell_auto_range_end: Z(l)
        }), A = (l)=>n.range ? n.autoRange ? T(l) : n.modelAuto ? {
            ...H(l),
            ...c(l)
        } : c(l) : n.weekPicker ? g(l) : H(l);
    return {
        setHoverDate: b,
        clearHoverDate: B,
        getDayClassData: (l)=>({
                ...R(l),
                ...A(l),
                [n.dayClass ? n.dayClass(l.value) : ""]: !0,
                [n.calendarCellClassName]: !!n.calendarCellClassName
            })
    };
}, Tr = [
    "id",
    "onKeydown"
], Cr = {
    key: 0,
    class: "dp__sidebar_left"
}, Sr = {
    key: 1,
    class: "dp__preset_ranges"
}, Pr = [
    "onClick"
], Nr = {
    key: 2,
    class: "dp__sidebar_right"
}, Rr = {
    key: 3,
    class: "dp__now_wrap"
}, Ir = /* @__PURE__ */ (0, _vue.defineComponent)({
    __name: "DatepickerMenu",
    props: {
        openOnTop: {
            type: Boolean,
            default: !1
        },
        internalModelValue: {
            type: [
                Date,
                Array
            ],
            default: null
        },
        ...qe
    },
    emits: [
        "close-picker",
        "select-date",
        "auto-apply",
        "time-update",
        "flow-step",
        "update-month-year",
        "invalid-select",
        "update:internal-model-value"
    ],
    setup (e, { emit: n }) {
        const a = e, { setMenuFocused: t, setShiftKey: r, control: i } = Hn(), { getCalendarDays: p, defaults: b } = Be(a), B = (0, _vue.useSlots)(), E = (0, _vue.ref)(null), L = (0, _vue.reactive)({
            timePicker: !!(!a.enableTimePicker || a.timePicker || a.monthPicker),
            monthYearInput: !!a.timePicker,
            calendar: !1
        }), s = (0, _vue.ref)([]), _ = (0, _vue.ref)([]), I = (0, _vue.ref)(null), Y = (0, _vue.ref)(null), Z = (0, _vue.ref)(0), ae = (0, _vue.ref)(!1), P = (0, _vue.ref)(0);
        (0, _vue.onMounted)(()=>{
            var x;
            ae.value = !0, !((x = a.presetRanges) != null && x.length) && !B["left-sidebar"] && !B["right-sidebar"] && Je();
            const f = Te(Y);
            if (f && !a.textInput && !a.inline && (t(!0), m()), f) {
                const pe = ($e)=>{
                    !a.monthYearComponent && !a.timePickerComponent && !Object.keys(B).length && $e.preventDefault(), $e.stopImmediatePropagation(), $e.stopPropagation();
                };
                f.addEventListener("pointerdown", pe), f.addEventListener("mousedown", pe);
            }
            document.addEventListener("resize", Je);
        }), (0, _vue.onUnmounted)(()=>{
            document.removeEventListener("resize", Je);
        });
        const { arrowRight: M, arrowLeft: G, arrowDown: J, arrowUp: Q } = Xe(), N = (f)=>{
            f || f === 0 ? _.value[f].triggerTransition(R.value(f), H.value(f)) : _.value.forEach((x, pe)=>x.triggerTransition(R.value(pe), H.value(pe)));
        }, m = ()=>{
            const f = Te(Y);
            f && f.focus({
                preventScroll: !0
            });
        }, O = ()=>{
            var f;
            ((f = a.flow) == null ? void 0 : f.length) && P.value !== -1 && (P.value += 1, n("flow-step", P.value), D());
        }, j = ()=>{
            P.value = -1;
        }, { modelValue: le, month: R, year: H, time: g, updateTime: c, updateMonthYear: T, selectDate: A, getWeekNum: W, monthYearSelect: l, handleScroll: d, handleArrow: k, handleSwipe: V, getMarker: y, selectCurrentDate: C, presetDateRange: v } = Sl(a, n, O, N), { setHoverDate: q, clearHoverDate: se, getDayClassData: ge } = Ar(le, a), Ce = lt(B, "calendar"), ee = lt(B, "action"), Ke = lt(B, "timePicker"), Ge = lt(B, "monthYear"), te = (0, _vue.computed)(()=>a.openOnTop ? "dp__arrow_bottom" : "dp__arrow_top"), De = (0, _vue.computed)(()=>kl(a.yearRange)), we = (0, _vue.computed)(()=>wl(a.locale, a.monthNameFormat)), Je = ()=>{
            const f = Te(E);
            f && (Z.value = f.getBoundingClientRect().width);
        }, We = (0, _vue.computed)(()=>(f)=>p(R.value(f), H.value(f))), Qe = (0, _vue.computed)(()=>b.value.multiCalendars > 0 && a.range ? [
                ...Array(b.value.multiCalendars).keys()
            ] : [
                0
            ]), vt = (0, _vue.computed)(()=>(f)=>f === 1), Bt = (0, _vue.computed)(()=>a.monthPicker || a.timePicker || a.yearPicker), Yt = (0, _vue.computed)(()=>({
                dp__flex_display: b.value.multiCalendars > 0
            })), Dt = (0, _vue.computed)(()=>({
                dp__instance_calendar: b.value.multiCalendars > 0
            })), mt = (0, _vue.computed)(()=>({
                dp__menu_disabled: a.disabled,
                dp__menu_readonly: a.readonly
            })), Vt = (0, _vue.computed)(()=>(f)=>Et(We, f)), Lt = (0, _vue.computed)(()=>({
                dp__menu: !0,
                dp__menu_index: !a.inline,
                dp__relative: a.inline,
                [a.menuClassName]: !!a.menuClassName
            })), Et = (f, x)=>f.value(x).map((pe)=>({
                    ...pe,
                    days: pe.days.map(($e)=>($e.marker = y($e), $e.classData = ge($e), $e))
                })), $t = (f)=>{
            f.stopPropagation(), f.preventDefault(), f.stopImmediatePropagation();
        }, mn = ()=>{
            a.escClose && n("close-picker");
        }, yn = (f, x = !1)=>{
            A(f, x), a.spaceConfirm && n("select-date");
        }, Mt = (f)=>{
            var x;
            (x = a.flow) != null && x.length && (L[f] = !0, Object.keys(L).filter((pe)=>!L[pe]).length || D());
        }, o = (f, x, pe, $e, ...Ve)=>{
            if (a.flow[P.value] === f) {
                const X = $e ? x.value[0] : x.value;
                X && X[pe](...Ve);
            }
        }, D = ()=>{
            o("month", s, "toggleMonthPicker", !0, !0), o("year", s, "toggleYearPicker", !0, !0), o("calendar", I, "toggleTimePicker", !1, !1, !0), o("time", I, "toggleTimePicker", !1, !0, !0);
            const f = a.flow[P.value];
            (f === "hours" || f === "minutes" || f === "seconds") && o(f, I, "toggleTimePicker", !1, !0, !0, f);
        }, z = (f)=>{
            if (a.arrowNavigation) {
                if (f === "up") return Q();
                if (f === "down") return J();
                if (f === "left") return G();
                if (f === "right") return M();
            } else f === "left" || f === "up" ? k("left", 0, f === "up") : k("right", 0, f === "down");
        }, re = (f)=>{
            r(f.shiftKey), !a.disableMonthYearSelect && f.code === "Tab" && f.target.classList.contains("dp__menu") && i.value.shiftKeyInMenu && (f.preventDefault(), f.stopImmediatePropagation(), n("close-picker"));
        };
        return (f, x)=>{
            var pe;
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.Transition), {
                appear: "",
                name: (pe = (0, _vue.unref)(b).transitions) == null ? void 0 : pe.menuAppear,
                mode: "out-in",
                css: !!f.transitions
            }, {
                default: (0, _vue.withCtx)(()=>{
                    var $e, Ve;
                    return [
                        (0, _vue.createElementVNode)("div", {
                            id: f.uid ? `dp-menu-${f.uid}` : void 0,
                            tabindex: "0",
                            ref_key: "dpMenuRef",
                            ref: Y,
                            role: "dialog",
                            class: (0, _vue.normalizeClass)((0, _vue.unref)(Lt)),
                            onMouseleave: x[12] || (x[12] = (...X)=>(0, _vue.unref)(se) && (0, _vue.unref)(se)(...X)),
                            onClick: $t,
                            onKeydown: [
                                (0, _vue.withKeys)(mn, [
                                    "esc"
                                ]),
                                x[13] || (x[13] = (0, _vue.withKeys)((0, _vue.withModifiers)((X)=>z("left"), [
                                    "prevent"
                                ]), [
                                    "left"
                                ])),
                                x[14] || (x[14] = (0, _vue.withKeys)((0, _vue.withModifiers)((X)=>z("up"), [
                                    "prevent"
                                ]), [
                                    "up"
                                ])),
                                x[15] || (x[15] = (0, _vue.withKeys)((0, _vue.withModifiers)((X)=>z("down"), [
                                    "prevent"
                                ]), [
                                    "down"
                                ])),
                                x[16] || (x[16] = (0, _vue.withKeys)((0, _vue.withModifiers)((X)=>z("right"), [
                                    "prevent"
                                ]), [
                                    "right"
                                ])),
                                re
                            ]
                        }, [
                            (f.disabled || f.readonly) && f.inline ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                key: 0,
                                class: (0, _vue.normalizeClass)((0, _vue.unref)(mt))
                            }, null, 2)) : (0, _vue.createCommentVNode)("", !0),
                            !f.inline && !f.teleportCenter ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                key: 1,
                                class: (0, _vue.normalizeClass)((0, _vue.unref)(te))
                            }, null, 2)) : (0, _vue.createCommentVNode)("", !0),
                            (0, _vue.createElementVNode)("div", {
                                class: (0, _vue.normalizeClass)({
                                    dp__menu_content_wrapper: (($e = f.presetRanges) == null ? void 0 : $e.length) || !!f.$slots["left-sidebar"] || !!f.$slots["right-sidebar"]
                                })
                            }, [
                                f.$slots["left-sidebar"] ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", Cr, [
                                    (0, _vue.renderSlot)(f.$slots, "left-sidebar")
                                ])) : (0, _vue.createCommentVNode)("", !0),
                                (Ve = f.presetRanges) != null && Ve.length ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", Sr, [
                                    ((0, _vue.openBlock)(!0), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)(f.presetRanges, (X, st)=>((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                            key: st,
                                            style: (0, _vue.normalizeStyle)(X.style || {}),
                                            class: "dp__preset_range",
                                            onClick: (ie)=>(0, _vue.unref)(v)(X.range, !!X.slot)
                                        }, [
                                            X.slot ? (0, _vue.renderSlot)(f.$slots, X.slot, {
                                                key: 0,
                                                presetDateRange: (0, _vue.unref)(v),
                                                label: X.label,
                                                range: X.range
                                            }) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                                                key: 1
                                            }, [
                                                (0, _vue.createTextVNode)((0, _vue.toDisplayString)(X.label), 1)
                                            ], 64))
                                        ], 12, Pr))), 128))
                                ])) : (0, _vue.createCommentVNode)("", !0),
                                (0, _vue.createElementVNode)("div", {
                                    class: "dp__instance_calendar",
                                    ref_key: "calendarWrapperRef",
                                    ref: E,
                                    role: "document"
                                }, [
                                    (0, _vue.createElementVNode)("div", {
                                        class: (0, _vue.normalizeClass)((0, _vue.unref)(Yt))
                                    }, [
                                        ((0, _vue.openBlock)(!0), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)((0, _vue.unref)(Qe), (X, st)=>((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                                key: X,
                                                class: (0, _vue.normalizeClass)((0, _vue.unref)(Dt))
                                            }, [
                                                !f.disableMonthYearSelect && !f.timePicker ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.resolveDynamicComponent)(f.monthYearComponent ? f.monthYearComponent : vr), (0, _vue.mergeProps)({
                                                    key: 0,
                                                    ref_for: !0,
                                                    ref: (ie)=>{
                                                        ie && (s.value[st] = ie);
                                                    },
                                                    months: (0, _vue.unref)(we),
                                                    years: (0, _vue.unref)(De),
                                                    month: (0, _vue.unref)(R)(X),
                                                    year: (0, _vue.unref)(H)(X),
                                                    instance: X,
                                                    "internal-model-value": e.internalModelValue
                                                }, f.$props, {
                                                    onMount: x[0] || (x[0] = (ie)=>Mt("monthYearInput")),
                                                    onResetFlow: j,
                                                    onUpdateMonthYear: (ie)=>(0, _vue.unref)(T)(X, ie),
                                                    onMonthYearSelect: (0, _vue.unref)(l),
                                                    onOverlayClosed: m
                                                }), (0, _vue.createSlots)({
                                                    _: 2
                                                }, [
                                                    (0, _vue.renderList)((0, _vue.unref)(Ge), (ie, Kn)=>({
                                                            name: ie,
                                                            fn: (0, _vue.withCtx)((Ft)=>[
                                                                    (0, _vue.renderSlot)(f.$slots, ie, (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(Ft)))
                                                                ])
                                                        }))
                                                ]), 1040, [
                                                    "months",
                                                    "years",
                                                    "month",
                                                    "year",
                                                    "instance",
                                                    "internal-model-value",
                                                    "onUpdateMonthYear",
                                                    "onMonthYearSelect"
                                                ])) : (0, _vue.createCommentVNode)("", !0),
                                                (0, _vue.createVNode)(er, (0, _vue.mergeProps)({
                                                    ref_for: !0,
                                                    ref: (ie)=>{
                                                        ie && (_.value[st] = ie);
                                                    },
                                                    "specific-mode": (0, _vue.unref)(Bt),
                                                    "get-week-num": (0, _vue.unref)(W),
                                                    instance: X,
                                                    "mapped-dates": (0, _vue.unref)(Vt)(X),
                                                    month: (0, _vue.unref)(R)(X),
                                                    year: (0, _vue.unref)(H)(X)
                                                }, f.$props, {
                                                    "flow-step": P.value,
                                                    "onUpdate:flow-step": x[1] || (x[1] = (ie)=>P.value = ie),
                                                    onSelectDate: (ie)=>(0, _vue.unref)(A)(ie, !(0, _vue.unref)(vt)(X)),
                                                    onHandleSpace: (ie)=>yn(ie, !(0, _vue.unref)(vt)(X)),
                                                    onSetHoverDate: x[2] || (x[2] = (ie)=>(0, _vue.unref)(q)(ie)),
                                                    onHandleScroll: (ie)=>(0, _vue.unref)(d)(ie, X),
                                                    onHandleSwipe: (ie)=>(0, _vue.unref)(V)(ie, X),
                                                    onMount: x[3] || (x[3] = (ie)=>Mt("calendar")),
                                                    onResetFlow: j
                                                }), (0, _vue.createSlots)({
                                                    _: 2
                                                }, [
                                                    (0, _vue.renderList)((0, _vue.unref)(Ce), (ie, Kn)=>({
                                                            name: ie,
                                                            fn: (0, _vue.withCtx)((Ft)=>[
                                                                    (0, _vue.renderSlot)(f.$slots, ie, (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                                                        ...Ft
                                                                    })))
                                                                ])
                                                        }))
                                                ]), 1040, [
                                                    "specific-mode",
                                                    "get-week-num",
                                                    "instance",
                                                    "mapped-dates",
                                                    "month",
                                                    "year",
                                                    "flow-step",
                                                    "onSelectDate",
                                                    "onHandleSpace",
                                                    "onHandleScroll",
                                                    "onHandleSwipe"
                                                ])
                                            ], 2))), 128))
                                    ], 2),
                                    (0, _vue.createElementVNode)("div", null, [
                                        f.$slots["time-picker"] ? (0, _vue.renderSlot)(f.$slots, "time-picker", (0, _vue.normalizeProps)((0, _vue.mergeProps)({
                                            key: 0
                                        }, {
                                            time: (0, _vue.unref)(g),
                                            updateTime: (0, _vue.unref)(c)
                                        }))) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                                            key: 1
                                        }, [
                                            f.enableTimePicker && !f.monthPicker && !f.weekPicker ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.resolveDynamicComponent)(f.timePickerComponent ? f.timePickerComponent : _r), (0, _vue.mergeProps)({
                                                key: 0,
                                                ref_key: "timePickerRef",
                                                ref: I,
                                                hours: (0, _vue.unref)(g).hours,
                                                minutes: (0, _vue.unref)(g).minutes,
                                                seconds: (0, _vue.unref)(g).seconds,
                                                "internal-model-value": e.internalModelValue
                                            }, f.$props, {
                                                onMount: x[4] || (x[4] = (X)=>Mt("timePicker")),
                                                "onUpdate:hours": x[5] || (x[5] = (X)=>(0, _vue.unref)(c)(X)),
                                                "onUpdate:minutes": x[6] || (x[6] = (X)=>(0, _vue.unref)(c)(X, !1)),
                                                "onUpdate:seconds": x[7] || (x[7] = (X)=>(0, _vue.unref)(c)(X, !1, !0)),
                                                onResetFlow: j,
                                                onOverlayClosed: m
                                            }), (0, _vue.createSlots)({
                                                _: 2
                                            }, [
                                                (0, _vue.renderList)((0, _vue.unref)(Ke), (X, st)=>({
                                                        name: X,
                                                        fn: (0, _vue.withCtx)((ie)=>[
                                                                (0, _vue.renderSlot)(f.$slots, X, (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(ie)))
                                                            ])
                                                    }))
                                            ]), 1040, [
                                                "hours",
                                                "minutes",
                                                "seconds",
                                                "internal-model-value"
                                            ])) : (0, _vue.createCommentVNode)("", !0)
                                        ], 64))
                                    ])
                                ], 512),
                                f.$slots["right-sidebar"] ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", Nr, [
                                    (0, _vue.renderSlot)(f.$slots, "right-sidebar")
                                ])) : (0, _vue.createCommentVNode)("", !0),
                                f.showNowButton ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", Rr, [
                                    f.$slots["now-button"] ? (0, _vue.renderSlot)(f.$slots, "now-button", {
                                        key: 0,
                                        selectCurrentDate: (0, _vue.unref)(C)
                                    }) : (0, _vue.createCommentVNode)("", !0),
                                    f.$slots["now-button"] ? (0, _vue.createCommentVNode)("", !0) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("button", {
                                        key: 1,
                                        type: "button",
                                        role: "button",
                                        class: "dp__now_button",
                                        onClick: x[8] || (x[8] = (...X)=>(0, _vue.unref)(C) && (0, _vue.unref)(C)(...X))
                                    }, (0, _vue.toDisplayString)(f.nowButtonLabel), 1))
                                ])) : (0, _vue.createCommentVNode)("", !0)
                            ], 2),
                            f.$slots["action-row"] ? (0, _vue.renderSlot)(f.$slots, "action-row", (0, _vue.normalizeProps)((0, _vue.mergeProps)({
                                key: 2
                            }, {
                                internalModelValue: e.internalModelValue,
                                selectDate: ()=>f.$emit("select-date"),
                                closePicker: ()=>f.$emit("close-picker")
                            }))) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                                key: 3
                            }, [
                                !f.autoApply || f.keepActionRow ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.resolveDynamicComponent)(f.actionRowComponent ? f.actionRowComponent : zl), (0, _vue.mergeProps)({
                                    key: 0,
                                    "menu-mount": ae.value,
                                    "calendar-width": Z.value,
                                    "internal-model-value": e.internalModelValue
                                }, f.$props, {
                                    onClosePicker: x[9] || (x[9] = (X)=>f.$emit("close-picker")),
                                    onSelectDate: x[10] || (x[10] = (X)=>f.$emit("select-date")),
                                    onInvalidSelect: x[11] || (x[11] = (X)=>f.$emit("invalid-select"))
                                }), (0, _vue.createSlots)({
                                    _: 2
                                }, [
                                    (0, _vue.renderList)((0, _vue.unref)(ee), (X, st)=>({
                                            name: X,
                                            fn: (0, _vue.withCtx)((ie)=>[
                                                    (0, _vue.renderSlot)(f.$slots, X, (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                                        ...ie
                                                    })))
                                                ])
                                        }))
                                ]), 1040, [
                                    "menu-mount",
                                    "calendar-width",
                                    "internal-model-value"
                                ])) : (0, _vue.createCommentVNode)("", !0)
                            ], 64))
                        ], 42, Tr)
                    ];
                }),
                _: 3
            }, 8, [
                "name",
                "css"
            ]);
        };
    }
}), Or = typeof window < "u" ? window : void 0, Xt = ()=>{}, Br = (e)=>(0, _vue.getCurrentScope)() ? ((0, _vue.onScopeDispose)(e), !0) : !1, Yr = (e, n, a, t)=>{
    if (!e) return Xt;
    let r = Xt;
    const i = (0, _vue.watch)(()=>(0, _vue.unref)(e), (b)=>{
        r(), b && (b.addEventListener(n, a, t), r = ()=>{
            b.removeEventListener(n, a, t), r = Xt;
        });
    }, {
        immediate: !0,
        flush: "post"
    }), p = ()=>{
        i(), r();
    };
    return Br(p), p;
}, Vr = (e, n, a, t = {})=>{
    const { window: r = Or, event: i = "pointerdown" } = t;
    return r ? Yr(r, i, (b)=>{
        const B = Te(e), E = Te(n);
        !B || !E || B === b.target || b.composedPath().includes(B) || b.composedPath().includes(E) || a(b);
    }, {
        passive: !0
    }) : void 0;
}, Lr = /* @__PURE__ */ (0, _vue.defineComponent)({
    __name: "VueDatePicker",
    props: {
        ...qe
    },
    emits: [
        "update:model-value",
        "text-submit",
        "closed",
        "cleared",
        "open",
        "focus",
        "blur",
        "internal-model-change",
        "recalculate-position",
        "flow-step",
        "update-month-year",
        "invalid-select"
    ],
    setup (e, { expose: n, emit: a }) {
        const t = e, r = (0, _vue.useSlots)(), i = (0, _vue.ref)(!1), p = (0, _vue.toRef)(t, "modelValue"), b = (0, _vue.toRef)(t, "timezone"), B = (0, _vue.ref)(null), E = (0, _vue.ref)(null), L = (0, _vue.ref)(!1), { setMenuFocused: s, setShiftKey: _ } = Hn(), { clearArrowNav: I } = Xe(), { validateDate: Y, isValidTime: Z, defaults: ae } = Be(t);
        (0, _vue.onMounted)(()=>{
            j(t.modelValue), t.inline || (window.addEventListener("scroll", T), window.addEventListener("resize", A)), t.inline && (i.value = !0);
        }), (0, _vue.onUnmounted)(()=>{
            t.inline || (window.removeEventListener("scroll", T), window.removeEventListener("resize", A));
        });
        const P = lt(r, "all", t.presetRanges), M = lt(r, "input");
        (0, _vue.watch)([
            p,
            b
        ], ()=>{
            j(p.value);
        }, {
            deep: !0
        });
        const { openOnTop: G, menuPosition: J, setMenuPosition: Q, setInitialPosition: N } = Rl(B, E, a, t), { inputValue: m, internalModelValue: O, parseExternalModelValue: j, emitModelValue: le, formatInputValue: R, checkBeforeEmit: H } = Pl(a, t, L), g = (0, _vue.computed)(()=>({
                dp__main: !0,
                dp__theme_dark: t.dark,
                dp__theme_light: !t.dark,
                dp__flex_display: t.inline,
                dp__flex_display_with_input: t.inlineWithInput
            })), c = (0, _vue.computed)(()=>t.dark ? "dp__theme_dark" : "dp__theme_light"), T = ()=>{
            i.value && (t.closeOnScroll ? v() : t.autoPosition ? Q() : window.removeEventListener("scroll", T));
        }, A = ()=>{
            i.value && Q();
        }, W = ()=>{
            !t.disabled && !t.readonly && (N(), i.value = !0, (0, _vue.nextTick)().then(()=>{
                Q(), i.value && a("open");
            }), i.value || C(), j(t.modelValue));
        }, l = ()=>{
            m.value = "", C(), a("update:model-value", null), a("cleared"), v();
        }, d = ()=>{
            const te = O.value;
            return !te || !Array.isArray(te) && Y(te) ? !0 : Array.isArray(te) ? te.length === 2 && Y(te[0]) && Y(te[1]) ? !0 : Y(te[0]) : !1;
        }, k = ()=>{
            H() && d() ? (le(), v()) : a("invalid-select", O.value);
        }, V = (te)=>{
            le(), t.closeOnAutoApply && !te && v();
        }, y = (te = !1)=>{
            t.autoApply && Z(O.value) && d() && (t.range && Array.isArray(O.value) ? (t.partialRange || O.value.length === 2) && V(te) : V(te));
        }, C = ()=>{
            t.textInput || (O.value = null);
        }, v = ()=>{
            t.inline || (i.value && (i.value = !1, s(!1), _(!1), I(), a("closed"), N(), m.value && j(p.value)), C(), E.value && E.value.focusInput());
        }, q = (te, De)=>{
            if (!te) {
                O.value = null;
                return;
            }
            O.value = te, De && (k(), a("text-submit"));
        }, se = ()=>{
            t.autoApply && Z(O.value) && le();
        }, ge = ()=>i.value ? v() : W(), Ce = (te)=>{
            O.value = te;
        }, ee = (0, _vue.computed)(()=>t.textInput && ae.value.textInputOptions.format), Ke = ()=>{
            ee.value && (L.value = !0, R()), a("focus");
        }, Ge = ()=>{
            ee.value && (L.value = !1, R()), a("blur");
        };
        return Vr(B, E, t.onClickOutside ? ()=>t.onClickOutside(d) : v), n({
            closeMenu: v,
            selectDate: k,
            clearValue: l,
            openMenu: W,
            onScroll: T,
            formatInputValue: R,
            updateInternalModelValue: Ce
        }), (te, De)=>((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: (0, _vue.normalizeClass)((0, _vue.unref)(g))
            }, [
                (0, _vue.createVNode)(Fl, (0, _vue.mergeProps)({
                    ref_key: "inputRef",
                    ref: E,
                    "is-menu-open": i.value,
                    "input-value": (0, _vue.unref)(m),
                    "onUpdate:input-value": De[0] || (De[0] = (we)=>(0, _vue.isRef)(m) ? m.value = we : null)
                }, te.$props, {
                    onClear: l,
                    onOpen: W,
                    onSetInputDate: q,
                    onSetEmptyDate: (0, _vue.unref)(le),
                    onSelectDate: k,
                    onToggle: ge,
                    onClose: v,
                    onFocus: Ke,
                    onBlur: Ge
                }), (0, _vue.createSlots)({
                    _: 2
                }, [
                    (0, _vue.renderList)((0, _vue.unref)(M), (we, Je)=>({
                            name: we,
                            fn: (0, _vue.withCtx)((We)=>[
                                    (0, _vue.renderSlot)(te.$slots, we, (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(We)))
                                ])
                        }))
                ]), 1040, [
                    "is-menu-open",
                    "input-value",
                    "onSetEmptyDate"
                ]),
                i.value ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.Teleport), {
                    key: 0,
                    to: te.teleport,
                    disabled: te.inline
                }, [
                    i.value ? ((0, _vue.openBlock)(), (0, _vue.createBlock)(Ir, (0, _vue.mergeProps)({
                        key: 0,
                        ref_key: "dpMenuRef",
                        ref: B,
                        class: (0, _vue.unref)(c),
                        style: (0, _vue.unref)(J),
                        "open-on-top": (0, _vue.unref)(G)
                    }, te.$props, {
                        "internal-model-value": (0, _vue.unref)(O),
                        "onUpdate:internal-model-value": De[1] || (De[1] = (we)=>(0, _vue.isRef)(O) ? O.value = we : null),
                        onClosePicker: v,
                        onSelectDate: k,
                        onAutoApply: y,
                        onTimeUpdate: se,
                        onFlowStep: De[2] || (De[2] = (we)=>te.$emit("flow-step", we)),
                        onUpdateMonthYear: De[3] || (De[3] = (we)=>te.$emit("update-month-year", we)),
                        onInvalidSelect: De[4] || (De[4] = (we)=>te.$emit("invalid-select", (0, _vue.unref)(O)))
                    }), (0, _vue.createSlots)({
                        _: 2
                    }, [
                        (0, _vue.renderList)((0, _vue.unref)(P), (we, Je)=>({
                                name: we,
                                fn: (0, _vue.withCtx)((We)=>[
                                        (0, _vue.renderSlot)(te.$slots, we, (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                            ...We
                                        })))
                                    ])
                            }))
                    ]), 1040, [
                        "class",
                        "style",
                        "open-on-top",
                        "internal-model-value"
                    ])) : (0, _vue.createCommentVNode)("", !0)
                ], 8, [
                    "to",
                    "disabled"
                ])) : (0, _vue.createCommentVNode)("", !0)
            ], 2));
    }
}), xn = /* @__PURE__ */ (()=>{
    const e = Lr;
    return e.install = (n)=>{
        n.component("Vue3DatePicker", e);
    }, e;
})(), Er = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: xn
}, Symbol.toStringTag, {
    value: "Module"
}));
Object.entries(Er).forEach(([e, n])=>{
    e !== "default" && (xn[e] = n);
});

},{"vue":"gzxs9","date-fns":"9yHCA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9yHCA":[function(require,module,exports) {
// This file is generated automatically by `scripts/build/indices.ts`. Please, don't change it.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "add", ()=>(0, _indexJsDefault.default));
parcelHelpers.export(exports, "addBusinessDays", ()=>(0, _indexJsDefault1.default));
parcelHelpers.export(exports, "addDays", ()=>(0, _indexJsDefault2.default));
parcelHelpers.export(exports, "addHours", ()=>(0, _indexJsDefault3.default));
parcelHelpers.export(exports, "addISOWeekYears", ()=>(0, _indexJsDefault4.default));
parcelHelpers.export(exports, "addMilliseconds", ()=>(0, _indexJsDefault5.default));
parcelHelpers.export(exports, "addMinutes", ()=>(0, _indexJsDefault6.default));
parcelHelpers.export(exports, "addMonths", ()=>(0, _indexJsDefault7.default));
parcelHelpers.export(exports, "addQuarters", ()=>(0, _indexJsDefault8.default));
parcelHelpers.export(exports, "addSeconds", ()=>(0, _indexJsDefault9.default));
parcelHelpers.export(exports, "addWeeks", ()=>(0, _indexJsDefault10.default));
parcelHelpers.export(exports, "addYears", ()=>(0, _indexJsDefault11.default));
parcelHelpers.export(exports, "areIntervalsOverlapping", ()=>(0, _indexJsDefault12.default));
parcelHelpers.export(exports, "clamp", ()=>(0, _indexJsDefault13.default));
parcelHelpers.export(exports, "closestIndexTo", ()=>(0, _indexJsDefault14.default));
parcelHelpers.export(exports, "closestTo", ()=>(0, _indexJsDefault15.default));
parcelHelpers.export(exports, "compareAsc", ()=>(0, _indexJsDefault16.default));
parcelHelpers.export(exports, "compareDesc", ()=>(0, _indexJsDefault17.default));
parcelHelpers.export(exports, "daysToWeeks", ()=>(0, _indexJsDefault18.default));
parcelHelpers.export(exports, "differenceInBusinessDays", ()=>(0, _indexJsDefault19.default));
parcelHelpers.export(exports, "differenceInCalendarDays", ()=>(0, _indexJsDefault20.default));
parcelHelpers.export(exports, "differenceInCalendarISOWeekYears", ()=>(0, _indexJsDefault21.default));
parcelHelpers.export(exports, "differenceInCalendarISOWeeks", ()=>(0, _indexJsDefault22.default));
parcelHelpers.export(exports, "differenceInCalendarMonths", ()=>(0, _indexJsDefault23.default));
parcelHelpers.export(exports, "differenceInCalendarQuarters", ()=>(0, _indexJsDefault24.default));
parcelHelpers.export(exports, "differenceInCalendarWeeks", ()=>(0, _indexJsDefault25.default));
parcelHelpers.export(exports, "differenceInCalendarYears", ()=>(0, _indexJsDefault26.default));
parcelHelpers.export(exports, "differenceInDays", ()=>(0, _indexJsDefault27.default));
parcelHelpers.export(exports, "differenceInHours", ()=>(0, _indexJsDefault28.default));
parcelHelpers.export(exports, "differenceInISOWeekYears", ()=>(0, _indexJsDefault29.default));
parcelHelpers.export(exports, "differenceInMilliseconds", ()=>(0, _indexJsDefault30.default));
parcelHelpers.export(exports, "differenceInMinutes", ()=>(0, _indexJsDefault31.default));
parcelHelpers.export(exports, "differenceInMonths", ()=>(0, _indexJsDefault32.default));
parcelHelpers.export(exports, "differenceInQuarters", ()=>(0, _indexJsDefault33.default));
parcelHelpers.export(exports, "differenceInSeconds", ()=>(0, _indexJsDefault34.default));
parcelHelpers.export(exports, "differenceInWeeks", ()=>(0, _indexJsDefault35.default));
parcelHelpers.export(exports, "differenceInYears", ()=>(0, _indexJsDefault36.default));
parcelHelpers.export(exports, "eachDayOfInterval", ()=>(0, _indexJsDefault37.default));
parcelHelpers.export(exports, "eachHourOfInterval", ()=>(0, _indexJsDefault38.default));
parcelHelpers.export(exports, "eachMinuteOfInterval", ()=>(0, _indexJsDefault39.default));
parcelHelpers.export(exports, "eachMonthOfInterval", ()=>(0, _indexJsDefault40.default));
parcelHelpers.export(exports, "eachQuarterOfInterval", ()=>(0, _indexJsDefault41.default));
parcelHelpers.export(exports, "eachWeekOfInterval", ()=>(0, _indexJsDefault42.default));
parcelHelpers.export(exports, "eachWeekendOfInterval", ()=>(0, _indexJsDefault43.default));
parcelHelpers.export(exports, "eachWeekendOfMonth", ()=>(0, _indexJsDefault44.default));
parcelHelpers.export(exports, "eachWeekendOfYear", ()=>(0, _indexJsDefault45.default));
parcelHelpers.export(exports, "eachYearOfInterval", ()=>(0, _indexJsDefault46.default));
parcelHelpers.export(exports, "endOfDay", ()=>(0, _indexJsDefault47.default));
parcelHelpers.export(exports, "endOfDecade", ()=>(0, _indexJsDefault48.default));
parcelHelpers.export(exports, "endOfHour", ()=>(0, _indexJsDefault49.default));
parcelHelpers.export(exports, "endOfISOWeek", ()=>(0, _indexJsDefault50.default));
parcelHelpers.export(exports, "endOfISOWeekYear", ()=>(0, _indexJsDefault51.default));
parcelHelpers.export(exports, "endOfMinute", ()=>(0, _indexJsDefault52.default));
parcelHelpers.export(exports, "endOfMonth", ()=>(0, _indexJsDefault53.default));
parcelHelpers.export(exports, "endOfQuarter", ()=>(0, _indexJsDefault54.default));
parcelHelpers.export(exports, "endOfSecond", ()=>(0, _indexJsDefault55.default));
parcelHelpers.export(exports, "endOfToday", ()=>(0, _indexJsDefault56.default));
parcelHelpers.export(exports, "endOfTomorrow", ()=>(0, _indexJsDefault57.default));
parcelHelpers.export(exports, "endOfWeek", ()=>(0, _indexJsDefault58.default));
parcelHelpers.export(exports, "endOfYear", ()=>(0, _indexJsDefault59.default));
parcelHelpers.export(exports, "endOfYesterday", ()=>(0, _indexJsDefault60.default));
parcelHelpers.export(exports, "format", ()=>(0, _indexJsDefault61.default));
parcelHelpers.export(exports, "formatDistance", ()=>(0, _indexJsDefault62.default));
parcelHelpers.export(exports, "formatDistanceStrict", ()=>(0, _indexJsDefault63.default));
parcelHelpers.export(exports, "formatDistanceToNow", ()=>(0, _indexJsDefault64.default));
parcelHelpers.export(exports, "formatDistanceToNowStrict", ()=>(0, _indexJsDefault65.default));
parcelHelpers.export(exports, "formatDuration", ()=>(0, _indexJsDefault66.default));
parcelHelpers.export(exports, "formatISO", ()=>(0, _indexJsDefault67.default));
parcelHelpers.export(exports, "formatISO9075", ()=>(0, _indexJsDefault68.default));
parcelHelpers.export(exports, "formatISODuration", ()=>(0, _indexJsDefault69.default));
parcelHelpers.export(exports, "formatRFC3339", ()=>(0, _indexJsDefault70.default));
parcelHelpers.export(exports, "formatRFC7231", ()=>(0, _indexJsDefault71.default));
parcelHelpers.export(exports, "formatRelative", ()=>(0, _indexJsDefault72.default));
parcelHelpers.export(exports, "fromUnixTime", ()=>(0, _indexJsDefault73.default));
parcelHelpers.export(exports, "getDate", ()=>(0, _indexJsDefault74.default));
parcelHelpers.export(exports, "getDay", ()=>(0, _indexJsDefault75.default));
parcelHelpers.export(exports, "getDayOfYear", ()=>(0, _indexJsDefault76.default));
parcelHelpers.export(exports, "getDaysInMonth", ()=>(0, _indexJsDefault77.default));
parcelHelpers.export(exports, "getDaysInYear", ()=>(0, _indexJsDefault78.default));
parcelHelpers.export(exports, "getDecade", ()=>(0, _indexJsDefault79.default));
parcelHelpers.export(exports, "getDefaultOptions", ()=>(0, _indexJsDefault80.default));
parcelHelpers.export(exports, "getHours", ()=>(0, _indexJsDefault81.default));
parcelHelpers.export(exports, "getISODay", ()=>(0, _indexJsDefault82.default));
parcelHelpers.export(exports, "getISOWeek", ()=>(0, _indexJsDefault83.default));
parcelHelpers.export(exports, "getISOWeekYear", ()=>(0, _indexJsDefault84.default));
parcelHelpers.export(exports, "getISOWeeksInYear", ()=>(0, _indexJsDefault85.default));
parcelHelpers.export(exports, "getMilliseconds", ()=>(0, _indexJsDefault86.default));
parcelHelpers.export(exports, "getMinutes", ()=>(0, _indexJsDefault87.default));
parcelHelpers.export(exports, "getMonth", ()=>(0, _indexJsDefault88.default));
parcelHelpers.export(exports, "getOverlappingDaysInIntervals", ()=>(0, _indexJsDefault89.default));
parcelHelpers.export(exports, "getQuarter", ()=>(0, _indexJsDefault90.default));
parcelHelpers.export(exports, "getSeconds", ()=>(0, _indexJsDefault91.default));
parcelHelpers.export(exports, "getTime", ()=>(0, _indexJsDefault92.default));
parcelHelpers.export(exports, "getUnixTime", ()=>(0, _indexJsDefault93.default));
parcelHelpers.export(exports, "getWeek", ()=>(0, _indexJsDefault94.default));
parcelHelpers.export(exports, "getWeekOfMonth", ()=>(0, _indexJsDefault95.default));
parcelHelpers.export(exports, "getWeekYear", ()=>(0, _indexJsDefault96.default));
parcelHelpers.export(exports, "getWeeksInMonth", ()=>(0, _indexJsDefault97.default));
parcelHelpers.export(exports, "getYear", ()=>(0, _indexJsDefault98.default));
parcelHelpers.export(exports, "hoursToMilliseconds", ()=>(0, _indexJsDefault99.default));
parcelHelpers.export(exports, "hoursToMinutes", ()=>(0, _indexJsDefault100.default));
parcelHelpers.export(exports, "hoursToSeconds", ()=>(0, _indexJsDefault101.default));
parcelHelpers.export(exports, "intervalToDuration", ()=>(0, _indexJsDefault102.default));
parcelHelpers.export(exports, "intlFormat", ()=>(0, _indexJsDefault103.default));
parcelHelpers.export(exports, "intlFormatDistance", ()=>(0, _indexJsDefault104.default));
parcelHelpers.export(exports, "isAfter", ()=>(0, _indexJsDefault105.default));
parcelHelpers.export(exports, "isBefore", ()=>(0, _indexJsDefault106.default));
parcelHelpers.export(exports, "isDate", ()=>(0, _indexJsDefault107.default));
parcelHelpers.export(exports, "isEqual", ()=>(0, _indexJsDefault108.default));
parcelHelpers.export(exports, "isExists", ()=>(0, _indexJsDefault109.default));
parcelHelpers.export(exports, "isFirstDayOfMonth", ()=>(0, _indexJsDefault110.default));
parcelHelpers.export(exports, "isFriday", ()=>(0, _indexJsDefault111.default));
parcelHelpers.export(exports, "isFuture", ()=>(0, _indexJsDefault112.default));
parcelHelpers.export(exports, "isLastDayOfMonth", ()=>(0, _indexJsDefault113.default));
parcelHelpers.export(exports, "isLeapYear", ()=>(0, _indexJsDefault114.default));
parcelHelpers.export(exports, "isMatch", ()=>(0, _indexJsDefault115.default));
parcelHelpers.export(exports, "isMonday", ()=>(0, _indexJsDefault116.default));
parcelHelpers.export(exports, "isPast", ()=>(0, _indexJsDefault117.default));
parcelHelpers.export(exports, "isSameDay", ()=>(0, _indexJsDefault118.default));
parcelHelpers.export(exports, "isSameHour", ()=>(0, _indexJsDefault119.default));
parcelHelpers.export(exports, "isSameISOWeek", ()=>(0, _indexJsDefault120.default));
parcelHelpers.export(exports, "isSameISOWeekYear", ()=>(0, _indexJsDefault121.default));
parcelHelpers.export(exports, "isSameMinute", ()=>(0, _indexJsDefault122.default));
parcelHelpers.export(exports, "isSameMonth", ()=>(0, _indexJsDefault123.default));
parcelHelpers.export(exports, "isSameQuarter", ()=>(0, _indexJsDefault124.default));
parcelHelpers.export(exports, "isSameSecond", ()=>(0, _indexJsDefault125.default));
parcelHelpers.export(exports, "isSameWeek", ()=>(0, _indexJsDefault126.default));
parcelHelpers.export(exports, "isSameYear", ()=>(0, _indexJsDefault127.default));
parcelHelpers.export(exports, "isSaturday", ()=>(0, _indexJsDefault128.default));
parcelHelpers.export(exports, "isSunday", ()=>(0, _indexJsDefault129.default));
parcelHelpers.export(exports, "isThisHour", ()=>(0, _indexJsDefault130.default));
parcelHelpers.export(exports, "isThisISOWeek", ()=>(0, _indexJsDefault131.default));
parcelHelpers.export(exports, "isThisMinute", ()=>(0, _indexJsDefault132.default));
parcelHelpers.export(exports, "isThisMonth", ()=>(0, _indexJsDefault133.default));
parcelHelpers.export(exports, "isThisQuarter", ()=>(0, _indexJsDefault134.default));
parcelHelpers.export(exports, "isThisSecond", ()=>(0, _indexJsDefault135.default));
parcelHelpers.export(exports, "isThisWeek", ()=>(0, _indexJsDefault136.default));
parcelHelpers.export(exports, "isThisYear", ()=>(0, _indexJsDefault137.default));
parcelHelpers.export(exports, "isThursday", ()=>(0, _indexJsDefault138.default));
parcelHelpers.export(exports, "isToday", ()=>(0, _indexJsDefault139.default));
parcelHelpers.export(exports, "isTomorrow", ()=>(0, _indexJsDefault140.default));
parcelHelpers.export(exports, "isTuesday", ()=>(0, _indexJsDefault141.default));
parcelHelpers.export(exports, "isValid", ()=>(0, _indexJsDefault142.default));
parcelHelpers.export(exports, "isWednesday", ()=>(0, _indexJsDefault143.default));
parcelHelpers.export(exports, "isWeekend", ()=>(0, _indexJsDefault144.default));
parcelHelpers.export(exports, "isWithinInterval", ()=>(0, _indexJsDefault145.default));
parcelHelpers.export(exports, "isYesterday", ()=>(0, _indexJsDefault146.default));
parcelHelpers.export(exports, "lastDayOfDecade", ()=>(0, _indexJsDefault147.default));
parcelHelpers.export(exports, "lastDayOfISOWeek", ()=>(0, _indexJsDefault148.default));
parcelHelpers.export(exports, "lastDayOfISOWeekYear", ()=>(0, _indexJsDefault149.default));
parcelHelpers.export(exports, "lastDayOfMonth", ()=>(0, _indexJsDefault150.default));
parcelHelpers.export(exports, "lastDayOfQuarter", ()=>(0, _indexJsDefault151.default));
parcelHelpers.export(exports, "lastDayOfWeek", ()=>(0, _indexJsDefault152.default));
parcelHelpers.export(exports, "lastDayOfYear", ()=>(0, _indexJsDefault153.default));
parcelHelpers.export(exports, "lightFormat", ()=>(0, _indexJsDefault154.default));
parcelHelpers.export(exports, "max", ()=>(0, _indexJsDefault155.default));
parcelHelpers.export(exports, "milliseconds", ()=>(0, _indexJsDefault156.default));
parcelHelpers.export(exports, "millisecondsToHours", ()=>(0, _indexJsDefault157.default));
parcelHelpers.export(exports, "millisecondsToMinutes", ()=>(0, _indexJsDefault158.default));
parcelHelpers.export(exports, "millisecondsToSeconds", ()=>(0, _indexJsDefault159.default));
parcelHelpers.export(exports, "min", ()=>(0, _indexJsDefault160.default));
parcelHelpers.export(exports, "minutesToHours", ()=>(0, _indexJsDefault161.default));
parcelHelpers.export(exports, "minutesToMilliseconds", ()=>(0, _indexJsDefault162.default));
parcelHelpers.export(exports, "minutesToSeconds", ()=>(0, _indexJsDefault163.default));
parcelHelpers.export(exports, "monthsToQuarters", ()=>(0, _indexJsDefault164.default));
parcelHelpers.export(exports, "monthsToYears", ()=>(0, _indexJsDefault165.default));
parcelHelpers.export(exports, "nextDay", ()=>(0, _indexJsDefault166.default));
parcelHelpers.export(exports, "nextFriday", ()=>(0, _indexJsDefault167.default));
parcelHelpers.export(exports, "nextMonday", ()=>(0, _indexJsDefault168.default));
parcelHelpers.export(exports, "nextSaturday", ()=>(0, _indexJsDefault169.default));
parcelHelpers.export(exports, "nextSunday", ()=>(0, _indexJsDefault170.default));
parcelHelpers.export(exports, "nextThursday", ()=>(0, _indexJsDefault171.default));
parcelHelpers.export(exports, "nextTuesday", ()=>(0, _indexJsDefault172.default));
parcelHelpers.export(exports, "nextWednesday", ()=>(0, _indexJsDefault173.default));
parcelHelpers.export(exports, "parse", ()=>(0, _indexJsDefault174.default));
parcelHelpers.export(exports, "parseISO", ()=>(0, _indexJsDefault175.default));
parcelHelpers.export(exports, "parseJSON", ()=>(0, _indexJsDefault176.default));
parcelHelpers.export(exports, "previousDay", ()=>(0, _indexJsDefault177.default));
parcelHelpers.export(exports, "previousFriday", ()=>(0, _indexJsDefault178.default));
parcelHelpers.export(exports, "previousMonday", ()=>(0, _indexJsDefault179.default));
parcelHelpers.export(exports, "previousSaturday", ()=>(0, _indexJsDefault180.default));
parcelHelpers.export(exports, "previousSunday", ()=>(0, _indexJsDefault181.default));
parcelHelpers.export(exports, "previousThursday", ()=>(0, _indexJsDefault182.default));
parcelHelpers.export(exports, "previousTuesday", ()=>(0, _indexJsDefault183.default));
parcelHelpers.export(exports, "previousWednesday", ()=>(0, _indexJsDefault184.default));
parcelHelpers.export(exports, "quartersToMonths", ()=>(0, _indexJsDefault185.default));
parcelHelpers.export(exports, "quartersToYears", ()=>(0, _indexJsDefault186.default));
parcelHelpers.export(exports, "roundToNearestMinutes", ()=>(0, _indexJsDefault187.default));
parcelHelpers.export(exports, "secondsToHours", ()=>(0, _indexJsDefault188.default));
parcelHelpers.export(exports, "secondsToMilliseconds", ()=>(0, _indexJsDefault189.default));
parcelHelpers.export(exports, "secondsToMinutes", ()=>(0, _indexJsDefault190.default));
parcelHelpers.export(exports, "set", ()=>(0, _indexJsDefault191.default));
parcelHelpers.export(exports, "setDate", ()=>(0, _indexJsDefault192.default));
parcelHelpers.export(exports, "setDay", ()=>(0, _indexJsDefault193.default));
parcelHelpers.export(exports, "setDayOfYear", ()=>(0, _indexJsDefault194.default));
parcelHelpers.export(exports, "setDefaultOptions", ()=>(0, _indexJsDefault195.default));
parcelHelpers.export(exports, "setHours", ()=>(0, _indexJsDefault196.default));
parcelHelpers.export(exports, "setISODay", ()=>(0, _indexJsDefault197.default));
parcelHelpers.export(exports, "setISOWeek", ()=>(0, _indexJsDefault198.default));
parcelHelpers.export(exports, "setISOWeekYear", ()=>(0, _indexJsDefault199.default));
parcelHelpers.export(exports, "setMilliseconds", ()=>(0, _indexJsDefault200.default));
parcelHelpers.export(exports, "setMinutes", ()=>(0, _indexJsDefault201.default));
parcelHelpers.export(exports, "setMonth", ()=>(0, _indexJsDefault202.default));
parcelHelpers.export(exports, "setQuarter", ()=>(0, _indexJsDefault203.default));
parcelHelpers.export(exports, "setSeconds", ()=>(0, _indexJsDefault204.default));
parcelHelpers.export(exports, "setWeek", ()=>(0, _indexJsDefault205.default));
parcelHelpers.export(exports, "setWeekYear", ()=>(0, _indexJsDefault206.default));
parcelHelpers.export(exports, "setYear", ()=>(0, _indexJsDefault207.default));
parcelHelpers.export(exports, "startOfDay", ()=>(0, _indexJsDefault208.default));
parcelHelpers.export(exports, "startOfDecade", ()=>(0, _indexJsDefault209.default));
parcelHelpers.export(exports, "startOfHour", ()=>(0, _indexJsDefault210.default));
parcelHelpers.export(exports, "startOfISOWeek", ()=>(0, _indexJsDefault211.default));
parcelHelpers.export(exports, "startOfISOWeekYear", ()=>(0, _indexJsDefault212.default));
parcelHelpers.export(exports, "startOfMinute", ()=>(0, _indexJsDefault213.default));
parcelHelpers.export(exports, "startOfMonth", ()=>(0, _indexJsDefault214.default));
parcelHelpers.export(exports, "startOfQuarter", ()=>(0, _indexJsDefault215.default));
parcelHelpers.export(exports, "startOfSecond", ()=>(0, _indexJsDefault216.default));
parcelHelpers.export(exports, "startOfToday", ()=>(0, _indexJsDefault217.default));
parcelHelpers.export(exports, "startOfTomorrow", ()=>(0, _indexJsDefault218.default));
parcelHelpers.export(exports, "startOfWeek", ()=>(0, _indexJsDefault219.default));
parcelHelpers.export(exports, "startOfWeekYear", ()=>(0, _indexJsDefault220.default));
parcelHelpers.export(exports, "startOfYear", ()=>(0, _indexJsDefault221.default));
parcelHelpers.export(exports, "startOfYesterday", ()=>(0, _indexJsDefault222.default));
parcelHelpers.export(exports, "sub", ()=>(0, _indexJsDefault223.default));
parcelHelpers.export(exports, "subBusinessDays", ()=>(0, _indexJsDefault224.default));
parcelHelpers.export(exports, "subDays", ()=>(0, _indexJsDefault225.default));
parcelHelpers.export(exports, "subHours", ()=>(0, _indexJsDefault226.default));
parcelHelpers.export(exports, "subISOWeekYears", ()=>(0, _indexJsDefault227.default));
parcelHelpers.export(exports, "subMilliseconds", ()=>(0, _indexJsDefault228.default));
parcelHelpers.export(exports, "subMinutes", ()=>(0, _indexJsDefault229.default));
parcelHelpers.export(exports, "subMonths", ()=>(0, _indexJsDefault230.default));
parcelHelpers.export(exports, "subQuarters", ()=>(0, _indexJsDefault231.default));
parcelHelpers.export(exports, "subSeconds", ()=>(0, _indexJsDefault232.default));
parcelHelpers.export(exports, "subWeeks", ()=>(0, _indexJsDefault233.default));
parcelHelpers.export(exports, "subYears", ()=>(0, _indexJsDefault234.default));
parcelHelpers.export(exports, "toDate", ()=>(0, _indexJsDefault235.default));
parcelHelpers.export(exports, "weeksToDays", ()=>(0, _indexJsDefault236.default));
parcelHelpers.export(exports, "yearsToMonths", ()=>(0, _indexJsDefault237.default));
parcelHelpers.export(exports, "yearsToQuarters", ()=>(0, _indexJsDefault238.default));
var _indexJs = require("./add/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("./addBusinessDays/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("./addDays/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
var _indexJs3 = require("./addHours/index.js");
var _indexJsDefault3 = parcelHelpers.interopDefault(_indexJs3);
var _indexJs4 = require("./addISOWeekYears/index.js");
var _indexJsDefault4 = parcelHelpers.interopDefault(_indexJs4);
var _indexJs5 = require("./addMilliseconds/index.js");
var _indexJsDefault5 = parcelHelpers.interopDefault(_indexJs5);
var _indexJs6 = require("./addMinutes/index.js");
var _indexJsDefault6 = parcelHelpers.interopDefault(_indexJs6);
var _indexJs7 = require("./addMonths/index.js");
var _indexJsDefault7 = parcelHelpers.interopDefault(_indexJs7);
var _indexJs8 = require("./addQuarters/index.js");
var _indexJsDefault8 = parcelHelpers.interopDefault(_indexJs8);
var _indexJs9 = require("./addSeconds/index.js");
var _indexJsDefault9 = parcelHelpers.interopDefault(_indexJs9);
var _indexJs10 = require("./addWeeks/index.js");
var _indexJsDefault10 = parcelHelpers.interopDefault(_indexJs10);
var _indexJs11 = require("./addYears/index.js");
var _indexJsDefault11 = parcelHelpers.interopDefault(_indexJs11);
var _indexJs12 = require("./areIntervalsOverlapping/index.js");
var _indexJsDefault12 = parcelHelpers.interopDefault(_indexJs12);
var _indexJs13 = require("./clamp/index.js");
var _indexJsDefault13 = parcelHelpers.interopDefault(_indexJs13);
var _indexJs14 = require("./closestIndexTo/index.js");
var _indexJsDefault14 = parcelHelpers.interopDefault(_indexJs14);
var _indexJs15 = require("./closestTo/index.js");
var _indexJsDefault15 = parcelHelpers.interopDefault(_indexJs15);
var _indexJs16 = require("./compareAsc/index.js");
var _indexJsDefault16 = parcelHelpers.interopDefault(_indexJs16);
var _indexJs17 = require("./compareDesc/index.js");
var _indexJsDefault17 = parcelHelpers.interopDefault(_indexJs17);
var _indexJs18 = require("./daysToWeeks/index.js");
var _indexJsDefault18 = parcelHelpers.interopDefault(_indexJs18);
var _indexJs19 = require("./differenceInBusinessDays/index.js");
var _indexJsDefault19 = parcelHelpers.interopDefault(_indexJs19);
var _indexJs20 = require("./differenceInCalendarDays/index.js");
var _indexJsDefault20 = parcelHelpers.interopDefault(_indexJs20);
var _indexJs21 = require("./differenceInCalendarISOWeekYears/index.js");
var _indexJsDefault21 = parcelHelpers.interopDefault(_indexJs21);
var _indexJs22 = require("./differenceInCalendarISOWeeks/index.js");
var _indexJsDefault22 = parcelHelpers.interopDefault(_indexJs22);
var _indexJs23 = require("./differenceInCalendarMonths/index.js");
var _indexJsDefault23 = parcelHelpers.interopDefault(_indexJs23);
var _indexJs24 = require("./differenceInCalendarQuarters/index.js");
var _indexJsDefault24 = parcelHelpers.interopDefault(_indexJs24);
var _indexJs25 = require("./differenceInCalendarWeeks/index.js");
var _indexJsDefault25 = parcelHelpers.interopDefault(_indexJs25);
var _indexJs26 = require("./differenceInCalendarYears/index.js");
var _indexJsDefault26 = parcelHelpers.interopDefault(_indexJs26);
var _indexJs27 = require("./differenceInDays/index.js");
var _indexJsDefault27 = parcelHelpers.interopDefault(_indexJs27);
var _indexJs28 = require("./differenceInHours/index.js");
var _indexJsDefault28 = parcelHelpers.interopDefault(_indexJs28);
var _indexJs29 = require("./differenceInISOWeekYears/index.js");
var _indexJsDefault29 = parcelHelpers.interopDefault(_indexJs29);
var _indexJs30 = require("./differenceInMilliseconds/index.js");
var _indexJsDefault30 = parcelHelpers.interopDefault(_indexJs30);
var _indexJs31 = require("./differenceInMinutes/index.js");
var _indexJsDefault31 = parcelHelpers.interopDefault(_indexJs31);
var _indexJs32 = require("./differenceInMonths/index.js");
var _indexJsDefault32 = parcelHelpers.interopDefault(_indexJs32);
var _indexJs33 = require("./differenceInQuarters/index.js");
var _indexJsDefault33 = parcelHelpers.interopDefault(_indexJs33);
var _indexJs34 = require("./differenceInSeconds/index.js");
var _indexJsDefault34 = parcelHelpers.interopDefault(_indexJs34);
var _indexJs35 = require("./differenceInWeeks/index.js");
var _indexJsDefault35 = parcelHelpers.interopDefault(_indexJs35);
var _indexJs36 = require("./differenceInYears/index.js");
var _indexJsDefault36 = parcelHelpers.interopDefault(_indexJs36);
var _indexJs37 = require("./eachDayOfInterval/index.js");
var _indexJsDefault37 = parcelHelpers.interopDefault(_indexJs37);
var _indexJs38 = require("./eachHourOfInterval/index.js");
var _indexJsDefault38 = parcelHelpers.interopDefault(_indexJs38);
var _indexJs39 = require("./eachMinuteOfInterval/index.js");
var _indexJsDefault39 = parcelHelpers.interopDefault(_indexJs39);
var _indexJs40 = require("./eachMonthOfInterval/index.js");
var _indexJsDefault40 = parcelHelpers.interopDefault(_indexJs40);
var _indexJs41 = require("./eachQuarterOfInterval/index.js");
var _indexJsDefault41 = parcelHelpers.interopDefault(_indexJs41);
var _indexJs42 = require("./eachWeekOfInterval/index.js");
var _indexJsDefault42 = parcelHelpers.interopDefault(_indexJs42);
var _indexJs43 = require("./eachWeekendOfInterval/index.js");
var _indexJsDefault43 = parcelHelpers.interopDefault(_indexJs43);
var _indexJs44 = require("./eachWeekendOfMonth/index.js");
var _indexJsDefault44 = parcelHelpers.interopDefault(_indexJs44);
var _indexJs45 = require("./eachWeekendOfYear/index.js");
var _indexJsDefault45 = parcelHelpers.interopDefault(_indexJs45);
var _indexJs46 = require("./eachYearOfInterval/index.js");
var _indexJsDefault46 = parcelHelpers.interopDefault(_indexJs46);
var _indexJs47 = require("./endOfDay/index.js");
var _indexJsDefault47 = parcelHelpers.interopDefault(_indexJs47);
var _indexJs48 = require("./endOfDecade/index.js");
var _indexJsDefault48 = parcelHelpers.interopDefault(_indexJs48);
var _indexJs49 = require("./endOfHour/index.js");
var _indexJsDefault49 = parcelHelpers.interopDefault(_indexJs49);
var _indexJs50 = require("./endOfISOWeek/index.js");
var _indexJsDefault50 = parcelHelpers.interopDefault(_indexJs50);
var _indexJs51 = require("./endOfISOWeekYear/index.js");
var _indexJsDefault51 = parcelHelpers.interopDefault(_indexJs51);
var _indexJs52 = require("./endOfMinute/index.js");
var _indexJsDefault52 = parcelHelpers.interopDefault(_indexJs52);
var _indexJs53 = require("./endOfMonth/index.js");
var _indexJsDefault53 = parcelHelpers.interopDefault(_indexJs53);
var _indexJs54 = require("./endOfQuarter/index.js");
var _indexJsDefault54 = parcelHelpers.interopDefault(_indexJs54);
var _indexJs55 = require("./endOfSecond/index.js");
var _indexJsDefault55 = parcelHelpers.interopDefault(_indexJs55);
var _indexJs56 = require("./endOfToday/index.js");
var _indexJsDefault56 = parcelHelpers.interopDefault(_indexJs56);
var _indexJs57 = require("./endOfTomorrow/index.js");
var _indexJsDefault57 = parcelHelpers.interopDefault(_indexJs57);
var _indexJs58 = require("./endOfWeek/index.js");
var _indexJsDefault58 = parcelHelpers.interopDefault(_indexJs58);
var _indexJs59 = require("./endOfYear/index.js");
var _indexJsDefault59 = parcelHelpers.interopDefault(_indexJs59);
var _indexJs60 = require("./endOfYesterday/index.js");
var _indexJsDefault60 = parcelHelpers.interopDefault(_indexJs60);
var _indexJs61 = require("./format/index.js");
var _indexJsDefault61 = parcelHelpers.interopDefault(_indexJs61);
var _indexJs62 = require("./formatDistance/index.js");
var _indexJsDefault62 = parcelHelpers.interopDefault(_indexJs62);
var _indexJs63 = require("./formatDistanceStrict/index.js");
var _indexJsDefault63 = parcelHelpers.interopDefault(_indexJs63);
var _indexJs64 = require("./formatDistanceToNow/index.js");
var _indexJsDefault64 = parcelHelpers.interopDefault(_indexJs64);
var _indexJs65 = require("./formatDistanceToNowStrict/index.js");
var _indexJsDefault65 = parcelHelpers.interopDefault(_indexJs65);
var _indexJs66 = require("./formatDuration/index.js");
var _indexJsDefault66 = parcelHelpers.interopDefault(_indexJs66);
var _indexJs67 = require("./formatISO/index.js");
var _indexJsDefault67 = parcelHelpers.interopDefault(_indexJs67);
var _indexJs68 = require("./formatISO9075/index.js");
var _indexJsDefault68 = parcelHelpers.interopDefault(_indexJs68);
var _indexJs69 = require("./formatISODuration/index.js");
var _indexJsDefault69 = parcelHelpers.interopDefault(_indexJs69);
var _indexJs70 = require("./formatRFC3339/index.js");
var _indexJsDefault70 = parcelHelpers.interopDefault(_indexJs70);
var _indexJs71 = require("./formatRFC7231/index.js");
var _indexJsDefault71 = parcelHelpers.interopDefault(_indexJs71);
var _indexJs72 = require("./formatRelative/index.js");
var _indexJsDefault72 = parcelHelpers.interopDefault(_indexJs72);
var _indexJs73 = require("./fromUnixTime/index.js");
var _indexJsDefault73 = parcelHelpers.interopDefault(_indexJs73);
var _indexJs74 = require("./getDate/index.js");
var _indexJsDefault74 = parcelHelpers.interopDefault(_indexJs74);
var _indexJs75 = require("./getDay/index.js");
var _indexJsDefault75 = parcelHelpers.interopDefault(_indexJs75);
var _indexJs76 = require("./getDayOfYear/index.js");
var _indexJsDefault76 = parcelHelpers.interopDefault(_indexJs76);
var _indexJs77 = require("./getDaysInMonth/index.js");
var _indexJsDefault77 = parcelHelpers.interopDefault(_indexJs77);
var _indexJs78 = require("./getDaysInYear/index.js");
var _indexJsDefault78 = parcelHelpers.interopDefault(_indexJs78);
var _indexJs79 = require("./getDecade/index.js");
var _indexJsDefault79 = parcelHelpers.interopDefault(_indexJs79);
var _indexJs80 = require("./getDefaultOptions/index.js");
var _indexJsDefault80 = parcelHelpers.interopDefault(_indexJs80);
var _indexJs81 = require("./getHours/index.js");
var _indexJsDefault81 = parcelHelpers.interopDefault(_indexJs81);
var _indexJs82 = require("./getISODay/index.js");
var _indexJsDefault82 = parcelHelpers.interopDefault(_indexJs82);
var _indexJs83 = require("./getISOWeek/index.js");
var _indexJsDefault83 = parcelHelpers.interopDefault(_indexJs83);
var _indexJs84 = require("./getISOWeekYear/index.js");
var _indexJsDefault84 = parcelHelpers.interopDefault(_indexJs84);
var _indexJs85 = require("./getISOWeeksInYear/index.js");
var _indexJsDefault85 = parcelHelpers.interopDefault(_indexJs85);
var _indexJs86 = require("./getMilliseconds/index.js");
var _indexJsDefault86 = parcelHelpers.interopDefault(_indexJs86);
var _indexJs87 = require("./getMinutes/index.js");
var _indexJsDefault87 = parcelHelpers.interopDefault(_indexJs87);
var _indexJs88 = require("./getMonth/index.js");
var _indexJsDefault88 = parcelHelpers.interopDefault(_indexJs88);
var _indexJs89 = require("./getOverlappingDaysInIntervals/index.js");
var _indexJsDefault89 = parcelHelpers.interopDefault(_indexJs89);
var _indexJs90 = require("./getQuarter/index.js");
var _indexJsDefault90 = parcelHelpers.interopDefault(_indexJs90);
var _indexJs91 = require("./getSeconds/index.js");
var _indexJsDefault91 = parcelHelpers.interopDefault(_indexJs91);
var _indexJs92 = require("./getTime/index.js");
var _indexJsDefault92 = parcelHelpers.interopDefault(_indexJs92);
var _indexJs93 = require("./getUnixTime/index.js");
var _indexJsDefault93 = parcelHelpers.interopDefault(_indexJs93);
var _indexJs94 = require("./getWeek/index.js");
var _indexJsDefault94 = parcelHelpers.interopDefault(_indexJs94);
var _indexJs95 = require("./getWeekOfMonth/index.js");
var _indexJsDefault95 = parcelHelpers.interopDefault(_indexJs95);
var _indexJs96 = require("./getWeekYear/index.js");
var _indexJsDefault96 = parcelHelpers.interopDefault(_indexJs96);
var _indexJs97 = require("./getWeeksInMonth/index.js");
var _indexJsDefault97 = parcelHelpers.interopDefault(_indexJs97);
var _indexJs98 = require("./getYear/index.js");
var _indexJsDefault98 = parcelHelpers.interopDefault(_indexJs98);
var _indexJs99 = require("./hoursToMilliseconds/index.js");
var _indexJsDefault99 = parcelHelpers.interopDefault(_indexJs99);
var _indexJs100 = require("./hoursToMinutes/index.js");
var _indexJsDefault100 = parcelHelpers.interopDefault(_indexJs100);
var _indexJs101 = require("./hoursToSeconds/index.js");
var _indexJsDefault101 = parcelHelpers.interopDefault(_indexJs101);
var _indexJs102 = require("./intervalToDuration/index.js");
var _indexJsDefault102 = parcelHelpers.interopDefault(_indexJs102);
var _indexJs103 = require("./intlFormat/index.js");
var _indexJsDefault103 = parcelHelpers.interopDefault(_indexJs103);
var _indexJs104 = require("./intlFormatDistance/index.js");
var _indexJsDefault104 = parcelHelpers.interopDefault(_indexJs104);
var _indexJs105 = require("./isAfter/index.js");
var _indexJsDefault105 = parcelHelpers.interopDefault(_indexJs105);
var _indexJs106 = require("./isBefore/index.js");
var _indexJsDefault106 = parcelHelpers.interopDefault(_indexJs106);
var _indexJs107 = require("./isDate/index.js");
var _indexJsDefault107 = parcelHelpers.interopDefault(_indexJs107);
var _indexJs108 = require("./isEqual/index.js");
var _indexJsDefault108 = parcelHelpers.interopDefault(_indexJs108);
var _indexJs109 = require("./isExists/index.js");
var _indexJsDefault109 = parcelHelpers.interopDefault(_indexJs109);
var _indexJs110 = require("./isFirstDayOfMonth/index.js");
var _indexJsDefault110 = parcelHelpers.interopDefault(_indexJs110);
var _indexJs111 = require("./isFriday/index.js");
var _indexJsDefault111 = parcelHelpers.interopDefault(_indexJs111);
var _indexJs112 = require("./isFuture/index.js");
var _indexJsDefault112 = parcelHelpers.interopDefault(_indexJs112);
var _indexJs113 = require("./isLastDayOfMonth/index.js");
var _indexJsDefault113 = parcelHelpers.interopDefault(_indexJs113);
var _indexJs114 = require("./isLeapYear/index.js");
var _indexJsDefault114 = parcelHelpers.interopDefault(_indexJs114);
var _indexJs115 = require("./isMatch/index.js");
var _indexJsDefault115 = parcelHelpers.interopDefault(_indexJs115);
var _indexJs116 = require("./isMonday/index.js");
var _indexJsDefault116 = parcelHelpers.interopDefault(_indexJs116);
var _indexJs117 = require("./isPast/index.js");
var _indexJsDefault117 = parcelHelpers.interopDefault(_indexJs117);
var _indexJs118 = require("./isSameDay/index.js");
var _indexJsDefault118 = parcelHelpers.interopDefault(_indexJs118);
var _indexJs119 = require("./isSameHour/index.js");
var _indexJsDefault119 = parcelHelpers.interopDefault(_indexJs119);
var _indexJs120 = require("./isSameISOWeek/index.js");
var _indexJsDefault120 = parcelHelpers.interopDefault(_indexJs120);
var _indexJs121 = require("./isSameISOWeekYear/index.js");
var _indexJsDefault121 = parcelHelpers.interopDefault(_indexJs121);
var _indexJs122 = require("./isSameMinute/index.js");
var _indexJsDefault122 = parcelHelpers.interopDefault(_indexJs122);
var _indexJs123 = require("./isSameMonth/index.js");
var _indexJsDefault123 = parcelHelpers.interopDefault(_indexJs123);
var _indexJs124 = require("./isSameQuarter/index.js");
var _indexJsDefault124 = parcelHelpers.interopDefault(_indexJs124);
var _indexJs125 = require("./isSameSecond/index.js");
var _indexJsDefault125 = parcelHelpers.interopDefault(_indexJs125);
var _indexJs126 = require("./isSameWeek/index.js");
var _indexJsDefault126 = parcelHelpers.interopDefault(_indexJs126);
var _indexJs127 = require("./isSameYear/index.js");
var _indexJsDefault127 = parcelHelpers.interopDefault(_indexJs127);
var _indexJs128 = require("./isSaturday/index.js");
var _indexJsDefault128 = parcelHelpers.interopDefault(_indexJs128);
var _indexJs129 = require("./isSunday/index.js");
var _indexJsDefault129 = parcelHelpers.interopDefault(_indexJs129);
var _indexJs130 = require("./isThisHour/index.js");
var _indexJsDefault130 = parcelHelpers.interopDefault(_indexJs130);
var _indexJs131 = require("./isThisISOWeek/index.js");
var _indexJsDefault131 = parcelHelpers.interopDefault(_indexJs131);
var _indexJs132 = require("./isThisMinute/index.js");
var _indexJsDefault132 = parcelHelpers.interopDefault(_indexJs132);
var _indexJs133 = require("./isThisMonth/index.js");
var _indexJsDefault133 = parcelHelpers.interopDefault(_indexJs133);
var _indexJs134 = require("./isThisQuarter/index.js");
var _indexJsDefault134 = parcelHelpers.interopDefault(_indexJs134);
var _indexJs135 = require("./isThisSecond/index.js");
var _indexJsDefault135 = parcelHelpers.interopDefault(_indexJs135);
var _indexJs136 = require("./isThisWeek/index.js");
var _indexJsDefault136 = parcelHelpers.interopDefault(_indexJs136);
var _indexJs137 = require("./isThisYear/index.js");
var _indexJsDefault137 = parcelHelpers.interopDefault(_indexJs137);
var _indexJs138 = require("./isThursday/index.js");
var _indexJsDefault138 = parcelHelpers.interopDefault(_indexJs138);
var _indexJs139 = require("./isToday/index.js");
var _indexJsDefault139 = parcelHelpers.interopDefault(_indexJs139);
var _indexJs140 = require("./isTomorrow/index.js");
var _indexJsDefault140 = parcelHelpers.interopDefault(_indexJs140);
var _indexJs141 = require("./isTuesday/index.js");
var _indexJsDefault141 = parcelHelpers.interopDefault(_indexJs141);
var _indexJs142 = require("./isValid/index.js");
var _indexJsDefault142 = parcelHelpers.interopDefault(_indexJs142);
var _indexJs143 = require("./isWednesday/index.js");
var _indexJsDefault143 = parcelHelpers.interopDefault(_indexJs143);
var _indexJs144 = require("./isWeekend/index.js");
var _indexJsDefault144 = parcelHelpers.interopDefault(_indexJs144);
var _indexJs145 = require("./isWithinInterval/index.js");
var _indexJsDefault145 = parcelHelpers.interopDefault(_indexJs145);
var _indexJs146 = require("./isYesterday/index.js");
var _indexJsDefault146 = parcelHelpers.interopDefault(_indexJs146);
var _indexJs147 = require("./lastDayOfDecade/index.js");
var _indexJsDefault147 = parcelHelpers.interopDefault(_indexJs147);
var _indexJs148 = require("./lastDayOfISOWeek/index.js");
var _indexJsDefault148 = parcelHelpers.interopDefault(_indexJs148);
var _indexJs149 = require("./lastDayOfISOWeekYear/index.js");
var _indexJsDefault149 = parcelHelpers.interopDefault(_indexJs149);
var _indexJs150 = require("./lastDayOfMonth/index.js");
var _indexJsDefault150 = parcelHelpers.interopDefault(_indexJs150);
var _indexJs151 = require("./lastDayOfQuarter/index.js");
var _indexJsDefault151 = parcelHelpers.interopDefault(_indexJs151);
var _indexJs152 = require("./lastDayOfWeek/index.js");
var _indexJsDefault152 = parcelHelpers.interopDefault(_indexJs152);
var _indexJs153 = require("./lastDayOfYear/index.js");
var _indexJsDefault153 = parcelHelpers.interopDefault(_indexJs153);
var _indexJs154 = require("./lightFormat/index.js");
var _indexJsDefault154 = parcelHelpers.interopDefault(_indexJs154);
var _indexJs155 = require("./max/index.js");
var _indexJsDefault155 = parcelHelpers.interopDefault(_indexJs155);
var _indexJs156 = require("./milliseconds/index.js");
var _indexJsDefault156 = parcelHelpers.interopDefault(_indexJs156);
var _indexJs157 = require("./millisecondsToHours/index.js");
var _indexJsDefault157 = parcelHelpers.interopDefault(_indexJs157);
var _indexJs158 = require("./millisecondsToMinutes/index.js");
var _indexJsDefault158 = parcelHelpers.interopDefault(_indexJs158);
var _indexJs159 = require("./millisecondsToSeconds/index.js");
var _indexJsDefault159 = parcelHelpers.interopDefault(_indexJs159);
var _indexJs160 = require("./min/index.js");
var _indexJsDefault160 = parcelHelpers.interopDefault(_indexJs160);
var _indexJs161 = require("./minutesToHours/index.js");
var _indexJsDefault161 = parcelHelpers.interopDefault(_indexJs161);
var _indexJs162 = require("./minutesToMilliseconds/index.js");
var _indexJsDefault162 = parcelHelpers.interopDefault(_indexJs162);
var _indexJs163 = require("./minutesToSeconds/index.js");
var _indexJsDefault163 = parcelHelpers.interopDefault(_indexJs163);
var _indexJs164 = require("./monthsToQuarters/index.js");
var _indexJsDefault164 = parcelHelpers.interopDefault(_indexJs164);
var _indexJs165 = require("./monthsToYears/index.js");
var _indexJsDefault165 = parcelHelpers.interopDefault(_indexJs165);
var _indexJs166 = require("./nextDay/index.js");
var _indexJsDefault166 = parcelHelpers.interopDefault(_indexJs166);
var _indexJs167 = require("./nextFriday/index.js");
var _indexJsDefault167 = parcelHelpers.interopDefault(_indexJs167);
var _indexJs168 = require("./nextMonday/index.js");
var _indexJsDefault168 = parcelHelpers.interopDefault(_indexJs168);
var _indexJs169 = require("./nextSaturday/index.js");
var _indexJsDefault169 = parcelHelpers.interopDefault(_indexJs169);
var _indexJs170 = require("./nextSunday/index.js");
var _indexJsDefault170 = parcelHelpers.interopDefault(_indexJs170);
var _indexJs171 = require("./nextThursday/index.js");
var _indexJsDefault171 = parcelHelpers.interopDefault(_indexJs171);
var _indexJs172 = require("./nextTuesday/index.js");
var _indexJsDefault172 = parcelHelpers.interopDefault(_indexJs172);
var _indexJs173 = require("./nextWednesday/index.js");
var _indexJsDefault173 = parcelHelpers.interopDefault(_indexJs173);
var _indexJs174 = require("./parse/index.js");
var _indexJsDefault174 = parcelHelpers.interopDefault(_indexJs174);
var _indexJs175 = require("./parseISO/index.js");
var _indexJsDefault175 = parcelHelpers.interopDefault(_indexJs175);
var _indexJs176 = require("./parseJSON/index.js");
var _indexJsDefault176 = parcelHelpers.interopDefault(_indexJs176);
var _indexJs177 = require("./previousDay/index.js");
var _indexJsDefault177 = parcelHelpers.interopDefault(_indexJs177);
var _indexJs178 = require("./previousFriday/index.js");
var _indexJsDefault178 = parcelHelpers.interopDefault(_indexJs178);
var _indexJs179 = require("./previousMonday/index.js");
var _indexJsDefault179 = parcelHelpers.interopDefault(_indexJs179);
var _indexJs180 = require("./previousSaturday/index.js");
var _indexJsDefault180 = parcelHelpers.interopDefault(_indexJs180);
var _indexJs181 = require("./previousSunday/index.js");
var _indexJsDefault181 = parcelHelpers.interopDefault(_indexJs181);
var _indexJs182 = require("./previousThursday/index.js");
var _indexJsDefault182 = parcelHelpers.interopDefault(_indexJs182);
var _indexJs183 = require("./previousTuesday/index.js");
var _indexJsDefault183 = parcelHelpers.interopDefault(_indexJs183);
var _indexJs184 = require("./previousWednesday/index.js");
var _indexJsDefault184 = parcelHelpers.interopDefault(_indexJs184);
var _indexJs185 = require("./quartersToMonths/index.js");
var _indexJsDefault185 = parcelHelpers.interopDefault(_indexJs185);
var _indexJs186 = require("./quartersToYears/index.js");
var _indexJsDefault186 = parcelHelpers.interopDefault(_indexJs186);
var _indexJs187 = require("./roundToNearestMinutes/index.js");
var _indexJsDefault187 = parcelHelpers.interopDefault(_indexJs187);
var _indexJs188 = require("./secondsToHours/index.js");
var _indexJsDefault188 = parcelHelpers.interopDefault(_indexJs188);
var _indexJs189 = require("./secondsToMilliseconds/index.js");
var _indexJsDefault189 = parcelHelpers.interopDefault(_indexJs189);
var _indexJs190 = require("./secondsToMinutes/index.js");
var _indexJsDefault190 = parcelHelpers.interopDefault(_indexJs190);
var _indexJs191 = require("./set/index.js");
var _indexJsDefault191 = parcelHelpers.interopDefault(_indexJs191);
var _indexJs192 = require("./setDate/index.js");
var _indexJsDefault192 = parcelHelpers.interopDefault(_indexJs192);
var _indexJs193 = require("./setDay/index.js");
var _indexJsDefault193 = parcelHelpers.interopDefault(_indexJs193);
var _indexJs194 = require("./setDayOfYear/index.js");
var _indexJsDefault194 = parcelHelpers.interopDefault(_indexJs194);
var _indexJs195 = require("./setDefaultOptions/index.js");
var _indexJsDefault195 = parcelHelpers.interopDefault(_indexJs195);
var _indexJs196 = require("./setHours/index.js");
var _indexJsDefault196 = parcelHelpers.interopDefault(_indexJs196);
var _indexJs197 = require("./setISODay/index.js");
var _indexJsDefault197 = parcelHelpers.interopDefault(_indexJs197);
var _indexJs198 = require("./setISOWeek/index.js");
var _indexJsDefault198 = parcelHelpers.interopDefault(_indexJs198);
var _indexJs199 = require("./setISOWeekYear/index.js");
var _indexJsDefault199 = parcelHelpers.interopDefault(_indexJs199);
var _indexJs200 = require("./setMilliseconds/index.js");
var _indexJsDefault200 = parcelHelpers.interopDefault(_indexJs200);
var _indexJs201 = require("./setMinutes/index.js");
var _indexJsDefault201 = parcelHelpers.interopDefault(_indexJs201);
var _indexJs202 = require("./setMonth/index.js");
var _indexJsDefault202 = parcelHelpers.interopDefault(_indexJs202);
var _indexJs203 = require("./setQuarter/index.js");
var _indexJsDefault203 = parcelHelpers.interopDefault(_indexJs203);
var _indexJs204 = require("./setSeconds/index.js");
var _indexJsDefault204 = parcelHelpers.interopDefault(_indexJs204);
var _indexJs205 = require("./setWeek/index.js");
var _indexJsDefault205 = parcelHelpers.interopDefault(_indexJs205);
var _indexJs206 = require("./setWeekYear/index.js");
var _indexJsDefault206 = parcelHelpers.interopDefault(_indexJs206);
var _indexJs207 = require("./setYear/index.js");
var _indexJsDefault207 = parcelHelpers.interopDefault(_indexJs207);
var _indexJs208 = require("./startOfDay/index.js");
var _indexJsDefault208 = parcelHelpers.interopDefault(_indexJs208);
var _indexJs209 = require("./startOfDecade/index.js");
var _indexJsDefault209 = parcelHelpers.interopDefault(_indexJs209);
var _indexJs210 = require("./startOfHour/index.js");
var _indexJsDefault210 = parcelHelpers.interopDefault(_indexJs210);
var _indexJs211 = require("./startOfISOWeek/index.js");
var _indexJsDefault211 = parcelHelpers.interopDefault(_indexJs211);
var _indexJs212 = require("./startOfISOWeekYear/index.js");
var _indexJsDefault212 = parcelHelpers.interopDefault(_indexJs212);
var _indexJs213 = require("./startOfMinute/index.js");
var _indexJsDefault213 = parcelHelpers.interopDefault(_indexJs213);
var _indexJs214 = require("./startOfMonth/index.js");
var _indexJsDefault214 = parcelHelpers.interopDefault(_indexJs214);
var _indexJs215 = require("./startOfQuarter/index.js");
var _indexJsDefault215 = parcelHelpers.interopDefault(_indexJs215);
var _indexJs216 = require("./startOfSecond/index.js");
var _indexJsDefault216 = parcelHelpers.interopDefault(_indexJs216);
var _indexJs217 = require("./startOfToday/index.js");
var _indexJsDefault217 = parcelHelpers.interopDefault(_indexJs217);
var _indexJs218 = require("./startOfTomorrow/index.js");
var _indexJsDefault218 = parcelHelpers.interopDefault(_indexJs218);
var _indexJs219 = require("./startOfWeek/index.js");
var _indexJsDefault219 = parcelHelpers.interopDefault(_indexJs219);
var _indexJs220 = require("./startOfWeekYear/index.js");
var _indexJsDefault220 = parcelHelpers.interopDefault(_indexJs220);
var _indexJs221 = require("./startOfYear/index.js");
var _indexJsDefault221 = parcelHelpers.interopDefault(_indexJs221);
var _indexJs222 = require("./startOfYesterday/index.js");
var _indexJsDefault222 = parcelHelpers.interopDefault(_indexJs222);
var _indexJs223 = require("./sub/index.js");
var _indexJsDefault223 = parcelHelpers.interopDefault(_indexJs223);
var _indexJs224 = require("./subBusinessDays/index.js");
var _indexJsDefault224 = parcelHelpers.interopDefault(_indexJs224);
var _indexJs225 = require("./subDays/index.js");
var _indexJsDefault225 = parcelHelpers.interopDefault(_indexJs225);
var _indexJs226 = require("./subHours/index.js");
var _indexJsDefault226 = parcelHelpers.interopDefault(_indexJs226);
var _indexJs227 = require("./subISOWeekYears/index.js");
var _indexJsDefault227 = parcelHelpers.interopDefault(_indexJs227);
var _indexJs228 = require("./subMilliseconds/index.js");
var _indexJsDefault228 = parcelHelpers.interopDefault(_indexJs228);
var _indexJs229 = require("./subMinutes/index.js");
var _indexJsDefault229 = parcelHelpers.interopDefault(_indexJs229);
var _indexJs230 = require("./subMonths/index.js");
var _indexJsDefault230 = parcelHelpers.interopDefault(_indexJs230);
var _indexJs231 = require("./subQuarters/index.js");
var _indexJsDefault231 = parcelHelpers.interopDefault(_indexJs231);
var _indexJs232 = require("./subSeconds/index.js");
var _indexJsDefault232 = parcelHelpers.interopDefault(_indexJs232);
var _indexJs233 = require("./subWeeks/index.js");
var _indexJsDefault233 = parcelHelpers.interopDefault(_indexJs233);
var _indexJs234 = require("./subYears/index.js");
var _indexJsDefault234 = parcelHelpers.interopDefault(_indexJs234);
var _indexJs235 = require("./toDate/index.js");
var _indexJsDefault235 = parcelHelpers.interopDefault(_indexJs235);
var _indexJs236 = require("./weeksToDays/index.js");
var _indexJsDefault236 = parcelHelpers.interopDefault(_indexJs236);
var _indexJs237 = require("./yearsToMonths/index.js");
var _indexJsDefault237 = parcelHelpers.interopDefault(_indexJs237);
var _indexJs238 = require("./yearsToQuarters/index.js");
var _indexJsDefault238 = parcelHelpers.interopDefault(_indexJs238);
var _indexJs239 = require("./constants/index.js");
parcelHelpers.exportAll(_indexJs239, exports);

},{"./add/index.js":"h7zb2","./addBusinessDays/index.js":false,"./addDays/index.js":"g6fAH","./addHours/index.js":false,"./addISOWeekYears/index.js":false,"./addMilliseconds/index.js":false,"./addMinutes/index.js":false,"./addMonths/index.js":"hES3W","./addQuarters/index.js":false,"./addSeconds/index.js":false,"./addWeeks/index.js":false,"./addYears/index.js":"g0YQq","./areIntervalsOverlapping/index.js":false,"./clamp/index.js":false,"./closestIndexTo/index.js":false,"./closestTo/index.js":false,"./compareAsc/index.js":false,"./compareDesc/index.js":false,"./daysToWeeks/index.js":false,"./differenceInBusinessDays/index.js":false,"./differenceInCalendarDays/index.js":"adZXy","./differenceInCalendarISOWeekYears/index.js":false,"./differenceInCalendarISOWeeks/index.js":false,"./differenceInCalendarMonths/index.js":false,"./differenceInCalendarQuarters/index.js":false,"./differenceInCalendarWeeks/index.js":false,"./differenceInCalendarYears/index.js":false,"./differenceInDays/index.js":false,"./differenceInHours/index.js":false,"./differenceInISOWeekYears/index.js":false,"./differenceInMilliseconds/index.js":false,"./differenceInMinutes/index.js":false,"./differenceInMonths/index.js":false,"./differenceInQuarters/index.js":false,"./differenceInSeconds/index.js":false,"./differenceInWeeks/index.js":false,"./differenceInYears/index.js":false,"./eachDayOfInterval/index.js":"a6iyr","./eachHourOfInterval/index.js":false,"./eachMinuteOfInterval/index.js":false,"./eachMonthOfInterval/index.js":false,"./eachQuarterOfInterval/index.js":false,"./eachWeekOfInterval/index.js":false,"./eachWeekendOfInterval/index.js":false,"./eachWeekendOfMonth/index.js":false,"./eachWeekendOfYear/index.js":false,"./eachYearOfInterval/index.js":false,"./endOfDay/index.js":false,"./endOfDecade/index.js":false,"./endOfHour/index.js":false,"./endOfISOWeek/index.js":false,"./endOfISOWeekYear/index.js":false,"./endOfMinute/index.js":false,"./endOfMonth/index.js":false,"./endOfQuarter/index.js":false,"./endOfSecond/index.js":false,"./endOfToday/index.js":false,"./endOfTomorrow/index.js":false,"./endOfWeek/index.js":"5zQJ5","./endOfYear/index.js":false,"./endOfYesterday/index.js":false,"./format/index.js":"lnm6V","./formatDistance/index.js":false,"./formatDistanceStrict/index.js":false,"./formatDistanceToNow/index.js":false,"./formatDistanceToNowStrict/index.js":false,"./formatDuration/index.js":false,"./formatISO/index.js":false,"./formatISO9075/index.js":false,"./formatISODuration/index.js":false,"./formatRFC3339/index.js":false,"./formatRFC7231/index.js":false,"./formatRelative/index.js":false,"./fromUnixTime/index.js":false,"./getDate/index.js":false,"./getDay/index.js":"jNMnL","./getDayOfYear/index.js":false,"./getDaysInMonth/index.js":false,"./getDaysInYear/index.js":false,"./getDecade/index.js":false,"./getDefaultOptions/index.js":false,"./getHours/index.js":"k3IR8","./getISODay/index.js":false,"./getISOWeek/index.js":"hp1by","./getISOWeekYear/index.js":false,"./getISOWeeksInYear/index.js":false,"./getMilliseconds/index.js":false,"./getMinutes/index.js":"4kIX6","./getMonth/index.js":"f3U40","./getOverlappingDaysInIntervals/index.js":false,"./getQuarter/index.js":false,"./getSeconds/index.js":"cZ7mt","./getTime/index.js":false,"./getUnixTime/index.js":false,"./getWeek/index.js":false,"./getWeekOfMonth/index.js":false,"./getWeekYear/index.js":false,"./getWeeksInMonth/index.js":false,"./getYear/index.js":"U2SFP","./hoursToMilliseconds/index.js":false,"./hoursToMinutes/index.js":false,"./hoursToSeconds/index.js":false,"./intervalToDuration/index.js":false,"./intlFormat/index.js":false,"./intlFormatDistance/index.js":false,"./isAfter/index.js":"4VQv8","./isBefore/index.js":"CNBdH","./isDate/index.js":"kqNhT","./isEqual/index.js":"8JhlH","./isExists/index.js":false,"./isFirstDayOfMonth/index.js":false,"./isFriday/index.js":false,"./isFuture/index.js":false,"./isLastDayOfMonth/index.js":false,"./isLeapYear/index.js":false,"./isMatch/index.js":false,"./isMonday/index.js":false,"./isPast/index.js":false,"./isSameDay/index.js":false,"./isSameHour/index.js":false,"./isSameISOWeek/index.js":false,"./isSameISOWeekYear/index.js":false,"./isSameMinute/index.js":false,"./isSameMonth/index.js":false,"./isSameQuarter/index.js":false,"./isSameSecond/index.js":false,"./isSameWeek/index.js":false,"./isSameYear/index.js":false,"./isSaturday/index.js":false,"./isSunday/index.js":false,"./isThisHour/index.js":false,"./isThisISOWeek/index.js":false,"./isThisMinute/index.js":false,"./isThisMonth/index.js":false,"./isThisQuarter/index.js":false,"./isThisSecond/index.js":false,"./isThisWeek/index.js":false,"./isThisYear/index.js":false,"./isThursday/index.js":false,"./isToday/index.js":false,"./isTomorrow/index.js":false,"./isTuesday/index.js":false,"./isValid/index.js":"eXoMl","./isWednesday/index.js":false,"./isWeekend/index.js":false,"./isWithinInterval/index.js":false,"./isYesterday/index.js":false,"./lastDayOfDecade/index.js":false,"./lastDayOfISOWeek/index.js":false,"./lastDayOfISOWeekYear/index.js":false,"./lastDayOfMonth/index.js":false,"./lastDayOfQuarter/index.js":false,"./lastDayOfWeek/index.js":false,"./lastDayOfYear/index.js":false,"./lightFormat/index.js":false,"./max/index.js":false,"./milliseconds/index.js":false,"./millisecondsToHours/index.js":false,"./millisecondsToMinutes/index.js":false,"./millisecondsToSeconds/index.js":false,"./min/index.js":false,"./minutesToHours/index.js":false,"./minutesToMilliseconds/index.js":false,"./minutesToSeconds/index.js":false,"./monthsToQuarters/index.js":false,"./monthsToYears/index.js":false,"./nextDay/index.js":false,"./nextFriday/index.js":false,"./nextMonday/index.js":false,"./nextSaturday/index.js":false,"./nextSunday/index.js":false,"./nextThursday/index.js":false,"./nextTuesday/index.js":false,"./nextWednesday/index.js":false,"./parse/index.js":"kVw8O","./parseISO/index.js":"3UpeK","./parseJSON/index.js":false,"./previousDay/index.js":false,"./previousFriday/index.js":false,"./previousMonday/index.js":false,"./previousSaturday/index.js":false,"./previousSunday/index.js":false,"./previousThursday/index.js":false,"./previousTuesday/index.js":false,"./previousWednesday/index.js":false,"./quartersToMonths/index.js":false,"./quartersToYears/index.js":false,"./roundToNearestMinutes/index.js":false,"./secondsToHours/index.js":false,"./secondsToMilliseconds/index.js":false,"./secondsToMinutes/index.js":false,"./set/index.js":"lqSMT","./setDate/index.js":false,"./setDay/index.js":false,"./setDayOfYear/index.js":false,"./setDefaultOptions/index.js":false,"./setHours/index.js":"aEL1Z","./setISODay/index.js":false,"./setISOWeek/index.js":false,"./setISOWeekYear/index.js":false,"./setMilliseconds/index.js":"cAmcB","./setMinutes/index.js":"5O4xT","./setMonth/index.js":"8IC8x","./setQuarter/index.js":false,"./setSeconds/index.js":"fCMSm","./setWeek/index.js":false,"./setWeekYear/index.js":false,"./setYear/index.js":"39i1J","./startOfDay/index.js":false,"./startOfDecade/index.js":false,"./startOfHour/index.js":false,"./startOfISOWeek/index.js":false,"./startOfISOWeekYear/index.js":false,"./startOfMinute/index.js":false,"./startOfMonth/index.js":false,"./startOfQuarter/index.js":false,"./startOfSecond/index.js":false,"./startOfToday/index.js":false,"./startOfTomorrow/index.js":false,"./startOfWeek/index.js":"fD46d","./startOfWeekYear/index.js":false,"./startOfYear/index.js":false,"./startOfYesterday/index.js":false,"./sub/index.js":"lF4Wf","./subBusinessDays/index.js":false,"./subDays/index.js":false,"./subHours/index.js":false,"./subISOWeekYears/index.js":false,"./subMilliseconds/index.js":false,"./subMinutes/index.js":false,"./subMonths/index.js":"8bL71","./subQuarters/index.js":false,"./subSeconds/index.js":false,"./subWeeks/index.js":false,"./subYears/index.js":"d6aiM","./toDate/index.js":false,"./weeksToDays/index.js":false,"./yearsToMonths/index.js":false,"./yearsToQuarters/index.js":false,"./constants/index.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h7zb2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>add);
var _indexJs = require("../addDays/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../addMonths/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../toDate/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
var _indexJs3 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault3 = parcelHelpers.interopDefault(_indexJs3);
var _indexJs4 = require("../_lib/toInteger/index.js");
var _indexJsDefault4 = parcelHelpers.interopDefault(_indexJs4);
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function add(dirtyDate, duration) {
    (0, _indexJsDefault3.default)(2, arguments);
    if (!duration || _typeof(duration) !== "object") return new Date(NaN);
    var years = duration.years ? (0, _indexJsDefault4.default)(duration.years) : 0;
    var months = duration.months ? (0, _indexJsDefault4.default)(duration.months) : 0;
    var weeks = duration.weeks ? (0, _indexJsDefault4.default)(duration.weeks) : 0;
    var days = duration.days ? (0, _indexJsDefault4.default)(duration.days) : 0;
    var hours = duration.hours ? (0, _indexJsDefault4.default)(duration.hours) : 0;
    var minutes = duration.minutes ? (0, _indexJsDefault4.default)(duration.minutes) : 0;
    var seconds = duration.seconds ? (0, _indexJsDefault4.default)(duration.seconds) : 0; // Add years and months
    var date = (0, _indexJsDefault2.default)(dirtyDate);
    var dateWithMonths = months || years ? (0, _indexJsDefault1.default)(date, months + years * 12) : date; // Add weeks and days
    var dateWithDays = days || weeks ? (0, _indexJsDefault.default)(dateWithMonths, days + weeks * 7) : dateWithMonths; // Add days, hours, minutes and seconds
    var minutesToAdd = minutes + hours * 60;
    var secondsToAdd = seconds + minutesToAdd * 60;
    var msToAdd = secondsToAdd * 1000;
    var finalDate = new Date(dateWithDays.getTime() + msToAdd);
    return finalDate;
}

},{"../addDays/index.js":"g6fAH","../addMonths/index.js":"hES3W","../toDate/index.js":"fsust","../_lib/requiredArgs/index.js":"9wUgQ","../_lib/toInteger/index.js":"f7kKX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g6fAH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>addDays);
var _indexJs = require("../_lib/toInteger/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../toDate/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
function addDays(dirtyDate, dirtyAmount) {
    (0, _indexJsDefault2.default)(2, arguments);
    var date = (0, _indexJsDefault1.default)(dirtyDate);
    var amount = (0, _indexJsDefault.default)(dirtyAmount);
    if (isNaN(amount)) return new Date(NaN);
    if (!amount) // If 0 days, no-op to avoid changing times in the hour before end of DST
    return date;
    date.setDate(date.getDate() + amount);
    return date;
}

},{"../_lib/toInteger/index.js":"f7kKX","../toDate/index.js":"fsust","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f7kKX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>toInteger);
function toInteger(dirtyNumber) {
    if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) return NaN;
    var number = Number(dirtyNumber);
    if (isNaN(number)) return number;
    return number < 0 ? Math.ceil(number) : Math.floor(number);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fsust":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>toDate);
var _indexJs = require("../_lib/requiredArgs/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function toDate(argument) {
    (0, _indexJsDefault.default)(1, arguments);
    var argStr = Object.prototype.toString.call(argument); // Clone the date
    if (argument instanceof Date || _typeof(argument) === "object" && argStr === "[object Date]") // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new Date(argument.getTime());
    else if (typeof argument === "number" || argStr === "[object Number]") return new Date(argument);
    else {
        if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
            // eslint-disable-next-line no-console
            console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"); // eslint-disable-next-line no-console
            console.warn(new Error().stack);
        }
        return new Date(NaN);
    }
}

},{"../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9wUgQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>requiredArgs);
function requiredArgs(required, args) {
    if (args.length < required) throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hES3W":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>addMonths);
var _indexJs = require("../_lib/toInteger/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../toDate/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
function addMonths(dirtyDate, dirtyAmount) {
    (0, _indexJsDefault2.default)(2, arguments);
    var date = (0, _indexJsDefault1.default)(dirtyDate);
    var amount = (0, _indexJsDefault.default)(dirtyAmount);
    if (isNaN(amount)) return new Date(NaN);
    if (!amount) // If 0 months, no-op to avoid changing times in the hour before end of DST
    return date;
    var dayOfMonth = date.getDate(); // The JS Date object supports date math by accepting out-of-bounds values for
    // month, day, etc. For example, new Date(2020, 0, 0) returns 31 Dec 2019 and
    // new Date(2020, 13, 1) returns 1 Feb 2021.  This is *almost* the behavior we
    // want except that dates will wrap around the end of a month, meaning that
    // new Date(2020, 13, 31) will return 3 Mar 2021 not 28 Feb 2021 as desired. So
    // we'll default to the end of the desired month by adding 1 to the desired
    // month and using a date of 0 to back up one day to the end of the desired
    // month.
    var endOfDesiredMonth = new Date(date.getTime());
    endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
    var daysInMonth = endOfDesiredMonth.getDate();
    if (dayOfMonth >= daysInMonth) // If we're already at the end of the month, then this is the correct date
    // and we're done.
    return endOfDesiredMonth;
    else {
        // Otherwise, we now know that setting the original day-of-month value won't
        // cause an overflow, so set the desired day-of-month. Note that we can't
        // just set the date of `endOfDesiredMonth` because that object may have had
        // its time changed in the unusual case where where a DST transition was on
        // the last day of the month and its local time was in the hour skipped or
        // repeated next to a DST transition.  So we use `date` instead which is
        // guaranteed to still have the original time.
        date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
        return date;
    }
}

},{"../_lib/toInteger/index.js":"f7kKX","../toDate/index.js":"fsust","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7Tp9s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>addMilliseconds);
var _indexJs = require("../_lib/toInteger/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../toDate/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
function addMilliseconds(dirtyDate, dirtyAmount) {
    (0, _indexJsDefault2.default)(2, arguments);
    var timestamp = (0, _indexJsDefault1.default)(dirtyDate).getTime();
    var amount = (0, _indexJsDefault.default)(dirtyAmount);
    return new Date(timestamp + amount);
}

},{"../_lib/toInteger/index.js":"f7kKX","../toDate/index.js":"fsust","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g0YQq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>addYears);
var _indexJs = require("../_lib/toInteger/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../addMonths/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
function addYears(dirtyDate, dirtyAmount) {
    (0, _indexJsDefault2.default)(2, arguments);
    var amount = (0, _indexJsDefault.default)(dirtyAmount);
    return (0, _indexJsDefault1.default)(dirtyDate, amount * 12);
}

},{"../_lib/toInteger/index.js":"f7kKX","../addMonths/index.js":"hES3W","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"adZXy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>differenceInCalendarDays);
var _indexJs = require("../_lib/getTimezoneOffsetInMilliseconds/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../startOfDay/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
var MILLISECONDS_IN_DAY = 86400000;
function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
    (0, _indexJsDefault2.default)(2, arguments);
    var startOfDayLeft = (0, _indexJsDefault1.default)(dirtyDateLeft);
    var startOfDayRight = (0, _indexJsDefault1.default)(dirtyDateRight);
    var timestampLeft = startOfDayLeft.getTime() - (0, _indexJsDefault.default)(startOfDayLeft);
    var timestampRight = startOfDayRight.getTime() - (0, _indexJsDefault.default)(startOfDayRight); // Round the number of days to the nearest integer
    // because the number of milliseconds in a day is not constant
    // (e.g. it's different in the day of the daylight saving time clock shift)
    return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY);
}

},{"../_lib/getTimezoneOffsetInMilliseconds/index.js":"bc74C","../startOfDay/index.js":"4Tvs3","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bc74C":[function(require,module,exports) {
/**
 * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
 * They usually appear for dates that denote time before the timezones were introduced
 * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
 * and GMT+01:00:00 after that date)
 *
 * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
 * which would lead to incorrect calculations.
 *
 * This function returns the timezone offset in milliseconds that takes seconds in account.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getTimezoneOffsetInMilliseconds);
function getTimezoneOffsetInMilliseconds(date) {
    var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
    utcDate.setUTCFullYear(date.getFullYear());
    return date.getTime() - utcDate.getTime();
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4Tvs3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>startOfDay);
var _indexJs = require("../toDate/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
function startOfDay(dirtyDate) {
    (0, _indexJsDefault1.default)(1, arguments);
    var date = (0, _indexJsDefault.default)(dirtyDate);
    date.setHours(0, 0, 0, 0);
    return date;
}

},{"../toDate/index.js":"fsust","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a6iyr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>eachDayOfInterval);
var _indexJs = require("../toDate/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
function eachDayOfInterval(dirtyInterval, options) {
    var _options$step;
    (0, _indexJsDefault1.default)(1, arguments);
    var interval = dirtyInterval || {};
    var startDate = (0, _indexJsDefault.default)(interval.start);
    var endDate = (0, _indexJsDefault.default)(interval.end);
    var endTime = endDate.getTime(); // Throw an exception if start date is after end date or if any date is `Invalid Date`
    if (!(startDate.getTime() <= endTime)) throw new RangeError("Invalid interval");
    var dates = [];
    var currentDate = startDate;
    currentDate.setHours(0, 0, 0, 0);
    var step = Number((_options$step = options === null || options === void 0 ? void 0 : options.step) !== null && _options$step !== void 0 ? _options$step : 1);
    if (step < 1 || isNaN(step)) throw new RangeError("`options.step` must be a number greater than 1");
    while(currentDate.getTime() <= endTime){
        dates.push((0, _indexJsDefault.default)(currentDate));
        currentDate.setDate(currentDate.getDate() + step);
        currentDate.setHours(0, 0, 0, 0);
    }
    return dates;
}

},{"../toDate/index.js":"fsust","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5zQJ5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>endOfWeek);
var _indexJs = require("../_lib/defaultOptions/index.js");
var _indexJs1 = require("../toDate/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../_lib/toInteger/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs2);
var _indexJs3 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs3);
function endOfWeek(dirtyDate, options) {
    var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _indexJsDefault2.default)(1, arguments);
    var defaultOptions = (0, _indexJs.getDefaultOptions)();
    var weekStartsOn = (0, _indexJsDefault1.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    var date = (0, _indexJsDefault.default)(dirtyDate);
    var day = date.getDay();
    var diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
    date.setDate(date.getDate() + diff);
    date.setHours(23, 59, 59, 999);
    return date;
}

},{"../_lib/defaultOptions/index.js":"dWs8l","../toDate/index.js":"fsust","../_lib/toInteger/index.js":"f7kKX","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dWs8l":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getDefaultOptions", ()=>getDefaultOptions);
parcelHelpers.export(exports, "setDefaultOptions", ()=>setDefaultOptions);
var defaultOptions = {};
function getDefaultOptions() {
    return defaultOptions;
}
function setDefaultOptions(newOptions) {
    defaultOptions = newOptions;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lnm6V":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>format);
var _indexJs = require("../isValid/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../subMilliseconds/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../toDate/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
var _indexJs3 = require("../_lib/format/formatters/index.js");
var _indexJsDefault3 = parcelHelpers.interopDefault(_indexJs3);
var _indexJs4 = require("../_lib/format/longFormatters/index.js");
var _indexJsDefault4 = parcelHelpers.interopDefault(_indexJs4);
var _indexJs5 = require("../_lib/getTimezoneOffsetInMilliseconds/index.js");
var _indexJsDefault5 = parcelHelpers.interopDefault(_indexJs5);
var _indexJs6 = require("../_lib/protectedTokens/index.js");
var _indexJs7 = require("../_lib/toInteger/index.js");
var _indexJsDefault6 = parcelHelpers.interopDefault(_indexJs7);
var _indexJs8 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault7 = parcelHelpers.interopDefault(_indexJs8);
var _indexJs9 = require("../_lib/defaultOptions/index.js");
var _indexJs10 = require("../_lib/defaultLocale/index.js"); // This RegExp consists of three parts separated by `|`:
var _indexJsDefault8 = parcelHelpers.interopDefault(_indexJs10);
// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format(dirtyDate, dirtyFormatStr, options) {
    var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
    (0, _indexJsDefault7.default)(2, arguments);
    var formatStr = String(dirtyFormatStr);
    var defaultOptions = (0, _indexJs9.getDefaultOptions)();
    var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : (0, _indexJsDefault8.default);
    var firstWeekContainsDate = (0, _indexJsDefault6.default)((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN
    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    var weekStartsOn = (0, _indexJsDefault6.default)((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    if (!locale.localize) throw new RangeError("locale must contain localize property");
    if (!locale.formatLong) throw new RangeError("locale must contain formatLong property");
    var originalDate = (0, _indexJsDefault2.default)(dirtyDate);
    if (!(0, _indexJsDefault.default)(originalDate)) throw new RangeError("Invalid time value");
     // Convert the date in system timezone to the same date in UTC+00:00 timezone.
    // This ensures that when UTC functions will be implemented, locales will be compatible with them.
    // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376
    var timezoneOffset = (0, _indexJsDefault5.default)(originalDate);
    var utcDate = (0, _indexJsDefault1.default)(originalDate, timezoneOffset);
    var formatterOptions = {
        firstWeekContainsDate: firstWeekContainsDate,
        weekStartsOn: weekStartsOn,
        locale: locale,
        _originalDate: originalDate
    };
    var result = formatStr.match(longFormattingTokensRegExp).map(function(substring) {
        var firstCharacter = substring[0];
        if (firstCharacter === "p" || firstCharacter === "P") {
            var longFormatter = (0, _indexJsDefault4.default)[firstCharacter];
            return longFormatter(substring, locale.formatLong);
        }
        return substring;
    }).join("").match(formattingTokensRegExp).map(function(substring) {
        // Replace two single quote characters with one single quote character
        if (substring === "''") return "'";
        var firstCharacter = substring[0];
        if (firstCharacter === "'") return cleanEscapedString(substring);
        var formatter = (0, _indexJsDefault3.default)[firstCharacter];
        if (formatter) {
            if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && (0, _indexJs6.isProtectedWeekYearToken)(substring)) (0, _indexJs6.throwProtectedError)(substring, dirtyFormatStr, String(dirtyDate));
            if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && (0, _indexJs6.isProtectedDayOfYearToken)(substring)) (0, _indexJs6.throwProtectedError)(substring, dirtyFormatStr, String(dirtyDate));
            return formatter(utcDate, substring, locale.localize, formatterOptions);
        }
        if (firstCharacter.match(unescapedLatinCharacterRegExp)) throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
        return substring;
    }).join("");
    return result;
}
function cleanEscapedString(input) {
    var matched = input.match(escapedStringRegExp);
    if (!matched) return input;
    return matched[1].replace(doubleQuoteRegExp, "'");
}

},{"../isValid/index.js":"eXoMl","../subMilliseconds/index.js":"lL2M9","../toDate/index.js":"fsust","../_lib/format/formatters/index.js":"3cYKM","../_lib/format/longFormatters/index.js":"1ztit","../_lib/getTimezoneOffsetInMilliseconds/index.js":"bc74C","../_lib/protectedTokens/index.js":"4R0Xq","../_lib/toInteger/index.js":"f7kKX","../_lib/requiredArgs/index.js":"9wUgQ","../_lib/defaultOptions/index.js":"dWs8l","../_lib/defaultLocale/index.js":"1rVeP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eXoMl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isValid);
var _indexJs = require("../isDate/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../toDate/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
function isValid(dirtyDate) {
    (0, _indexJsDefault2.default)(1, arguments);
    if (!(0, _indexJsDefault.default)(dirtyDate) && typeof dirtyDate !== "number") return false;
    var date = (0, _indexJsDefault1.default)(dirtyDate);
    return !isNaN(Number(date));
}

},{"../isDate/index.js":"kqNhT","../toDate/index.js":"fsust","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kqNhT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isDate);
var _indexJs = require("../_lib/requiredArgs/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function isDate(value) {
    (0, _indexJsDefault.default)(1, arguments);
    return value instanceof Date || _typeof(value) === "object" && Object.prototype.toString.call(value) === "[object Date]";
}

},{"../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lL2M9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>subMilliseconds);
var _indexJs = require("../addMilliseconds/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../_lib/toInteger/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
function subMilliseconds(dirtyDate, dirtyAmount) {
    (0, _indexJsDefault1.default)(2, arguments);
    var amount = (0, _indexJsDefault2.default)(dirtyAmount);
    return (0, _indexJsDefault.default)(dirtyDate, -amount);
}

},{"../addMilliseconds/index.js":"7Tp9s","../_lib/requiredArgs/index.js":"9wUgQ","../_lib/toInteger/index.js":"f7kKX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3cYKM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("../../../_lib/getUTCDayOfYear/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../../../_lib/getUTCISOWeek/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../../../_lib/getUTCISOWeekYear/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
var _indexJs3 = require("../../../_lib/getUTCWeek/index.js");
var _indexJsDefault3 = parcelHelpers.interopDefault(_indexJs3);
var _indexJs4 = require("../../../_lib/getUTCWeekYear/index.js");
var _indexJsDefault4 = parcelHelpers.interopDefault(_indexJs4);
var _indexJs5 = require("../../addLeadingZeros/index.js");
var _indexJsDefault5 = parcelHelpers.interopDefault(_indexJs5);
var _indexJs6 = require("../lightFormatters/index.js");
var _indexJsDefault6 = parcelHelpers.interopDefault(_indexJs6);
var dayPeriodEnum = {
    am: "am",
    pm: "pm",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
};
/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
 * |  p! | Long localized time            |  P! | Long localized date            |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 * - `P` is long localized date format
 * - `p` is long localized time format
 */ var formatters = {
    // Era
    G: function G(date, token, localize) {
        var era = date.getUTCFullYear() > 0 ? 1 : 0;
        switch(token){
            // AD, BC
            case "G":
            case "GG":
            case "GGG":
                return localize.era(era, {
                    width: "abbreviated"
                });
            // A, B
            case "GGGGG":
                return localize.era(era, {
                    width: "narrow"
                });
            // Anno Domini, Before Christ
            case "GGGG":
            default:
                return localize.era(era, {
                    width: "wide"
                });
        }
    },
    // Year
    y: function y(date, token, localize) {
        // Ordinal number
        if (token === "yo") {
            var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)
            var year = signedYear > 0 ? signedYear : 1 - signedYear;
            return localize.ordinalNumber(year, {
                unit: "year"
            });
        }
        return (0, _indexJsDefault6.default).y(date, token);
    },
    // Local week-numbering year
    Y: function Y(date, token, localize, options) {
        var signedWeekYear = (0, _indexJsDefault4.default)(date, options); // Returns 1 for 1 BC (which is year 0 in JavaScript)
        var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear; // Two digit year
        if (token === "YY") {
            var twoDigitYear = weekYear % 100;
            return (0, _indexJsDefault5.default)(twoDigitYear, 2);
        } // Ordinal number
        if (token === "Yo") return localize.ordinalNumber(weekYear, {
            unit: "year"
        });
         // Padding
        return (0, _indexJsDefault5.default)(weekYear, token.length);
    },
    // ISO week-numbering year
    R: function R(date, token) {
        var isoWeekYear = (0, _indexJsDefault2.default)(date); // Padding
        return (0, _indexJsDefault5.default)(isoWeekYear, token.length);
    },
    // Extended year. This is a single number designating the year of this calendar system.
    // The main difference between `y` and `u` localizers are B.C. years:
    // | Year | `y` | `u` |
    // |------|-----|-----|
    // | AC 1 |   1 |   1 |
    // | BC 1 |   1 |   0 |
    // | BC 2 |   2 |  -1 |
    // Also `yy` always returns the last two digits of a year,
    // while `uu` pads single digit years to 2 characters and returns other years unchanged.
    u: function u(date, token) {
        var year = date.getUTCFullYear();
        return (0, _indexJsDefault5.default)(year, token.length);
    },
    // Quarter
    Q: function Q(date, token, localize) {
        var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
        switch(token){
            // 1, 2, 3, 4
            case "Q":
                return String(quarter);
            // 01, 02, 03, 04
            case "QQ":
                return (0, _indexJsDefault5.default)(quarter, 2);
            // 1st, 2nd, 3rd, 4th
            case "Qo":
                return localize.ordinalNumber(quarter, {
                    unit: "quarter"
                });
            // Q1, Q2, Q3, Q4
            case "QQQ":
                return localize.quarter(quarter, {
                    width: "abbreviated",
                    context: "formatting"
                });
            // 1, 2, 3, 4 (narrow quarter; could be not numerical)
            case "QQQQQ":
                return localize.quarter(quarter, {
                    width: "narrow",
                    context: "formatting"
                });
            // 1st quarter, 2nd quarter, ...
            case "QQQQ":
            default:
                return localize.quarter(quarter, {
                    width: "wide",
                    context: "formatting"
                });
        }
    },
    // Stand-alone quarter
    q: function q(date, token, localize) {
        var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
        switch(token){
            // 1, 2, 3, 4
            case "q":
                return String(quarter);
            // 01, 02, 03, 04
            case "qq":
                return (0, _indexJsDefault5.default)(quarter, 2);
            // 1st, 2nd, 3rd, 4th
            case "qo":
                return localize.ordinalNumber(quarter, {
                    unit: "quarter"
                });
            // Q1, Q2, Q3, Q4
            case "qqq":
                return localize.quarter(quarter, {
                    width: "abbreviated",
                    context: "standalone"
                });
            // 1, 2, 3, 4 (narrow quarter; could be not numerical)
            case "qqqqq":
                return localize.quarter(quarter, {
                    width: "narrow",
                    context: "standalone"
                });
            // 1st quarter, 2nd quarter, ...
            case "qqqq":
            default:
                return localize.quarter(quarter, {
                    width: "wide",
                    context: "standalone"
                });
        }
    },
    // Month
    M: function M(date, token, localize) {
        var month = date.getUTCMonth();
        switch(token){
            case "M":
            case "MM":
                return (0, _indexJsDefault6.default).M(date, token);
            // 1st, 2nd, ..., 12th
            case "Mo":
                return localize.ordinalNumber(month + 1, {
                    unit: "month"
                });
            // Jan, Feb, ..., Dec
            case "MMM":
                return localize.month(month, {
                    width: "abbreviated",
                    context: "formatting"
                });
            // J, F, ..., D
            case "MMMMM":
                return localize.month(month, {
                    width: "narrow",
                    context: "formatting"
                });
            // January, February, ..., December
            case "MMMM":
            default:
                return localize.month(month, {
                    width: "wide",
                    context: "formatting"
                });
        }
    },
    // Stand-alone month
    L: function L(date, token, localize) {
        var month = date.getUTCMonth();
        switch(token){
            // 1, 2, ..., 12
            case "L":
                return String(month + 1);
            // 01, 02, ..., 12
            case "LL":
                return (0, _indexJsDefault5.default)(month + 1, 2);
            // 1st, 2nd, ..., 12th
            case "Lo":
                return localize.ordinalNumber(month + 1, {
                    unit: "month"
                });
            // Jan, Feb, ..., Dec
            case "LLL":
                return localize.month(month, {
                    width: "abbreviated",
                    context: "standalone"
                });
            // J, F, ..., D
            case "LLLLL":
                return localize.month(month, {
                    width: "narrow",
                    context: "standalone"
                });
            // January, February, ..., December
            case "LLLL":
            default:
                return localize.month(month, {
                    width: "wide",
                    context: "standalone"
                });
        }
    },
    // Local week of year
    w: function w(date, token, localize, options) {
        var week = (0, _indexJsDefault3.default)(date, options);
        if (token === "wo") return localize.ordinalNumber(week, {
            unit: "week"
        });
        return (0, _indexJsDefault5.default)(week, token.length);
    },
    // ISO week of year
    I: function I(date, token, localize) {
        var isoWeek = (0, _indexJsDefault1.default)(date);
        if (token === "Io") return localize.ordinalNumber(isoWeek, {
            unit: "week"
        });
        return (0, _indexJsDefault5.default)(isoWeek, token.length);
    },
    // Day of the month
    d: function d(date, token, localize) {
        if (token === "do") return localize.ordinalNumber(date.getUTCDate(), {
            unit: "date"
        });
        return (0, _indexJsDefault6.default).d(date, token);
    },
    // Day of year
    D: function D(date, token, localize) {
        var dayOfYear = (0, _indexJsDefault.default)(date);
        if (token === "Do") return localize.ordinalNumber(dayOfYear, {
            unit: "dayOfYear"
        });
        return (0, _indexJsDefault5.default)(dayOfYear, token.length);
    },
    // Day of week
    E: function E(date, token, localize) {
        var dayOfWeek = date.getUTCDay();
        switch(token){
            // Tue
            case "E":
            case "EE":
            case "EEE":
                return localize.day(dayOfWeek, {
                    width: "abbreviated",
                    context: "formatting"
                });
            // T
            case "EEEEE":
                return localize.day(dayOfWeek, {
                    width: "narrow",
                    context: "formatting"
                });
            // Tu
            case "EEEEEE":
                return localize.day(dayOfWeek, {
                    width: "short",
                    context: "formatting"
                });
            // Tuesday
            case "EEEE":
            default:
                return localize.day(dayOfWeek, {
                    width: "wide",
                    context: "formatting"
                });
        }
    },
    // Local day of week
    e: function e(date, token, localize, options) {
        var dayOfWeek = date.getUTCDay();
        var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
        switch(token){
            // Numerical value (Nth day of week with current locale or weekStartsOn)
            case "e":
                return String(localDayOfWeek);
            // Padded numerical value
            case "ee":
                return (0, _indexJsDefault5.default)(localDayOfWeek, 2);
            // 1st, 2nd, ..., 7th
            case "eo":
                return localize.ordinalNumber(localDayOfWeek, {
                    unit: "day"
                });
            case "eee":
                return localize.day(dayOfWeek, {
                    width: "abbreviated",
                    context: "formatting"
                });
            // T
            case "eeeee":
                return localize.day(dayOfWeek, {
                    width: "narrow",
                    context: "formatting"
                });
            // Tu
            case "eeeeee":
                return localize.day(dayOfWeek, {
                    width: "short",
                    context: "formatting"
                });
            // Tuesday
            case "eeee":
            default:
                return localize.day(dayOfWeek, {
                    width: "wide",
                    context: "formatting"
                });
        }
    },
    // Stand-alone local day of week
    c: function c(date, token, localize, options) {
        var dayOfWeek = date.getUTCDay();
        var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
        switch(token){
            // Numerical value (same as in `e`)
            case "c":
                return String(localDayOfWeek);
            // Padded numerical value
            case "cc":
                return (0, _indexJsDefault5.default)(localDayOfWeek, token.length);
            // 1st, 2nd, ..., 7th
            case "co":
                return localize.ordinalNumber(localDayOfWeek, {
                    unit: "day"
                });
            case "ccc":
                return localize.day(dayOfWeek, {
                    width: "abbreviated",
                    context: "standalone"
                });
            // T
            case "ccccc":
                return localize.day(dayOfWeek, {
                    width: "narrow",
                    context: "standalone"
                });
            // Tu
            case "cccccc":
                return localize.day(dayOfWeek, {
                    width: "short",
                    context: "standalone"
                });
            // Tuesday
            case "cccc":
            default:
                return localize.day(dayOfWeek, {
                    width: "wide",
                    context: "standalone"
                });
        }
    },
    // ISO day of week
    i: function i(date, token, localize) {
        var dayOfWeek = date.getUTCDay();
        var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
        switch(token){
            // 2
            case "i":
                return String(isoDayOfWeek);
            // 02
            case "ii":
                return (0, _indexJsDefault5.default)(isoDayOfWeek, token.length);
            // 2nd
            case "io":
                return localize.ordinalNumber(isoDayOfWeek, {
                    unit: "day"
                });
            // Tue
            case "iii":
                return localize.day(dayOfWeek, {
                    width: "abbreviated",
                    context: "formatting"
                });
            // T
            case "iiiii":
                return localize.day(dayOfWeek, {
                    width: "narrow",
                    context: "formatting"
                });
            // Tu
            case "iiiiii":
                return localize.day(dayOfWeek, {
                    width: "short",
                    context: "formatting"
                });
            // Tuesday
            case "iiii":
            default:
                return localize.day(dayOfWeek, {
                    width: "wide",
                    context: "formatting"
                });
        }
    },
    // AM or PM
    a: function a(date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
        switch(token){
            case "a":
            case "aa":
                return localize.dayPeriod(dayPeriodEnumValue, {
                    width: "abbreviated",
                    context: "formatting"
                });
            case "aaa":
                return localize.dayPeriod(dayPeriodEnumValue, {
                    width: "abbreviated",
                    context: "formatting"
                }).toLowerCase();
            case "aaaaa":
                return localize.dayPeriod(dayPeriodEnumValue, {
                    width: "narrow",
                    context: "formatting"
                });
            case "aaaa":
            default:
                return localize.dayPeriod(dayPeriodEnumValue, {
                    width: "wide",
                    context: "formatting"
                });
        }
    },
    // AM, PM, midnight, noon
    b: function b(date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue;
        if (hours === 12) dayPeriodEnumValue = dayPeriodEnum.noon;
        else if (hours === 0) dayPeriodEnumValue = dayPeriodEnum.midnight;
        else dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
        switch(token){
            case "b":
            case "bb":
                return localize.dayPeriod(dayPeriodEnumValue, {
                    width: "abbreviated",
                    context: "formatting"
                });
            case "bbb":
                return localize.dayPeriod(dayPeriodEnumValue, {
                    width: "abbreviated",
                    context: "formatting"
                }).toLowerCase();
            case "bbbbb":
                return localize.dayPeriod(dayPeriodEnumValue, {
                    width: "narrow",
                    context: "formatting"
                });
            case "bbbb":
            default:
                return localize.dayPeriod(dayPeriodEnumValue, {
                    width: "wide",
                    context: "formatting"
                });
        }
    },
    // in the morning, in the afternoon, in the evening, at night
    B: function B(date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue;
        if (hours >= 17) dayPeriodEnumValue = dayPeriodEnum.evening;
        else if (hours >= 12) dayPeriodEnumValue = dayPeriodEnum.afternoon;
        else if (hours >= 4) dayPeriodEnumValue = dayPeriodEnum.morning;
        else dayPeriodEnumValue = dayPeriodEnum.night;
        switch(token){
            case "B":
            case "BB":
            case "BBB":
                return localize.dayPeriod(dayPeriodEnumValue, {
                    width: "abbreviated",
                    context: "formatting"
                });
            case "BBBBB":
                return localize.dayPeriod(dayPeriodEnumValue, {
                    width: "narrow",
                    context: "formatting"
                });
            case "BBBB":
            default:
                return localize.dayPeriod(dayPeriodEnumValue, {
                    width: "wide",
                    context: "formatting"
                });
        }
    },
    // Hour [1-12]
    h: function h(date, token, localize) {
        if (token === "ho") {
            var hours = date.getUTCHours() % 12;
            if (hours === 0) hours = 12;
            return localize.ordinalNumber(hours, {
                unit: "hour"
            });
        }
        return (0, _indexJsDefault6.default).h(date, token);
    },
    // Hour [0-23]
    H: function H(date, token, localize) {
        if (token === "Ho") return localize.ordinalNumber(date.getUTCHours(), {
            unit: "hour"
        });
        return (0, _indexJsDefault6.default).H(date, token);
    },
    // Hour [0-11]
    K: function K(date, token, localize) {
        var hours = date.getUTCHours() % 12;
        if (token === "Ko") return localize.ordinalNumber(hours, {
            unit: "hour"
        });
        return (0, _indexJsDefault5.default)(hours, token.length);
    },
    // Hour [1-24]
    k: function k(date, token, localize) {
        var hours = date.getUTCHours();
        if (hours === 0) hours = 24;
        if (token === "ko") return localize.ordinalNumber(hours, {
            unit: "hour"
        });
        return (0, _indexJsDefault5.default)(hours, token.length);
    },
    // Minute
    m: function m(date, token, localize) {
        if (token === "mo") return localize.ordinalNumber(date.getUTCMinutes(), {
            unit: "minute"
        });
        return (0, _indexJsDefault6.default).m(date, token);
    },
    // Second
    s: function s(date, token, localize) {
        if (token === "so") return localize.ordinalNumber(date.getUTCSeconds(), {
            unit: "second"
        });
        return (0, _indexJsDefault6.default).s(date, token);
    },
    // Fraction of second
    S: function S(date, token) {
        return (0, _indexJsDefault6.default).S(date, token);
    },
    // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
    X: function X(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();
        if (timezoneOffset === 0) return "Z";
        switch(token){
            // Hours and optional minutes
            case "X":
                return formatTimezoneWithOptionalMinutes(timezoneOffset);
            // Hours, minutes and optional seconds without `:` delimiter
            // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
            // so this token always has the same output as `XX`
            case "XXXX":
            case "XX":
                // Hours and minutes without `:` delimiter
                return formatTimezone(timezoneOffset);
            // Hours, minutes and optional seconds with `:` delimiter
            // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
            // so this token always has the same output as `XXX`
            case "XXXXX":
            case "XXX":
            default:
                return formatTimezone(timezoneOffset, ":");
        }
    },
    // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
    x: function x(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();
        switch(token){
            // Hours and optional minutes
            case "x":
                return formatTimezoneWithOptionalMinutes(timezoneOffset);
            // Hours, minutes and optional seconds without `:` delimiter
            // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
            // so this token always has the same output as `xx`
            case "xxxx":
            case "xx":
                // Hours and minutes without `:` delimiter
                return formatTimezone(timezoneOffset);
            // Hours, minutes and optional seconds with `:` delimiter
            // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
            // so this token always has the same output as `xxx`
            case "xxxxx":
            case "xxx":
            default:
                return formatTimezone(timezoneOffset, ":");
        }
    },
    // Timezone (GMT)
    O: function O(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();
        switch(token){
            // Short
            case "O":
            case "OO":
            case "OOO":
                return "GMT" + formatTimezoneShort(timezoneOffset, ":");
            // Long
            case "OOOO":
            default:
                return "GMT" + formatTimezone(timezoneOffset, ":");
        }
    },
    // Timezone (specific non-location)
    z: function z(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();
        switch(token){
            // Short
            case "z":
            case "zz":
            case "zzz":
                return "GMT" + formatTimezoneShort(timezoneOffset, ":");
            // Long
            case "zzzz":
            default:
                return "GMT" + formatTimezone(timezoneOffset, ":");
        }
    },
    // Seconds timestamp
    t: function t(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timestamp = Math.floor(originalDate.getTime() / 1000);
        return (0, _indexJsDefault5.default)(timestamp, token.length);
    },
    // Milliseconds timestamp
    T: function T(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timestamp = originalDate.getTime();
        return (0, _indexJsDefault5.default)(timestamp, token.length);
    }
};
function formatTimezoneShort(offset, dirtyDelimiter) {
    var sign = offset > 0 ? "-" : "+";
    var absOffset = Math.abs(offset);
    var hours = Math.floor(absOffset / 60);
    var minutes = absOffset % 60;
    if (minutes === 0) return sign + String(hours);
    var delimiter = dirtyDelimiter || "";
    return sign + String(hours) + delimiter + (0, _indexJsDefault5.default)(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
    if (offset % 60 === 0) {
        var sign = offset > 0 ? "-" : "+";
        return sign + (0, _indexJsDefault5.default)(Math.abs(offset) / 60, 2);
    }
    return formatTimezone(offset, dirtyDelimiter);
}
function formatTimezone(offset, dirtyDelimiter) {
    var delimiter = dirtyDelimiter || "";
    var sign = offset > 0 ? "-" : "+";
    var absOffset = Math.abs(offset);
    var hours = (0, _indexJsDefault5.default)(Math.floor(absOffset / 60), 2);
    var minutes = (0, _indexJsDefault5.default)(absOffset % 60, 2);
    return sign + hours + delimiter + minutes;
}
exports.default = formatters;

},{"../../../_lib/getUTCDayOfYear/index.js":"7wqIf","../../../_lib/getUTCISOWeek/index.js":"4nEkI","../../../_lib/getUTCISOWeekYear/index.js":"03QaQ","../../../_lib/getUTCWeek/index.js":"b7GgV","../../../_lib/getUTCWeekYear/index.js":"8i6st","../../addLeadingZeros/index.js":"6pP6x","../lightFormatters/index.js":"9oZiA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7wqIf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getUTCDayOfYear);
var _indexJs = require("../../toDate/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../requiredArgs/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var MILLISECONDS_IN_DAY = 86400000;
function getUTCDayOfYear(dirtyDate) {
    (0, _indexJsDefault1.default)(1, arguments);
    var date = (0, _indexJsDefault.default)(dirtyDate);
    var timestamp = date.getTime();
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
    var startOfYearTimestamp = date.getTime();
    var difference = timestamp - startOfYearTimestamp;
    return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}

},{"../../toDate/index.js":"fsust","../requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4nEkI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getUTCISOWeek);
var _indexJs = require("../../toDate/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../startOfUTCISOWeek/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../startOfUTCISOWeekYear/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
var _indexJs3 = require("../requiredArgs/index.js");
var _indexJsDefault3 = parcelHelpers.interopDefault(_indexJs3);
var MILLISECONDS_IN_WEEK = 604800000;
function getUTCISOWeek(dirtyDate) {
    (0, _indexJsDefault3.default)(1, arguments);
    var date = (0, _indexJsDefault.default)(dirtyDate);
    var diff = (0, _indexJsDefault1.default)(date).getTime() - (0, _indexJsDefault2.default)(date).getTime(); // Round the number of days to the nearest integer
    // because the number of milliseconds in a week is not constant
    // (e.g. it's different in the week of the daylight saving time clock shift)
    return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

},{"../../toDate/index.js":"fsust","../startOfUTCISOWeek/index.js":"3ta4C","../startOfUTCISOWeekYear/index.js":"4u8O6","../requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3ta4C":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>startOfUTCISOWeek);
var _indexJs = require("../../toDate/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../requiredArgs/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
function startOfUTCISOWeek(dirtyDate) {
    (0, _indexJsDefault1.default)(1, arguments);
    var weekStartsOn = 1;
    var date = (0, _indexJsDefault.default)(dirtyDate);
    var day = date.getUTCDay();
    var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    date.setUTCDate(date.getUTCDate() - diff);
    date.setUTCHours(0, 0, 0, 0);
    return date;
}

},{"../../toDate/index.js":"fsust","../requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4u8O6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>startOfUTCISOWeekYear);
var _indexJs = require("../getUTCISOWeekYear/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../startOfUTCISOWeek/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../requiredArgs/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
function startOfUTCISOWeekYear(dirtyDate) {
    (0, _indexJsDefault2.default)(1, arguments);
    var year = (0, _indexJsDefault.default)(dirtyDate);
    var fourthOfJanuary = new Date(0);
    fourthOfJanuary.setUTCFullYear(year, 0, 4);
    fourthOfJanuary.setUTCHours(0, 0, 0, 0);
    var date = (0, _indexJsDefault1.default)(fourthOfJanuary);
    return date;
}

},{"../getUTCISOWeekYear/index.js":"03QaQ","../startOfUTCISOWeek/index.js":"3ta4C","../requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"03QaQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getUTCISOWeekYear);
var _indexJs = require("../../toDate/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../requiredArgs/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../startOfUTCISOWeek/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
function getUTCISOWeekYear(dirtyDate) {
    (0, _indexJsDefault1.default)(1, arguments);
    var date = (0, _indexJsDefault.default)(dirtyDate);
    var year = date.getUTCFullYear();
    var fourthOfJanuaryOfNextYear = new Date(0);
    fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
    var startOfNextYear = (0, _indexJsDefault2.default)(fourthOfJanuaryOfNextYear);
    var fourthOfJanuaryOfThisYear = new Date(0);
    fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
    fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
    var startOfThisYear = (0, _indexJsDefault2.default)(fourthOfJanuaryOfThisYear);
    if (date.getTime() >= startOfNextYear.getTime()) return year + 1;
    else if (date.getTime() >= startOfThisYear.getTime()) return year;
    else return year - 1;
}

},{"../../toDate/index.js":"fsust","../requiredArgs/index.js":"9wUgQ","../startOfUTCISOWeek/index.js":"3ta4C","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b7GgV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getUTCWeek);
var _indexJs = require("../../toDate/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../startOfUTCWeek/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../startOfUTCWeekYear/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
var _indexJs3 = require("../requiredArgs/index.js");
var _indexJsDefault3 = parcelHelpers.interopDefault(_indexJs3);
var MILLISECONDS_IN_WEEK = 604800000;
function getUTCWeek(dirtyDate, options) {
    (0, _indexJsDefault3.default)(1, arguments);
    var date = (0, _indexJsDefault.default)(dirtyDate);
    var diff = (0, _indexJsDefault1.default)(date, options).getTime() - (0, _indexJsDefault2.default)(date, options).getTime(); // Round the number of days to the nearest integer
    // because the number of milliseconds in a week is not constant
    // (e.g. it's different in the week of the daylight saving time clock shift)
    return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

},{"../../toDate/index.js":"fsust","../startOfUTCWeek/index.js":"dDZbE","../startOfUTCWeekYear/index.js":"bJAVl","../requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dDZbE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>startOfUTCWeek);
var _indexJs = require("../../toDate/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../requiredArgs/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../toInteger/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
var _indexJs3 = require("../defaultOptions/index.js");
function startOfUTCWeek(dirtyDate, options) {
    var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _indexJsDefault1.default)(1, arguments);
    var defaultOptions = (0, _indexJs3.getDefaultOptions)();
    var weekStartsOn = (0, _indexJsDefault2.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    var date = (0, _indexJsDefault.default)(dirtyDate);
    var day = date.getUTCDay();
    var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    date.setUTCDate(date.getUTCDate() - diff);
    date.setUTCHours(0, 0, 0, 0);
    return date;
}

},{"../../toDate/index.js":"fsust","../requiredArgs/index.js":"9wUgQ","../toInteger/index.js":"f7kKX","../defaultOptions/index.js":"dWs8l","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bJAVl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>startOfUTCWeekYear);
var _indexJs = require("../getUTCWeekYear/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../requiredArgs/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../startOfUTCWeek/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
var _indexJs3 = require("../toInteger/index.js");
var _indexJsDefault3 = parcelHelpers.interopDefault(_indexJs3);
var _indexJs4 = require("../defaultOptions/index.js");
function startOfUTCWeekYear(dirtyDate, options) {
    var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _indexJsDefault1.default)(1, arguments);
    var defaultOptions = (0, _indexJs4.getDefaultOptions)();
    var firstWeekContainsDate = (0, _indexJsDefault3.default)((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
    var year = (0, _indexJsDefault.default)(dirtyDate, options);
    var firstWeek = new Date(0);
    firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
    firstWeek.setUTCHours(0, 0, 0, 0);
    var date = (0, _indexJsDefault2.default)(firstWeek, options);
    return date;
}

},{"../getUTCWeekYear/index.js":"8i6st","../requiredArgs/index.js":"9wUgQ","../startOfUTCWeek/index.js":"dDZbE","../toInteger/index.js":"f7kKX","../defaultOptions/index.js":"dWs8l","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8i6st":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getUTCWeekYear);
var _indexJs = require("../../toDate/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../requiredArgs/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../startOfUTCWeek/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
var _indexJs3 = require("../toInteger/index.js");
var _indexJsDefault3 = parcelHelpers.interopDefault(_indexJs3);
var _indexJs4 = require("../defaultOptions/index.js");
function getUTCWeekYear(dirtyDate, options) {
    var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _indexJsDefault1.default)(1, arguments);
    var date = (0, _indexJsDefault.default)(dirtyDate);
    var year = date.getUTCFullYear();
    var defaultOptions = (0, _indexJs4.getDefaultOptions)();
    var firstWeekContainsDate = (0, _indexJsDefault3.default)((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN
    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    var firstWeekOfNextYear = new Date(0);
    firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
    firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
    var startOfNextYear = (0, _indexJsDefault2.default)(firstWeekOfNextYear, options);
    var firstWeekOfThisYear = new Date(0);
    firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
    firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
    var startOfThisYear = (0, _indexJsDefault2.default)(firstWeekOfThisYear, options);
    if (date.getTime() >= startOfNextYear.getTime()) return year + 1;
    else if (date.getTime() >= startOfThisYear.getTime()) return year;
    else return year - 1;
}

},{"../../toDate/index.js":"fsust","../requiredArgs/index.js":"9wUgQ","../startOfUTCWeek/index.js":"dDZbE","../toInteger/index.js":"f7kKX","../defaultOptions/index.js":"dWs8l","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6pP6x":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>addLeadingZeros);
function addLeadingZeros(number, targetLength) {
    var sign = number < 0 ? "-" : "";
    var output = Math.abs(number).toString();
    while(output.length < targetLength)output = "0" + output;
    return sign + output;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9oZiA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("../../addLeadingZeros/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* |                                |
 * |  d  | Day of month                   |  D  |                                |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  m  | Minute                         |  M  | Month                          |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  y  | Year (abs)                     |  Y  |                                |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 */ var formatters = {
    // Year
    y: function y(date, token) {
        // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
        // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
        // |----------|-------|----|-------|-------|-------|
        // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
        // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
        // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
        // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
        // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
        var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)
        var year = signedYear > 0 ? signedYear : 1 - signedYear;
        return (0, _indexJsDefault.default)(token === "yy" ? year % 100 : year, token.length);
    },
    // Month
    M: function M(date, token) {
        var month = date.getUTCMonth();
        return token === "M" ? String(month + 1) : (0, _indexJsDefault.default)(month + 1, 2);
    },
    // Day of the month
    d: function d(date, token) {
        return (0, _indexJsDefault.default)(date.getUTCDate(), token.length);
    },
    // AM or PM
    a: function a(date, token) {
        var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
        switch(token){
            case "a":
            case "aa":
                return dayPeriodEnumValue.toUpperCase();
            case "aaa":
                return dayPeriodEnumValue;
            case "aaaaa":
                return dayPeriodEnumValue[0];
            case "aaaa":
            default:
                return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
        }
    },
    // Hour [1-12]
    h: function h(date, token) {
        return (0, _indexJsDefault.default)(date.getUTCHours() % 12 || 12, token.length);
    },
    // Hour [0-23]
    H: function H(date, token) {
        return (0, _indexJsDefault.default)(date.getUTCHours(), token.length);
    },
    // Minute
    m: function m(date, token) {
        return (0, _indexJsDefault.default)(date.getUTCMinutes(), token.length);
    },
    // Second
    s: function s(date, token) {
        return (0, _indexJsDefault.default)(date.getUTCSeconds(), token.length);
    },
    // Fraction of second
    S: function S(date, token) {
        var numberOfDigits = token.length;
        var milliseconds = date.getUTCMilliseconds();
        var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
        return (0, _indexJsDefault.default)(fractionalSeconds, token.length);
    }
};
exports.default = formatters;

},{"../../addLeadingZeros/index.js":"6pP6x","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1ztit":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var dateLongFormatter = function dateLongFormatter(pattern, formatLong) {
    switch(pattern){
        case "P":
            return formatLong.date({
                width: "short"
            });
        case "PP":
            return formatLong.date({
                width: "medium"
            });
        case "PPP":
            return formatLong.date({
                width: "long"
            });
        case "PPPP":
        default:
            return formatLong.date({
                width: "full"
            });
    }
};
var timeLongFormatter = function timeLongFormatter(pattern, formatLong) {
    switch(pattern){
        case "p":
            return formatLong.time({
                width: "short"
            });
        case "pp":
            return formatLong.time({
                width: "medium"
            });
        case "ppp":
            return formatLong.time({
                width: "long"
            });
        case "pppp":
        default:
            return formatLong.time({
                width: "full"
            });
    }
};
var dateTimeLongFormatter = function dateTimeLongFormatter(pattern, formatLong) {
    var matchResult = pattern.match(/(P+)(p+)?/) || [];
    var datePattern = matchResult[1];
    var timePattern = matchResult[2];
    if (!timePattern) return dateLongFormatter(pattern, formatLong);
    var dateTimeFormat;
    switch(datePattern){
        case "P":
            dateTimeFormat = formatLong.dateTime({
                width: "short"
            });
            break;
        case "PP":
            dateTimeFormat = formatLong.dateTime({
                width: "medium"
            });
            break;
        case "PPP":
            dateTimeFormat = formatLong.dateTime({
                width: "long"
            });
            break;
        case "PPPP":
        default:
            dateTimeFormat = formatLong.dateTime({
                width: "full"
            });
            break;
    }
    return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong)).replace("{{time}}", timeLongFormatter(timePattern, formatLong));
};
var longFormatters = {
    p: timeLongFormatter,
    P: dateTimeLongFormatter
};
exports.default = longFormatters;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4R0Xq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isProtectedDayOfYearToken", ()=>isProtectedDayOfYearToken);
parcelHelpers.export(exports, "isProtectedWeekYearToken", ()=>isProtectedWeekYearToken);
parcelHelpers.export(exports, "throwProtectedError", ()=>throwProtectedError);
var protectedDayOfYearTokens = [
    "D",
    "DD"
];
var protectedWeekYearTokens = [
    "YY",
    "YYYY"
];
function isProtectedDayOfYearToken(token) {
    return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
    return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format, input) {
    if (token === "YYYY") throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    else if (token === "YY") throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    else if (token === "D") throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    else if (token === "DD") throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1rVeP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("../../locale/en-US/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
exports.default = (0, _indexJsDefault.default);

},{"../../locale/en-US/index.js":"8XKCq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8XKCq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./_lib/formatDistance/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("./_lib/formatLong/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("./_lib/formatRelative/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
var _indexJs3 = require("./_lib/localize/index.js");
var _indexJsDefault3 = parcelHelpers.interopDefault(_indexJs3);
var _indexJs4 = require("./_lib/match/index.js");
var _indexJsDefault4 = parcelHelpers.interopDefault(_indexJs4);
/**
 * @type {Locale}
 * @category Locales
 * @summary English locale (United States).
 * @language English
 * @iso-639-2 eng
 * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
 * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
 */ var locale = {
    code: "en-US",
    formatDistance: (0, _indexJsDefault.default),
    formatLong: (0, _indexJsDefault1.default),
    formatRelative: (0, _indexJsDefault2.default),
    localize: (0, _indexJsDefault3.default),
    match: (0, _indexJsDefault4.default),
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
exports.default = locale;

},{"./_lib/formatDistance/index.js":"lLrcE","./_lib/formatLong/index.js":"cA6Xb","./_lib/formatRelative/index.js":"9QlMp","./_lib/localize/index.js":"jv1Fa","./_lib/match/index.js":"1wA2o","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lLrcE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var formatDistanceLocale = {
    lessThanXSeconds: {
        one: "less than a second",
        other: "less than {{count}} seconds"
    },
    xSeconds: {
        one: "1 second",
        other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
        one: "less than a minute",
        other: "less than {{count}} minutes"
    },
    xMinutes: {
        one: "1 minute",
        other: "{{count}} minutes"
    },
    aboutXHours: {
        one: "about 1 hour",
        other: "about {{count}} hours"
    },
    xHours: {
        one: "1 hour",
        other: "{{count}} hours"
    },
    xDays: {
        one: "1 day",
        other: "{{count}} days"
    },
    aboutXWeeks: {
        one: "about 1 week",
        other: "about {{count}} weeks"
    },
    xWeeks: {
        one: "1 week",
        other: "{{count}} weeks"
    },
    aboutXMonths: {
        one: "about 1 month",
        other: "about {{count}} months"
    },
    xMonths: {
        one: "1 month",
        other: "{{count}} months"
    },
    aboutXYears: {
        one: "about 1 year",
        other: "about {{count}} years"
    },
    xYears: {
        one: "1 year",
        other: "{{count}} years"
    },
    overXYears: {
        one: "over 1 year",
        other: "over {{count}} years"
    },
    almostXYears: {
        one: "almost 1 year",
        other: "almost {{count}} years"
    }
};
var formatDistance = function formatDistance(token, count, options) {
    var result;
    var tokenValue = formatDistanceLocale[token];
    if (typeof tokenValue === "string") result = tokenValue;
    else if (count === 1) result = tokenValue.one;
    else result = tokenValue.other.replace("{{count}}", count.toString());
    if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) return "in " + result;
        else return result + " ago";
    }
    return result;
};
exports.default = formatDistance;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cA6Xb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("../../../_lib/buildFormatLongFn/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var dateFormats = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
};
var timeFormats = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
};
var dateTimeFormats = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
var formatLong = {
    date: (0, _indexJsDefault.default)({
        formats: dateFormats,
        defaultWidth: "full"
    }),
    time: (0, _indexJsDefault.default)({
        formats: timeFormats,
        defaultWidth: "full"
    }),
    dateTime: (0, _indexJsDefault.default)({
        formats: dateTimeFormats,
        defaultWidth: "full"
    })
};
exports.default = formatLong;

},{"../../../_lib/buildFormatLongFn/index.js":"h1FGd","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h1FGd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>buildFormatLongFn);
function buildFormatLongFn(args) {
    return function() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        // TODO: Remove String()
        var width = options.width ? String(options.width) : args.defaultWidth;
        var format = args.formats[width] || args.formats[args.defaultWidth];
        return format;
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9QlMp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var formatRelativeLocale = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
};
var formatRelative = function formatRelative(token, _date, _baseDate, _options) {
    return formatRelativeLocale[token];
};
exports.default = formatRelative;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jv1Fa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("../../../_lib/buildLocalizeFn/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var eraValues = {
    narrow: [
        "B",
        "A"
    ],
    abbreviated: [
        "BC",
        "AD"
    ],
    wide: [
        "Before Christ",
        "Anno Domini"
    ]
};
var quarterValues = {
    narrow: [
        "1",
        "2",
        "3",
        "4"
    ],
    abbreviated: [
        "Q1",
        "Q2",
        "Q3",
        "Q4"
    ],
    wide: [
        "1st quarter",
        "2nd quarter",
        "3rd quarter",
        "4th quarter"
    ]
}; // Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.
var monthValues = {
    narrow: [
        "J",
        "F",
        "M",
        "A",
        "M",
        "J",
        "J",
        "A",
        "S",
        "O",
        "N",
        "D"
    ],
    abbreviated: [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
    ],
    wide: [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
    ]
};
var dayValues = {
    narrow: [
        "S",
        "M",
        "T",
        "W",
        "T",
        "F",
        "S"
    ],
    short: [
        "Su",
        "Mo",
        "Tu",
        "We",
        "Th",
        "Fr",
        "Sa"
    ],
    abbreviated: [
        "Sun",
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat"
    ],
    wide: [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
    ]
};
var dayPeriodValues = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    }
};
var formattingDayPeriodValues = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    }
};
var ordinalNumber = function ordinalNumber(dirtyNumber, _options) {
    var number = Number(dirtyNumber); // If ordinal numbers depend on context, for example,
    // if they are different for different grammatical genders,
    // use `options.unit`.
    //
    // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
    // 'day', 'hour', 'minute', 'second'.
    var rem100 = number % 100;
    if (rem100 > 20 || rem100 < 10) switch(rem100 % 10){
        case 1:
            return number + "st";
        case 2:
            return number + "nd";
        case 3:
            return number + "rd";
    }
    return number + "th";
};
var localize = {
    ordinalNumber: ordinalNumber,
    era: (0, _indexJsDefault.default)({
        values: eraValues,
        defaultWidth: "wide"
    }),
    quarter: (0, _indexJsDefault.default)({
        values: quarterValues,
        defaultWidth: "wide",
        argumentCallback: function argumentCallback(quarter) {
            return quarter - 1;
        }
    }),
    month: (0, _indexJsDefault.default)({
        values: monthValues,
        defaultWidth: "wide"
    }),
    day: (0, _indexJsDefault.default)({
        values: dayValues,
        defaultWidth: "wide"
    }),
    dayPeriod: (0, _indexJsDefault.default)({
        values: dayPeriodValues,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues,
        defaultFormattingWidth: "wide"
    })
};
exports.default = localize;

},{"../../../_lib/buildLocalizeFn/index.js":"5l2rZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5l2rZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>buildLocalizeFn);
function buildLocalizeFn(args) {
    return function(dirtyIndex, options) {
        var context = options !== null && options !== void 0 && options.context ? String(options.context) : "standalone";
        var valuesArray;
        if (context === "formatting" && args.formattingValues) {
            var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
            var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
            valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
        } else {
            var _defaultWidth = args.defaultWidth;
            var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
            valuesArray = args.values[_width] || args.values[_defaultWidth];
        }
        var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex; // @ts-ignore: For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!
        return valuesArray[index];
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1wA2o":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("../../../_lib/buildMatchFn/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../../../_lib/buildMatchPatternFn/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
    any: [
        /^b/i,
        /^(a|c)/i
    ]
};
var matchQuarterPatterns = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
    any: [
        /1/i,
        /2/i,
        /3/i,
        /4/i
    ]
};
var matchMonthPatterns = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
    narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^ja/i,
        /^f/i,
        /^mar/i,
        /^ap/i,
        /^may/i,
        /^jun/i,
        /^jul/i,
        /^au/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ]
};
var matchDayPatterns = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
    narrow: [
        /^s/i,
        /^m/i,
        /^t/i,
        /^w/i,
        /^t/i,
        /^f/i,
        /^s/i
    ],
    any: [
        /^su/i,
        /^m/i,
        /^tu/i,
        /^w/i,
        /^th/i,
        /^f/i,
        /^sa/i
    ]
};
var matchDayPeriodPatterns = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
    }
};
var match = {
    ordinalNumber: (0, _indexJsDefault1.default)({
        matchPattern: matchOrdinalNumberPattern,
        parsePattern: parseOrdinalNumberPattern,
        valueCallback: function valueCallback(value) {
            return parseInt(value, 10);
        }
    }),
    era: (0, _indexJsDefault.default)({
        matchPatterns: matchEraPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns,
        defaultParseWidth: "any"
    }),
    quarter: (0, _indexJsDefault.default)({
        matchPatterns: matchQuarterPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns,
        defaultParseWidth: "any",
        valueCallback: function valueCallback(index) {
            return index + 1;
        }
    }),
    month: (0, _indexJsDefault.default)({
        matchPatterns: matchMonthPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns,
        defaultParseWidth: "any"
    }),
    day: (0, _indexJsDefault.default)({
        matchPatterns: matchDayPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns,
        defaultParseWidth: "any"
    }),
    dayPeriod: (0, _indexJsDefault.default)({
        matchPatterns: matchDayPeriodPatterns,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns,
        defaultParseWidth: "any"
    })
};
exports.default = match;

},{"../../../_lib/buildMatchFn/index.js":"2nEf9","../../../_lib/buildMatchPatternFn/index.js":"4GjCS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2nEf9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>buildMatchFn);
function buildMatchFn(args) {
    return function(string) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var width = options.width;
        var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
        var matchResult = string.match(matchPattern);
        if (!matchResult) return null;
        var matchedString = matchResult[0];
        var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
        var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
            return pattern.test(matchedString);
        }) : findKey(parsePatterns, function(pattern) {
            return pattern.test(matchedString);
        });
        var value;
        value = args.valueCallback ? args.valueCallback(key) : key;
        value = options.valueCallback ? options.valueCallback(value) : value;
        var rest = string.slice(matchedString.length);
        return {
            value: value,
            rest: rest
        };
    };
}
function findKey(object, predicate) {
    for(var key in object){
        if (object.hasOwnProperty(key) && predicate(object[key])) return key;
    }
    return undefined;
}
function findIndex(array, predicate) {
    for(var key = 0; key < array.length; key++){
        if (predicate(array[key])) return key;
    }
    return undefined;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4GjCS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>buildMatchPatternFn);
function buildMatchPatternFn(args) {
    return function(string) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var matchResult = string.match(args.matchPattern);
        if (!matchResult) return null;
        var matchedString = matchResult[0];
        var parseResult = string.match(args.parsePattern);
        if (!parseResult) return null;
        var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
        value = options.valueCallback ? options.valueCallback(value) : value;
        var rest = string.slice(matchedString.length);
        return {
            value: value,
            rest: rest
        };
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jNMnL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getDay);
var _indexJs = require("../toDate/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
function getDay(dirtyDate) {
    (0, _indexJsDefault1.default)(1, arguments);
    var date = (0, _indexJsDefault.default)(dirtyDate);
    var day = date.getDay();
    return day;
}

},{"../toDate/index.js":"fsust","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d31S3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getDaysInMonth);
var _indexJs = require("../toDate/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
function getDaysInMonth(dirtyDate) {
    (0, _indexJsDefault1.default)(1, arguments);
    var date = (0, _indexJsDefault.default)(dirtyDate);
    var year = date.getFullYear();
    var monthIndex = date.getMonth();
    var lastDayOfMonth = new Date(0);
    lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
    lastDayOfMonth.setHours(0, 0, 0, 0);
    return lastDayOfMonth.getDate();
}

},{"../toDate/index.js":"fsust","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k3IR8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getHours);
var _indexJs = require("../toDate/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
function getHours(dirtyDate) {
    (0, _indexJsDefault1.default)(1, arguments);
    var date = (0, _indexJsDefault.default)(dirtyDate);
    var hours = date.getHours();
    return hours;
}

},{"../toDate/index.js":"fsust","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hp1by":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getISOWeek);
var _indexJs = require("../toDate/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../startOfISOWeek/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../startOfISOWeekYear/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
var _indexJs3 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault3 = parcelHelpers.interopDefault(_indexJs3);
var MILLISECONDS_IN_WEEK = 604800000;
function getISOWeek(dirtyDate) {
    (0, _indexJsDefault3.default)(1, arguments);
    var date = (0, _indexJsDefault.default)(dirtyDate);
    var diff = (0, _indexJsDefault1.default)(date).getTime() - (0, _indexJsDefault2.default)(date).getTime(); // Round the number of days to the nearest integer
    // because the number of milliseconds in a week is not constant
    // (e.g. it's different in the week of the daylight saving time clock shift)
    return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

},{"../toDate/index.js":"fsust","../startOfISOWeek/index.js":"eEFWQ","../startOfISOWeekYear/index.js":"d30Dg","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eEFWQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>startOfISOWeek);
var _indexJs = require("../startOfWeek/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
function startOfISOWeek(dirtyDate) {
    (0, _indexJsDefault1.default)(1, arguments);
    return (0, _indexJsDefault.default)(dirtyDate, {
        weekStartsOn: 1
    });
}

},{"../startOfWeek/index.js":"fD46d","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fD46d":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>startOfWeek);
var _indexJs = require("../toDate/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../_lib/toInteger/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
var _indexJs3 = require("../_lib/defaultOptions/index.js");
function startOfWeek(dirtyDate, options) {
    var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _indexJsDefault2.default)(1, arguments);
    var defaultOptions = (0, _indexJs3.getDefaultOptions)();
    var weekStartsOn = (0, _indexJsDefault1.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    var date = (0, _indexJsDefault.default)(dirtyDate);
    var day = date.getDay();
    var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    date.setDate(date.getDate() - diff);
    date.setHours(0, 0, 0, 0);
    return date;
}

},{"../toDate/index.js":"fsust","../_lib/toInteger/index.js":"f7kKX","../_lib/requiredArgs/index.js":"9wUgQ","../_lib/defaultOptions/index.js":"dWs8l","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d30Dg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>startOfISOWeekYear);
var _indexJs = require("../getISOWeekYear/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../startOfISOWeek/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
function startOfISOWeekYear(dirtyDate) {
    (0, _indexJsDefault2.default)(1, arguments);
    var year = (0, _indexJsDefault.default)(dirtyDate);
    var fourthOfJanuary = new Date(0);
    fourthOfJanuary.setFullYear(year, 0, 4);
    fourthOfJanuary.setHours(0, 0, 0, 0);
    var date = (0, _indexJsDefault1.default)(fourthOfJanuary);
    return date;
}

},{"../getISOWeekYear/index.js":"bI5NI","../startOfISOWeek/index.js":"eEFWQ","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bI5NI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getISOWeekYear);
var _indexJs = require("../toDate/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../startOfISOWeek/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
function getISOWeekYear(dirtyDate) {
    (0, _indexJsDefault2.default)(1, arguments);
    var date = (0, _indexJsDefault.default)(dirtyDate);
    var year = date.getFullYear();
    var fourthOfJanuaryOfNextYear = new Date(0);
    fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
    var startOfNextYear = (0, _indexJsDefault1.default)(fourthOfJanuaryOfNextYear);
    var fourthOfJanuaryOfThisYear = new Date(0);
    fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
    fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
    var startOfThisYear = (0, _indexJsDefault1.default)(fourthOfJanuaryOfThisYear);
    if (date.getTime() >= startOfNextYear.getTime()) return year + 1;
    else if (date.getTime() >= startOfThisYear.getTime()) return year;
    else return year - 1;
}

},{"../toDate/index.js":"fsust","../startOfISOWeek/index.js":"eEFWQ","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4kIX6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getMinutes);
var _indexJs = require("../toDate/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
function getMinutes(dirtyDate) {
    (0, _indexJsDefault1.default)(1, arguments);
    var date = (0, _indexJsDefault.default)(dirtyDate);
    var minutes = date.getMinutes();
    return minutes;
}

},{"../toDate/index.js":"fsust","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f3U40":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getMonth);
var _indexJs = require("../toDate/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
function getMonth(dirtyDate) {
    (0, _indexJsDefault1.default)(1, arguments);
    var date = (0, _indexJsDefault.default)(dirtyDate);
    var month = date.getMonth();
    return month;
}

},{"../toDate/index.js":"fsust","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cZ7mt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getSeconds);
var _indexJs = require("../toDate/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
function getSeconds(dirtyDate) {
    (0, _indexJsDefault1.default)(1, arguments);
    var date = (0, _indexJsDefault.default)(dirtyDate);
    var seconds = date.getSeconds();
    return seconds;
}

},{"../toDate/index.js":"fsust","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"U2SFP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getYear);
var _indexJs = require("../toDate/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
function getYear(dirtyDate) {
    (0, _indexJsDefault1.default)(1, arguments);
    return (0, _indexJsDefault.default)(dirtyDate).getFullYear();
}

},{"../toDate/index.js":"fsust","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4VQv8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isAfter);
var _indexJs = require("../toDate/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
function isAfter(dirtyDate, dirtyDateToCompare) {
    (0, _indexJsDefault1.default)(2, arguments);
    var date = (0, _indexJsDefault.default)(dirtyDate);
    var dateToCompare = (0, _indexJsDefault.default)(dirtyDateToCompare);
    return date.getTime() > dateToCompare.getTime();
}

},{"../toDate/index.js":"fsust","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"CNBdH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isBefore);
var _indexJs = require("../toDate/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
function isBefore(dirtyDate, dirtyDateToCompare) {
    (0, _indexJsDefault1.default)(2, arguments);
    var date = (0, _indexJsDefault.default)(dirtyDate);
    var dateToCompare = (0, _indexJsDefault.default)(dirtyDateToCompare);
    return date.getTime() < dateToCompare.getTime();
}

},{"../toDate/index.js":"fsust","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8JhlH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isEqual);
var _indexJs = require("../toDate/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
function isEqual(dirtyLeftDate, dirtyRightDate) {
    (0, _indexJsDefault1.default)(2, arguments);
    var dateLeft = (0, _indexJsDefault.default)(dirtyLeftDate);
    var dateRight = (0, _indexJsDefault.default)(dirtyRightDate);
    return dateLeft.getTime() === dateRight.getTime();
}

},{"../toDate/index.js":"fsust","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kVw8O":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>parse);
var _indexJs = require("../_lib/defaultLocale/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../subMilliseconds/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../toDate/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
var _indexJs3 = require("../_lib/assign/index.js");
var _indexJsDefault3 = parcelHelpers.interopDefault(_indexJs3);
var _indexJs4 = require("../_lib/format/longFormatters/index.js");
var _indexJsDefault4 = parcelHelpers.interopDefault(_indexJs4);
var _indexJs5 = require("../_lib/getTimezoneOffsetInMilliseconds/index.js");
var _indexJsDefault5 = parcelHelpers.interopDefault(_indexJs5);
var _indexJs6 = require("../_lib/protectedTokens/index.js");
var _indexJs7 = require("../_lib/toInteger/index.js");
var _indexJsDefault6 = parcelHelpers.interopDefault(_indexJs7);
var _indexJs8 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault7 = parcelHelpers.interopDefault(_indexJs8);
var _setterJs = require("./_lib/Setter.js");
var _indexJs9 = require("./_lib/parsers/index.js");
var _indexJs10 = require("../_lib/defaultOptions/index.js"); // This RegExp consists of three parts separated by `|`:
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = o[Symbol.iterator]();
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var notWhitespaceRegExp = /\S/;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
    var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
    (0, _indexJsDefault7.default)(3, arguments);
    var dateString = String(dirtyDateString);
    var formatString = String(dirtyFormatString);
    var defaultOptions = (0, _indexJs10.getDefaultOptions)();
    var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : (0, _indexJsDefault.default);
    if (!locale.match) throw new RangeError("locale must contain match property");
    var firstWeekContainsDate = (0, _indexJsDefault6.default)((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN
    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    var weekStartsOn = (0, _indexJsDefault6.default)((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    if (formatString === "") {
        if (dateString === "") return (0, _indexJsDefault2.default)(dirtyReferenceDate);
        else return new Date(NaN);
    }
    var subFnOptions = {
        firstWeekContainsDate: firstWeekContainsDate,
        weekStartsOn: weekStartsOn,
        locale: locale
    }; // If timezone isn't specified, it will be set to the system timezone
    var setters = [
        new (0, _setterJs.DateToSystemTimezoneSetter)()
    ];
    var tokens = formatString.match(longFormattingTokensRegExp).map(function(substring) {
        var firstCharacter = substring[0];
        if (firstCharacter in (0, _indexJsDefault4.default)) {
            var longFormatter = (0, _indexJsDefault4.default)[firstCharacter];
            return longFormatter(substring, locale.formatLong);
        }
        return substring;
    }).join("").match(formattingTokensRegExp);
    var usedTokens = [];
    var _iterator = _createForOfIteratorHelper(tokens), _step;
    try {
        var _loop = function _loop() {
            var token = _step.value;
            if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && (0, _indexJs6.isProtectedWeekYearToken)(token)) (0, _indexJs6.throwProtectedError)(token, formatString, dirtyDateString);
            if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && (0, _indexJs6.isProtectedDayOfYearToken)(token)) (0, _indexJs6.throwProtectedError)(token, formatString, dirtyDateString);
            var firstCharacter = token[0];
            var parser = (0, _indexJs9.parsers)[firstCharacter];
            if (parser) {
                var incompatibleTokens = parser.incompatibleTokens;
                if (Array.isArray(incompatibleTokens)) {
                    var incompatibleToken = usedTokens.find(function(usedToken) {
                        return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
                    });
                    if (incompatibleToken) throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
                } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
                usedTokens.push({
                    token: firstCharacter,
                    fullToken: token
                });
                var parseResult = parser.run(dateString, token, locale.match, subFnOptions);
                if (!parseResult) return {
                    v: new Date(NaN)
                };
                setters.push(parseResult.setter);
                dateString = parseResult.rest;
            } else {
                if (firstCharacter.match(unescapedLatinCharacterRegExp)) throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
                 // Replace two single quote characters with one single quote character
                if (token === "''") token = "'";
                else if (firstCharacter === "'") token = cleanEscapedString(token);
                 // Cut token from string, or, if string doesn't match the token, return Invalid Date
                if (dateString.indexOf(token) === 0) dateString = dateString.slice(token.length);
                else return {
                    v: new Date(NaN)
                };
            }
        };
        for(_iterator.s(); !(_step = _iterator.n()).done;){
            var _ret = _loop();
            if (_typeof(_ret) === "object") return _ret.v;
        } // Check if the remaining input contains something other than whitespace
    } catch (err) {
        _iterator.e(err);
    } finally{
        _iterator.f();
    }
    if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) return new Date(NaN);
    var uniquePrioritySetters = setters.map(function(setter) {
        return setter.priority;
    }).sort(function(a, b) {
        return b - a;
    }).filter(function(priority, index, array) {
        return array.indexOf(priority) === index;
    }).map(function(priority) {
        return setters.filter(function(setter) {
            return setter.priority === priority;
        }).sort(function(a, b) {
            return b.subPriority - a.subPriority;
        });
    }).map(function(setterArray) {
        return setterArray[0];
    });
    var date = (0, _indexJsDefault2.default)(dirtyReferenceDate);
    if (isNaN(date.getTime())) return new Date(NaN);
     // Convert the date in system timezone to the same date in UTC+00:00 timezone.
    var utcDate = (0, _indexJsDefault1.default)(date, (0, _indexJsDefault5.default)(date));
    var flags = {};
    var _iterator2 = _createForOfIteratorHelper(uniquePrioritySetters), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var setter = _step2.value;
            if (!setter.validate(utcDate, subFnOptions)) return new Date(NaN);
            var result = setter.set(utcDate, flags, subFnOptions); // Result is tuple (date, flags)
            if (Array.isArray(result)) {
                utcDate = result[0];
                (0, _indexJsDefault3.default)(flags, result[1]); // Result is date
            } else utcDate = result;
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
    return utcDate;
}
function cleanEscapedString(input) {
    return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}

},{"../_lib/defaultLocale/index.js":"1rVeP","../subMilliseconds/index.js":"lL2M9","../toDate/index.js":"fsust","../_lib/assign/index.js":"hBuJM","../_lib/format/longFormatters/index.js":"1ztit","../_lib/getTimezoneOffsetInMilliseconds/index.js":"bc74C","../_lib/protectedTokens/index.js":"4R0Xq","../_lib/toInteger/index.js":"f7kKX","../_lib/requiredArgs/index.js":"9wUgQ","./_lib/Setter.js":"iIumE","./_lib/parsers/index.js":"k4V8j","../_lib/defaultOptions/index.js":"dWs8l","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hBuJM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>assign);
function assign(target, object) {
    if (target == null) throw new TypeError("assign requires that input parameter not be null or undefined");
    for(var property in object)if (Object.prototype.hasOwnProperty.call(object, property)) target[property] = object[property];
    return target;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iIumE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Setter", ()=>Setter);
parcelHelpers.export(exports, "ValueSetter", ()=>ValueSetter);
parcelHelpers.export(exports, "DateToSystemTimezoneSetter", ()=>DateToSystemTimezoneSetter);
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var TIMEZONE_UNIT_PRIORITY = 10;
var Setter = /*#__PURE__*/ function() {
    function Setter() {
        _classCallCheck(this, Setter);
        _defineProperty(this, "subPriority", 0);
    }
    _createClass(Setter, [
        {
            key: "validate",
            value: function validate(_utcDate, _options) {
                return true;
            }
        }
    ]);
    return Setter;
}();
var ValueSetter = /*#__PURE__*/ function(_Setter) {
    _inherits(ValueSetter, _Setter);
    var _super = _createSuper(ValueSetter);
    function ValueSetter(value, validateValue, setValue, priority, subPriority) {
        var _this;
        _classCallCheck(this, ValueSetter);
        _this = _super.call(this);
        _this.value = value;
        _this.validateValue = validateValue;
        _this.setValue = setValue;
        _this.priority = priority;
        if (subPriority) _this.subPriority = subPriority;
        return _this;
    }
    _createClass(ValueSetter, [
        {
            key: "validate",
            value: function validate(utcDate, options) {
                return this.validateValue(utcDate, this.value, options);
            }
        },
        {
            key: "set",
            value: function set(utcDate, flags, options) {
                return this.setValue(utcDate, flags, this.value, options);
            }
        }
    ]);
    return ValueSetter;
}(Setter);
var DateToSystemTimezoneSetter = /*#__PURE__*/ function(_Setter2) {
    _inherits(DateToSystemTimezoneSetter, _Setter2);
    var _super2 = _createSuper(DateToSystemTimezoneSetter);
    function DateToSystemTimezoneSetter() {
        var _this2;
        _classCallCheck(this, DateToSystemTimezoneSetter);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this2 = _super2.call.apply(_super2, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this2), "priority", TIMEZONE_UNIT_PRIORITY);
        _defineProperty(_assertThisInitialized(_this2), "subPriority", -1);
        return _this2;
    }
    _createClass(DateToSystemTimezoneSetter, [
        {
            key: "set",
            value: function set(date, flags) {
                if (flags.timestampIsSet) return date;
                var convertedDate = new Date(0);
                convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
                convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
                return convertedDate;
            }
        }
    ]);
    return DateToSystemTimezoneSetter;
}(Setter);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k4V8j":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "parsers", ()=>parsers);
var _eraParserJs = require("./EraParser.js");
var _yearParserJs = require("./YearParser.js");
var _localWeekYearParserJs = require("./LocalWeekYearParser.js");
var _isoweekYearParserJs = require("./ISOWeekYearParser.js");
var _extendedYearParserJs = require("./ExtendedYearParser.js");
var _quarterParserJs = require("./QuarterParser.js");
var _standAloneQuarterParserJs = require("./StandAloneQuarterParser.js");
var _monthParserJs = require("./MonthParser.js");
var _standAloneMonthParserJs = require("./StandAloneMonthParser.js");
var _localWeekParserJs = require("./LocalWeekParser.js");
var _isoweekParserJs = require("./ISOWeekParser.js");
var _dateParserJs = require("./DateParser.js");
var _dayOfYearParserJs = require("./DayOfYearParser.js");
var _dayParserJs = require("./DayParser.js");
var _localDayParserJs = require("./LocalDayParser.js");
var _standAloneLocalDayParserJs = require("./StandAloneLocalDayParser.js");
var _isodayParserJs = require("./ISODayParser.js");
var _ampmparserJs = require("./AMPMParser.js");
var _ampmmidnightParserJs = require("./AMPMMidnightParser.js");
var _dayPeriodParserJs = require("./DayPeriodParser.js");
var _hour1To12ParserJs = require("./Hour1to12Parser.js");
var _hour0To23ParserJs = require("./Hour0to23Parser.js");
var _hour0To11ParserJs = require("./Hour0To11Parser.js");
var _hour1To24ParserJs = require("./Hour1To24Parser.js");
var _minuteParserJs = require("./MinuteParser.js");
var _secondParserJs = require("./SecondParser.js");
var _fractionOfSecondParserJs = require("./FractionOfSecondParser.js");
var _isotimezoneWithZParserJs = require("./ISOTimezoneWithZParser.js");
var _isotimezoneParserJs = require("./ISOTimezoneParser.js");
var _timestampSecondsParserJs = require("./TimestampSecondsParser.js");
var _timestampMillisecondsParserJs = require("./TimestampMillisecondsParser.js");
var parsers = {
    G: new (0, _eraParserJs.EraParser)(),
    y: new (0, _yearParserJs.YearParser)(),
    Y: new (0, _localWeekYearParserJs.LocalWeekYearParser)(),
    R: new (0, _isoweekYearParserJs.ISOWeekYearParser)(),
    u: new (0, _extendedYearParserJs.ExtendedYearParser)(),
    Q: new (0, _quarterParserJs.QuarterParser)(),
    q: new (0, _standAloneQuarterParserJs.StandAloneQuarterParser)(),
    M: new (0, _monthParserJs.MonthParser)(),
    L: new (0, _standAloneMonthParserJs.StandAloneMonthParser)(),
    w: new (0, _localWeekParserJs.LocalWeekParser)(),
    I: new (0, _isoweekParserJs.ISOWeekParser)(),
    d: new (0, _dateParserJs.DateParser)(),
    D: new (0, _dayOfYearParserJs.DayOfYearParser)(),
    E: new (0, _dayParserJs.DayParser)(),
    e: new (0, _localDayParserJs.LocalDayParser)(),
    c: new (0, _standAloneLocalDayParserJs.StandAloneLocalDayParser)(),
    i: new (0, _isodayParserJs.ISODayParser)(),
    a: new (0, _ampmparserJs.AMPMParser)(),
    b: new (0, _ampmmidnightParserJs.AMPMMidnightParser)(),
    B: new (0, _dayPeriodParserJs.DayPeriodParser)(),
    h: new (0, _hour1To12ParserJs.Hour1to12Parser)(),
    H: new (0, _hour0To23ParserJs.Hour0to23Parser)(),
    K: new (0, _hour0To11ParserJs.Hour0To11Parser)(),
    k: new (0, _hour1To24ParserJs.Hour1To24Parser)(),
    m: new (0, _minuteParserJs.MinuteParser)(),
    s: new (0, _secondParserJs.SecondParser)(),
    S: new (0, _fractionOfSecondParserJs.FractionOfSecondParser)(),
    X: new (0, _isotimezoneWithZParserJs.ISOTimezoneWithZParser)(),
    x: new (0, _isotimezoneParserJs.ISOTimezoneParser)(),
    t: new (0, _timestampSecondsParserJs.TimestampSecondsParser)(),
    T: new (0, _timestampMillisecondsParserJs.TimestampMillisecondsParser)()
};

},{"./EraParser.js":"aXnT0","./YearParser.js":"ahFj6","./LocalWeekYearParser.js":"65m4R","./ISOWeekYearParser.js":"6p6Sa","./ExtendedYearParser.js":"4rJp8","./QuarterParser.js":"lkQmG","./StandAloneQuarterParser.js":"9zxhy","./MonthParser.js":"7gzbd","./StandAloneMonthParser.js":"itoh7","./LocalWeekParser.js":"dcoE4","./ISOWeekParser.js":"fppkm","./DateParser.js":"lnbjC","./DayOfYearParser.js":"al32L","./DayParser.js":"aov76","./LocalDayParser.js":"hc8LA","./StandAloneLocalDayParser.js":"6igat","./ISODayParser.js":"2kwtL","./AMPMParser.js":"2zbXB","./AMPMMidnightParser.js":"jb5BD","./DayPeriodParser.js":"9kE14","./Hour1to12Parser.js":"gzNEC","./Hour0to23Parser.js":"j3kuC","./Hour0To11Parser.js":"73sgE","./Hour1To24Parser.js":"3WDRF","./MinuteParser.js":"eALta","./SecondParser.js":"1nVjx","./FractionOfSecondParser.js":"46M6Z","./ISOTimezoneWithZParser.js":"b1yp4","./ISOTimezoneParser.js":"bDXkg","./TimestampSecondsParser.js":"kPdA3","./TimestampMillisecondsParser.js":"gy8e8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aXnT0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EraParser", ()=>EraParser);
var _parserJs = require("../Parser.js");
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var EraParser = /*#__PURE__*/ function(_Parser) {
    _inherits(EraParser, _Parser);
    var _super = _createSuper(EraParser);
    function EraParser() {
        var _this;
        _classCallCheck(this, EraParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 140);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", [
            "R",
            "u",
            "t",
            "T"
        ]);
        return _this;
    }
    _createClass(EraParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    // AD, BC
                    case "G":
                    case "GG":
                    case "GGG":
                        return match.era(dateString, {
                            width: "abbreviated"
                        }) || match.era(dateString, {
                            width: "narrow"
                        });
                    // A, B
                    case "GGGGG":
                        return match.era(dateString, {
                            width: "narrow"
                        });
                    // Anno Domini, Before Christ
                    case "GGGG":
                    default:
                        return match.era(dateString, {
                            width: "wide"
                        }) || match.era(dateString, {
                            width: "abbreviated"
                        }) || match.era(dateString, {
                            width: "narrow"
                        });
                }
            }
        },
        {
            key: "set",
            value: function set(date, flags, value) {
                flags.era = value;
                date.setUTCFullYear(value, 0, 1);
                date.setUTCHours(0, 0, 0, 0);
                return date;
            }
        }
    ]);
    return EraParser;
}((0, _parserJs.Parser));

},{"../Parser.js":"eoGZr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eoGZr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Parser", ()=>Parser);
var _setterJs = require("./Setter.js");
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
var Parser = /*#__PURE__*/ function() {
    function Parser() {
        _classCallCheck(this, Parser);
    }
    _createClass(Parser, [
        {
            key: "run",
            value: function run(dateString, token, match, options) {
                var result = this.parse(dateString, token, match, options);
                if (!result) return null;
                return {
                    setter: new (0, _setterJs.ValueSetter)(result.value, this.validate, this.set, this.priority, this.subPriority),
                    rest: result.rest
                };
            }
        },
        {
            key: "validate",
            value: function validate(_utcDate, _value, _options) {
                return true;
            }
        }
    ]);
    return Parser;
}();

},{"./Setter.js":"iIumE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ahFj6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "YearParser", ()=>YearParser);
var _parserJs = require("../Parser.js");
var _utilsJs = require("../utils.js");
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var YearParser = /*#__PURE__*/ function(_Parser) {
    _inherits(YearParser, _Parser);
    var _super = _createSuper(YearParser);
    function YearParser() {
        var _this;
        _classCallCheck(this, YearParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 130);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", [
            "Y",
            "R",
            "u",
            "w",
            "I",
            "i",
            "e",
            "c",
            "t",
            "T"
        ]);
        return _this;
    }
    _createClass(YearParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                var valueCallback = function valueCallback(year) {
                    return {
                        year: year,
                        isTwoDigitYear: token === "yy"
                    };
                };
                switch(token){
                    case "y":
                        return (0, _utilsJs.mapValue)((0, _utilsJs.parseNDigits)(4, dateString), valueCallback);
                    case "yo":
                        return (0, _utilsJs.mapValue)(match.ordinalNumber(dateString, {
                            unit: "year"
                        }), valueCallback);
                    default:
                        return (0, _utilsJs.mapValue)((0, _utilsJs.parseNDigits)(token.length, dateString), valueCallback);
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value.isTwoDigitYear || value.year > 0;
            }
        },
        {
            key: "set",
            value: function set(date, flags, value) {
                var currentYear = date.getUTCFullYear();
                if (value.isTwoDigitYear) {
                    var normalizedTwoDigitYear = (0, _utilsJs.normalizeTwoDigitYear)(value.year, currentYear);
                    date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
                    date.setUTCHours(0, 0, 0, 0);
                    return date;
                }
                var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
                date.setUTCFullYear(year, 0, 1);
                date.setUTCHours(0, 0, 0, 0);
                return date;
            }
        }
    ]);
    return YearParser;
}((0, _parserJs.Parser));

},{"../Parser.js":"eoGZr","../utils.js":"d5y8M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d5y8M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mapValue", ()=>mapValue);
parcelHelpers.export(exports, "parseNumericPattern", ()=>parseNumericPattern);
parcelHelpers.export(exports, "parseTimezonePattern", ()=>parseTimezonePattern);
parcelHelpers.export(exports, "parseAnyDigitsSigned", ()=>parseAnyDigitsSigned);
parcelHelpers.export(exports, "parseNDigits", ()=>parseNDigits);
parcelHelpers.export(exports, "parseNDigitsSigned", ()=>parseNDigitsSigned);
parcelHelpers.export(exports, "dayPeriodEnumToHours", ()=>dayPeriodEnumToHours);
parcelHelpers.export(exports, "normalizeTwoDigitYear", ()=>normalizeTwoDigitYear);
parcelHelpers.export(exports, "isLeapYearIndex", ()=>isLeapYearIndex);
var _indexJs = require("../../constants/index.js");
var _constantsJs = require("./constants.js");
function mapValue(parseFnResult, mapFn) {
    if (!parseFnResult) return parseFnResult;
    return {
        value: mapFn(parseFnResult.value),
        rest: parseFnResult.rest
    };
}
function parseNumericPattern(pattern, dateString) {
    var matchResult = dateString.match(pattern);
    if (!matchResult) return null;
    return {
        value: parseInt(matchResult[0], 10),
        rest: dateString.slice(matchResult[0].length)
    };
}
function parseTimezonePattern(pattern, dateString) {
    var matchResult = dateString.match(pattern);
    if (!matchResult) return null;
     // Input is 'Z'
    if (matchResult[0] === "Z") return {
        value: 0,
        rest: dateString.slice(1)
    };
    var sign = matchResult[1] === "+" ? 1 : -1;
    var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
    var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
    var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
    return {
        value: sign * (hours * (0, _indexJs.millisecondsInHour) + minutes * (0, _indexJs.millisecondsInMinute) + seconds * (0, _indexJs.millisecondsInSecond)),
        rest: dateString.slice(matchResult[0].length)
    };
}
function parseAnyDigitsSigned(dateString) {
    return parseNumericPattern((0, _constantsJs.numericPatterns).anyDigitsSigned, dateString);
}
function parseNDigits(n, dateString) {
    switch(n){
        case 1:
            return parseNumericPattern((0, _constantsJs.numericPatterns).singleDigit, dateString);
        case 2:
            return parseNumericPattern((0, _constantsJs.numericPatterns).twoDigits, dateString);
        case 3:
            return parseNumericPattern((0, _constantsJs.numericPatterns).threeDigits, dateString);
        case 4:
            return parseNumericPattern((0, _constantsJs.numericPatterns).fourDigits, dateString);
        default:
            return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
    }
}
function parseNDigitsSigned(n, dateString) {
    switch(n){
        case 1:
            return parseNumericPattern((0, _constantsJs.numericPatterns).singleDigitSigned, dateString);
        case 2:
            return parseNumericPattern((0, _constantsJs.numericPatterns).twoDigitsSigned, dateString);
        case 3:
            return parseNumericPattern((0, _constantsJs.numericPatterns).threeDigitsSigned, dateString);
        case 4:
            return parseNumericPattern((0, _constantsJs.numericPatterns).fourDigitsSigned, dateString);
        default:
            return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
    }
}
function dayPeriodEnumToHours(dayPeriod) {
    switch(dayPeriod){
        case "morning":
            return 4;
        case "evening":
            return 17;
        case "pm":
        case "noon":
        case "afternoon":
            return 12;
        case "am":
        case "midnight":
        case "night":
        default:
            return 0;
    }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
    var isCommonEra = currentYear > 0; // Absolute number of the current year:
    // 1 -> 1 AC
    // 0 -> 1 BC
    // -1 -> 2 BC
    var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
    var result;
    if (absCurrentYear <= 50) result = twoDigitYear || 100;
    else {
        var rangeEnd = absCurrentYear + 50;
        var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
        var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
        result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
    }
    return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}

},{"../../constants/index.js":"iOhcx","./constants.js":"dtRjG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iOhcx":[function(require,module,exports) {
/**
 * Days in 1 week.
 *
 * @name daysInWeek
 * @constant
 * @type {number}
 * @default
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "daysInWeek", ()=>daysInWeek);
parcelHelpers.export(exports, "daysInYear", ()=>daysInYear);
parcelHelpers.export(exports, "maxTime", ()=>maxTime);
parcelHelpers.export(exports, "millisecondsInMinute", ()=>millisecondsInMinute);
parcelHelpers.export(exports, "millisecondsInHour", ()=>millisecondsInHour);
parcelHelpers.export(exports, "millisecondsInSecond", ()=>millisecondsInSecond);
parcelHelpers.export(exports, "minTime", ()=>minTime);
parcelHelpers.export(exports, "minutesInHour", ()=>minutesInHour);
parcelHelpers.export(exports, "monthsInQuarter", ()=>monthsInQuarter);
parcelHelpers.export(exports, "monthsInYear", ()=>monthsInYear);
parcelHelpers.export(exports, "quartersInYear", ()=>quartersInYear);
parcelHelpers.export(exports, "secondsInHour", ()=>secondsInHour);
parcelHelpers.export(exports, "secondsInMinute", ()=>secondsInMinute);
parcelHelpers.export(exports, "secondsInDay", ()=>secondsInDay);
parcelHelpers.export(exports, "secondsInWeek", ()=>secondsInWeek);
parcelHelpers.export(exports, "secondsInYear", ()=>secondsInYear);
parcelHelpers.export(exports, "secondsInMonth", ()=>secondsInMonth);
parcelHelpers.export(exports, "secondsInQuarter", ()=>secondsInQuarter);
var daysInWeek = 7;
var daysInYear = 365.2425;
var maxTime = Math.pow(10, 8) * 86400000;
var millisecondsInMinute = 60000;
var millisecondsInHour = 3600000;
var millisecondsInSecond = 1000;
var minTime = -maxTime;
var minutesInHour = 60;
var monthsInQuarter = 3;
var monthsInYear = 12;
var quartersInYear = 4;
var secondsInHour = 3600;
var secondsInMinute = 60;
var secondsInDay = secondsInHour * 24;
var secondsInWeek = secondsInDay * 7;
var secondsInYear = secondsInDay * daysInYear;
var secondsInMonth = secondsInYear / 12;
var secondsInQuarter = secondsInMonth * 3;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dtRjG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "numericPatterns", ()=>numericPatterns);
parcelHelpers.export(exports, "timezonePatterns", ()=>timezonePatterns);
var numericPatterns = {
    month: /^(1[0-2]|0?\d)/,
    // 0 to 12
    date: /^(3[0-1]|[0-2]?\d)/,
    // 0 to 31
    dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
    // 0 to 366
    week: /^(5[0-3]|[0-4]?\d)/,
    // 0 to 53
    hour23h: /^(2[0-3]|[0-1]?\d)/,
    // 0 to 23
    hour24h: /^(2[0-4]|[0-1]?\d)/,
    // 0 to 24
    hour11h: /^(1[0-1]|0?\d)/,
    // 0 to 11
    hour12h: /^(1[0-2]|0?\d)/,
    // 0 to 12
    minute: /^[0-5]?\d/,
    // 0 to 59
    second: /^[0-5]?\d/,
    // 0 to 59
    singleDigit: /^\d/,
    // 0 to 9
    twoDigits: /^\d{1,2}/,
    // 0 to 99
    threeDigits: /^\d{1,3}/,
    // 0 to 999
    fourDigits: /^\d{1,4}/,
    // 0 to 9999
    anyDigitsSigned: /^-?\d+/,
    singleDigitSigned: /^-?\d/,
    // 0 to 9, -0 to -9
    twoDigitsSigned: /^-?\d{1,2}/,
    // 0 to 99, -0 to -99
    threeDigitsSigned: /^-?\d{1,3}/,
    // 0 to 999, -0 to -999
    fourDigitsSigned: /^-?\d{1,4}/ // 0 to 9999, -0 to -9999
};
var timezonePatterns = {
    basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
    basic: /^([+-])(\d{2})(\d{2})|Z/,
    basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
    extended: /^([+-])(\d{2}):(\d{2})|Z/,
    extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"65m4R":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LocalWeekYearParser", ()=>LocalWeekYearParser);
var _parserJs = require("../Parser.js");
var _utilsJs = require("../utils.js");
var _indexJs = require("../../../_lib/getUTCWeekYear/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../../../_lib/startOfUTCWeek/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var LocalWeekYearParser = /*#__PURE__*/ function(_Parser) {
    _inherits(LocalWeekYearParser, _Parser);
    var _super = _createSuper(LocalWeekYearParser);
    function LocalWeekYearParser() {
        var _this;
        _classCallCheck(this, LocalWeekYearParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 130);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", [
            "y",
            "R",
            "u",
            "Q",
            "q",
            "M",
            "L",
            "I",
            "d",
            "D",
            "i",
            "t",
            "T"
        ]);
        return _this;
    }
    _createClass(LocalWeekYearParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                var valueCallback = function valueCallback(year) {
                    return {
                        year: year,
                        isTwoDigitYear: token === "YY"
                    };
                };
                switch(token){
                    case "Y":
                        return (0, _utilsJs.mapValue)((0, _utilsJs.parseNDigits)(4, dateString), valueCallback);
                    case "Yo":
                        return (0, _utilsJs.mapValue)(match.ordinalNumber(dateString, {
                            unit: "year"
                        }), valueCallback);
                    default:
                        return (0, _utilsJs.mapValue)((0, _utilsJs.parseNDigits)(token.length, dateString), valueCallback);
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value.isTwoDigitYear || value.year > 0;
            }
        },
        {
            key: "set",
            value: function set(date, flags, value, options) {
                var currentYear = (0, _indexJsDefault.default)(date, options);
                if (value.isTwoDigitYear) {
                    var normalizedTwoDigitYear = (0, _utilsJs.normalizeTwoDigitYear)(value.year, currentYear);
                    date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
                    date.setUTCHours(0, 0, 0, 0);
                    return (0, _indexJsDefault1.default)(date, options);
                }
                var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
                date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
                date.setUTCHours(0, 0, 0, 0);
                return (0, _indexJsDefault1.default)(date, options);
            }
        }
    ]);
    return LocalWeekYearParser;
}((0, _parserJs.Parser));

},{"../Parser.js":"eoGZr","../utils.js":"d5y8M","../../../_lib/getUTCWeekYear/index.js":"8i6st","../../../_lib/startOfUTCWeek/index.js":"dDZbE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6p6Sa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ISOWeekYearParser", ()=>ISOWeekYearParser);
var _parserJs = require("../Parser.js");
var _utilsJs = require("../utils.js");
var _indexJs = require("../../../_lib/startOfUTCISOWeek/index.js"); // ISO week-numbering year
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var ISOWeekYearParser = /*#__PURE__*/ function(_Parser) {
    _inherits(ISOWeekYearParser, _Parser);
    var _super = _createSuper(ISOWeekYearParser);
    function ISOWeekYearParser() {
        var _this;
        _classCallCheck(this, ISOWeekYearParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 130);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", [
            "G",
            "y",
            "Y",
            "u",
            "Q",
            "q",
            "M",
            "L",
            "w",
            "d",
            "D",
            "e",
            "c",
            "t",
            "T"
        ]);
        return _this;
    }
    _createClass(ISOWeekYearParser, [
        {
            key: "parse",
            value: function parse(dateString, token) {
                if (token === "R") return (0, _utilsJs.parseNDigitsSigned)(4, dateString);
                return (0, _utilsJs.parseNDigitsSigned)(token.length, dateString);
            }
        },
        {
            key: "set",
            value: function set(_date, _flags, value) {
                var firstWeekOfYear = new Date(0);
                firstWeekOfYear.setUTCFullYear(value, 0, 4);
                firstWeekOfYear.setUTCHours(0, 0, 0, 0);
                return (0, _indexJsDefault.default)(firstWeekOfYear);
            }
        }
    ]);
    return ISOWeekYearParser;
}((0, _parserJs.Parser));

},{"../Parser.js":"eoGZr","../utils.js":"d5y8M","../../../_lib/startOfUTCISOWeek/index.js":"3ta4C","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4rJp8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ExtendedYearParser", ()=>ExtendedYearParser);
var _parserJs = require("../Parser.js");
var _utilsJs = require("../utils.js");
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var ExtendedYearParser = /*#__PURE__*/ function(_Parser) {
    _inherits(ExtendedYearParser, _Parser);
    var _super = _createSuper(ExtendedYearParser);
    function ExtendedYearParser() {
        var _this;
        _classCallCheck(this, ExtendedYearParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 130);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", [
            "G",
            "y",
            "Y",
            "R",
            "w",
            "I",
            "i",
            "e",
            "c",
            "t",
            "T"
        ]);
        return _this;
    }
    _createClass(ExtendedYearParser, [
        {
            key: "parse",
            value: function parse(dateString, token) {
                if (token === "u") return (0, _utilsJs.parseNDigitsSigned)(4, dateString);
                return (0, _utilsJs.parseNDigitsSigned)(token.length, dateString);
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date.setUTCFullYear(value, 0, 1);
                date.setUTCHours(0, 0, 0, 0);
                return date;
            }
        }
    ]);
    return ExtendedYearParser;
}((0, _parserJs.Parser));

},{"../Parser.js":"eoGZr","../utils.js":"d5y8M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lkQmG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "QuarterParser", ()=>QuarterParser);
var _parserJs = require("../Parser.js");
var _utilsJs = require("../utils.js");
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var QuarterParser = /*#__PURE__*/ function(_Parser) {
    _inherits(QuarterParser, _Parser);
    var _super = _createSuper(QuarterParser);
    function QuarterParser() {
        var _this;
        _classCallCheck(this, QuarterParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 120);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", [
            "Y",
            "R",
            "q",
            "M",
            "L",
            "w",
            "I",
            "d",
            "D",
            "i",
            "e",
            "c",
            "t",
            "T"
        ]);
        return _this;
    }
    _createClass(QuarterParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    // 1, 2, 3, 4
                    case "Q":
                    case "QQ":
                        // 01, 02, 03, 04
                        return (0, _utilsJs.parseNDigits)(token.length, dateString);
                    // 1st, 2nd, 3rd, 4th
                    case "Qo":
                        return match.ordinalNumber(dateString, {
                            unit: "quarter"
                        });
                    // Q1, Q2, Q3, Q4
                    case "QQQ":
                        return match.quarter(dateString, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || match.quarter(dateString, {
                            width: "narrow",
                            context: "formatting"
                        });
                    // 1, 2, 3, 4 (narrow quarter; could be not numerical)
                    case "QQQQQ":
                        return match.quarter(dateString, {
                            width: "narrow",
                            context: "formatting"
                        });
                    // 1st quarter, 2nd quarter, ...
                    case "QQQQ":
                    default:
                        return match.quarter(dateString, {
                            width: "wide",
                            context: "formatting"
                        }) || match.quarter(dateString, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || match.quarter(dateString, {
                            width: "narrow",
                            context: "formatting"
                        });
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 1 && value <= 4;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date.setUTCMonth((value - 1) * 3, 1);
                date.setUTCHours(0, 0, 0, 0);
                return date;
            }
        }
    ]);
    return QuarterParser;
}((0, _parserJs.Parser));

},{"../Parser.js":"eoGZr","../utils.js":"d5y8M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9zxhy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "StandAloneQuarterParser", ()=>StandAloneQuarterParser);
var _parserJs = require("../Parser.js");
var _utilsJs = require("../utils.js");
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var StandAloneQuarterParser = /*#__PURE__*/ function(_Parser) {
    _inherits(StandAloneQuarterParser, _Parser);
    var _super = _createSuper(StandAloneQuarterParser);
    function StandAloneQuarterParser() {
        var _this;
        _classCallCheck(this, StandAloneQuarterParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 120);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", [
            "Y",
            "R",
            "Q",
            "M",
            "L",
            "w",
            "I",
            "d",
            "D",
            "i",
            "e",
            "c",
            "t",
            "T"
        ]);
        return _this;
    }
    _createClass(StandAloneQuarterParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    // 1, 2, 3, 4
                    case "q":
                    case "qq":
                        // 01, 02, 03, 04
                        return (0, _utilsJs.parseNDigits)(token.length, dateString);
                    // 1st, 2nd, 3rd, 4th
                    case "qo":
                        return match.ordinalNumber(dateString, {
                            unit: "quarter"
                        });
                    // Q1, Q2, Q3, Q4
                    case "qqq":
                        return match.quarter(dateString, {
                            width: "abbreviated",
                            context: "standalone"
                        }) || match.quarter(dateString, {
                            width: "narrow",
                            context: "standalone"
                        });
                    // 1, 2, 3, 4 (narrow quarter; could be not numerical)
                    case "qqqqq":
                        return match.quarter(dateString, {
                            width: "narrow",
                            context: "standalone"
                        });
                    // 1st quarter, 2nd quarter, ...
                    case "qqqq":
                    default:
                        return match.quarter(dateString, {
                            width: "wide",
                            context: "standalone"
                        }) || match.quarter(dateString, {
                            width: "abbreviated",
                            context: "standalone"
                        }) || match.quarter(dateString, {
                            width: "narrow",
                            context: "standalone"
                        });
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 1 && value <= 4;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date.setUTCMonth((value - 1) * 3, 1);
                date.setUTCHours(0, 0, 0, 0);
                return date;
            }
        }
    ]);
    return StandAloneQuarterParser;
}((0, _parserJs.Parser));

},{"../Parser.js":"eoGZr","../utils.js":"d5y8M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7gzbd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MonthParser", ()=>MonthParser);
var _utilsJs = require("../utils.js");
var _parserJs = require("../Parser.js");
var _constantsJs = require("../constants.js");
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var MonthParser = /*#__PURE__*/ function(_Parser) {
    _inherits(MonthParser, _Parser);
    var _super = _createSuper(MonthParser);
    function MonthParser() {
        var _this;
        _classCallCheck(this, MonthParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", [
            "Y",
            "R",
            "q",
            "Q",
            "L",
            "w",
            "I",
            "D",
            "i",
            "e",
            "c",
            "t",
            "T"
        ]);
        _defineProperty(_assertThisInitialized(_this), "priority", 110);
        return _this;
    }
    _createClass(MonthParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                var valueCallback = function valueCallback(value) {
                    return value - 1;
                };
                switch(token){
                    // 1, 2, ..., 12
                    case "M":
                        return (0, _utilsJs.mapValue)((0, _utilsJs.parseNumericPattern)((0, _constantsJs.numericPatterns).month, dateString), valueCallback);
                    // 01, 02, ..., 12
                    case "MM":
                        return (0, _utilsJs.mapValue)((0, _utilsJs.parseNDigits)(2, dateString), valueCallback);
                    // 1st, 2nd, ..., 12th
                    case "Mo":
                        return (0, _utilsJs.mapValue)(match.ordinalNumber(dateString, {
                            unit: "month"
                        }), valueCallback);
                    // Jan, Feb, ..., Dec
                    case "MMM":
                        return match.month(dateString, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || match.month(dateString, {
                            width: "narrow",
                            context: "formatting"
                        });
                    // J, F, ..., D
                    case "MMMMM":
                        return match.month(dateString, {
                            width: "narrow",
                            context: "formatting"
                        });
                    // January, February, ..., December
                    case "MMMM":
                    default:
                        return match.month(dateString, {
                            width: "wide",
                            context: "formatting"
                        }) || match.month(dateString, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || match.month(dateString, {
                            width: "narrow",
                            context: "formatting"
                        });
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 0 && value <= 11;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date.setUTCMonth(value, 1);
                date.setUTCHours(0, 0, 0, 0);
                return date;
            }
        }
    ]);
    return MonthParser;
}((0, _parserJs.Parser));

},{"../utils.js":"d5y8M","../Parser.js":"eoGZr","../constants.js":"dtRjG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"itoh7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "StandAloneMonthParser", ()=>StandAloneMonthParser);
var _parserJs = require("../Parser.js");
var _constantsJs = require("../constants.js");
var _utilsJs = require("../utils.js");
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var StandAloneMonthParser = /*#__PURE__*/ function(_Parser) {
    _inherits(StandAloneMonthParser, _Parser);
    var _super = _createSuper(StandAloneMonthParser);
    function StandAloneMonthParser() {
        var _this;
        _classCallCheck(this, StandAloneMonthParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 110);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", [
            "Y",
            "R",
            "q",
            "Q",
            "M",
            "w",
            "I",
            "D",
            "i",
            "e",
            "c",
            "t",
            "T"
        ]);
        return _this;
    }
    _createClass(StandAloneMonthParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                var valueCallback = function valueCallback(value) {
                    return value - 1;
                };
                switch(token){
                    // 1, 2, ..., 12
                    case "L":
                        return (0, _utilsJs.mapValue)((0, _utilsJs.parseNumericPattern)((0, _constantsJs.numericPatterns).month, dateString), valueCallback);
                    // 01, 02, ..., 12
                    case "LL":
                        return (0, _utilsJs.mapValue)((0, _utilsJs.parseNDigits)(2, dateString), valueCallback);
                    // 1st, 2nd, ..., 12th
                    case "Lo":
                        return (0, _utilsJs.mapValue)(match.ordinalNumber(dateString, {
                            unit: "month"
                        }), valueCallback);
                    // Jan, Feb, ..., Dec
                    case "LLL":
                        return match.month(dateString, {
                            width: "abbreviated",
                            context: "standalone"
                        }) || match.month(dateString, {
                            width: "narrow",
                            context: "standalone"
                        });
                    // J, F, ..., D
                    case "LLLLL":
                        return match.month(dateString, {
                            width: "narrow",
                            context: "standalone"
                        });
                    // January, February, ..., December
                    case "LLLL":
                    default:
                        return match.month(dateString, {
                            width: "wide",
                            context: "standalone"
                        }) || match.month(dateString, {
                            width: "abbreviated",
                            context: "standalone"
                        }) || match.month(dateString, {
                            width: "narrow",
                            context: "standalone"
                        });
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 0 && value <= 11;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date.setUTCMonth(value, 1);
                date.setUTCHours(0, 0, 0, 0);
                return date;
            }
        }
    ]);
    return StandAloneMonthParser;
}((0, _parserJs.Parser));

},{"../Parser.js":"eoGZr","../constants.js":"dtRjG","../utils.js":"d5y8M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dcoE4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LocalWeekParser", ()=>LocalWeekParser);
var _parserJs = require("../Parser.js");
var _constantsJs = require("../constants.js");
var _utilsJs = require("../utils.js");
var _indexJs = require("../../../_lib/setUTCWeek/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../../../_lib/startOfUTCWeek/index.js"); // Local week of year
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var LocalWeekParser = /*#__PURE__*/ function(_Parser) {
    _inherits(LocalWeekParser, _Parser);
    var _super = _createSuper(LocalWeekParser);
    function LocalWeekParser() {
        var _this;
        _classCallCheck(this, LocalWeekParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 100);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", [
            "y",
            "R",
            "u",
            "q",
            "Q",
            "M",
            "L",
            "I",
            "d",
            "D",
            "i",
            "t",
            "T"
        ]);
        return _this;
    }
    _createClass(LocalWeekParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case "w":
                        return (0, _utilsJs.parseNumericPattern)((0, _constantsJs.numericPatterns).week, dateString);
                    case "wo":
                        return match.ordinalNumber(dateString, {
                            unit: "week"
                        });
                    default:
                        return (0, _utilsJs.parseNDigits)(token.length, dateString);
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 1 && value <= 53;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value, options) {
                return (0, _indexJsDefault1.default)((0, _indexJsDefault.default)(date, value, options), options);
            }
        }
    ]);
    return LocalWeekParser;
}((0, _parserJs.Parser));

},{"../Parser.js":"eoGZr","../constants.js":"dtRjG","../utils.js":"d5y8M","../../../_lib/setUTCWeek/index.js":"knxjU","../../../_lib/startOfUTCWeek/index.js":"dDZbE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"knxjU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>setUTCWeek);
var _indexJs = require("../toInteger/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../../toDate/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../getUTCWeek/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
var _indexJs3 = require("../requiredArgs/index.js");
var _indexJsDefault3 = parcelHelpers.interopDefault(_indexJs3);
function setUTCWeek(dirtyDate, dirtyWeek, options) {
    (0, _indexJsDefault3.default)(2, arguments);
    var date = (0, _indexJsDefault1.default)(dirtyDate);
    var week = (0, _indexJsDefault.default)(dirtyWeek);
    var diff = (0, _indexJsDefault2.default)(date, options) - week;
    date.setUTCDate(date.getUTCDate() - diff * 7);
    return date;
}

},{"../toInteger/index.js":"f7kKX","../../toDate/index.js":"fsust","../getUTCWeek/index.js":"b7GgV","../requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fppkm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ISOWeekParser", ()=>ISOWeekParser);
var _parserJs = require("../Parser.js");
var _constantsJs = require("../constants.js");
var _utilsJs = require("../utils.js");
var _indexJs = require("../../../_lib/setUTCISOWeek/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../../../_lib/startOfUTCISOWeek/index.js"); // ISO week of year
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var ISOWeekParser = /*#__PURE__*/ function(_Parser) {
    _inherits(ISOWeekParser, _Parser);
    var _super = _createSuper(ISOWeekParser);
    function ISOWeekParser() {
        var _this;
        _classCallCheck(this, ISOWeekParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 100);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", [
            "y",
            "Y",
            "u",
            "q",
            "Q",
            "M",
            "L",
            "w",
            "d",
            "D",
            "e",
            "c",
            "t",
            "T"
        ]);
        return _this;
    }
    _createClass(ISOWeekParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case "I":
                        return (0, _utilsJs.parseNumericPattern)((0, _constantsJs.numericPatterns).week, dateString);
                    case "Io":
                        return match.ordinalNumber(dateString, {
                            unit: "week"
                        });
                    default:
                        return (0, _utilsJs.parseNDigits)(token.length, dateString);
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 1 && value <= 53;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                return (0, _indexJsDefault1.default)((0, _indexJsDefault.default)(date, value));
            }
        }
    ]);
    return ISOWeekParser;
}((0, _parserJs.Parser));

},{"../Parser.js":"eoGZr","../constants.js":"dtRjG","../utils.js":"d5y8M","../../../_lib/setUTCISOWeek/index.js":"7CSIN","../../../_lib/startOfUTCISOWeek/index.js":"3ta4C","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7CSIN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>setUTCISOWeek);
var _indexJs = require("../toInteger/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../../toDate/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../getUTCISOWeek/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
var _indexJs3 = require("../requiredArgs/index.js");
var _indexJsDefault3 = parcelHelpers.interopDefault(_indexJs3);
function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
    (0, _indexJsDefault3.default)(2, arguments);
    var date = (0, _indexJsDefault1.default)(dirtyDate);
    var isoWeek = (0, _indexJsDefault.default)(dirtyISOWeek);
    var diff = (0, _indexJsDefault2.default)(date) - isoWeek;
    date.setUTCDate(date.getUTCDate() - diff * 7);
    return date;
}

},{"../toInteger/index.js":"f7kKX","../../toDate/index.js":"fsust","../getUTCISOWeek/index.js":"4nEkI","../requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lnbjC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DateParser", ()=>DateParser);
var _utilsJs = require("../utils.js");
var _parserJs = require("../Parser.js");
var _constantsJs = require("../constants.js");
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var DAYS_IN_MONTH = [
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
];
var DAYS_IN_MONTH_LEAP_YEAR = [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
]; // Day of the month
var DateParser = /*#__PURE__*/ function(_Parser) {
    _inherits(DateParser, _Parser);
    var _super = _createSuper(DateParser);
    function DateParser() {
        var _this;
        _classCallCheck(this, DateParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 90);
        _defineProperty(_assertThisInitialized(_this), "subPriority", 1);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", [
            "Y",
            "R",
            "q",
            "Q",
            "w",
            "I",
            "D",
            "i",
            "e",
            "c",
            "t",
            "T"
        ]);
        return _this;
    }
    _createClass(DateParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case "d":
                        return (0, _utilsJs.parseNumericPattern)((0, _constantsJs.numericPatterns).date, dateString);
                    case "do":
                        return match.ordinalNumber(dateString, {
                            unit: "date"
                        });
                    default:
                        return (0, _utilsJs.parseNDigits)(token.length, dateString);
                }
            }
        },
        {
            key: "validate",
            value: function validate(date, value) {
                var year = date.getUTCFullYear();
                var isLeapYear = (0, _utilsJs.isLeapYearIndex)(year);
                var month = date.getUTCMonth();
                if (isLeapYear) return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
                else return value >= 1 && value <= DAYS_IN_MONTH[month];
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date.setUTCDate(value);
                date.setUTCHours(0, 0, 0, 0);
                return date;
            }
        }
    ]);
    return DateParser;
}((0, _parserJs.Parser));

},{"../utils.js":"d5y8M","../Parser.js":"eoGZr","../constants.js":"dtRjG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"al32L":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DayOfYearParser", ()=>DayOfYearParser);
var _parserJs = require("../Parser.js");
var _constantsJs = require("../constants.js");
var _utilsJs = require("../utils.js");
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var DayOfYearParser = /*#__PURE__*/ function(_Parser) {
    _inherits(DayOfYearParser, _Parser);
    var _super = _createSuper(DayOfYearParser);
    function DayOfYearParser() {
        var _this;
        _classCallCheck(this, DayOfYearParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 90);
        _defineProperty(_assertThisInitialized(_this), "subpriority", 1);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", [
            "Y",
            "R",
            "q",
            "Q",
            "M",
            "L",
            "w",
            "I",
            "d",
            "E",
            "i",
            "e",
            "c",
            "t",
            "T"
        ]);
        return _this;
    }
    _createClass(DayOfYearParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case "D":
                    case "DD":
                        return (0, _utilsJs.parseNumericPattern)((0, _constantsJs.numericPatterns).dayOfYear, dateString);
                    case "Do":
                        return match.ordinalNumber(dateString, {
                            unit: "date"
                        });
                    default:
                        return (0, _utilsJs.parseNDigits)(token.length, dateString);
                }
            }
        },
        {
            key: "validate",
            value: function validate(date, value) {
                var year = date.getUTCFullYear();
                var isLeapYear = (0, _utilsJs.isLeapYearIndex)(year);
                if (isLeapYear) return value >= 1 && value <= 366;
                else return value >= 1 && value <= 365;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date.setUTCMonth(0, value);
                date.setUTCHours(0, 0, 0, 0);
                return date;
            }
        }
    ]);
    return DayOfYearParser;
}((0, _parserJs.Parser));

},{"../Parser.js":"eoGZr","../constants.js":"dtRjG","../utils.js":"d5y8M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aov76":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DayParser", ()=>DayParser);
var _parserJs = require("../Parser.js");
var _indexJs = require("../../../_lib/setUTCDay/index.js"); // Day of week
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var DayParser = /*#__PURE__*/ function(_Parser) {
    _inherits(DayParser, _Parser);
    var _super = _createSuper(DayParser);
    function DayParser() {
        var _this;
        _classCallCheck(this, DayParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 90);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", [
            "D",
            "i",
            "e",
            "c",
            "t",
            "T"
        ]);
        return _this;
    }
    _createClass(DayParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    // Tue
                    case "E":
                    case "EE":
                    case "EEE":
                        return match.day(dateString, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || match.day(dateString, {
                            width: "short",
                            context: "formatting"
                        }) || match.day(dateString, {
                            width: "narrow",
                            context: "formatting"
                        });
                    // T
                    case "EEEEE":
                        return match.day(dateString, {
                            width: "narrow",
                            context: "formatting"
                        });
                    // Tu
                    case "EEEEEE":
                        return match.day(dateString, {
                            width: "short",
                            context: "formatting"
                        }) || match.day(dateString, {
                            width: "narrow",
                            context: "formatting"
                        });
                    // Tuesday
                    case "EEEE":
                    default:
                        return match.day(dateString, {
                            width: "wide",
                            context: "formatting"
                        }) || match.day(dateString, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || match.day(dateString, {
                            width: "short",
                            context: "formatting"
                        }) || match.day(dateString, {
                            width: "narrow",
                            context: "formatting"
                        });
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 0 && value <= 6;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value, options) {
                date = (0, _indexJsDefault.default)(date, value, options);
                date.setUTCHours(0, 0, 0, 0);
                return date;
            }
        }
    ]);
    return DayParser;
}((0, _parserJs.Parser));

},{"../Parser.js":"eoGZr","../../../_lib/setUTCDay/index.js":"gbld5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gbld5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>setUTCDay);
var _indexJs = require("../../toDate/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../requiredArgs/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../toInteger/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
var _indexJs3 = require("../defaultOptions/index.js");
function setUTCDay(dirtyDate, dirtyDay, options) {
    var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _indexJsDefault1.default)(2, arguments);
    var defaultOptions = (0, _indexJs3.getDefaultOptions)();
    var weekStartsOn = (0, _indexJsDefault2.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    var date = (0, _indexJsDefault.default)(dirtyDate);
    var day = (0, _indexJsDefault2.default)(dirtyDay);
    var currentDay = date.getUTCDay();
    var remainder = day % 7;
    var dayIndex = (remainder + 7) % 7;
    var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date;
}

},{"../../toDate/index.js":"fsust","../requiredArgs/index.js":"9wUgQ","../toInteger/index.js":"f7kKX","../defaultOptions/index.js":"dWs8l","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hc8LA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LocalDayParser", ()=>LocalDayParser);
var _parserJs = require("../Parser.js");
var _utilsJs = require("../utils.js");
var _indexJs = require("../../../_lib/setUTCDay/index.js"); // Local day of week
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var LocalDayParser = /*#__PURE__*/ function(_Parser) {
    _inherits(LocalDayParser, _Parser);
    var _super = _createSuper(LocalDayParser);
    function LocalDayParser() {
        var _this;
        _classCallCheck(this, LocalDayParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 90);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", [
            "y",
            "R",
            "u",
            "q",
            "Q",
            "M",
            "L",
            "I",
            "d",
            "D",
            "E",
            "i",
            "c",
            "t",
            "T"
        ]);
        return _this;
    }
    _createClass(LocalDayParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match, options) {
                var valueCallback = function valueCallback(value) {
                    var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
                    return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
                };
                switch(token){
                    // 3
                    case "e":
                    case "ee":
                        // 03
                        return (0, _utilsJs.mapValue)((0, _utilsJs.parseNDigits)(token.length, dateString), valueCallback);
                    // 3rd
                    case "eo":
                        return (0, _utilsJs.mapValue)(match.ordinalNumber(dateString, {
                            unit: "day"
                        }), valueCallback);
                    // Tue
                    case "eee":
                        return match.day(dateString, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || match.day(dateString, {
                            width: "short",
                            context: "formatting"
                        }) || match.day(dateString, {
                            width: "narrow",
                            context: "formatting"
                        });
                    // T
                    case "eeeee":
                        return match.day(dateString, {
                            width: "narrow",
                            context: "formatting"
                        });
                    // Tu
                    case "eeeeee":
                        return match.day(dateString, {
                            width: "short",
                            context: "formatting"
                        }) || match.day(dateString, {
                            width: "narrow",
                            context: "formatting"
                        });
                    // Tuesday
                    case "eeee":
                    default:
                        return match.day(dateString, {
                            width: "wide",
                            context: "formatting"
                        }) || match.day(dateString, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || match.day(dateString, {
                            width: "short",
                            context: "formatting"
                        }) || match.day(dateString, {
                            width: "narrow",
                            context: "formatting"
                        });
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 0 && value <= 6;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value, options) {
                date = (0, _indexJsDefault.default)(date, value, options);
                date.setUTCHours(0, 0, 0, 0);
                return date;
            }
        }
    ]);
    return LocalDayParser;
}((0, _parserJs.Parser));

},{"../Parser.js":"eoGZr","../utils.js":"d5y8M","../../../_lib/setUTCDay/index.js":"gbld5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6igat":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "StandAloneLocalDayParser", ()=>StandAloneLocalDayParser);
var _parserJs = require("../Parser.js");
var _utilsJs = require("../utils.js");
var _indexJs = require("../../../_lib/setUTCDay/index.js"); // Stand-alone local day of week
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var StandAloneLocalDayParser = /*#__PURE__*/ function(_Parser) {
    _inherits(StandAloneLocalDayParser, _Parser);
    var _super = _createSuper(StandAloneLocalDayParser);
    function StandAloneLocalDayParser() {
        var _this;
        _classCallCheck(this, StandAloneLocalDayParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 90);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", [
            "y",
            "R",
            "u",
            "q",
            "Q",
            "M",
            "L",
            "I",
            "d",
            "D",
            "E",
            "i",
            "e",
            "t",
            "T"
        ]);
        return _this;
    }
    _createClass(StandAloneLocalDayParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match, options) {
                var valueCallback = function valueCallback(value) {
                    var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
                    return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
                };
                switch(token){
                    // 3
                    case "c":
                    case "cc":
                        // 03
                        return (0, _utilsJs.mapValue)((0, _utilsJs.parseNDigits)(token.length, dateString), valueCallback);
                    // 3rd
                    case "co":
                        return (0, _utilsJs.mapValue)(match.ordinalNumber(dateString, {
                            unit: "day"
                        }), valueCallback);
                    // Tue
                    case "ccc":
                        return match.day(dateString, {
                            width: "abbreviated",
                            context: "standalone"
                        }) || match.day(dateString, {
                            width: "short",
                            context: "standalone"
                        }) || match.day(dateString, {
                            width: "narrow",
                            context: "standalone"
                        });
                    // T
                    case "ccccc":
                        return match.day(dateString, {
                            width: "narrow",
                            context: "standalone"
                        });
                    // Tu
                    case "cccccc":
                        return match.day(dateString, {
                            width: "short",
                            context: "standalone"
                        }) || match.day(dateString, {
                            width: "narrow",
                            context: "standalone"
                        });
                    // Tuesday
                    case "cccc":
                    default:
                        return match.day(dateString, {
                            width: "wide",
                            context: "standalone"
                        }) || match.day(dateString, {
                            width: "abbreviated",
                            context: "standalone"
                        }) || match.day(dateString, {
                            width: "short",
                            context: "standalone"
                        }) || match.day(dateString, {
                            width: "narrow",
                            context: "standalone"
                        });
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 0 && value <= 6;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value, options) {
                date = (0, _indexJsDefault.default)(date, value, options);
                date.setUTCHours(0, 0, 0, 0);
                return date;
            }
        }
    ]);
    return StandAloneLocalDayParser;
}((0, _parserJs.Parser));

},{"../Parser.js":"eoGZr","../utils.js":"d5y8M","../../../_lib/setUTCDay/index.js":"gbld5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2kwtL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ISODayParser", ()=>ISODayParser);
var _parserJs = require("../Parser.js");
var _utilsJs = require("../utils.js");
var _indexJs = require("../../../_lib/setUTCISODay/index.js"); // ISO day of week
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var ISODayParser = /*#__PURE__*/ function(_Parser) {
    _inherits(ISODayParser, _Parser);
    var _super = _createSuper(ISODayParser);
    function ISODayParser() {
        var _this;
        _classCallCheck(this, ISODayParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 90);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", [
            "y",
            "Y",
            "u",
            "q",
            "Q",
            "M",
            "L",
            "w",
            "d",
            "D",
            "E",
            "e",
            "c",
            "t",
            "T"
        ]);
        return _this;
    }
    _createClass(ISODayParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                var valueCallback = function valueCallback(value) {
                    if (value === 0) return 7;
                    return value;
                };
                switch(token){
                    // 2
                    case "i":
                    case "ii":
                        // 02
                        return (0, _utilsJs.parseNDigits)(token.length, dateString);
                    // 2nd
                    case "io":
                        return match.ordinalNumber(dateString, {
                            unit: "day"
                        });
                    // Tue
                    case "iii":
                        return (0, _utilsJs.mapValue)(match.day(dateString, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || match.day(dateString, {
                            width: "short",
                            context: "formatting"
                        }) || match.day(dateString, {
                            width: "narrow",
                            context: "formatting"
                        }), valueCallback);
                    // T
                    case "iiiii":
                        return (0, _utilsJs.mapValue)(match.day(dateString, {
                            width: "narrow",
                            context: "formatting"
                        }), valueCallback);
                    // Tu
                    case "iiiiii":
                        return (0, _utilsJs.mapValue)(match.day(dateString, {
                            width: "short",
                            context: "formatting"
                        }) || match.day(dateString, {
                            width: "narrow",
                            context: "formatting"
                        }), valueCallback);
                    // Tuesday
                    case "iiii":
                    default:
                        return (0, _utilsJs.mapValue)(match.day(dateString, {
                            width: "wide",
                            context: "formatting"
                        }) || match.day(dateString, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || match.day(dateString, {
                            width: "short",
                            context: "formatting"
                        }) || match.day(dateString, {
                            width: "narrow",
                            context: "formatting"
                        }), valueCallback);
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 1 && value <= 7;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date = (0, _indexJsDefault.default)(date, value);
                date.setUTCHours(0, 0, 0, 0);
                return date;
            }
        }
    ]);
    return ISODayParser;
}((0, _parserJs.Parser));

},{"../Parser.js":"eoGZr","../utils.js":"d5y8M","../../../_lib/setUTCISODay/index.js":"c12Xt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c12Xt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>setUTCISODay);
var _indexJs = require("../../toDate/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../requiredArgs/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../toInteger/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
function setUTCISODay(dirtyDate, dirtyDay) {
    (0, _indexJsDefault1.default)(2, arguments);
    var day = (0, _indexJsDefault2.default)(dirtyDay);
    if (day % 7 === 0) day = day - 7;
    var weekStartsOn = 1;
    var date = (0, _indexJsDefault.default)(dirtyDate);
    var currentDay = date.getUTCDay();
    var remainder = day % 7;
    var dayIndex = (remainder + 7) % 7;
    var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date;
}

},{"../../toDate/index.js":"fsust","../requiredArgs/index.js":"9wUgQ","../toInteger/index.js":"f7kKX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2zbXB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AMPMParser", ()=>AMPMParser);
var _parserJs = require("../Parser.js");
var _utilsJs = require("../utils.js");
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var AMPMParser = /*#__PURE__*/ function(_Parser) {
    _inherits(AMPMParser, _Parser);
    var _super = _createSuper(AMPMParser);
    function AMPMParser() {
        var _this;
        _classCallCheck(this, AMPMParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 80);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", [
            "b",
            "B",
            "H",
            "k",
            "t",
            "T"
        ]);
        return _this;
    }
    _createClass(AMPMParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case "a":
                    case "aa":
                    case "aaa":
                        return match.dayPeriod(dateString, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || match.dayPeriod(dateString, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "aaaaa":
                        return match.dayPeriod(dateString, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "aaaa":
                    default:
                        return match.dayPeriod(dateString, {
                            width: "wide",
                            context: "formatting"
                        }) || match.dayPeriod(dateString, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || match.dayPeriod(dateString, {
                            width: "narrow",
                            context: "formatting"
                        });
                }
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date.setUTCHours((0, _utilsJs.dayPeriodEnumToHours)(value), 0, 0, 0);
                return date;
            }
        }
    ]);
    return AMPMParser;
}((0, _parserJs.Parser));

},{"../Parser.js":"eoGZr","../utils.js":"d5y8M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jb5BD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AMPMMidnightParser", ()=>AMPMMidnightParser);
var _parserJs = require("../Parser.js");
var _utilsJs = require("../utils.js");
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var AMPMMidnightParser = /*#__PURE__*/ function(_Parser) {
    _inherits(AMPMMidnightParser, _Parser);
    var _super = _createSuper(AMPMMidnightParser);
    function AMPMMidnightParser() {
        var _this;
        _classCallCheck(this, AMPMMidnightParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 80);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", [
            "a",
            "B",
            "H",
            "k",
            "t",
            "T"
        ]);
        return _this;
    }
    _createClass(AMPMMidnightParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case "b":
                    case "bb":
                    case "bbb":
                        return match.dayPeriod(dateString, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || match.dayPeriod(dateString, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "bbbbb":
                        return match.dayPeriod(dateString, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "bbbb":
                    default:
                        return match.dayPeriod(dateString, {
                            width: "wide",
                            context: "formatting"
                        }) || match.dayPeriod(dateString, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || match.dayPeriod(dateString, {
                            width: "narrow",
                            context: "formatting"
                        });
                }
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date.setUTCHours((0, _utilsJs.dayPeriodEnumToHours)(value), 0, 0, 0);
                return date;
            }
        }
    ]);
    return AMPMMidnightParser;
}((0, _parserJs.Parser));

},{"../Parser.js":"eoGZr","../utils.js":"d5y8M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9kE14":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DayPeriodParser", ()=>DayPeriodParser);
var _parserJs = require("../Parser.js");
var _utilsJs = require("../utils.js"); // in the morning, in the afternoon, in the evening, at night
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var DayPeriodParser = /*#__PURE__*/ function(_Parser) {
    _inherits(DayPeriodParser, _Parser);
    var _super = _createSuper(DayPeriodParser);
    function DayPeriodParser() {
        var _this;
        _classCallCheck(this, DayPeriodParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 80);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", [
            "a",
            "b",
            "t",
            "T"
        ]);
        return _this;
    }
    _createClass(DayPeriodParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case "B":
                    case "BB":
                    case "BBB":
                        return match.dayPeriod(dateString, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || match.dayPeriod(dateString, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "BBBBB":
                        return match.dayPeriod(dateString, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "BBBB":
                    default:
                        return match.dayPeriod(dateString, {
                            width: "wide",
                            context: "formatting"
                        }) || match.dayPeriod(dateString, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || match.dayPeriod(dateString, {
                            width: "narrow",
                            context: "formatting"
                        });
                }
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date.setUTCHours((0, _utilsJs.dayPeriodEnumToHours)(value), 0, 0, 0);
                return date;
            }
        }
    ]);
    return DayPeriodParser;
}((0, _parserJs.Parser));

},{"../Parser.js":"eoGZr","../utils.js":"d5y8M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gzNEC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Hour1to12Parser", ()=>Hour1to12Parser);
var _parserJs = require("../Parser.js");
var _constantsJs = require("../constants.js");
var _utilsJs = require("../utils.js");
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var Hour1to12Parser = /*#__PURE__*/ function(_Parser) {
    _inherits(Hour1to12Parser, _Parser);
    var _super = _createSuper(Hour1to12Parser);
    function Hour1to12Parser() {
        var _this;
        _classCallCheck(this, Hour1to12Parser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 70);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", [
            "H",
            "K",
            "k",
            "t",
            "T"
        ]);
        return _this;
    }
    _createClass(Hour1to12Parser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case "h":
                        return (0, _utilsJs.parseNumericPattern)((0, _constantsJs.numericPatterns).hour12h, dateString);
                    case "ho":
                        return match.ordinalNumber(dateString, {
                            unit: "hour"
                        });
                    default:
                        return (0, _utilsJs.parseNDigits)(token.length, dateString);
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 1 && value <= 12;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                var isPM = date.getUTCHours() >= 12;
                if (isPM && value < 12) date.setUTCHours(value + 12, 0, 0, 0);
                else if (!isPM && value === 12) date.setUTCHours(0, 0, 0, 0);
                else date.setUTCHours(value, 0, 0, 0);
                return date;
            }
        }
    ]);
    return Hour1to12Parser;
}((0, _parserJs.Parser));

},{"../Parser.js":"eoGZr","../constants.js":"dtRjG","../utils.js":"d5y8M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j3kuC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Hour0to23Parser", ()=>Hour0to23Parser);
var _parserJs = require("../Parser.js");
var _constantsJs = require("../constants.js");
var _utilsJs = require("../utils.js");
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var Hour0to23Parser = /*#__PURE__*/ function(_Parser) {
    _inherits(Hour0to23Parser, _Parser);
    var _super = _createSuper(Hour0to23Parser);
    function Hour0to23Parser() {
        var _this;
        _classCallCheck(this, Hour0to23Parser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 70);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", [
            "a",
            "b",
            "h",
            "K",
            "k",
            "t",
            "T"
        ]);
        return _this;
    }
    _createClass(Hour0to23Parser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case "H":
                        return (0, _utilsJs.parseNumericPattern)((0, _constantsJs.numericPatterns).hour23h, dateString);
                    case "Ho":
                        return match.ordinalNumber(dateString, {
                            unit: "hour"
                        });
                    default:
                        return (0, _utilsJs.parseNDigits)(token.length, dateString);
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 0 && value <= 23;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date.setUTCHours(value, 0, 0, 0);
                return date;
            }
        }
    ]);
    return Hour0to23Parser;
}((0, _parserJs.Parser));

},{"../Parser.js":"eoGZr","../constants.js":"dtRjG","../utils.js":"d5y8M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"73sgE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Hour0To11Parser", ()=>Hour0To11Parser);
var _parserJs = require("../Parser.js");
var _constantsJs = require("../constants.js");
var _utilsJs = require("../utils.js");
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var Hour0To11Parser = /*#__PURE__*/ function(_Parser) {
    _inherits(Hour0To11Parser, _Parser);
    var _super = _createSuper(Hour0To11Parser);
    function Hour0To11Parser() {
        var _this;
        _classCallCheck(this, Hour0To11Parser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 70);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", [
            "h",
            "H",
            "k",
            "t",
            "T"
        ]);
        return _this;
    }
    _createClass(Hour0To11Parser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case "K":
                        return (0, _utilsJs.parseNumericPattern)((0, _constantsJs.numericPatterns).hour11h, dateString);
                    case "Ko":
                        return match.ordinalNumber(dateString, {
                            unit: "hour"
                        });
                    default:
                        return (0, _utilsJs.parseNDigits)(token.length, dateString);
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 0 && value <= 11;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                var isPM = date.getUTCHours() >= 12;
                if (isPM && value < 12) date.setUTCHours(value + 12, 0, 0, 0);
                else date.setUTCHours(value, 0, 0, 0);
                return date;
            }
        }
    ]);
    return Hour0To11Parser;
}((0, _parserJs.Parser));

},{"../Parser.js":"eoGZr","../constants.js":"dtRjG","../utils.js":"d5y8M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3WDRF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Hour1To24Parser", ()=>Hour1To24Parser);
var _parserJs = require("../Parser.js");
var _constantsJs = require("../constants.js");
var _utilsJs = require("../utils.js");
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var Hour1To24Parser = /*#__PURE__*/ function(_Parser) {
    _inherits(Hour1To24Parser, _Parser);
    var _super = _createSuper(Hour1To24Parser);
    function Hour1To24Parser() {
        var _this;
        _classCallCheck(this, Hour1To24Parser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 70);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", [
            "a",
            "b",
            "h",
            "H",
            "K",
            "t",
            "T"
        ]);
        return _this;
    }
    _createClass(Hour1To24Parser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case "k":
                        return (0, _utilsJs.parseNumericPattern)((0, _constantsJs.numericPatterns).hour24h, dateString);
                    case "ko":
                        return match.ordinalNumber(dateString, {
                            unit: "hour"
                        });
                    default:
                        return (0, _utilsJs.parseNDigits)(token.length, dateString);
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 1 && value <= 24;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                var hours = value <= 24 ? value % 24 : value;
                date.setUTCHours(hours, 0, 0, 0);
                return date;
            }
        }
    ]);
    return Hour1To24Parser;
}((0, _parserJs.Parser));

},{"../Parser.js":"eoGZr","../constants.js":"dtRjG","../utils.js":"d5y8M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eALta":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MinuteParser", ()=>MinuteParser);
var _parserJs = require("../Parser.js");
var _constantsJs = require("../constants.js");
var _utilsJs = require("../utils.js");
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var MinuteParser = /*#__PURE__*/ function(_Parser) {
    _inherits(MinuteParser, _Parser);
    var _super = _createSuper(MinuteParser);
    function MinuteParser() {
        var _this;
        _classCallCheck(this, MinuteParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 60);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", [
            "t",
            "T"
        ]);
        return _this;
    }
    _createClass(MinuteParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case "m":
                        return (0, _utilsJs.parseNumericPattern)((0, _constantsJs.numericPatterns).minute, dateString);
                    case "mo":
                        return match.ordinalNumber(dateString, {
                            unit: "minute"
                        });
                    default:
                        return (0, _utilsJs.parseNDigits)(token.length, dateString);
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 0 && value <= 59;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date.setUTCMinutes(value, 0, 0);
                return date;
            }
        }
    ]);
    return MinuteParser;
}((0, _parserJs.Parser));

},{"../Parser.js":"eoGZr","../constants.js":"dtRjG","../utils.js":"d5y8M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1nVjx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SecondParser", ()=>SecondParser);
var _parserJs = require("../Parser.js");
var _constantsJs = require("../constants.js");
var _utilsJs = require("../utils.js");
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var SecondParser = /*#__PURE__*/ function(_Parser) {
    _inherits(SecondParser, _Parser);
    var _super = _createSuper(SecondParser);
    function SecondParser() {
        var _this;
        _classCallCheck(this, SecondParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 50);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", [
            "t",
            "T"
        ]);
        return _this;
    }
    _createClass(SecondParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case "s":
                        return (0, _utilsJs.parseNumericPattern)((0, _constantsJs.numericPatterns).second, dateString);
                    case "so":
                        return match.ordinalNumber(dateString, {
                            unit: "second"
                        });
                    default:
                        return (0, _utilsJs.parseNDigits)(token.length, dateString);
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 0 && value <= 59;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date.setUTCSeconds(value, 0);
                return date;
            }
        }
    ]);
    return SecondParser;
}((0, _parserJs.Parser));

},{"../Parser.js":"eoGZr","../constants.js":"dtRjG","../utils.js":"d5y8M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"46M6Z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FractionOfSecondParser", ()=>FractionOfSecondParser);
var _parserJs = require("../Parser.js");
var _utilsJs = require("../utils.js");
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var FractionOfSecondParser = /*#__PURE__*/ function(_Parser) {
    _inherits(FractionOfSecondParser, _Parser);
    var _super = _createSuper(FractionOfSecondParser);
    function FractionOfSecondParser() {
        var _this;
        _classCallCheck(this, FractionOfSecondParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 30);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", [
            "t",
            "T"
        ]);
        return _this;
    }
    _createClass(FractionOfSecondParser, [
        {
            key: "parse",
            value: function parse(dateString, token) {
                var valueCallback = function valueCallback(value) {
                    return Math.floor(value * Math.pow(10, -token.length + 3));
                };
                return (0, _utilsJs.mapValue)((0, _utilsJs.parseNDigits)(token.length, dateString), valueCallback);
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date.setUTCMilliseconds(value);
                return date;
            }
        }
    ]);
    return FractionOfSecondParser;
}((0, _parserJs.Parser));

},{"../Parser.js":"eoGZr","../utils.js":"d5y8M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b1yp4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ISOTimezoneWithZParser", ()=>ISOTimezoneWithZParser);
var _parserJs = require("../Parser.js");
var _constantsJs = require("../constants.js");
var _utilsJs = require("../utils.js"); // Timezone (ISO-8601. +00:00 is `'Z'`)
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var ISOTimezoneWithZParser = /*#__PURE__*/ function(_Parser) {
    _inherits(ISOTimezoneWithZParser, _Parser);
    var _super = _createSuper(ISOTimezoneWithZParser);
    function ISOTimezoneWithZParser() {
        var _this;
        _classCallCheck(this, ISOTimezoneWithZParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 10);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", [
            "t",
            "T",
            "x"
        ]);
        return _this;
    }
    _createClass(ISOTimezoneWithZParser, [
        {
            key: "parse",
            value: function parse(dateString, token) {
                switch(token){
                    case "X":
                        return (0, _utilsJs.parseTimezonePattern)((0, _constantsJs.timezonePatterns).basicOptionalMinutes, dateString);
                    case "XX":
                        return (0, _utilsJs.parseTimezonePattern)((0, _constantsJs.timezonePatterns).basic, dateString);
                    case "XXXX":
                        return (0, _utilsJs.parseTimezonePattern)((0, _constantsJs.timezonePatterns).basicOptionalSeconds, dateString);
                    case "XXXXX":
                        return (0, _utilsJs.parseTimezonePattern)((0, _constantsJs.timezonePatterns).extendedOptionalSeconds, dateString);
                    case "XXX":
                    default:
                        return (0, _utilsJs.parseTimezonePattern)((0, _constantsJs.timezonePatterns).extended, dateString);
                }
            }
        },
        {
            key: "set",
            value: function set(date, flags, value) {
                if (flags.timestampIsSet) return date;
                return new Date(date.getTime() - value);
            }
        }
    ]);
    return ISOTimezoneWithZParser;
}((0, _parserJs.Parser));

},{"../Parser.js":"eoGZr","../constants.js":"dtRjG","../utils.js":"d5y8M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bDXkg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ISOTimezoneParser", ()=>ISOTimezoneParser);
var _parserJs = require("../Parser.js");
var _constantsJs = require("../constants.js");
var _utilsJs = require("../utils.js"); // Timezone (ISO-8601)
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var ISOTimezoneParser = /*#__PURE__*/ function(_Parser) {
    _inherits(ISOTimezoneParser, _Parser);
    var _super = _createSuper(ISOTimezoneParser);
    function ISOTimezoneParser() {
        var _this;
        _classCallCheck(this, ISOTimezoneParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 10);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", [
            "t",
            "T",
            "X"
        ]);
        return _this;
    }
    _createClass(ISOTimezoneParser, [
        {
            key: "parse",
            value: function parse(dateString, token) {
                switch(token){
                    case "x":
                        return (0, _utilsJs.parseTimezonePattern)((0, _constantsJs.timezonePatterns).basicOptionalMinutes, dateString);
                    case "xx":
                        return (0, _utilsJs.parseTimezonePattern)((0, _constantsJs.timezonePatterns).basic, dateString);
                    case "xxxx":
                        return (0, _utilsJs.parseTimezonePattern)((0, _constantsJs.timezonePatterns).basicOptionalSeconds, dateString);
                    case "xxxxx":
                        return (0, _utilsJs.parseTimezonePattern)((0, _constantsJs.timezonePatterns).extendedOptionalSeconds, dateString);
                    case "xxx":
                    default:
                        return (0, _utilsJs.parseTimezonePattern)((0, _constantsJs.timezonePatterns).extended, dateString);
                }
            }
        },
        {
            key: "set",
            value: function set(date, flags, value) {
                if (flags.timestampIsSet) return date;
                return new Date(date.getTime() - value);
            }
        }
    ]);
    return ISOTimezoneParser;
}((0, _parserJs.Parser));

},{"../Parser.js":"eoGZr","../constants.js":"dtRjG","../utils.js":"d5y8M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kPdA3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TimestampSecondsParser", ()=>TimestampSecondsParser);
var _parserJs = require("../Parser.js");
var _utilsJs = require("../utils.js");
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var TimestampSecondsParser = /*#__PURE__*/ function(_Parser) {
    _inherits(TimestampSecondsParser, _Parser);
    var _super = _createSuper(TimestampSecondsParser);
    function TimestampSecondsParser() {
        var _this;
        _classCallCheck(this, TimestampSecondsParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 40);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", "*");
        return _this;
    }
    _createClass(TimestampSecondsParser, [
        {
            key: "parse",
            value: function parse(dateString) {
                return (0, _utilsJs.parseAnyDigitsSigned)(dateString);
            }
        },
        {
            key: "set",
            value: function set(_date, _flags, value) {
                return [
                    new Date(value * 1000),
                    {
                        timestampIsSet: true
                    }
                ];
            }
        }
    ]);
    return TimestampSecondsParser;
}((0, _parserJs.Parser));

},{"../Parser.js":"eoGZr","../utils.js":"d5y8M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gy8e8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TimestampMillisecondsParser", ()=>TimestampMillisecondsParser);
var _parserJs = require("../Parser.js");
var _utilsJs = require("../utils.js");
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var TimestampMillisecondsParser = /*#__PURE__*/ function(_Parser) {
    _inherits(TimestampMillisecondsParser, _Parser);
    var _super = _createSuper(TimestampMillisecondsParser);
    function TimestampMillisecondsParser() {
        var _this;
        _classCallCheck(this, TimestampMillisecondsParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 20);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", "*");
        return _this;
    }
    _createClass(TimestampMillisecondsParser, [
        {
            key: "parse",
            value: function parse(dateString) {
                return (0, _utilsJs.parseAnyDigitsSigned)(dateString);
            }
        },
        {
            key: "set",
            value: function set(_date, _flags, value) {
                return [
                    new Date(value),
                    {
                        timestampIsSet: true
                    }
                ];
            }
        }
    ]);
    return TimestampMillisecondsParser;
}((0, _parserJs.Parser));

},{"../Parser.js":"eoGZr","../utils.js":"d5y8M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3UpeK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>parseISO);
var _indexJs = require("../constants/index.js");
var _indexJs1 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../_lib/toInteger/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs2);
function parseISO(argument, options) {
    var _options$additionalDi;
    (0, _indexJsDefault.default)(1, arguments);
    var additionalDigits = (0, _indexJsDefault1.default)((_options$additionalDi = options === null || options === void 0 ? void 0 : options.additionalDigits) !== null && _options$additionalDi !== void 0 ? _options$additionalDi : 2);
    if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) throw new RangeError("additionalDigits must be 0, 1 or 2");
    if (!(typeof argument === "string" || Object.prototype.toString.call(argument) === "[object String]")) return new Date(NaN);
    var dateStrings = splitDateString(argument);
    var date;
    if (dateStrings.date) {
        var parseYearResult = parseYear(dateStrings.date, additionalDigits);
        date = parseDate(parseYearResult.restDateString, parseYearResult.year);
    }
    if (!date || isNaN(date.getTime())) return new Date(NaN);
    var timestamp = date.getTime();
    var time = 0;
    var offset;
    if (dateStrings.time) {
        time = parseTime(dateStrings.time);
        if (isNaN(time)) return new Date(NaN);
    }
    if (dateStrings.timezone) {
        offset = parseTimezone(dateStrings.timezone);
        if (isNaN(offset)) return new Date(NaN);
    } else {
        var dirtyDate = new Date(timestamp + time); // js parsed string assuming it's in UTC timezone
        // but we need it to be parsed in our timezone
        // so we use utc values to build date in our timezone.
        // Year values from 0 to 99 map to the years 1900 to 1999
        // so set year explicitly with setFullYear.
        var result = new Date(0);
        result.setFullYear(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate());
        result.setHours(dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
        return result;
    }
    return new Date(timestamp + time + offset);
}
var patterns = {
    dateTimeDelimiter: /[T ]/,
    timeZoneDelimiter: /[Z ]/i,
    timezone: /([Z+-].*)$/
};
var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function splitDateString(dateString) {
    var dateStrings = {};
    var array = dateString.split(patterns.dateTimeDelimiter);
    var timeString; // The regex match should only return at maximum two array elements.
    // [date], [time], or [date, time].
    if (array.length > 2) return dateStrings;
    if (/:/.test(array[0])) timeString = array[0];
    else {
        dateStrings.date = array[0];
        timeString = array[1];
        if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
            dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
            timeString = dateString.substr(dateStrings.date.length, dateString.length);
        }
    }
    if (timeString) {
        var token = patterns.timezone.exec(timeString);
        if (token) {
            dateStrings.time = timeString.replace(token[1], "");
            dateStrings.timezone = token[1];
        } else dateStrings.time = timeString;
    }
    return dateStrings;
}
function parseYear(dateString, additionalDigits) {
    var regex = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)");
    var captures = dateString.match(regex); // Invalid ISO-formatted year
    if (!captures) return {
        year: NaN,
        restDateString: ""
    };
    var year = captures[1] ? parseInt(captures[1]) : null;
    var century = captures[2] ? parseInt(captures[2]) : null; // either year or century is null, not both
    return {
        year: century === null ? year : century * 100,
        restDateString: dateString.slice((captures[1] || captures[2]).length)
    };
}
function parseDate(dateString, year) {
    // Invalid ISO-formatted year
    if (year === null) return new Date(NaN);
    var captures = dateString.match(dateRegex); // Invalid ISO-formatted string
    if (!captures) return new Date(NaN);
    var isWeekDate = !!captures[4];
    var dayOfYear = parseDateUnit(captures[1]);
    var month = parseDateUnit(captures[2]) - 1;
    var day = parseDateUnit(captures[3]);
    var week = parseDateUnit(captures[4]);
    var dayOfWeek = parseDateUnit(captures[5]) - 1;
    if (isWeekDate) {
        if (!validateWeekDate(year, week, dayOfWeek)) return new Date(NaN);
        return dayOfISOWeekYear(year, week, dayOfWeek);
    } else {
        var date = new Date(0);
        if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) return new Date(NaN);
        date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
        return date;
    }
}
function parseDateUnit(value) {
    return value ? parseInt(value) : 1;
}
function parseTime(timeString) {
    var captures = timeString.match(timeRegex);
    if (!captures) return NaN; // Invalid ISO-formatted time
    var hours = parseTimeUnit(captures[1]);
    var minutes = parseTimeUnit(captures[2]);
    var seconds = parseTimeUnit(captures[3]);
    if (!validateTime(hours, minutes, seconds)) return NaN;
    return hours * (0, _indexJs.millisecondsInHour) + minutes * (0, _indexJs.millisecondsInMinute) + seconds * 1000;
}
function parseTimeUnit(value) {
    return value && parseFloat(value.replace(",", ".")) || 0;
}
function parseTimezone(timezoneString) {
    if (timezoneString === "Z") return 0;
    var captures = timezoneString.match(timezoneRegex);
    if (!captures) return 0;
    var sign = captures[1] === "+" ? -1 : 1;
    var hours = parseInt(captures[2]);
    var minutes = captures[3] && parseInt(captures[3]) || 0;
    if (!validateTimezone(hours, minutes)) return NaN;
    return sign * (hours * (0, _indexJs.millisecondsInHour) + minutes * (0, _indexJs.millisecondsInMinute));
}
function dayOfISOWeekYear(isoWeekYear, week, day) {
    var date = new Date(0);
    date.setUTCFullYear(isoWeekYear, 0, 4);
    var fourthOfJanuaryDay = date.getUTCDay() || 7;
    var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date;
} // Validation functions
// February is null to handle the leap year (using ||)
var daysInMonths = [
    31,
    null,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
];
function isLeapYearIndex(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function validateDate(year, month, date) {
    return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
}
function validateDayOfYearDate(year, dayOfYear) {
    return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
}
function validateWeekDate(_year, week, day) {
    return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}
function validateTime(hours, minutes, seconds) {
    if (hours === 24) return minutes === 0 && seconds === 0;
    return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
}
function validateTimezone(_hours, minutes) {
    return minutes >= 0 && minutes <= 59;
}

},{"../constants/index.js":"iOhcx","../_lib/requiredArgs/index.js":"9wUgQ","../_lib/toInteger/index.js":"f7kKX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lqSMT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>set);
var _indexJs = require("../toDate/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../setMonth/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../_lib/toInteger/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
var _indexJs3 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault3 = parcelHelpers.interopDefault(_indexJs3);
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function set(dirtyDate, values) {
    (0, _indexJsDefault3.default)(2, arguments);
    if (_typeof(values) !== "object" || values === null) throw new RangeError("values parameter must be an object");
    var date = (0, _indexJsDefault.default)(dirtyDate); // Check if date is Invalid Date because Date.prototype.setFullYear ignores the value of Invalid Date
    if (isNaN(date.getTime())) return new Date(NaN);
    if (values.year != null) date.setFullYear(values.year);
    if (values.month != null) date = (0, _indexJsDefault1.default)(date, values.month);
    if (values.date != null) date.setDate((0, _indexJsDefault2.default)(values.date));
    if (values.hours != null) date.setHours((0, _indexJsDefault2.default)(values.hours));
    if (values.minutes != null) date.setMinutes((0, _indexJsDefault2.default)(values.minutes));
    if (values.seconds != null) date.setSeconds((0, _indexJsDefault2.default)(values.seconds));
    if (values.milliseconds != null) date.setMilliseconds((0, _indexJsDefault2.default)(values.milliseconds));
    return date;
}

},{"../toDate/index.js":"fsust","../setMonth/index.js":"8IC8x","../_lib/toInteger/index.js":"f7kKX","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8IC8x":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>setMonth);
var _indexJs = require("../_lib/toInteger/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../toDate/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../getDaysInMonth/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
var _indexJs3 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault3 = parcelHelpers.interopDefault(_indexJs3);
function setMonth(dirtyDate, dirtyMonth) {
    (0, _indexJsDefault3.default)(2, arguments);
    var date = (0, _indexJsDefault1.default)(dirtyDate);
    var month = (0, _indexJsDefault.default)(dirtyMonth);
    var year = date.getFullYear();
    var day = date.getDate();
    var dateWithDesiredMonth = new Date(0);
    dateWithDesiredMonth.setFullYear(year, month, 15);
    dateWithDesiredMonth.setHours(0, 0, 0, 0);
    var daysInMonth = (0, _indexJsDefault2.default)(dateWithDesiredMonth); // Set the last day of the new month
    // if the original date was the last day of the longer month
    date.setMonth(month, Math.min(day, daysInMonth));
    return date;
}

},{"../_lib/toInteger/index.js":"f7kKX","../toDate/index.js":"fsust","../getDaysInMonth/index.js":"d31S3","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aEL1Z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>setHours);
var _indexJs = require("../_lib/toInteger/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../toDate/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
function setHours(dirtyDate, dirtyHours) {
    (0, _indexJsDefault2.default)(2, arguments);
    var date = (0, _indexJsDefault1.default)(dirtyDate);
    var hours = (0, _indexJsDefault.default)(dirtyHours);
    date.setHours(hours);
    return date;
}

},{"../_lib/toInteger/index.js":"f7kKX","../toDate/index.js":"fsust","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cAmcB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>setMilliseconds);
var _indexJs = require("../_lib/toInteger/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../toDate/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
function setMilliseconds(dirtyDate, dirtyMilliseconds) {
    (0, _indexJsDefault2.default)(2, arguments);
    var date = (0, _indexJsDefault1.default)(dirtyDate);
    var milliseconds = (0, _indexJsDefault.default)(dirtyMilliseconds);
    date.setMilliseconds(milliseconds);
    return date;
}

},{"../_lib/toInteger/index.js":"f7kKX","../toDate/index.js":"fsust","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5O4xT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>setMinutes);
var _indexJs = require("../_lib/toInteger/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../toDate/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
function setMinutes(dirtyDate, dirtyMinutes) {
    (0, _indexJsDefault2.default)(2, arguments);
    var date = (0, _indexJsDefault1.default)(dirtyDate);
    var minutes = (0, _indexJsDefault.default)(dirtyMinutes);
    date.setMinutes(minutes);
    return date;
}

},{"../_lib/toInteger/index.js":"f7kKX","../toDate/index.js":"fsust","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fCMSm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>setSeconds);
var _indexJs = require("../_lib/toInteger/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../toDate/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
function setSeconds(dirtyDate, dirtySeconds) {
    (0, _indexJsDefault2.default)(2, arguments);
    var date = (0, _indexJsDefault1.default)(dirtyDate);
    var seconds = (0, _indexJsDefault.default)(dirtySeconds);
    date.setSeconds(seconds);
    return date;
}

},{"../_lib/toInteger/index.js":"f7kKX","../toDate/index.js":"fsust","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"39i1J":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>setYear);
var _indexJs = require("../_lib/toInteger/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../toDate/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
function setYear(dirtyDate, dirtyYear) {
    (0, _indexJsDefault2.default)(2, arguments);
    var date = (0, _indexJsDefault1.default)(dirtyDate);
    var year = (0, _indexJsDefault.default)(dirtyYear); // Check if date is Invalid Date because Date.prototype.setFullYear ignores the value of Invalid Date
    if (isNaN(date.getTime())) return new Date(NaN);
    date.setFullYear(year);
    return date;
}

},{"../_lib/toInteger/index.js":"f7kKX","../toDate/index.js":"fsust","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lF4Wf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>sub);
var _indexJs = require("../subDays/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../subMonths/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
var _indexJs3 = require("../_lib/toInteger/index.js");
var _indexJsDefault3 = parcelHelpers.interopDefault(_indexJs3);
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function sub(date, duration) {
    (0, _indexJsDefault2.default)(2, arguments);
    if (!duration || _typeof(duration) !== "object") return new Date(NaN);
    var years = duration.years ? (0, _indexJsDefault3.default)(duration.years) : 0;
    var months = duration.months ? (0, _indexJsDefault3.default)(duration.months) : 0;
    var weeks = duration.weeks ? (0, _indexJsDefault3.default)(duration.weeks) : 0;
    var days = duration.days ? (0, _indexJsDefault3.default)(duration.days) : 0;
    var hours = duration.hours ? (0, _indexJsDefault3.default)(duration.hours) : 0;
    var minutes = duration.minutes ? (0, _indexJsDefault3.default)(duration.minutes) : 0;
    var seconds = duration.seconds ? (0, _indexJsDefault3.default)(duration.seconds) : 0; // Subtract years and months
    var dateWithoutMonths = (0, _indexJsDefault1.default)(date, months + years * 12); // Subtract weeks and days
    var dateWithoutDays = (0, _indexJsDefault.default)(dateWithoutMonths, days + weeks * 7); // Subtract hours, minutes and seconds
    var minutestoSub = minutes + hours * 60;
    var secondstoSub = seconds + minutestoSub * 60;
    var mstoSub = secondstoSub * 1000;
    var finalDate = new Date(dateWithoutDays.getTime() - mstoSub);
    return finalDate;
}

},{"../subDays/index.js":"8gyqn","../subMonths/index.js":"8bL71","../_lib/requiredArgs/index.js":"9wUgQ","../_lib/toInteger/index.js":"f7kKX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8gyqn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>subDays);
var _indexJs = require("../addDays/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../_lib/toInteger/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
function subDays(dirtyDate, dirtyAmount) {
    (0, _indexJsDefault1.default)(2, arguments);
    var amount = (0, _indexJsDefault2.default)(dirtyAmount);
    return (0, _indexJsDefault.default)(dirtyDate, -amount);
}

},{"../addDays/index.js":"g6fAH","../_lib/requiredArgs/index.js":"9wUgQ","../_lib/toInteger/index.js":"f7kKX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8bL71":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>subMonths);
var _indexJs = require("../_lib/toInteger/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../addMonths/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
function subMonths(dirtyDate, dirtyAmount) {
    (0, _indexJsDefault2.default)(2, arguments);
    var amount = (0, _indexJsDefault.default)(dirtyAmount);
    return (0, _indexJsDefault1.default)(dirtyDate, -amount);
}

},{"../_lib/toInteger/index.js":"f7kKX","../addMonths/index.js":"hES3W","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d6aiM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>subYears);
var _indexJs = require("../_lib/toInteger/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("../addYears/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../_lib/requiredArgs/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
function subYears(dirtyDate, dirtyAmount) {
    (0, _indexJsDefault2.default)(2, arguments);
    var amount = (0, _indexJsDefault.default)(dirtyAmount);
    return (0, _indexJsDefault1.default)(dirtyDate, -amount);
}

},{"../_lib/toInteger/index.js":"f7kKX","../addYears/index.js":"g0YQq","../_lib/requiredArgs/index.js":"9wUgQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d7I8C":[function() {},{}],"8BiRm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BreakpointConfigPlugin", ()=>(0, _indexJs3.B));
parcelHelpers.export(exports, "CachePlugin", ()=>(0, _indexJs7.C));
parcelHelpers.export(exports, "ColorConfigPlugin", ()=>(0, _indexJs2.C));
parcelHelpers.export(exports, "ColorsClassesPlugin", ()=>(0, _indexJs8.C));
parcelHelpers.export(exports, "GlobalConfigPlugin", ()=>(0, _indexJs1.G));
parcelHelpers.export(exports, "TabsViewKey", ()=>(0, _typesJs1.T));
parcelHelpers.export(exports, "VaAccordion", ()=>(0, _indexJs17.V));
parcelHelpers.export(exports, "VaAffix", ()=>(0, _indexJs18.V));
parcelHelpers.export(exports, "VaAlert", ()=>(0, _indexJs19.V));
parcelHelpers.export(exports, "VaAppBar", ()=>(0, _indexJs20.V));
parcelHelpers.export(exports, "VaAspectRatio", ()=>(0, _indexJs21.V));
parcelHelpers.export(exports, "VaAvatar", ()=>(0, _indexJs22.V));
parcelHelpers.export(exports, "VaAvatarGroup", ()=>(0, _indexJs23.V));
parcelHelpers.export(exports, "VaBacktop", ()=>(0, _indexJs24.V));
parcelHelpers.export(exports, "VaBadge", ()=>(0, _indexJs25.V));
parcelHelpers.export(exports, "VaBreadcrumbs", ()=>(0, _indexJs26.a));
parcelHelpers.export(exports, "VaBreadcrumbsItem", ()=>(0, _indexJs26.V));
parcelHelpers.export(exports, "VaButton", ()=>(0, _indexJs15.V));
parcelHelpers.export(exports, "VaButtonDropdown", ()=>(0, _indexJs27.V));
parcelHelpers.export(exports, "VaButtonGroup", ()=>(0, _indexJs28.V));
parcelHelpers.export(exports, "VaButtonToggle", ()=>(0, _indexJs29.V));
parcelHelpers.export(exports, "VaCard", ()=>(0, _indexJs14.d));
parcelHelpers.export(exports, "VaCardActions", ()=>(0, _indexJs14.b));
parcelHelpers.export(exports, "VaCardBlock", ()=>(0, _indexJs14.c));
parcelHelpers.export(exports, "VaCardContent", ()=>(0, _indexJs14.V));
parcelHelpers.export(exports, "VaCardTitle", ()=>(0, _indexJs14.a));
parcelHelpers.export(exports, "VaCarousel", ()=>(0, _indexJs30.V));
parcelHelpers.export(exports, "VaCheckbox", ()=>(0, _indexJs31.V));
parcelHelpers.export(exports, "VaChip", ()=>(0, _indexJs32.V));
parcelHelpers.export(exports, "VaCollapse", ()=>(0, _indexJs13.V));
parcelHelpers.export(exports, "VaColorIndicator", ()=>(0, _indexJs33.V));
parcelHelpers.export(exports, "VaColorInput", ()=>(0, _indexJs34.V));
parcelHelpers.export(exports, "VaColorPalette", ()=>(0, _indexJs35.V));
parcelHelpers.export(exports, "VaConfig", ()=>(0, _vaConfigVueVueTypeScriptSetupTrueLangJs._));
parcelHelpers.export(exports, "VaContent", ()=>(0, _indexJs36.V));
parcelHelpers.export(exports, "VaCounter", ()=>(0, _indexJs37.V));
parcelHelpers.export(exports, "VaDataTable", ()=>(0, _indexJs38.V));
parcelHelpers.export(exports, "VaDateInput", ()=>(0, _indexJs39.V));
parcelHelpers.export(exports, "VaDatePicker", ()=>(0, _indexJs40.V));
parcelHelpers.export(exports, "VaDivider", ()=>(0, _indexJs41.V));
parcelHelpers.export(exports, "VaDropdown", ()=>(0, _indexJs43.V));
parcelHelpers.export(exports, "VaDropdownContent", ()=>(0, _indexJs42.V));
parcelHelpers.export(exports, "VaDropdownPlugin", ()=>(0, _indexJs5.V));
parcelHelpers.export(exports, "VaFallback", ()=>(0, _indexJs12.V));
parcelHelpers.export(exports, "VaFileUpload", ()=>(0, _indexJs88.V));
parcelHelpers.export(exports, "VaFileUploadGalleryItem", ()=>(0, _indexJs83.V));
parcelHelpers.export(exports, "VaFileUploadKey", ()=>(0, _typesJs2.V));
parcelHelpers.export(exports, "VaFileUploadList", ()=>(0, _indexJs84.V));
parcelHelpers.export(exports, "VaFileUploadListItem", ()=>(0, _indexJs85.V));
parcelHelpers.export(exports, "VaFileUploadSingleItem", ()=>(0, _indexJs86.V));
parcelHelpers.export(exports, "VaFileUploadUndo", ()=>(0, _indexJs87.V));
parcelHelpers.export(exports, "VaForm", ()=>(0, _indexJs44.V));
parcelHelpers.export(exports, "VaFormField", ()=>(0, _indexJs90.V));
parcelHelpers.export(exports, "VaHover", ()=>(0, _indexJs45.V));
parcelHelpers.export(exports, "VaIcon", ()=>(0, _indexJs9.V));
parcelHelpers.export(exports, "VaImage", ()=>(0, _indexJs46.V));
parcelHelpers.export(exports, "VaInfiniteScroll", ()=>(0, _indexJs47.V));
parcelHelpers.export(exports, "VaInnerLoading", ()=>(0, _indexJs48.V));
parcelHelpers.export(exports, "VaInput", ()=>(0, _indexJs11.V));
parcelHelpers.export(exports, "VaInputWrapper", ()=>(0, _indexJs10.V));
parcelHelpers.export(exports, "VaLayout", ()=>(0, _indexJs49.V));
parcelHelpers.export(exports, "VaList", ()=>(0, _indexJs50.b));
parcelHelpers.export(exports, "VaListItem", ()=>(0, _indexJs50.V));
parcelHelpers.export(exports, "VaListItemLabel", ()=>(0, _indexJs50.d));
parcelHelpers.export(exports, "VaListItemSection", ()=>(0, _indexJs50.a));
parcelHelpers.export(exports, "VaListLabel", ()=>(0, _indexJs50.c));
parcelHelpers.export(exports, "VaListSeparator", ()=>(0, _indexJs50.e));
parcelHelpers.export(exports, "VaMenu", ()=>(0, _vaMenuJs.V));
parcelHelpers.export(exports, "VaMenuGroup", ()=>(0, _indexJs16.b));
parcelHelpers.export(exports, "VaMenuItem", ()=>(0, _indexJs16.a));
parcelHelpers.export(exports, "VaMenuList", ()=>(0, _indexJs16.V));
parcelHelpers.export(exports, "VaMessageList", ()=>(0, _vaMessageListJs.V));
parcelHelpers.export(exports, "VaMessageListWrapper", ()=>(0, _vaMessageListWrapperVueVueTypeScriptSetupTrueLangJs._));
parcelHelpers.export(exports, "VaModal", ()=>(0, _vaModalJs.V));
parcelHelpers.export(exports, "VaModalPlugin", ()=>(0, _indexJs6.V));
parcelHelpers.export(exports, "VaNavbar", ()=>(0, _indexJs51.V));
parcelHelpers.export(exports, "VaNavbarItem", ()=>(0, _indexJs51.a));
parcelHelpers.export(exports, "VaOptionList", ()=>(0, _indexJs52.V));
parcelHelpers.export(exports, "VaPagination", ()=>(0, _indexJs53.V));
parcelHelpers.export(exports, "VaParallax", ()=>(0, _indexJs54.V));
parcelHelpers.export(exports, "VaPopover", ()=>(0, _indexJs55.V));
parcelHelpers.export(exports, "VaProgressBar", ()=>(0, _indexJs56.V));
parcelHelpers.export(exports, "VaProgressCircle", ()=>(0, _indexJs57.V));
parcelHelpers.export(exports, "VaRadio", ()=>(0, _indexJs58.V));
parcelHelpers.export(exports, "VaRating", ()=>(0, _indexJs60.V));
parcelHelpers.export(exports, "VaRatingItem", ()=>(0, _indexJs59.V));
parcelHelpers.export(exports, "VaScrollContainer", ()=>(0, _indexJs79.V));
parcelHelpers.export(exports, "VaSelect", ()=>(0, _indexJs63.V));
parcelHelpers.export(exports, "VaSelectOption", ()=>(0, _indexJs62.V));
parcelHelpers.export(exports, "VaSelectOptionList", ()=>(0, _indexJs61.V));
parcelHelpers.export(exports, "VaSeparator", ()=>(0, _vaSeparatorVueVueTypeScriptSetupTrueLangJs._));
parcelHelpers.export(exports, "VaSidebar", ()=>(0, _indexJs66.V));
parcelHelpers.export(exports, "VaSidebarItem", ()=>(0, _indexJs65.V));
parcelHelpers.export(exports, "VaSidebarItemContent", ()=>(0, _indexJs65.a));
parcelHelpers.export(exports, "VaSidebarItemTitle", ()=>(0, _indexJs65.b));
parcelHelpers.export(exports, "VaSkeleton", ()=>(0, _indexJs64.V));
parcelHelpers.export(exports, "VaSkeletonGroup", ()=>(0, _indexJs64.a));
parcelHelpers.export(exports, "VaSlider", ()=>(0, _indexJs67.V));
parcelHelpers.export(exports, "VaSpacer", ()=>(0, _vaSpacerVueVueTypeScriptSetupTrueLangJs._));
parcelHelpers.export(exports, "VaSplit", ()=>(0, _indexJs68.V));
parcelHelpers.export(exports, "VaStepper", ()=>(0, _indexJs69.V));
parcelHelpers.export(exports, "VaSwitch", ()=>(0, _indexJs70.V));
parcelHelpers.export(exports, "VaTab", ()=>(0, _indexJs71.V));
parcelHelpers.export(exports, "VaTabs", ()=>(0, _indexJs72.V));
parcelHelpers.export(exports, "VaTextarea", ()=>(0, _indexJs89.V));
parcelHelpers.export(exports, "VaTimeInput", ()=>(0, _indexJs73.V));
parcelHelpers.export(exports, "VaTimePicker", ()=>(0, _indexJs74.V));
parcelHelpers.export(exports, "VaTimeline", ()=>(0, _indexJs77.V));
parcelHelpers.export(exports, "VaTimelineItem", ()=>(0, _indexJs75.V));
parcelHelpers.export(exports, "VaTimelineSeparator", ()=>(0, _indexJs76.V));
parcelHelpers.export(exports, "VaToast", ()=>(0, _toastJs.V));
parcelHelpers.export(exports, "VaToastPlugin", ()=>(0, _indexJs4.V));
parcelHelpers.export(exports, "VaTreeView", ()=>(0, _indexJs78.V));
parcelHelpers.export(exports, "VaValue", ()=>(0, _indexJs82.V));
parcelHelpers.export(exports, "VaViewer", ()=>(0, _indexJs80.V));
parcelHelpers.export(exports, "VaVirtualScroller", ()=>(0, _indexJs81.V));
parcelHelpers.export(exports, "VuesticIconAliases", ()=>(0, _vuesticAliasesJs.V));
parcelHelpers.export(exports, "VuesticIconFonts", ()=>(0, _fontsJs.V));
parcelHelpers.export(exports, "colorsPreset", ()=>(0, _presetsJs.p));
parcelHelpers.export(exports, "createIconsConfig", ()=>(0, _createIconsConfigJs.c));
parcelHelpers.export(exports, "createVuestic", ()=>(0, _createVuesticJs.c));
parcelHelpers.export(exports, "createVuesticEssential", ()=>(0, _createVuesticEssentialJs.c));
parcelHelpers.export(exports, "defineVaDataTableColumns", ()=>(0, _fabricsJs.d));
parcelHelpers.export(exports, "defineVaDataTableItems", ()=>(0, _fabricsJs.a));
parcelHelpers.export(exports, "defineVaStepperSteps", ()=>(0, _indexJs69.d));
parcelHelpers.export(exports, "defineVuesticConfig", ()=>(0, _typesJs.d));
parcelHelpers.export(exports, "registerVuesticWebComponents", ()=>(0, _registerVuesticWebComponentsJs.r));
parcelHelpers.export(exports, "registerVuesticWebComponentsEssential", ()=>(0, _registerVuesticWebComponentsEssentialJs.r));
parcelHelpers.export(exports, "thresholdsPreset", ()=>(0, _indexJs.d));
parcelHelpers.export(exports, "useBreakpoint", ()=>(0, _useBreakpointJs.u));
parcelHelpers.export(exports, "useColors", ()=>(0, _useColorsJs.u));
parcelHelpers.export(exports, "useElementTextColor", ()=>(0, _useElementTextColorJs.u));
parcelHelpers.export(exports, "useForm", ()=>(0, _useFormJs.u));
parcelHelpers.export(exports, "useGlobalConfig", ()=>(0, _useGlobalConfigJs.u));
parcelHelpers.export(exports, "useI18nConfig", ()=>(0, _useI18NJs.u));
parcelHelpers.export(exports, "useIcons", ()=>(0, _useIconJs.u));
parcelHelpers.export(exports, "useMenu", ()=>(0, _useMenuJs.u));
parcelHelpers.export(exports, "useModal", ()=>(0, _useModalJs.u));
parcelHelpers.export(exports, "useToast", ()=>(0, _useToastJs.u));
var _presetsJs = require("./src/services/color/presets.js");
var _indexJs = require("./src/services/breakpoint/index.js");
var _typesJs = require("./src/services/global-config/types.js");
var _vaMessageListWrapperVueVueTypeScriptSetupTrueLangJs = require("./src/components/va-message-list/VaMessageListWrapper.vue_vue_type_script_setup_true_lang.js");
var _vaConfigVueVueTypeScriptSetupTrueLangJs = require("./src/components/va-config/VaConfig.vue_vue_type_script_setup_true_lang.js");
var _vaSeparatorVueVueTypeScriptSetupTrueLangJs = require("./src/components/va-separator/VaSeparator.vue_vue_type_script_setup_true_lang.js");
var _vaSpacerVueVueTypeScriptSetupTrueLangJs = require("./src/components/va-spacer/VaSpacer.vue_vue_type_script_setup_true_lang.js");
var _useGlobalConfigJs = require("./src/composables/useGlobalConfig.js");
var _useColorsJs = require("./src/composables/useColors.js");
var _useBreakpointJs = require("./src/composables/useBreakpoint.js");
var _useI18NJs = require("./src/composables/useI18n.js");
var _useIconJs = require("./src/composables/useIcon.js");
var _useFormJs = require("./src/composables/useForm/useForm.js");
var _createIconsConfigJs = require("./src/services/icon/create-icons-config.js");
var _fontsJs = require("./src/services/icon/presets/fonts.js");
var _vuesticAliasesJs = require("./src/services/icon/presets/vuestic-aliases.js");
var _indexJs1 = require("./src/services/global-config/plugin/index.js");
var _indexJs2 = require("./src/services/color/plugin/index.js");
var _indexJs3 = require("./src/services/breakpoint/plugin/index.js");
var _indexJs4 = require("./src/components/va-toast/plugin/index.js");
var _indexJs5 = require("./src/components/va-dropdown/plugin/index.js");
var _indexJs6 = require("./src/components/va-modal/plugin/index.js");
var _indexJs7 = require("./src/services/cache/plugin/index.js");
var _indexJs8 = require("./src/services/colors-classes/plugin/index.js");
var _createVuesticJs = require("./src/services/vue-plugin/create-vuestic/create-vuestic.js");
var _createVuesticEssentialJs = require("./src/services/vue-plugin/create-vuestic/create-vuestic-essential.js");
var _useElementTextColorJs = require("./src/composables/useElementTextColor.js");
var _registerVuesticWebComponentsJs = require("./src/services/web-components/register-vuestic-web-components.js");
var _registerVuesticWebComponentsEssentialJs = require("./src/services/web-components/register-vuestic-web-components-essential.js");
var _indexJs9 = require("./src/components/va-icon/index.js");
var _vaMessageListJs = require("./src/components/va-message-list/VaMessageList.js");
var _indexJs10 = require("./src/components/va-input-wrapper/index.js");
var _indexJs11 = require("./src/components/va-input/index.js");
var _indexJs12 = require("./src/components/va-fallback/index.js");
var _indexJs13 = require("./src/components/va-collapse/index.js");
var _indexJs14 = require("./src/components/va-card/index.js");
var _indexJs15 = require("./src/components/va-button/index.js");
var _indexJs16 = require("./src/components/va-menu-list/index.js");
var _indexJs17 = require("./src/components/va-accordion/index.js");
var _indexJs18 = require("./src/components/va-affix/index.js");
var _indexJs19 = require("./src/components/va-alert/index.js");
var _indexJs20 = require("./src/components/va-app-bar/index.js");
var _indexJs21 = require("./src/components/va-aspect-ratio/index.js");
var _indexJs22 = require("./src/components/va-avatar/index.js");
var _indexJs23 = require("./src/components/va-avatar-group/index.js");
var _indexJs24 = require("./src/components/va-backtop/index.js");
var _indexJs25 = require("./src/components/va-badge/index.js");
var _indexJs26 = require("./src/components/va-breadcrumbs/index.js");
var _indexJs27 = require("./src/components/va-button-dropdown/index.js");
var _indexJs28 = require("./src/components/va-button-group/index.js");
var _indexJs29 = require("./src/components/va-button-toggle/index.js");
var _indexJs30 = require("./src/components/va-carousel/index.js");
var _indexJs31 = require("./src/components/va-checkbox/index.js");
var _indexJs32 = require("./src/components/va-chip/index.js");
var _indexJs33 = require("./src/components/va-color-indicator/index.js");
var _indexJs34 = require("./src/components/va-color-input/index.js");
var _indexJs35 = require("./src/components/va-color-palette/index.js");
var _indexJs36 = require("./src/components/va-content/index.js");
var _indexJs37 = require("./src/components/va-counter/index.js");
var _fabricsJs = require("./src/components/va-data-table/fabrics.js");
var _indexJs38 = require("./src/components/va-data-table/index.js");
var _indexJs39 = require("./src/components/va-date-input/index.js");
var _indexJs40 = require("./src/components/va-date-picker/index.js");
var _indexJs41 = require("./src/components/va-divider/index.js");
var _indexJs42 = require("./src/components/va-dropdown/components/VaDropdownContent/index.js");
var _indexJs43 = require("./src/components/va-dropdown/index.js");
var _indexJs44 = require("./src/components/va-form/index.js");
var _indexJs45 = require("./src/components/va-hover/index.js");
var _indexJs46 = require("./src/components/va-image/index.js");
var _indexJs47 = require("./src/components/va-infinite-scroll/index.js");
var _indexJs48 = require("./src/components/va-inner-loading/index.js");
var _indexJs49 = require("./src/components/va-layout/index.js");
var _indexJs50 = require("./src/components/va-list/index.js");
var _useModalJs = require("./src/components/va-modal/hooks/useModal.js");
var _vaModalJs = require("./src/components/va-modal/VaModal.js");
var _indexJs51 = require("./src/components/va-navbar/index.js");
var _indexJs52 = require("./src/components/va-option-list/index.js");
var _indexJs53 = require("./src/components/va-pagination/index.js");
var _indexJs54 = require("./src/components/va-parallax/index.js");
var _indexJs55 = require("./src/components/va-popover/index.js");
var _indexJs56 = require("./src/components/va-progress-bar/index.js");
var _indexJs57 = require("./src/components/va-progress-circle/index.js");
var _indexJs58 = require("./src/components/va-radio/index.js");
var _indexJs59 = require("./src/components/va-rating/components/VaRatingItem/index.js");
var _indexJs60 = require("./src/components/va-rating/index.js");
var _indexJs61 = require("./src/components/va-select/components/VaSelectOptionList/index.js");
var _indexJs62 = require("./src/components/va-select/components/VaSelectOption/index.js");
var _indexJs63 = require("./src/components/va-select/index.js");
var _indexJs64 = require("./src/components/va-skeleton/index.js");
var _indexJs65 = require("./src/components/va-sidebar/VaSidebarItem/index.js");
var _indexJs66 = require("./src/components/va-sidebar/index.js");
var _indexJs67 = require("./src/components/va-slider/index.js");
var _indexJs68 = require("./src/components/va-split/index.js");
var _indexJs69 = require("./src/components/va-stepper/index.js");
var _indexJs70 = require("./src/components/va-switch/index.js");
var _toastJs = require("./src/components/va-toast/toast.js");
var _useToastJs = require("./src/components/va-toast/hooks/useToast.js");
var _indexJs71 = require("./src/components/va-tabs/components/VaTab/index.js");
var _typesJs1 = require("./src/components/va-tabs/types.js");
var _indexJs72 = require("./src/components/va-tabs/index.js");
var _indexJs73 = require("./src/components/va-time-input/index.js");
var _indexJs74 = require("./src/components/va-time-picker/index.js");
var _indexJs75 = require("./src/components/va-timeline/VaTimelineItem/index.js");
var _indexJs76 = require("./src/components/va-timeline/VaTimelineSeparator/index.js");
var _indexJs77 = require("./src/components/va-timeline/index.js");
var _indexJs78 = require("./src/components/va-tree-view/index.js");
var _indexJs79 = require("./src/components/va-scroll-container/index.js");
var _indexJs80 = require("./src/components/va-viewer/index.js");
var _indexJs81 = require("./src/components/va-virtual-scroller/index.js");
var _indexJs82 = require("./src/components/va-value/index.js");
var _indexJs83 = require("./src/components/va-file-upload/VaFileUploadGalleryItem/index.js");
var _indexJs84 = require("./src/components/va-file-upload/VaFileUploadList/index.js");
var _indexJs85 = require("./src/components/va-file-upload/VaFileUploadListItem/index.js");
var _indexJs86 = require("./src/components/va-file-upload/VaFileUploadSingleItem/index.js");
var _indexJs87 = require("./src/components/va-file-upload/VaFileUploadUndo/index.js");
var _typesJs2 = require("./src/components/va-file-upload/types.js");
var _indexJs88 = require("./src/components/va-file-upload/index.js");
var _indexJs89 = require("./src/components/va-textarea/index.js");
var _vaMenuJs = require("./src/components/va-menu/va-menu.js");
var _useMenuJs = require("./src/components/va-menu/hooks/useMenu.js");
var _indexJs90 = require("./src/components/va-form-field/index.js");

},{"./src/services/color/presets.js":false,"./src/services/breakpoint/index.js":false,"./src/services/global-config/types.js":false,"./src/components/va-message-list/VaMessageListWrapper.vue_vue_type_script_setup_true_lang.js":false,"./src/components/va-config/VaConfig.vue_vue_type_script_setup_true_lang.js":false,"./src/components/va-separator/VaSeparator.vue_vue_type_script_setup_true_lang.js":false,"./src/components/va-spacer/VaSpacer.vue_vue_type_script_setup_true_lang.js":false,"./src/composables/useGlobalConfig.js":false,"./src/composables/useColors.js":false,"./src/composables/useBreakpoint.js":false,"./src/composables/useI18n.js":false,"./src/composables/useIcon.js":false,"./src/composables/useForm/useForm.js":false,"./src/services/icon/create-icons-config.js":false,"./src/services/icon/presets/fonts.js":false,"./src/services/icon/presets/vuestic-aliases.js":false,"./src/services/global-config/plugin/index.js":false,"./src/services/color/plugin/index.js":false,"./src/services/breakpoint/plugin/index.js":false,"./src/components/va-toast/plugin/index.js":false,"./src/components/va-dropdown/plugin/index.js":false,"./src/components/va-modal/plugin/index.js":false,"./src/services/cache/plugin/index.js":false,"./src/services/colors-classes/plugin/index.js":false,"./src/services/vue-plugin/create-vuestic/create-vuestic.js":"1T9zx","./src/services/vue-plugin/create-vuestic/create-vuestic-essential.js":false,"./src/composables/useElementTextColor.js":false,"./src/services/web-components/register-vuestic-web-components.js":false,"./src/services/web-components/register-vuestic-web-components-essential.js":false,"./src/components/va-icon/index.js":false,"./src/components/va-message-list/VaMessageList.js":false,"./src/components/va-input-wrapper/index.js":false,"./src/components/va-input/index.js":false,"./src/components/va-fallback/index.js":false,"./src/components/va-collapse/index.js":false,"./src/components/va-card/index.js":false,"./src/components/va-button/index.js":false,"./src/components/va-menu-list/index.js":false,"./src/components/va-accordion/index.js":false,"./src/components/va-affix/index.js":false,"./src/components/va-alert/index.js":false,"./src/components/va-app-bar/index.js":false,"./src/components/va-aspect-ratio/index.js":false,"./src/components/va-avatar/index.js":false,"./src/components/va-avatar-group/index.js":false,"./src/components/va-backtop/index.js":false,"./src/components/va-badge/index.js":false,"./src/components/va-breadcrumbs/index.js":false,"./src/components/va-button-dropdown/index.js":false,"./src/components/va-button-group/index.js":false,"./src/components/va-button-toggle/index.js":false,"./src/components/va-carousel/index.js":false,"./src/components/va-checkbox/index.js":false,"./src/components/va-chip/index.js":false,"./src/components/va-color-indicator/index.js":false,"./src/components/va-color-input/index.js":false,"./src/components/va-color-palette/index.js":false,"./src/components/va-content/index.js":false,"./src/components/va-counter/index.js":false,"./src/components/va-data-table/fabrics.js":false,"./src/components/va-data-table/index.js":false,"./src/components/va-date-input/index.js":false,"./src/components/va-date-picker/index.js":false,"./src/components/va-divider/index.js":false,"./src/components/va-dropdown/components/VaDropdownContent/index.js":false,"./src/components/va-dropdown/index.js":false,"./src/components/va-form/index.js":false,"./src/components/va-hover/index.js":false,"./src/components/va-image/index.js":false,"./src/components/va-infinite-scroll/index.js":false,"./src/components/va-inner-loading/index.js":false,"./src/components/va-layout/index.js":false,"./src/components/va-list/index.js":false,"./src/components/va-modal/hooks/useModal.js":false,"./src/components/va-modal/VaModal.js":false,"./src/components/va-navbar/index.js":false,"./src/components/va-option-list/index.js":false,"./src/components/va-pagination/index.js":false,"./src/components/va-parallax/index.js":false,"./src/components/va-popover/index.js":false,"./src/components/va-progress-bar/index.js":false,"./src/components/va-progress-circle/index.js":false,"./src/components/va-radio/index.js":false,"./src/components/va-rating/components/VaRatingItem/index.js":false,"./src/components/va-rating/index.js":false,"./src/components/va-select/components/VaSelectOptionList/index.js":false,"./src/components/va-select/components/VaSelectOption/index.js":false,"./src/components/va-select/index.js":false,"./src/components/va-skeleton/index.js":false,"./src/components/va-sidebar/VaSidebarItem/index.js":false,"./src/components/va-sidebar/index.js":false,"./src/components/va-slider/index.js":false,"./src/components/va-split/index.js":false,"./src/components/va-stepper/index.js":false,"./src/components/va-switch/index.js":false,"./src/components/va-toast/toast.js":false,"./src/components/va-toast/hooks/useToast.js":false,"./src/components/va-tabs/components/VaTab/index.js":false,"./src/components/va-tabs/types.js":false,"./src/components/va-tabs/index.js":false,"./src/components/va-time-input/index.js":false,"./src/components/va-time-picker/index.js":false,"./src/components/va-timeline/VaTimelineItem/index.js":false,"./src/components/va-timeline/VaTimelineSeparator/index.js":false,"./src/components/va-timeline/index.js":false,"./src/components/va-tree-view/index.js":false,"./src/components/va-scroll-container/index.js":false,"./src/components/va-viewer/index.js":false,"./src/components/va-virtual-scroller/index.js":false,"./src/components/va-value/index.js":false,"./src/components/va-file-upload/VaFileUploadGalleryItem/index.js":false,"./src/components/va-file-upload/VaFileUploadList/index.js":false,"./src/components/va-file-upload/VaFileUploadListItem/index.js":false,"./src/components/va-file-upload/VaFileUploadSingleItem/index.js":false,"./src/components/va-file-upload/VaFileUploadUndo/index.js":false,"./src/components/va-file-upload/types.js":false,"./src/components/va-file-upload/index.js":false,"./src/components/va-textarea/index.js":false,"./src/components/va-menu/va-menu.js":false,"./src/components/va-menu/hooks/useMenu.js":false,"./src/components/va-form-field/index.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bMTF6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "p", ()=>presets);
const presets = {
    light: {
        // Accent
        primary: "#154EC1",
        secondary: "#767C88",
        success: "#3D9209",
        info: "#158DE3",
        danger: "#E42222",
        warning: "#FFD43A",
        // Background Colors
        backgroundPrimary: "#f6f6f6",
        backgroundSecondary: "#FFFFFF",
        backgroundElement: "#ECF0F1",
        backgroundBorder: "#DEE5F2",
        // Text Colors
        textPrimary: "#262824",
        textInverted: "#FFFFFF",
        // Misc
        shadow: "rgba(0, 0, 0, 0.12)",
        focus: "#49A8FF",
        transparent: "rgba(0, 0, 0, 0)"
    },
    dark: {
        // Accent
        primary: "#3472F0",
        secondary: "#767C88",
        success: "#66BE33",
        info: "#3EAAF8",
        danger: "#F34030",
        warning: "#FFD952",
        // Background Colors
        backgroundPrimary: "#050A10",
        backgroundSecondary: "#1F262F",
        backgroundElement: "#131A22",
        backgroundBorder: "#3D4C58",
        // Text Colors
        textPrimary: "#F1F1F1",
        textInverted: "#0B121A",
        // Misc
        shadow: "rgba(255, 255, 255, 0.12)",
        focus: "#49A8FF",
        transparent: "rgba(0, 0, 0, 0)"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"94cKv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "d", ()=>defaultThresholds);
parcelHelpers.export(exports, "g", ()=>getBreakpointDefaultConfig);
parcelHelpers.export(exports, "v", ()=>vaBreakpointSymbol);
const vaBreakpointSymbol = Symbol("vaBreakpoint");
const defaultThresholds = {
    xs: 0,
    sm: 640,
    md: 1024,
    lg: 1440,
    xl: 1920
};
const getBreakpointDefaultConfig = ()=>({
        enabled: true,
        bodyClass: true,
        thresholds: defaultThresholds
    });

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"050bm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vaMessageListJs = require("./VaMessageList.js");
var _useValidationJs = require("../../composables/useValidation.js");
var _vaMessageListWrapperCss = require("../../../VaMessageListWrapper.css");
const _hoisted_1 = {
    class: "va-message-list-wrapper"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaMessageListWrapper",
    __name: "VaMessageListWrapper",
    props: {
        ...(0, _useValidationJs.b)
    },
    setup (__props) {
        const props = __props;
        const messagesColor = (0, _vue.computed)(()=>{
            if (props.error) return "danger";
            if (props.success) return "success";
            return "";
        });
        const hasError = (0, _vue.toRef)(props, "error");
        const messagesComputed = (0, _vue.computed)(()=>props.error ? props.errorMessages : props.messages);
        const errorLimit = (0, _vue.computed)(()=>props.error ? Number(props.errorCount) : 99);
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_1, [
                (0, _vue.createVNode)((0, _vue.unref)((0, _vaMessageListJs.V)), {
                    color: messagesColor.value,
                    limit: errorLimit.value,
                    "has-error": hasError.value,
                    "model-value": messagesComputed.value,
                    "inherit-slots": [
                        "message"
                    ]
                }, {
                    default: (0, _vue.withCtx)((bind)=>[
                            (0, _vue.renderSlot)(_ctx.$slots, "default", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(bind)))
                        ]),
                    _: 3
                }, 8, [
                    "color",
                    "limit",
                    "has-error",
                    "model-value"
                ])
            ]);
        };
    }
});

},{"vue":"gzxs9","./VaMessageList.js":"kMkwf","../../composables/useValidation.js":"iFHh2","../../../VaMessageListWrapper.css":"fgand","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kMkwf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaMessageList);
var _vaMessageListVueVueTypeScriptSetupTrueLangJs = require("./VaMessageList.vue_vue_type_script_setup_true_lang.js");
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaMessageListCss = require("../../../VaMessageList.css");
const VaMessageList_vue_vue_type_style_index_0_lang = "";
const VaMessageList = (0, _withConfigTransportJs.w)((0, _vaMessageListVueVueTypeScriptSetupTrueLangJs._));

},{"./VaMessageList.vue_vue_type_script_setup_true_lang.js":"bHu04","../../services/config-transport/withConfigTransport.js":"b7Tgy","../../../VaMessageList.css":"f9kzg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bHu04":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _indexJs = require("../va-icon/index.js");
var _useMessageListAriaJs = require("./hooks/useMessageListAria.js");
var _useColorsJs = require("../../composables/useColors.js");
var _vaMessageListCss = require("../../../VaMessageList.css");
const _hoisted_1 = {
    class: "va-message-list__list"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaMessageList",
    inheritAttrs: false,
    __name: "VaMessageList",
    props: {
        modelValue: {
            type: [
                String,
                Array
            ],
            default: ""
        },
        limit: {
            type: Number,
            default: 1
        },
        color: {
            type: String
        },
        hasError: {
            type: Boolean,
            default: false
        }
    },
    setup (__props, { expose: __expose }) {
        const props = __props;
        const { getColor } = (0, _useColorsJs.u)();
        const { childAttributes, messageListAttributes } = (0, _useMessageListAriaJs.u)(props);
        const messages = (0, _vue.computed)(()=>{
            if (!props.modelValue) return [];
            if (!Array.isArray(props.modelValue)) return [
                props.modelValue
            ];
            return props.modelValue.slice(0, props.limit);
        });
        const computedStyle = (0, _vue.computed)(()=>props.color ? {
                color: getColor(props.color)
            } : {});
        __expose({
            messages
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), null, [
                (0, _vue.renderSlot)(_ctx.$slots, "default", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                    ariaAttributes: (0, _vue.unref)(childAttributes),
                    messages: messages.value,
                    attrs: _ctx.$attrs
                }))),
                (0, _vue.renderSlot)(_ctx.$slots, "messages", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                    ariaAttributes: (0, _vue.unref)(messageListAttributes),
                    messages: messages.value
                })), ()=>[
                        messages.value.length > 0 ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", (0, _vue.mergeProps)({
                            key: 0,
                            class: "va-message-list",
                            style: computedStyle.value
                        }, (0, _vue.unref)(messageListAttributes)), [
                            (0, _vue.createElementVNode)("ul", _hoisted_1, [
                                ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)(messages.value, (message, index)=>{
                                    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("li", {
                                        key: index,
                                        class: "va-message-list__message"
                                    }, [
                                        (0, _vue.renderSlot)(_ctx.$slots, "message", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                            messages: messages.value,
                                            message
                                        })), ()=>[
                                                __props.hasError ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), {
                                                    key: 0,
                                                    class: "va-message-list__icon",
                                                    name: "va-warning",
                                                    size: 16
                                                })) : (0, _vue.createCommentVNode)("", true),
                                                (0, _vue.createTextVNode)((0, _vue.toDisplayString)(message), 1)
                                            ])
                                    ]);
                                }), 128))
                            ])
                        ], 16)) : (0, _vue.createCommentVNode)("", true)
                    ])
            ], 64);
        };
    }
});

},{"vue":"gzxs9","../va-icon/index.js":"82tPo","./hooks/useMessageListAria.js":"75Exv","../../composables/useColors.js":"a4Qgv","../../../VaMessageList.css":"f9kzg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"82tPo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaIcon);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaIconVueVueTypeScriptSetupTrueLangJs = require("./VaIcon.vue_vue_type_script_setup_true_lang.js");
const VaIcon = (0, _withConfigTransportJs.w)((0, _vaIconVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaIcon.vue_vue_type_script_setup_true_lang.js":"8g95K","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b7Tgy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>withConfigTransport);
parcelHelpers.export(exports, "w", ()=>withConfigTransport$1);
var _createProxyComponentJs = require("./createProxyComponent.js");
const CLASS_COMPONENT_KEY = "__c";
const patchClassComponent = (component)=>{
    component[CLASS_COMPONENT_KEY] = (0, _createProxyComponentJs.c)(component[CLASS_COMPONENT_KEY]);
    return component;
};
const withConfigTransport = (component)=>{
    if ("setup" in component) return (0, _createProxyComponentJs.c)(component);
    else if (CLASS_COMPONENT_KEY in component) return patchClassComponent(component);
    else {
        component.setup = ()=>({
            });
        return (0, _createProxyComponentJs.c)(component);
    }
};
const withConfigTransport$1 = withConfigTransport;

},{"./createProxyComponent.js":"fzvP5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fzvP5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "c", ()=>createProxyComponent);
var _createRenderFnJs = require("./createRenderFn.js");
var _createSetupFnJs = require("./createSetupFn.js");
const createProxyComponent = (component)=>{
    const setupFn = (0, _createSetupFnJs.c)(component);
    const renderFn = (0, _createRenderFnJs.c)(component);
    return {
        ...component,
        setup: setupFn,
        render: "render" in component ? renderFn : void 0,
        ssrRender: "ssrRender" in component ? renderFn : void 0
    };
};

},{"./createRenderFn.js":"5TRzn","./createSetupFn.js":"3CHEx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5TRzn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "c", ()=>createRenderFn);
parcelHelpers.export(exports, "m", ()=>makeVNode);
parcelHelpers.export(exports, "r", ()=>renderSlotNode);
var _vue = require("vue");
const renderSlotNode = (node, ctx = null)=>{
    return (0, _vue.withCtx)(()=>[
            node
        ], ctx);
};
const makeVNode = (node)=>{
    if (typeof node === "string") return (0, _vue.h)((0, _vue.Text), node);
    return (0, _vue.isVNode)(node) ? node : (0, _vue.createBlock)(node);
};
const renderSlots = (slots, ctx = null)=>{
    return Object.keys(slots).reduce((acc, slotName)=>{
        const slot = slots[slotName];
        acc[slotName] = typeof slot === "function" ? slot : renderSlotNode(slot, ctx);
        return acc;
    }, {});
};
const createRenderFn = (component)=>{
    const originalRenderFn = component.render || component.ssrRender;
    if (!originalRenderFn) return void 0;
    const compiledRenderedFn = originalRenderFn.name === "_sfc_render" || originalRenderFn.name === "_sfc_ssrRender";
    return function(...args) {
        const ctx = args[0];
        const slots = ctx.$.slots;
        const customCtx = new Proxy(ctx, {
            get (target, key) {
                if (key === "$slots") return renderSlots(slots);
                return target[key];
            }
        });
        const thisArg = compiledRenderedFn ? void 0 : customCtx;
        return originalRenderFn.call(thisArg, customCtx, ...args.slice(1));
    };
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3CHEx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "c", ()=>createSetupFn);
var _vue = require("vue");
var _vendorJs = require("../../../vendor.js");
var _createPropsJs = require("./createProps.js");
var _createAttrsJs = require("./createAttrs.js");
var _createSlotsJs = require("./createSlots.js");
var _useComponentConfigPropsJs = require("../component-config/utils/use-component-config-props.js");
const createSetupFn = (component)=>{
    return (originalProps, ctx)=>{
        var _a;
        const instance = (0, _vue.getCurrentInstance)();
        const propsFromConfig = (0, _useComponentConfigPropsJs.u)(component, originalProps);
        const attrsFromConfig = (0, _vue.computed)(()=>{
            return (0, _vendorJs.o)(propsFromConfig.value, Object.keys(originalProps));
        });
        const props = (0, _createPropsJs.c)(instance, propsFromConfig);
        const attrs = (0, _createAttrsJs.c)(instance, attrsFromConfig);
        const slots = (0, _createSlotsJs.c)(instance, propsFromConfig);
        instance.props = props;
        instance.attrs = attrs;
        instance.slots = slots;
        const setupState = (_a = component.setup) == null ? void 0 : _a.call(component, (0, _vue.shallowReadonly)(props), {
            ...ctx,
            attrs,
            slots
        });
        if (typeof setupState === "object" && !instance.exposed) ctx.expose(setupState);
        return setupState;
    };
};

},{"vue":"gzxs9","../../../vendor.js":"l6TAc","./createProps.js":"kdMVI","./createAttrs.js":"depDp","./createSlots.js":"w5WyW","../component-config/utils/use-component-config-props.js":"6jKmc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l6TAc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>isDate$1);
parcelHelpers.export(exports, "b", ()=>clamp$1);
parcelHelpers.export(exports, "c", ()=>cloneDeep$1);
parcelHelpers.export(exports, "d", ()=>debounce$2);
parcelHelpers.export(exports, "e", ()=>isNumber$1);
parcelHelpers.export(exports, "f", ()=>isString$1);
parcelHelpers.export(exports, "g", ()=>isFunction$4);
parcelHelpers.export(exports, "h", ()=>flatten$2);
parcelHelpers.export(exports, "i", ()=>isNil$1);
parcelHelpers.export(exports, "j", ()=>camelCase$1);
parcelHelpers.export(exports, "k", ()=>kebabCase$1);
parcelHelpers.export(exports, "l", ()=>isObject$d);
parcelHelpers.export(exports, "m", ()=>merge$1);
parcelHelpers.export(exports, "n", ()=>noop$1);
parcelHelpers.export(exports, "o", ()=>omit$1);
parcelHelpers.export(exports, "p", ()=>pick$1);
parcelHelpers.export(exports, "s", ()=>startCase$1);
parcelHelpers.export(exports, "t", ()=>throttle$1);
var _commonjsHelpersJs = require("./__commonjsHelpers__.js");
function listCacheClear$1() {
    this.__data__ = [];
    this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$4(value, other) {
    return value === other || value !== value && other !== other;
}
var eq_1 = eq$4;
var eq$3 = eq_1;
function assocIndexOf$4(array, key) {
    var length = array.length;
    while(length--){
        if (eq$3(array[length][0], key)) return length;
    }
    return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key) {
    var data = this.__data__, index = assocIndexOf$3(data, key);
    if (index < 0) return false;
    var lastIndex = data.length - 1;
    if (index == lastIndex) data.pop();
    else splice.call(data, index, 1);
    --this.size;
    return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
    var data = this.__data__, index = assocIndexOf$2(data, key);
    return index < 0 ? void 0 : data[index][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
    return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        ++this.size;
        data.push([
            key,
            value
        ]);
    } else data[index][1] = value;
    return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$4(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var ListCache$3 = _ListCache;
function stackClear$1() {
    this.__data__ = new ListCache$3();
    this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key) {
    return this.__data__.get(key);
}
var _stackGet = stackGet$1;
function stackHas$1(key) {
    return this.__data__.has(key);
}
var _stackHas = stackHas$1;
var freeGlobal$1 = typeof (0, _commonjsHelpersJs.c) == "object" && (0, _commonjsHelpersJs.c) && (0, _commonjsHelpersJs.c).Object === Object && (0, _commonjsHelpersJs.c);
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$9 = freeGlobal || freeSelf || Function("return this")();
var _root = root$9;
var root$8 = _root;
var Symbol$6 = root$8.Symbol;
var _Symbol = Symbol$6;
var Symbol$5 = _Symbol;
var objectProto$d = Object.prototype;
var hasOwnProperty$a = objectProto$d.hasOwnProperty;
var nativeObjectToString$1 = objectProto$d.toString;
var symToStringTag$1 = Symbol$5 ? Symbol$5.toStringTag : void 0;
function getRawTag$1(value) {
    var isOwn = hasOwnProperty$a.call(value, symToStringTag$1), tag = value[symToStringTag$1];
    try {
        value[symToStringTag$1] = void 0;
        var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
        if (isOwn) value[symToStringTag$1] = tag;
        else delete value[symToStringTag$1];
    }
    return result;
}
var _getRawTag = getRawTag$1;
var objectProto$c = Object.prototype;
var nativeObjectToString = objectProto$c.toString;
function objectToString$1(value) {
    return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$4 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$4 ? Symbol$4.toStringTag : void 0;
function baseGetTag$9(value) {
    if (value == null) return value === void 0 ? undefinedTag : nullTag;
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$9;
function isObject$c(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
}
var isObject_1 = isObject$c;
const isObject$d = /* @__PURE__ */ (0, _commonjsHelpersJs.g)(isObject_1);
var baseGetTag$8 = _baseGetTag, isObject$b = isObject_1;
var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$3(value) {
    if (!isObject$b(value)) return false;
    var tag = baseGetTag$8(value);
    return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$3;
const isFunction$4 = /* @__PURE__ */ (0, _commonjsHelpersJs.g)(isFunction_1);
var root$7 = _root;
var coreJsData$1 = root$7["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource$2(func) {
    if (func != null) {
        try {
            return funcToString$2.call(func);
        } catch (e) {}
        try {
            return func + "";
        } catch (e) {}
    }
    return "";
}
var _toSource = toSource$2;
var isFunction$2 = isFunction_1, isMasked = _isMasked, isObject$a = isObject_1, toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype, objectProto$b = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString$1.call(hasOwnProperty$9).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative$1(value) {
    if (!isObject$a(value) || isMasked(value)) return false;
    var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource$1(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object, key) {
    return object == null ? void 0 : object[key];
}
var _getValue = getValue$1;
var baseIsNative = _baseIsNative, getValue = _getValue;
function getNative$7(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$7;
var getNative$6 = _getNative, root$6 = _root;
var Map$3 = getNative$6(root$6, "Map");
var _Map = Map$3;
var getNative$5 = _getNative;
var nativeCreate$4 = getNative$5(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
    this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
    this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
var objectProto$a = Object.prototype;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
function hashGet$1(key) {
    var data = this.__data__;
    if (nativeCreate$2) {
        var result = data[key];
        return result === HASH_UNDEFINED$1 ? void 0 : result;
    }
    return hasOwnProperty$8.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$9 = Object.prototype;
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
function hashHas$1(key) {
    var data = this.__data__;
    return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$7.call(data, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
var Hash = _Hash, ListCache$2 = _ListCache, Map$2 = _Map;
function mapCacheClear$1() {
    this.size = 0;
    this.__data__ = {
        "hash": new Hash(),
        "map": new (Map$2 || ListCache$2)(),
        "string": new Hash()
    };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
    var result = getMapData$3(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
    return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
    return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$2(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
MapCache$2.prototype.clear = mapCacheClear;
MapCache$2.prototype["delete"] = mapCacheDelete;
MapCache$2.prototype.get = mapCacheGet;
MapCache$2.prototype.has = mapCacheHas;
MapCache$2.prototype.set = mapCacheSet;
var _MapCache = MapCache$2;
var ListCache$1 = _ListCache, Map$1 = _Map, MapCache$1 = _MapCache;
var LARGE_ARRAY_SIZE = 200;
function stackSet$1(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache$1) {
        var pairs = data.__data__;
        if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([
                key,
                value
            ]);
            this.size = ++data.size;
            return this;
        }
        data = this.__data__ = new MapCache$1(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
function Stack$2(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
}
Stack$2.prototype.clear = stackClear;
Stack$2.prototype["delete"] = stackDelete;
Stack$2.prototype.get = stackGet;
Stack$2.prototype.has = stackHas;
Stack$2.prototype.set = stackSet;
var _Stack = Stack$2;
function arrayEach$1(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length;
    while(++index < length){
        if (iteratee(array[index], index, array) === false) break;
    }
    return array;
}
var _arrayEach = arrayEach$1;
var getNative$4 = _getNative;
var defineProperty$2 = function() {
    try {
        var func = getNative$4(Object, "defineProperty");
        func({}, "", {});
        return func;
    } catch (e) {}
}();
var _defineProperty = defineProperty$2;
var defineProperty$1 = _defineProperty;
function baseAssignValue$3(object, key, value) {
    if (key == "__proto__" && defineProperty$1) defineProperty$1(object, key, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
    });
    else object[key] = value;
}
var _baseAssignValue = baseAssignValue$3;
var baseAssignValue$2 = _baseAssignValue, eq$2 = eq_1;
var objectProto$8 = Object.prototype;
var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
function assignValue$3(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty$6.call(object, key) && eq$2(objValue, value)) || value === void 0 && !(key in object)) baseAssignValue$2(object, key, value);
}
var _assignValue = assignValue$3;
var assignValue$2 = _assignValue, baseAssignValue$1 = _baseAssignValue;
function copyObject$6(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index = -1, length = props.length;
    while(++index < length){
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) newValue = source[key];
        if (isNew) baseAssignValue$1(object, key, newValue);
        else assignValue$2(object, key, newValue);
    }
    return object;
}
var _copyObject = copyObject$6;
function baseTimes$1(n, iteratee) {
    var index = -1, result = Array(n);
    while(++index < n)result[index] = iteratee(index);
    return result;
}
var _baseTimes = baseTimes$1;
function isObjectLike$b(value) {
    return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$b;
var baseGetTag$7 = _baseGetTag, isObjectLike$a = isObjectLike_1;
var argsTag$2 = "[object Arguments]";
function baseIsArguments$1(value) {
    return isObjectLike$a(value) && baseGetTag$7(value) == argsTag$2;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments, isObjectLike$9 = isObjectLike_1;
var objectProto$7 = Object.prototype;
var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable;
var isArguments$4 = baseIsArguments(function() {
    return arguments;
}()) ? baseIsArguments : function(value) {
    return isObjectLike$9(value) && hasOwnProperty$5.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments_1 = isArguments$4;
var isArray$a = Array.isArray;
var isArray_1 = isArray$a;
var isBuffer$3 = {
    exports: {}
};
function stubFalse() {
    return false;
}
var stubFalse_1 = stubFalse;
isBuffer$3.exports;
(function(module, exports) {
    var root2 = _root, stubFalse2 = stubFalse_1;
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer = moduleExports ? root2.Buffer : void 0;
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var isBuffer2 = nativeIsBuffer || stubFalse2;
    module.exports = isBuffer2;
})(isBuffer$3, isBuffer$3.exports);
var isBufferExports = isBuffer$3.exports;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$4(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER$1 : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
var _isIndex = isIndex$4;
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength$3(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength$3;
var baseGetTag$6 = _baseGetTag, isLength$2 = isLength_1, isObjectLike$8 = isObjectLike_1;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", mapTag$4 = "[object Map]", numberTag$3 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray$1(value) {
    return isObjectLike$8(value) && isLength$2(value.length) && !!typedArrayTags[baseGetTag$6(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$4(func) {
    return function(value) {
        return func(value);
    };
}
var _baseUnary = baseUnary$4;
var _nodeUtil = {
    exports: {}
};
_nodeUtil.exports;
(function(module, exports) {
    var freeGlobal2 = _freeGlobal;
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal2.process;
    var nodeUtil2 = function() {
        try {
            var types = freeModule && freeModule.require && freeModule.require("util").types;
            if (types) return types;
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {}
    }();
    module.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var _nodeUtilExports = _nodeUtil.exports;
var baseIsTypedArray = _baseIsTypedArray, baseUnary$3 = _baseUnary, nodeUtil$3 = _nodeUtilExports;
var nodeIsTypedArray = nodeUtil$3 && nodeUtil$3.isTypedArray;
var isTypedArray$2 = nodeIsTypedArray ? baseUnary$3(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$2;
var baseTimes = _baseTimes, isArguments$3 = isArguments_1, isArray$9 = isArray_1, isBuffer$2 = isBufferExports, isIndex$3 = _isIndex, isTypedArray$1 = isTypedArray_1;
var objectProto$6 = Object.prototype;
var hasOwnProperty$4 = objectProto$6.hasOwnProperty;
function arrayLikeKeys$2(value, inherited) {
    var isArr = isArray$9(value), isArg = !isArr && isArguments$3(value), isBuff = !isArr && !isArg && isBuffer$2(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for(var key in value)if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex$3(key, length)))) result.push(key);
    return result;
}
var _arrayLikeKeys = arrayLikeKeys$2;
var objectProto$5 = Object.prototype;
function isPrototype$3(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$5;
    return value === proto;
}
var _isPrototype = isPrototype$3;
function overArg$2(func, transform) {
    return function(arg) {
        return func(transform(arg));
    };
}
var _overArg = overArg$2;
var overArg$1 = _overArg;
var nativeKeys$1 = overArg$1(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype$2 = _isPrototype, nativeKeys = _nativeKeys;
var objectProto$4 = Object.prototype;
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
function baseKeys$1(object) {
    if (!isPrototype$2(object)) return nativeKeys(object);
    var result = [];
    for(var key in Object(object))if (hasOwnProperty$3.call(object, key) && key != "constructor") result.push(key);
    return result;
}
var _baseKeys = baseKeys$1;
var isFunction$1 = isFunction_1, isLength$1 = isLength_1;
function isArrayLike$4(value) {
    return value != null && isLength$1(value.length) && !isFunction$1(value);
}
var isArrayLike_1 = isArrayLike$4;
var arrayLikeKeys$1 = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike$3 = isArrayLike_1;
function keys$3(object) {
    return isArrayLike$3(object) ? arrayLikeKeys$1(object) : baseKeys(object);
}
var keys_1 = keys$3;
var copyObject$5 = _copyObject, keys$2 = keys_1;
function baseAssign$1(object, source) {
    return object && copyObject$5(source, keys$2(source), object);
}
var _baseAssign = baseAssign$1;
function nativeKeysIn$1(object) {
    var result = [];
    if (object != null) for(var key in Object(object))result.push(key);
    return result;
}
var _nativeKeysIn = nativeKeysIn$1;
var isObject$9 = isObject_1, isPrototype$1 = _isPrototype, nativeKeysIn = _nativeKeysIn;
var objectProto$3 = Object.prototype;
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
function baseKeysIn$1(object) {
    if (!isObject$9(object)) return nativeKeysIn(object);
    var isProto = isPrototype$1(object), result = [];
    for(var key in object)if (!(key == "constructor" && (isProto || !hasOwnProperty$2.call(object, key)))) result.push(key);
    return result;
}
var _baseKeysIn = baseKeysIn$1;
var arrayLikeKeys = _arrayLikeKeys, baseKeysIn = _baseKeysIn, isArrayLike$2 = isArrayLike_1;
function keysIn$5(object) {
    return isArrayLike$2(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var keysIn_1 = keysIn$5;
var copyObject$4 = _copyObject, keysIn$4 = keysIn_1;
function baseAssignIn$1(object, source) {
    return object && copyObject$4(source, keysIn$4(source), object);
}
var _baseAssignIn = baseAssignIn$1;
var _cloneBuffer = {
    exports: {}
};
_cloneBuffer.exports;
(function(module, exports) {
    var root2 = _root;
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer = moduleExports ? root2.Buffer : void 0, allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
    function cloneBuffer2(buffer, isDeep) {
        if (isDeep) return buffer.slice();
        var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result);
        return result;
    }
    module.exports = cloneBuffer2;
})(_cloneBuffer, _cloneBuffer.exports);
var _cloneBufferExports = _cloneBuffer.exports;
function copyArray$2(source, array) {
    var index = -1, length = source.length;
    array || (array = Array(length));
    while(++index < length)array[index] = source[index];
    return array;
}
var _copyArray = copyArray$2;
function arrayFilter$1(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while(++index < length){
        var value = array[index];
        if (predicate(value, index, array)) result[resIndex++] = value;
    }
    return result;
}
var _arrayFilter = arrayFilter$1;
function stubArray$2() {
    return [];
}
var stubArray_1 = stubArray$2;
var arrayFilter = _arrayFilter, stubArray$1 = stubArray_1;
var objectProto$2 = Object.prototype;
var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols$3 = !nativeGetSymbols$1 ? stubArray$1 : function(object) {
    if (object == null) return [];
    object = Object(object);
    return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
    });
};
var _getSymbols = getSymbols$3;
var copyObject$3 = _copyObject, getSymbols$2 = _getSymbols;
function copySymbols$1(source, object) {
    return copyObject$3(source, getSymbols$2(source), object);
}
var _copySymbols = copySymbols$1;
function arrayPush$3(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while(++index < length)array[offset + index] = values[index];
    return array;
}
var _arrayPush = arrayPush$3;
var overArg = _overArg;
var getPrototype$3 = overArg(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$3;
var arrayPush$2 = _arrayPush, getPrototype$2 = _getPrototype, getSymbols$1 = _getSymbols, stubArray = stubArray_1;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn$2 = !nativeGetSymbols ? stubArray : function(object) {
    var result = [];
    while(object){
        arrayPush$2(result, getSymbols$1(object));
        object = getPrototype$2(object);
    }
    return result;
};
var _getSymbolsIn = getSymbolsIn$2;
var copyObject$2 = _copyObject, getSymbolsIn$1 = _getSymbolsIn;
function copySymbolsIn$1(source, object) {
    return copyObject$2(source, getSymbolsIn$1(source), object);
}
var _copySymbolsIn = copySymbolsIn$1;
var arrayPush$1 = _arrayPush, isArray$8 = isArray_1;
function baseGetAllKeys$2(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray$8(object) ? result : arrayPush$1(result, symbolsFunc(object));
}
var _baseGetAllKeys = baseGetAllKeys$2;
var baseGetAllKeys$1 = _baseGetAllKeys, getSymbols = _getSymbols, keys$1 = keys_1;
function getAllKeys$1(object) {
    return baseGetAllKeys$1(object, keys$1, getSymbols);
}
var _getAllKeys = getAllKeys$1;
var baseGetAllKeys = _baseGetAllKeys, getSymbolsIn = _getSymbolsIn, keysIn$3 = keysIn_1;
function getAllKeysIn$2(object) {
    return baseGetAllKeys(object, keysIn$3, getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$2;
var getNative$3 = _getNative, root$5 = _root;
var DataView$1 = getNative$3(root$5, "DataView");
var _DataView = DataView$1;
var getNative$2 = _getNative, root$4 = _root;
var Promise$2 = getNative$2(root$4, "Promise");
var _Promise = Promise$2;
var getNative$1 = _getNative, root$3 = _root;
var Set$1 = getNative$1(root$3, "Set");
var _Set = Set$1;
var getNative = _getNative, root$2 = _root;
var WeakMap$1 = getNative(root$2, "WeakMap");
var _WeakMap = WeakMap$1;
var DataView = _DataView, Map = _Map, Promise$1 = _Promise, Set = _Set, WeakMap = _WeakMap, baseGetTag$5 = _baseGetTag, toSource = _toSource;
var mapTag$3 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$2 = "[object DataView]";
var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
var getTag$3 = baseGetTag$5;
if (DataView && getTag$3(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map && getTag$3(new Map()) != mapTag$3 || Promise$1 && getTag$3(Promise$1.resolve()) != promiseTag || Set && getTag$3(new Set()) != setTag$3 || WeakMap && getTag$3(new WeakMap()) != weakMapTag$1) getTag$3 = function(value) {
    var result = baseGetTag$5(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) switch(ctorString){
        case dataViewCtorString:
            return dataViewTag$2;
        case mapCtorString:
            return mapTag$3;
        case promiseCtorString:
            return promiseTag;
        case setCtorString:
            return setTag$3;
        case weakMapCtorString:
            return weakMapTag$1;
    }
    return result;
};
var _getTag = getTag$3;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function initCloneArray$1(array) {
    var length = array.length, result = new array.constructor(length);
    if (length && typeof array[0] == "string" && hasOwnProperty$1.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
    }
    return result;
}
var _initCloneArray = initCloneArray$1;
var root$1 = _root;
var Uint8Array$1 = root$1.Uint8Array;
var _Uint8Array = Uint8Array$1;
var Uint8Array = _Uint8Array;
function cloneArrayBuffer$3(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
}
var _cloneArrayBuffer = cloneArrayBuffer$3;
var cloneArrayBuffer$2 = _cloneArrayBuffer;
function cloneDataView$1(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer$2(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView = cloneDataView$1;
var reFlags = /\w*$/;
function cloneRegExp$1(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
}
var _cloneRegExp = cloneRegExp$1;
var Symbol$3 = _Symbol;
var symbolProto$1 = Symbol$3 ? Symbol$3.prototype : void 0, symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function cloneSymbol$1(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var _cloneSymbol = cloneSymbol$1;
var cloneArrayBuffer$1 = _cloneArrayBuffer;
function cloneTypedArray$2(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer$1(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray$2;
var cloneArrayBuffer = _cloneArrayBuffer, cloneDataView = _cloneDataView, cloneRegExp = _cloneRegExp, cloneSymbol = _cloneSymbol, cloneTypedArray$1 = _cloneTypedArray;
var boolTag$1 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$2 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag$1(object, tag, isDeep) {
    var Ctor = object.constructor;
    switch(tag){
        case arrayBufferTag$1:
            return cloneArrayBuffer(object);
        case boolTag$1:
        case dateTag$2:
            return new Ctor(+object);
        case dataViewTag$1:
            return cloneDataView(object, isDeep);
        case float32Tag$1:
        case float64Tag$1:
        case int8Tag$1:
        case int16Tag$1:
        case int32Tag$1:
        case uint8Tag$1:
        case uint8ClampedTag$1:
        case uint16Tag$1:
        case uint32Tag$1:
            return cloneTypedArray$1(object, isDeep);
        case mapTag$2:
            return new Ctor();
        case numberTag$2:
        case stringTag$2:
            return new Ctor(object);
        case regexpTag$1:
            return cloneRegExp(object);
        case setTag$2:
            return new Ctor();
        case symbolTag$2:
            return cloneSymbol(object);
    }
}
var _initCloneByTag = initCloneByTag$1;
var isObject$8 = isObject_1;
var objectCreate = Object.create;
var baseCreate$1 = function() {
    function object() {}
    return function(proto) {
        if (!isObject$8(proto)) return {};
        if (objectCreate) return objectCreate(proto);
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
    };
}();
var _baseCreate = baseCreate$1;
var baseCreate = _baseCreate, getPrototype$1 = _getPrototype, isPrototype = _isPrototype;
function initCloneObject$2(object) {
    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype$1(object)) : {};
}
var _initCloneObject = initCloneObject$2;
var getTag$2 = _getTag, isObjectLike$7 = isObjectLike_1;
var mapTag$1 = "[object Map]";
function baseIsMap$1(value) {
    return isObjectLike$7(value) && getTag$2(value) == mapTag$1;
}
var _baseIsMap = baseIsMap$1;
var baseIsMap = _baseIsMap, baseUnary$2 = _baseUnary, nodeUtil$2 = _nodeUtilExports;
var nodeIsMap = nodeUtil$2 && nodeUtil$2.isMap;
var isMap$1 = nodeIsMap ? baseUnary$2(nodeIsMap) : baseIsMap;
var isMap_1 = isMap$1;
var getTag$1 = _getTag, isObjectLike$6 = isObjectLike_1;
var setTag$1 = "[object Set]";
function baseIsSet$1(value) {
    return isObjectLike$6(value) && getTag$1(value) == setTag$1;
}
var _baseIsSet = baseIsSet$1;
var baseIsSet = _baseIsSet, baseUnary$1 = _baseUnary, nodeUtil$1 = _nodeUtilExports;
var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;
var isSet$1 = nodeIsSet ? baseUnary$1(nodeIsSet) : baseIsSet;
var isSet_1 = isSet$1;
var Stack$1 = _Stack, arrayEach = _arrayEach, assignValue$1 = _assignValue, baseAssign = _baseAssign, baseAssignIn = _baseAssignIn, cloneBuffer$1 = _cloneBufferExports, copyArray$1 = _copyArray, copySymbols = _copySymbols, copySymbolsIn = _copySymbolsIn, getAllKeys = _getAllKeys, getAllKeysIn$1 = _getAllKeysIn, getTag = _getTag, initCloneArray = _initCloneArray, initCloneByTag = _initCloneByTag, initCloneObject$1 = _initCloneObject, isArray$7 = isArray_1, isBuffer$1 = isBufferExports, isMap = isMap_1, isObject$7 = isObject_1, isSet = isSet_1, keys = keys_1, keysIn$2 = keysIn_1;
var CLONE_DEEP_FLAG$2 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$2 = 4;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag$1 = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag$1 = "[object Number]", objectTag$1 = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone$2(value, bitmask, customizer, key, object, stack) {
    var result, isDeep = bitmask & CLONE_DEEP_FLAG$2, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
    if (customizer) result = object ? customizer(value, key, object, stack) : customizer(value);
    if (result !== void 0) return result;
    if (!isObject$7(value)) return value;
    var isArr = isArray$7(value);
    if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) return copyArray$1(value, result);
    } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer$1(value)) return cloneBuffer$1(value, isDeep);
        if (tag == objectTag$1 || tag == argsTag || isFunc && !object) {
            result = isFlat || isFunc ? {} : initCloneObject$1(value);
            if (!isDeep) return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
        } else {
            if (!cloneableTags[tag]) return object ? value : {};
            result = initCloneByTag(value, tag, isDeep);
        }
    }
    stack || (stack = new Stack$1());
    var stacked = stack.get(value);
    if (stacked) return stacked;
    stack.set(value, result);
    if (isSet(value)) value.forEach(function(subValue) {
        result.add(baseClone$2(subValue, bitmask, customizer, subValue, value, stack));
    });
    else if (isMap(value)) value.forEach(function(subValue, key2) {
        result.set(key2, baseClone$2(subValue, bitmask, customizer, key2, value, stack));
    });
    var keysFunc = isFull ? isFlat ? getAllKeysIn$1 : getAllKeys : isFlat ? keysIn$2 : keys;
    var props = isArr ? void 0 : keysFunc(value);
    arrayEach(props || value, function(subValue, key2) {
        if (props) {
            key2 = subValue;
            subValue = value[key2];
        }
        assignValue$1(result, key2, baseClone$2(subValue, bitmask, customizer, key2, value, stack));
    });
    return result;
}
var _baseClone = baseClone$2;
var baseClone$1 = _baseClone;
var CLONE_DEEP_FLAG$1 = 1, CLONE_SYMBOLS_FLAG$1 = 4;
function cloneDeep(value) {
    return baseClone$1(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
}
var cloneDeep_1 = cloneDeep;
const cloneDeep$1 = /* @__PURE__ */ (0, _commonjsHelpersJs.g)(cloneDeep_1);
function arrayReduce$1(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array == null ? 0 : array.length;
    if (initAccum && length) accumulator = array[++index];
    while(++index < length)accumulator = iteratee(accumulator, array[index], index, array);
    return accumulator;
}
var _arrayReduce = arrayReduce$1;
function basePropertyOf$1(object) {
    return function(key) {
        return object == null ? void 0 : object[key];
    };
}
var _basePropertyOf = basePropertyOf$1;
var basePropertyOf = _basePropertyOf;
var deburredLetters = {
    // Latin-1 Supplement block.
    "\xc0": "A",
    "\xc1": "A",
    "\xc2": "A",
    "\xc3": "A",
    "\xc4": "A",
    "\xc5": "A",
    "\xe0": "a",
    "\xe1": "a",
    "\xe2": "a",
    "\xe3": "a",
    "\xe4": "a",
    "\xe5": "a",
    "\xc7": "C",
    "\xe7": "c",
    "\xd0": "D",
    "\xf0": "d",
    "\xc8": "E",
    "\xc9": "E",
    "\xca": "E",
    "\xcb": "E",
    "\xe8": "e",
    "\xe9": "e",
    "\xea": "e",
    "\xeb": "e",
    "\xcc": "I",
    "\xcd": "I",
    "\xce": "I",
    "\xcf": "I",
    "\xec": "i",
    "\xed": "i",
    "\xee": "i",
    "\xef": "i",
    "\xd1": "N",
    "\xf1": "n",
    "\xd2": "O",
    "\xd3": "O",
    "\xd4": "O",
    "\xd5": "O",
    "\xd6": "O",
    "\xd8": "O",
    "\xf2": "o",
    "\xf3": "o",
    "\xf4": "o",
    "\xf5": "o",
    "\xf6": "o",
    "\xf8": "o",
    "\xd9": "U",
    "\xda": "U",
    "\xdb": "U",
    "\xdc": "U",
    "\xf9": "u",
    "\xfa": "u",
    "\xfb": "u",
    "\xfc": "u",
    "\xdd": "Y",
    "\xfd": "y",
    "\xff": "y",
    "\xc6": "Ae",
    "\xe6": "ae",
    "\xde": "Th",
    "\xfe": "th",
    "\xdf": "ss",
    // Latin Extended-A block.
    "\u0100": "A",
    "\u0102": "A",
    "\u0104": "A",
    "\u0101": "a",
    "\u0103": "a",
    "\u0105": "a",
    "\u0106": "C",
    "\u0108": "C",
    "\u010A": "C",
    "\u010C": "C",
    "\u0107": "c",
    "\u0109": "c",
    "\u010B": "c",
    "\u010D": "c",
    "\u010E": "D",
    "\u0110": "D",
    "\u010F": "d",
    "\u0111": "d",
    "\u0112": "E",
    "\u0114": "E",
    "\u0116": "E",
    "\u0118": "E",
    "\u011A": "E",
    "\u0113": "e",
    "\u0115": "e",
    "\u0117": "e",
    "\u0119": "e",
    "\u011B": "e",
    "\u011C": "G",
    "\u011E": "G",
    "\u0120": "G",
    "\u0122": "G",
    "\u011D": "g",
    "\u011F": "g",
    "\u0121": "g",
    "\u0123": "g",
    "\u0124": "H",
    "\u0126": "H",
    "\u0125": "h",
    "\u0127": "h",
    "\u0128": "I",
    "\u012A": "I",
    "\u012C": "I",
    "\u012E": "I",
    "\u0130": "I",
    "\u0129": "i",
    "\u012B": "i",
    "\u012D": "i",
    "\u012F": "i",
    "\u0131": "i",
    "\u0134": "J",
    "\u0135": "j",
    "\u0136": "K",
    "\u0137": "k",
    "\u0138": "k",
    "\u0139": "L",
    "\u013B": "L",
    "\u013D": "L",
    "\u013F": "L",
    "\u0141": "L",
    "\u013A": "l",
    "\u013C": "l",
    "\u013E": "l",
    "\u0140": "l",
    "\u0142": "l",
    "\u0143": "N",
    "\u0145": "N",
    "\u0147": "N",
    "\u014A": "N",
    "\u0144": "n",
    "\u0146": "n",
    "\u0148": "n",
    "\u014B": "n",
    "\u014C": "O",
    "\u014E": "O",
    "\u0150": "O",
    "\u014D": "o",
    "\u014F": "o",
    "\u0151": "o",
    "\u0154": "R",
    "\u0156": "R",
    "\u0158": "R",
    "\u0155": "r",
    "\u0157": "r",
    "\u0159": "r",
    "\u015A": "S",
    "\u015C": "S",
    "\u015E": "S",
    "\u0160": "S",
    "\u015B": "s",
    "\u015D": "s",
    "\u015F": "s",
    "\u0161": "s",
    "\u0162": "T",
    "\u0164": "T",
    "\u0166": "T",
    "\u0163": "t",
    "\u0165": "t",
    "\u0167": "t",
    "\u0168": "U",
    "\u016A": "U",
    "\u016C": "U",
    "\u016E": "U",
    "\u0170": "U",
    "\u0172": "U",
    "\u0169": "u",
    "\u016B": "u",
    "\u016D": "u",
    "\u016F": "u",
    "\u0171": "u",
    "\u0173": "u",
    "\u0174": "W",
    "\u0175": "w",
    "\u0176": "Y",
    "\u0177": "y",
    "\u0178": "Y",
    "\u0179": "Z",
    "\u017B": "Z",
    "\u017D": "Z",
    "\u017A": "z",
    "\u017C": "z",
    "\u017E": "z",
    "\u0132": "IJ",
    "\u0133": "ij",
    "\u0152": "Oe",
    "\u0153": "oe",
    "\u0149": "'n",
    "\u017F": "s"
};
var deburrLetter$1 = basePropertyOf(deburredLetters);
var _deburrLetter = deburrLetter$1;
function arrayMap$2(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length, result = Array(length);
    while(++index < length)result[index] = iteratee(array[index], index, array);
    return result;
}
var _arrayMap = arrayMap$2;
var baseGetTag$4 = _baseGetTag, isObjectLike$5 = isObjectLike_1;
var symbolTag = "[object Symbol]";
function isSymbol$4(value) {
    return typeof value == "symbol" || isObjectLike$5(value) && baseGetTag$4(value) == symbolTag;
}
var isSymbol_1 = isSymbol$4;
var Symbol$2 = _Symbol, arrayMap$1 = _arrayMap, isArray$6 = isArray_1, isSymbol$3 = isSymbol_1;
var INFINITY$1 = 1 / 0;
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString$1(value) {
    if (typeof value == "string") return value;
    if (isArray$6(value)) return arrayMap$1(value, baseToString$1) + "";
    if (isSymbol$3(value)) return symbolToString ? symbolToString.call(value) : "";
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
var _baseToString = baseToString$1;
var baseToString = _baseToString;
function toString$5(value) {
    return value == null ? "" : baseToString(value);
}
var toString_1 = toString$5;
var deburrLetter = _deburrLetter, toString$4 = toString_1;
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange$3 = "\\u0300-\\u036f", reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$3 = "\\u20d0-\\u20ff", rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3;
var rsCombo$2 = "[" + rsComboRange$3 + "]";
var reComboMark = RegExp(rsCombo$2, "g");
function deburr$1(string) {
    string = toString$4(string);
    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
}
var deburr_1 = deburr$1;
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords$1(string) {
    return string.match(reAsciiWord) || [];
}
var _asciiWords = asciiWords$1;
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord$1(string) {
    return reHasUnicodeWord.test(string);
}
var _hasUnicodeWord = hasUnicodeWord$1;
var rsAstralRange$2 = "\ud800-\udfff", rsComboMarksRange$2 = "\\u0300-\\u036f", reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$2 = "\\u20d0-\\u20ff", rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange$2 = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
var rsApos$1 = "['\u2019]", rsBreak = "[" + rsBreakRange + "]", rsCombo$1 = "[" + rsComboRange$2 + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange$2 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz$1 = "\ud83c[\udffb-\udfff]", rsModifier$1 = "(?:" + rsCombo$1 + "|" + rsFitz$1 + ")", rsNonAstral$1 = "[^" + rsAstralRange$2 + "]", rsRegional$1 = "(?:\ud83c[\udde6-\uddff]){2}", rsSurrPair$1 = "[\ud800-\udbff][\udc00-\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ$2 = "\\u200d";
var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?", reOptMod$1 = rsModifier$1 + "?", rsOptVar$1 = "[" + rsVarRange$2 + "]?", rsOptJoin$1 = "(?:" + rsZWJ$2 + "(?:" + [
    rsNonAstral$1,
    rsRegional$1,
    rsSurrPair$1
].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsEmoji = "(?:" + [
    rsDingbat,
    rsRegional$1,
    rsSurrPair$1
].join("|") + ")" + rsSeq$1;
var reUnicodeWord = RegExp([
    rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [
        rsBreak,
        rsUpper,
        "$"
    ].join("|") + ")",
    rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [
        rsBreak,
        rsUpper + rsMiscLower,
        "$"
    ].join("|") + ")",
    rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
    rsUpper + "+" + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
].join("|"), "g");
function unicodeWords$1(string) {
    return string.match(reUnicodeWord) || [];
}
var _unicodeWords = unicodeWords$1;
var asciiWords = _asciiWords, hasUnicodeWord = _hasUnicodeWord, toString$3 = toString_1, unicodeWords = _unicodeWords;
function words$1(string, pattern, guard) {
    string = toString$3(string);
    pattern = guard ? void 0 : pattern;
    if (pattern === void 0) return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
    return string.match(pattern) || [];
}
var words_1 = words$1;
var arrayReduce = _arrayReduce, deburr = deburr_1, words = words_1;
var rsApos = "['\u2019]";
var reApos = RegExp(rsApos, "g");
function createCompounder$3(callback) {
    return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
    };
}
var _createCompounder = createCompounder$3;
var createCompounder$2 = _createCompounder;
var kebabCase = createCompounder$2(function(result, word, index) {
    return result + (index ? "-" : "") + word.toLowerCase();
});
var kebabCase_1 = kebabCase;
const kebabCase$1 = /* @__PURE__ */ (0, _commonjsHelpersJs.g)(kebabCase_1);
function baseSlice$2(array, start, end) {
    var index = -1, length = array.length;
    if (start < 0) start = -start > length ? 0 : length + start;
    end = end > length ? length : end;
    if (end < 0) end += length;
    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);
    while(++index < length)result[index] = array[index + start];
    return result;
}
var _baseSlice = baseSlice$2;
var baseSlice$1 = _baseSlice;
function castSlice$1(array, start, end) {
    var length = array.length;
    end = end === void 0 ? length : end;
    return !start && end >= length ? array : baseSlice$1(array, start, end);
}
var _castSlice = castSlice$1;
var rsAstralRange$1 = "\ud800-\udfff", rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsVarRange$1 = "\\ufe0e\\ufe0f";
var rsZWJ$1 = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ$1 + rsAstralRange$1 + rsComboRange$1 + rsVarRange$1 + "]");
function hasUnicode$2(string) {
    return reHasUnicode.test(string);
}
var _hasUnicode = hasUnicode$2;
function asciiToArray$1(string) {
    return string.split("");
}
var _asciiToArray = asciiToArray$1;
var rsAstralRange = "\ud800-\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\ud83c[\udffb-\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\ud83c[\udde6-\uddff]){2}", rsSurrPair = "[\ud800-\udbff][\udc00-\udfff]", rsZWJ = "\\u200d";
var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [
    rsNonAstral,
    rsRegional,
    rsSurrPair
].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [
    rsNonAstral + rsCombo + "?",
    rsCombo,
    rsRegional,
    rsSurrPair,
    rsAstral
].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray$1(string) {
    return string.match(reUnicode) || [];
}
var _unicodeToArray = unicodeToArray$1;
var asciiToArray = _asciiToArray, hasUnicode$1 = _hasUnicode, unicodeToArray = _unicodeToArray;
function stringToArray$1(string) {
    return hasUnicode$1(string) ? unicodeToArray(string) : asciiToArray(string);
}
var _stringToArray = stringToArray$1;
var castSlice = _castSlice, hasUnicode = _hasUnicode, stringToArray = _stringToArray, toString$2 = toString_1;
function createCaseFirst$1(methodName) {
    return function(string) {
        string = toString$2(string);
        var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
        var chr = strSymbols ? strSymbols[0] : string.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
        return chr[methodName]() + trailing;
    };
}
var _createCaseFirst = createCaseFirst$1;
var createCaseFirst = _createCaseFirst;
var upperFirst$2 = createCaseFirst("toUpperCase");
var upperFirst_1 = upperFirst$2;
var toString$1 = toString_1, upperFirst$1 = upperFirst_1;
function capitalize$1(string) {
    return upperFirst$1(toString$1(string).toLowerCase());
}
var capitalize_1 = capitalize$1;
var capitalize = capitalize_1, createCompounder$1 = _createCompounder;
var camelCase = createCompounder$1(function(result, word, index) {
    word = word.toLowerCase();
    return result + (index ? capitalize(word) : word);
});
var camelCase_1 = camelCase;
const camelCase$1 = /* @__PURE__ */ (0, _commonjsHelpersJs.g)(camelCase_1);
function isNil(value) {
    return value == null;
}
var isNil_1 = isNil;
const isNil$1 = /* @__PURE__ */ (0, _commonjsHelpersJs.g)(isNil_1);
var root = _root;
var now$1 = function() {
    return root.Date.now();
};
var now_1 = now$1;
var reWhitespace = /\s/;
function trimmedEndIndex$1(string) {
    var index = string.length;
    while(index-- && reWhitespace.test(string.charAt(index)));
    return index;
}
var _trimmedEndIndex = trimmedEndIndex$1;
var trimmedEndIndex = _trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim$1(string) {
    return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
var _baseTrim = baseTrim$1;
var baseTrim = _baseTrim, isObject$6 = isObject_1, isSymbol$2 = isSymbol_1;
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber$2(value) {
    if (typeof value == "number") return value;
    if (isSymbol$2(value)) return NAN;
    if (isObject$6(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject$6(other) ? other + "" : other;
    }
    if (typeof value != "string") return value === 0 ? value : +value;
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_1 = toNumber$2;
var isObject$5 = isObject_1, now = now_1, toNumber$1 = toNumber_1;
var FUNC_ERROR_TEXT$2 = "Expected a function";
var nativeMax$1 = Math.max, nativeMin = Math.min;
function debounce$1(func, wait, options) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") throw new TypeError(FUNC_ERROR_TEXT$2);
    wait = toNumber$1(wait) || 0;
    if (isObject$5(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax$1(toNumber$1(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
    }
    function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }
    function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) return trailingEdge(time);
        timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) return invokeFunc(time);
        lastArgs = lastThis = void 0;
        return result;
    }
    function cancel() {
        if (timerId !== void 0) clearTimeout(timerId);
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
    }
    function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
            if (timerId === void 0) return leadingEdge(lastCallTime);
            if (maxing) {
                clearTimeout(timerId);
                timerId = setTimeout(timerExpired, wait);
                return invokeFunc(lastCallTime);
            }
        }
        if (timerId === void 0) timerId = setTimeout(timerExpired, wait);
        return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
}
var debounce_1 = debounce$1;
const debounce$2 = /* @__PURE__ */ (0, _commonjsHelpersJs.g)(debounce_1);
var isArray$5 = isArray_1, isSymbol$1 = isSymbol_1;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey$1(value, object) {
    if (isArray$5(value)) return false;
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$1(value)) return true;
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var _isKey = isKey$1;
var MapCache = _MapCache;
var FUNC_ERROR_TEXT$1 = "Expected a function";
function memoize$1(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") throw new TypeError(FUNC_ERROR_TEXT$1);
    var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) return cache.get(key);
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
    };
    memoized.cache = new (memoize$1.Cache || MapCache)();
    return memoized;
}
memoize$1.Cache = MapCache;
var memoize_1 = memoize$1;
var memoize = memoize_1;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped$1(func) {
    var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) cache.clear();
        return key;
    });
    var cache = result.cache;
    return result;
}
var _memoizeCapped = memoizeCapped$1;
var memoizeCapped = _memoizeCapped;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath$1 = memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46) result.push("");
    string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
    });
    return result;
});
var _stringToPath = stringToPath$1;
var isArray$4 = isArray_1, isKey = _isKey, stringToPath = _stringToPath, toString = toString_1;
function castPath$6(value, object) {
    if (isArray$4(value)) return value;
    return isKey(value, object) ? [
        value
    ] : stringToPath(toString(value));
}
var _castPath = castPath$6;
var isSymbol = isSymbol_1;
var INFINITY = 1 / 0;
function toKey$4(value) {
    if (typeof value == "string" || isSymbol(value)) return value;
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var _toKey = toKey$4;
var castPath$5 = _castPath, toKey$3 = _toKey;
function baseGet$2(object, path) {
    path = castPath$5(path, object);
    var index = 0, length = path.length;
    while(object != null && index < length)object = object[toKey$3(path[index++])];
    return index && index == length ? object : void 0;
}
var _baseGet = baseGet$2;
var assignValue = _assignValue, castPath$4 = _castPath, isIndex$2 = _isIndex, isObject$4 = isObject_1, toKey$2 = _toKey;
function baseSet$1(object, path, value, customizer) {
    if (!isObject$4(object)) return object;
    path = castPath$4(path, object);
    var index = -1, length = path.length, lastIndex = length - 1, nested = object;
    while(nested != null && ++index < length){
        var key = toKey$2(path[index]), newValue = value;
        if (key === "__proto__" || key === "constructor" || key === "prototype") return object;
        if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : void 0;
            if (newValue === void 0) newValue = isObject$4(objValue) ? objValue : isIndex$2(path[index + 1]) ? [] : {};
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
    }
    return object;
}
var _baseSet = baseSet$1;
var baseGet$1 = _baseGet, baseSet = _baseSet, castPath$3 = _castPath;
function basePickBy$1(object, paths, predicate) {
    var index = -1, length = paths.length, result = {};
    while(++index < length){
        var path = paths[index], value = baseGet$1(object, path);
        if (predicate(value, path)) baseSet(result, castPath$3(path, object), value);
    }
    return result;
}
var _basePickBy = basePickBy$1;
function baseHasIn$1(object, key) {
    return object != null && key in Object(object);
}
var _baseHasIn = baseHasIn$1;
var castPath$2 = _castPath, isArguments$2 = isArguments_1, isArray$3 = isArray_1, isIndex$1 = _isIndex, isLength = isLength_1, toKey$1 = _toKey;
function hasPath$1(object, path, hasFunc) {
    path = castPath$2(path, object);
    var index = -1, length = path.length, result = false;
    while(++index < length){
        var key = toKey$1(path[index]);
        if (!(result = object != null && hasFunc(object, key))) break;
        object = object[key];
    }
    if (result || ++index != length) return result;
    length = object == null ? 0 : object.length;
    return !!length && isLength(length) && isIndex$1(key, length) && (isArray$3(object) || isArguments$2(object));
}
var _hasPath = hasPath$1;
var baseHasIn = _baseHasIn, hasPath = _hasPath;
function hasIn$1(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
}
var hasIn_1 = hasIn$1;
var basePickBy = _basePickBy, hasIn = hasIn_1;
function basePick$1(object, paths) {
    return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
    });
}
var _basePick = basePick$1;
var Symbol$1 = _Symbol, isArguments$1 = isArguments_1, isArray$2 = isArray_1;
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
function isFlattenable$1(value) {
    return isArray$2(value) || isArguments$1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var _isFlattenable = isFlattenable$1;
var arrayPush = _arrayPush, isFlattenable = _isFlattenable;
function baseFlatten$1(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while(++index < length){
        var value = array[index];
        if (depth > 0 && predicate(value)) {
            if (depth > 1) baseFlatten$1(value, depth - 1, predicate, isStrict, result);
            else arrayPush(result, value);
        } else if (!isStrict) result[result.length] = value;
    }
    return result;
}
var _baseFlatten = baseFlatten$1;
var baseFlatten = _baseFlatten;
function flatten$1(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseFlatten(array, 1) : [];
}
var flatten_1 = flatten$1;
const flatten$2 = /* @__PURE__ */ (0, _commonjsHelpersJs.g)(flatten_1);
function apply$1(func, thisArg, args) {
    switch(args.length){
        case 0:
            return func.call(thisArg);
        case 1:
            return func.call(thisArg, args[0]);
        case 2:
            return func.call(thisArg, args[0], args[1]);
        case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
}
var _apply = apply$1;
var apply = _apply;
var nativeMax = Math.max;
function overRest$2(func, start, transform) {
    start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
    return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while(++index < length)array[index] = args[start + index];
        index = -1;
        var otherArgs = Array(start + 1);
        while(++index < start)otherArgs[index] = args[index];
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
    };
}
var _overRest = overRest$2;
function constant$1(value) {
    return function() {
        return value;
    };
}
var constant_1 = constant$1;
function identity$2(value) {
    return value;
}
var identity_1 = identity$2;
var constant = constant_1, defineProperty = _defineProperty, identity$1 = identity_1;
var baseSetToString$1 = !defineProperty ? identity$1 : function(func, string) {
    return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
    });
};
var _baseSetToString = baseSetToString$1;
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut$1(func) {
    var count = 0, lastCalled = 0;
    return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
            if (++count >= HOT_COUNT) return arguments[0];
        } else count = 0;
        return func.apply(void 0, arguments);
    };
}
var _shortOut = shortOut$1;
var baseSetToString = _baseSetToString, shortOut = _shortOut;
var setToString$2 = shortOut(baseSetToString);
var _setToString = setToString$2;
var flatten = flatten_1, overRest$1 = _overRest, setToString$1 = _setToString;
function flatRest$2(func) {
    return setToString$1(overRest$1(func, void 0, flatten), func + "");
}
var _flatRest = flatRest$2;
var basePick = _basePick, flatRest$1 = _flatRest;
var pick = flatRest$1(function(object, paths) {
    return object == null ? {} : basePick(object, paths);
});
var pick_1 = pick;
const pick$1 = /* @__PURE__ */ (0, _commonjsHelpersJs.g)(pick_1);
var baseGetTag$3 = _baseGetTag, isArray$1 = isArray_1, isObjectLike$4 = isObjectLike_1;
var stringTag = "[object String]";
function isString(value) {
    return typeof value == "string" || !isArray$1(value) && isObjectLike$4(value) && baseGetTag$3(value) == stringTag;
}
var isString_1 = isString;
const isString$1 = /* @__PURE__ */ (0, _commonjsHelpersJs.g)(isString_1);
var baseAssignValue = _baseAssignValue, eq$1 = eq_1;
function assignMergeValue$2(object, key, value) {
    if (value !== void 0 && !eq$1(object[key], value) || value === void 0 && !(key in object)) baseAssignValue(object, key, value);
}
var _assignMergeValue = assignMergeValue$2;
function createBaseFor$1(fromRight) {
    return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while(length--){
            var key = props[fromRight ? length : ++index];
            if (iteratee(iterable[key], key, iterable) === false) break;
        }
        return object;
    };
}
var _createBaseFor = createBaseFor$1;
var createBaseFor = _createBaseFor;
var baseFor$1 = createBaseFor();
var _baseFor = baseFor$1;
var isArrayLike$1 = isArrayLike_1, isObjectLike$3 = isObjectLike_1;
function isArrayLikeObject$1(value) {
    return isObjectLike$3(value) && isArrayLike$1(value);
}
var isArrayLikeObject_1 = isArrayLikeObject$1;
var baseGetTag$2 = _baseGetTag, getPrototype = _getPrototype, isObjectLike$2 = isObjectLike_1;
var objectTag = "[object Object]";
var funcProto = Function.prototype, objectProto = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject$2(value) {
    if (!isObjectLike$2(value) || baseGetTag$2(value) != objectTag) return false;
    var proto = getPrototype(value);
    if (proto === null) return true;
    var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var isPlainObject_1 = isPlainObject$2;
function safeGet$2(object, key) {
    if (key === "constructor" && typeof object[key] === "function") return;
    if (key == "__proto__") return;
    return object[key];
}
var _safeGet = safeGet$2;
var copyObject$1 = _copyObject, keysIn$1 = keysIn_1;
function toPlainObject$1(value) {
    return copyObject$1(value, keysIn$1(value));
}
var toPlainObject_1 = toPlainObject$1;
var assignMergeValue$1 = _assignMergeValue, cloneBuffer = _cloneBufferExports, cloneTypedArray = _cloneTypedArray, copyArray = _copyArray, initCloneObject = _initCloneObject, isArguments = isArguments_1, isArray = isArray_1, isArrayLikeObject = isArrayLikeObject_1, isBuffer = isBufferExports, isFunction = isFunction_1, isObject$3 = isObject_1, isPlainObject$1 = isPlainObject_1, isTypedArray = isTypedArray_1, safeGet$1 = _safeGet, toPlainObject = toPlainObject_1;
function baseMergeDeep$1(object, source, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet$1(object, key), srcValue = safeGet$1(source, key), stacked = stack.get(srcValue);
    if (stacked) {
        assignMergeValue$1(object, key, stacked);
        return;
    }
    var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
    var isCommon = newValue === void 0;
    if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) newValue = objValue;
            else if (isArrayLikeObject(objValue)) newValue = copyArray(objValue);
            else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
            } else newValue = [];
        } else if (isPlainObject$1(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) newValue = toPlainObject(objValue);
            else if (!isObject$3(objValue) || isFunction(objValue)) newValue = initCloneObject(srcValue);
        } else isCommon = false;
    }
    if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
    }
    assignMergeValue$1(object, key, newValue);
}
var _baseMergeDeep = baseMergeDeep$1;
var Stack = _Stack, assignMergeValue = _assignMergeValue, baseFor = _baseFor, baseMergeDeep = _baseMergeDeep, isObject$2 = isObject_1, keysIn = keysIn_1, safeGet = _safeGet;
function baseMerge$1(object, source, srcIndex, customizer, stack) {
    if (object === source) return;
    baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject$2(srcValue)) baseMergeDeep(object, source, key, srcIndex, baseMerge$1, customizer, stack);
        else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
            if (newValue === void 0) newValue = srcValue;
            assignMergeValue(object, key, newValue);
        }
    }, keysIn);
}
var _baseMerge = baseMerge$1;
var identity = identity_1, overRest = _overRest, setToString = _setToString;
function baseRest$1(func, start) {
    return setToString(overRest(func, start, identity), func + "");
}
var _baseRest = baseRest$1;
var eq = eq_1, isArrayLike = isArrayLike_1, isIndex = _isIndex, isObject$1 = isObject_1;
function isIterateeCall$1(value, index, object) {
    if (!isObject$1(object)) return false;
    var type = typeof index;
    if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) return eq(object[index], value);
    return false;
}
var _isIterateeCall = isIterateeCall$1;
var baseRest = _baseRest, isIterateeCall = _isIterateeCall;
function createAssigner$1(assigner) {
    return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? void 0 : customizer;
            length = 1;
        }
        object = Object(object);
        while(++index < length){
            var source = sources[index];
            if (source) assigner(object, source, index, customizer);
        }
        return object;
    });
}
var _createAssigner = createAssigner$1;
var baseMerge = _baseMerge, createAssigner = _createAssigner;
var merge = createAssigner(function(object, source, srcIndex) {
    baseMerge(object, source, srcIndex);
});
var merge_1 = merge;
const merge$1 = /* @__PURE__ */ (0, _commonjsHelpersJs.g)(merge_1);
function last$1(array) {
    var length = array == null ? 0 : array.length;
    return length ? array[length - 1] : void 0;
}
var last_1 = last$1;
var baseGet = _baseGet, baseSlice = _baseSlice;
function parent$1(object, path) {
    return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}
var _parent = parent$1;
var castPath$1 = _castPath, last = last_1, parent = _parent, toKey = _toKey;
function baseUnset$1(object, path) {
    path = castPath$1(path, object);
    object = parent(object, path);
    return object == null || delete object[toKey(last(path))];
}
var _baseUnset = baseUnset$1;
var isPlainObject = isPlainObject_1;
function customOmitClone$1(value) {
    return isPlainObject(value) ? void 0 : value;
}
var _customOmitClone = customOmitClone$1;
var arrayMap = _arrayMap, baseClone = _baseClone, baseUnset = _baseUnset, castPath = _castPath, copyObject = _copyObject, customOmitClone = _customOmitClone, flatRest = _flatRest, getAllKeysIn = _getAllKeysIn;
var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
var omit = flatRest(function(object, paths) {
    var result = {};
    if (object == null) return result;
    var isDeep = false;
    paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
    });
    copyObject(object, getAllKeysIn(object), result);
    if (isDeep) result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
    var length = paths.length;
    while(length--)baseUnset(result, paths[length]);
    return result;
});
var omit_1 = omit;
const omit$1 = /* @__PURE__ */ (0, _commonjsHelpersJs.g)(omit_1);
function baseClamp$1(number, lower, upper) {
    if (number === number) {
        if (upper !== void 0) number = number <= upper ? number : upper;
        if (lower !== void 0) number = number >= lower ? number : lower;
    }
    return number;
}
var _baseClamp = baseClamp$1;
var baseClamp = _baseClamp, toNumber = toNumber_1;
function clamp(number, lower, upper) {
    if (upper === void 0) {
        upper = lower;
        lower = void 0;
    }
    if (upper !== void 0) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
    }
    if (lower !== void 0) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
    }
    return baseClamp(toNumber(number), lower, upper);
}
var clamp_1 = clamp;
const clamp$1 = /* @__PURE__ */ (0, _commonjsHelpersJs.g)(clamp_1);
function noop() {}
var noop_1 = noop;
const noop$1 = /* @__PURE__ */ (0, _commonjsHelpersJs.g)(noop_1);
var debounce = debounce_1, isObject = isObject_1;
var FUNC_ERROR_TEXT = "Expected a function";
function throttle(func, wait, options) {
    var leading = true, trailing = true;
    if (typeof func != "function") throw new TypeError(FUNC_ERROR_TEXT);
    if (isObject(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    return debounce(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
    });
}
var throttle_1 = throttle;
const throttle$1 = /* @__PURE__ */ (0, _commonjsHelpersJs.g)(throttle_1);
var createCompounder = _createCompounder, upperFirst = upperFirst_1;
var startCase = createCompounder(function(result, word, index) {
    return result + (index ? " " : "") + upperFirst(word);
});
var startCase_1 = startCase;
const startCase$1 = /* @__PURE__ */ (0, _commonjsHelpersJs.g)(startCase_1);
var baseGetTag$1 = _baseGetTag, isObjectLike$1 = isObjectLike_1;
var dateTag = "[object Date]";
function baseIsDate$1(value) {
    return isObjectLike$1(value) && baseGetTag$1(value) == dateTag;
}
var _baseIsDate = baseIsDate$1;
var baseIsDate = _baseIsDate, baseUnary = _baseUnary, nodeUtil = _nodeUtilExports;
var nodeIsDate = nodeUtil && nodeUtil.isDate;
var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
var isDate_1 = isDate;
const isDate$1 = /* @__PURE__ */ (0, _commonjsHelpersJs.g)(isDate_1);
var baseGetTag = _baseGetTag, isObjectLike = isObjectLike_1;
var numberTag = "[object Number]";
function isNumber(value) {
    return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
}
var isNumber_1 = isNumber;
const isNumber$1 = /* @__PURE__ */ (0, _commonjsHelpersJs.g)(isNumber_1);

},{"./__commonjsHelpers__.js":"24MVU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"24MVU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "c", ()=>commonjsGlobal);
parcelHelpers.export(exports, "g", ()=>getDefaultExportFromCjs);
var global = arguments[3];
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kdMVI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "c", ()=>createProps);
var _useChildComponentsJs = require("../../composables/useChildComponents.js");
const KEBAB_CASE_REGEX = /([a-z0-9])([A-Z])/g;
const toKebabCase = (str)=>str.replace(KEBAB_CASE_REGEX, "$1-$2").toLowerCase();
const findCamelCased = (obj, key)=>{
    if (key in obj) return obj[key];
    return obj[toKebabCase(key)];
};
const createProps = (instance, propsFromConfig)=>{
    const instanceProps = instance.props;
    const childPropsFromParent = (0, _useChildComponentsJs.a)();
    return new Proxy(instanceProps, {
        get: (target, key)=>{
            var _a, _b;
            if (typeof key !== "string") return target[key];
            const childProp = (_a = childPropsFromParent == null ? void 0 : childPropsFromParent.value) == null ? void 0 : _a[key];
            if (childProp !== void 0) return childProp;
            const incomingProps = instance.vnode.props || {};
            const originalProp = target[key];
            const incomingProp = findCamelCased(incomingProps, key);
            if (incomingProp !== void 0) return originalProp;
            const propFromConfig = (_b = propsFromConfig.value) == null ? void 0 : _b[key];
            if (propFromConfig !== void 0) return propFromConfig;
            return originalProp;
        }
    });
};

},{"../../composables/useChildComponents.js":"gy3gn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gy3gn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>injectChildPropsFromParent);
parcelHelpers.export(exports, "d", ()=>defineChildProps);
parcelHelpers.export(exports, "i", ()=>injectChildPresetPropFromParent);
parcelHelpers.export(exports, "u", ()=>useChildComponents);
var _vue = require("vue");
const CHILD_COMPONENT_PROP_PREFIX = "child:";
const CHILD_COMPONENTS_INJECT_KEY = "$va:childComponents";
const defineChildProps = (obj)=>{
    return Object.keys(obj).reduce((acc, key)=>{
        const childName = `${CHILD_COMPONENT_PROP_PREFIX}${key}`;
        acc[childName] = {
            type: Object,
            required: false,
            default: void 0
        };
        return acc;
    }, {});
};
const useChildComponents = (props)=>{
    const childProps = (0, _vue.computed)(()=>{
        const propNames = Object.keys(props);
        return propNames.reduce((acc, propName)=>{
            if (propName.startsWith(CHILD_COMPONENT_PROP_PREFIX)) {
                const childName = propName.slice(CHILD_COMPONENT_PROP_PREFIX.length);
                acc[childName] = props[propName];
            }
            return acc;
        }, {});
    });
    (0, _vue.provide)(CHILD_COMPONENTS_INJECT_KEY, childProps);
};
const injectChildPropsFromParent = ()=>{
    var _a;
    const childName = (_a = (0, _vue.getCurrentInstance)()) == null ? void 0 : _a.attrs["va-child"];
    if (!childName) return null;
    const childProps = (0, _vue.inject)(CHILD_COMPONENTS_INJECT_KEY);
    if (!(childProps == null ? void 0 : childProps.value)) return null;
    return (0, _vue.computed)(()=>childProps.value[childName]);
};
const injectChildPresetPropFromParent = ()=>{
    var _a;
    const childName = (_a = (0, _vue.getCurrentInstance)()) == null ? void 0 : _a.attrs["va-child"];
    if (!childName) return null;
    const childProps = (0, _vue.inject)(CHILD_COMPONENTS_INJECT_KEY);
    if (!(childProps == null ? void 0 : childProps.value)) return null;
    return (0, _vue.computed)(()=>{
        var _a2;
        return (_a2 = childProps.value[childName]) == null ? void 0 : _a2.preset;
    });
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"depDp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "c", ()=>createAttrs);
var _vue = require("vue");
const createAttrs = (instance, propsFromConfig)=>{
    const instanceAttrs = instance.attrs;
    return new Proxy(instanceAttrs, {
        get: (target, key)=>{
            var _a;
            if (typeof key !== "string") return target[key];
            if (key === "class") return (0, _vue.normalizeClass)([
                propsFromConfig.value.class,
                instanceAttrs.class
            ]);
            if (key === "style") return (0, _vue.normalizeStyle)([
                propsFromConfig.value.style,
                instanceAttrs.style
            ]);
            const attrFromConfig = (_a = propsFromConfig.value) == null ? void 0 : _a[key];
            if (attrFromConfig !== void 0) return attrFromConfig;
            return target[key];
        },
        ownKeys (target) {
            return [
                .../* @__PURE__ */ new Set([
                    ...Object.keys(instanceAttrs),
                    ...Object.keys(propsFromConfig.value)
                ])
            ];
        },
        getOwnPropertyDescriptor (target, key) {
            return Reflect.getOwnPropertyDescriptor(propsFromConfig.value, key) ?? Reflect.getOwnPropertyDescriptor(instanceAttrs, key);
        }
    });
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"w5WyW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "c", ()=>createSlots);
var _vue = require("vue");
var _useChildComponentsJs = require("../../composables/useChildComponents.js");
var _createRenderFnJs = require("./createRenderFn.js");
const SLOT_PREFIX = "slot:";
const createSlots = (instance, propsFromConfig)=>{
    const instanceSlots = instance.slots;
    const childPropsFromParent = (0, _useChildComponentsJs.a)();
    const slotsFromConfig = (0, _vue.computed)(()=>{
        return Object.keys(propsFromConfig.value).reduce((acc, key)=>{
            if (key.startsWith(SLOT_PREFIX)) acc[key.slice(SLOT_PREFIX.length)] = propsFromConfig.value[key];
            return acc;
        }, {});
    });
    return new Proxy(instanceSlots, {
        get: (target, key)=>{
            var _a, _b;
            if (typeof key !== "string") return target[key];
            const prefixedKey = `${SLOT_PREFIX}${key}`;
            const childSlot = (_a = childPropsFromParent == null ? void 0 : childPropsFromParent.value) == null ? void 0 : _a[prefixedKey];
            if (childSlot !== void 0) return (0, _createRenderFnJs.r)((0, _createRenderFnJs.m)(childSlot));
            const originalSlot = target[key];
            if (originalSlot !== void 0) return originalSlot;
            const propFromConfig = (_b = slotsFromConfig.value) == null ? void 0 : _b[key];
            if (propFromConfig !== void 0) return (0, _createRenderFnJs.r)((0, _createRenderFnJs.m)(propFromConfig));
            return originalSlot;
        },
        ownKeys (target) {
            return [
                .../* @__PURE__ */ new Set([
                    ...Object.keys(instanceSlots),
                    ...Object.keys(slotsFromConfig.value)
                ])
            ];
        },
        getOwnPropertyDescriptor (target, key) {
            return Reflect.getOwnPropertyDescriptor(slotsFromConfig.value, key) ?? Reflect.getOwnPropertyDescriptor(instanceSlots, key);
        }
    });
};

},{"vue":"gzxs9","../../composables/useChildComponents.js":"gy3gn","./createRenderFn.js":"5TRzn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6jKmc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useComponentConfigProps);
var _useLocalConfigJs = require("../../../composables/useLocalConfig.js");
var _vue = require("vue");
var _useChildComponentsJs = require("../../../composables/useChildComponents.js");
var _useGlobalConfigJs = require("../../../composables/useGlobalConfig.js");
const useComponentConfigProps = (component, originalProps)=>{
    const localConfig = (0, _useLocalConfigJs.u)();
    const { globalConfig } = (0, _useGlobalConfigJs.u)();
    const instancePreset = (0, _vue.computed)(()=>originalProps.preset);
    const getPresetProps = (presetName)=>{
        var _a, _b, _c;
        return (_c = (_b = (_a = globalConfig.value.components) == null ? void 0 : _a.presets) == null ? void 0 : _b[component.name]) == null ? void 0 : _c[presetName];
    };
    const parentPropPreset = (0, _useChildComponentsJs.i)();
    return (0, _vue.computed)(()=>{
        var _a, _b;
        const globalConfigProps = {
            ...(_a = globalConfig.value.components) == null ? void 0 : _a.all,
            ...(_b = globalConfig.value.components) == null ? void 0 : _b[component.name]
        };
        const localConfigProps = localConfig.value.reduce((finalConfig, config)=>config[component.name] ? {
                ...finalConfig,
                ...config[component.name]
            } : finalConfig, {});
        const presetName = (parentPropPreset == null ? void 0 : parentPropPreset.value) || instancePreset.value || localConfigProps.preset || globalConfigProps.preset;
        const presetProps = presetName && getPresetProps(presetName);
        return {
            ...globalConfigProps,
            ...localConfigProps,
            ...presetProps
        };
    });
};

},{"../../../composables/useLocalConfig.js":"dvyav","vue":"gzxs9","../../../composables/useChildComponents.js":"gy3gn","../../../composables/useGlobalConfig.js":"8pVeR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dvyav":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useLocalConfigProvider);
parcelHelpers.export(exports, "p", ()=>provideLocalConfig);
parcelHelpers.export(exports, "u", ()=>useLocalConfig);
var _vue = require("vue");
const LocalConfigKey = "VaLocalConfig";
const CONFIGS_DEFAULT = (0, _vue.computed)(()=>[]);
function useLocalConfig() {
    return (0, _vue.inject)(LocalConfigKey, CONFIGS_DEFAULT);
}
function provideLocalConfig(config) {
    (0, _vue.provide)(LocalConfigKey, config);
}
function useLocalConfigProvider(config) {
    const prevChain = useLocalConfig();
    const nextChain = (0, _vue.computed)(()=>[
            ...prevChain.value,
            config.value
        ]);
    provideLocalConfig(nextChain);
}

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8pVeR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useGlobalConfig);
var _currentAppJs = require("../services/current-app.js");
var _globalConfigJs = require("../services/global-config/global-config.js");
function useGlobalConfig() {
    let injected = (0, _currentAppJs.i)((0, _globalConfigJs.G));
    if (!injected) {
        injected = (0, _globalConfigJs.c)();
        (0, _globalConfigJs.p)(injected);
    }
    return injected;
}

},{"../services/current-app.js":"eBy1M","../services/global-config/global-config.js":"7ORqt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eBy1M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "g", ()=>getCurrentApp);
parcelHelpers.export(exports, "i", ()=>inject);
parcelHelpers.export(exports, "s", ()=>setCurrentApp);
var _vue = require("vue");
var _consoleJs = require("../utils/console.js");
let currentApp = null;
let prevRegisteredApp = null;
const setCurrentApp = (newApp)=>{
    if ((prevRegisteredApp == null ? void 0 : prevRegisteredApp._instance) === null) prevRegisteredApp = null;
    if (newApp === null && prevRegisteredApp === null) return;
    prevRegisteredApp = currentApp;
    currentApp = newApp;
};
const getCurrentApp = ()=>currentApp;
const inject = (key, value)=>{
    var _a;
    const injectedFromApp = (_a = getCurrentApp()) == null ? void 0 : _a._context.provides[key];
    const vm = (0, _vue.getCurrentInstance)();
    if (vm) return (0, _vue.inject)(key, value);
    return injectedFromApp ?? (0, _consoleJs.t)("You're using Vuestic composable outside Vue app. Since you registered Vuestic in multiple apps, composables can not be used outside setup function anymore.");
};

},{"vue":"gzxs9","../utils/console.js":"58L6z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"58L6z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "t", ()=>throwError);
parcelHelpers.export(exports, "w", ()=>warn);
var _envJs = require("./env.js");
const warn = (...attrs)=>{
    if (0, _envJs.i) console.warn(...attrs);
    return false;
};
const throwError = (message)=>{
    throw new Error(`[Vuestic] ${message}`);
};

},{"./env.js":"Fmkmq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"Fmkmq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "i", ()=>isDev);
var process = require("da320c4e50a77490");
const processShim = typeof process !== "undefined" ? process : {};
const envShim = processShim.env || {};
const nodeEnv = envShim.NODE_ENV || "";
const isDev = typeof __DEV__ !== "undefined" ? __DEV__ : ![
    "prod",
    "production"
].includes(nodeEnv);

},{"da320c4e50a77490":"d5jf4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d5jf4":[function(require,module,exports) {
// shim for using process in browser
var process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
}
(function() {
    try {
        if (typeof setTimeout === "function") cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === "function") cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = ""; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error("process.binding is not supported");
};
process.cwd = function() {
    return "/";
};
process.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
};
process.umask = function() {
    return 0;
};

},{}],"7ORqt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "G", ()=>GLOBAL_CONFIG);
parcelHelpers.export(exports, "c", ()=>createGlobalConfig);
parcelHelpers.export(exports, "p", ()=>provideForCurrentApp);
var _vendorJs = require("../../../vendor.js");
var _vue = require("vue");
var _indexJs = require("../breakpoint/index.js");
var _currentAppJs = require("../current-app.js");
var _mergeDeepJs = require("../../utils/merge-deep.js");
var _defaultJs = require("../colors-classes/config/default.js");
var _defaultJs1 = require("../color/config/default.js");
var _defaultJs2 = require("../icon/config/default.js");
var _defaultJs3 = require("../component-config/config/default.js");
var _defaultJs4 = require("../i18n/config/default.js");
const GLOBAL_CONFIG = Symbol("GLOBAL_CONFIG");
const getDefaultConfig = ()=>({
        colors: (0, _defaultJs1.g)(),
        icons: (0, _defaultJs2.g)(),
        components: (0, _defaultJs3.g)(),
        breakpoint: (0, _indexJs.g)(),
        i18n: (0, _defaultJs4.g)(),
        colorsClasses: (0, _defaultJs.g)(),
        /**
   * global config variable to pass nuxt-link component to vuestic-ui via @vuestic/nuxt
   * TODO: give a try to integrate inertia js router components via this option
   * TODO: if this try won't be success, may be remake to provide/inject
   */ routerComponent: void 0
    });
const createGlobalConfig = (defaultConfig = {})=>{
    const globalConfig = (0, _vue.ref)((0, _mergeDeepJs.m)(getDefaultConfig(), defaultConfig));
    const getGlobalConfig = ()=>globalConfig.value;
    const setGlobalConfig = (updater)=>{
        const config = typeof updater === "function" ? updater(globalConfig.value) : updater;
        globalConfig.value = (0, _vendorJs.c)(config);
    };
    const mergeGlobalConfig = (updater)=>{
        const config = typeof updater === "function" ? updater(globalConfig.value) : updater;
        globalConfig.value = (0, _mergeDeepJs.m)((0, _vendorJs.c)(globalConfig.value), config);
    };
    return {
        getGlobalConfig,
        setGlobalConfig,
        mergeGlobalConfig,
        globalConfig
    };
};
const provideForCurrentApp = (provide)=>{
    var _a, _b;
    const provides = ((_a = (0, _vue.getCurrentInstance)()) == null ? void 0 : _a.appContext.provides) || ((_b = (0, _currentAppJs.g)()) == null ? void 0 : _b._context.provides);
    if (!provides) throw new Error("Vue app not found for provide");
    provides[GLOBAL_CONFIG] = provide;
    return provide;
};

},{"../../../vendor.js":"l6TAc","vue":"gzxs9","../breakpoint/index.js":"94cKv","../current-app.js":"eBy1M","../../utils/merge-deep.js":"eRzih","../colors-classes/config/default.js":"4lZXJ","../color/config/default.js":"fAJDm","../icon/config/default.js":"1k3pY","../component-config/config/default.js":"9ZPKE","../i18n/config/default.js":"dmUSQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eRzih":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "m", ()=>mergeDeep);
const isObject = (obj)=>obj && typeof obj === "object" && !Array.isArray(obj);
const mergeDeep = (target, source)=>{
    if (!isObject(target) || !isObject(source)) return source;
    Object.keys(source).forEach((key)=>{
        const targetValue = target[key];
        const sourceValue = source[key];
        if (isObject(targetValue) && isObject(sourceValue)) target[key] = mergeDeep(Object.create(Object.getPrototypeOf(targetValue), Object.getOwnPropertyDescriptors(targetValue)), sourceValue);
        else target[key] = sourceValue;
    });
    return target;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4lZXJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "g", ()=>getColorsClassesDefaultConfig);
const ColorsClassesPresets = [
    {
        prefix: "bg",
        property: "background-color"
    },
    {
        prefix: "text",
        property: [
            "color",
            "fill"
        ]
    }
];
const getColorsClassesDefaultConfig = ()=>ColorsClassesPresets;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fAJDm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "g", ()=>getColorDefaultConfig);
var _presetsJs = require("../presets.js");
var _makeConfigJs = require("./make-config.js");
const getColorDefaultConfig = ()=>(0, _makeConfigJs.m)({
        threshold: 150,
        presets: {
            light: (0, _presetsJs.p).light,
            dark: (0, _presetsJs.p).dark
        },
        currentPresetName: "light"
    });

},{"../presets.js":"bMTF6","./make-config.js":"1Uqg8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Uqg8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "m", ()=>makeColorsConfig);
const makeColorsConfig = (values)=>({
        ...values,
        get variables () {
            return this.presets[this.currentPresetName];
        },
        set variables (value){
            this.presets[this.currentPresetName] = value;
        }
    });

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1k3pY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "g", ()=>getIconDefaultConfig);
var _createIconsConfigJs = require("../create-icons-config.js");
const getIconDefaultConfig = ()=>(0, _createIconsConfigJs.c)({});

},{"../create-icons-config.js":"l3Bco","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l3Bco":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "c", ()=>createIconsConfig);
var _vuesticAliasesJs = require("./presets/vuestic-aliases.js");
var _fontsJs = require("./presets/fonts.js");
const createIconsConfig = (config)=>{
    config.aliases = config.aliases || [];
    config.fonts = config.fonts || [];
    return [
        ...config.aliases,
        ...(0, _vuesticAliasesJs.V),
        ...config.fonts,
        ...(0, _fontsJs.V)
    ];
};

},{"./presets/vuestic-aliases.js":"5e7e3","./presets/fonts.js":"lBy3n","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5e7e3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VuesticIconAliases);
const VuesticIconAliases = [
    {
        name: "va-arrow-first",
        to: "mi-first_page"
    },
    {
        name: "va-arrow-last",
        to: "mi-last_page"
    },
    {
        name: "va-arrow-right",
        to: "mi-chevron_right"
    },
    {
        name: "va-arrow-left",
        to: "mi-chevron_left"
    },
    {
        name: "va-arrow-down",
        to: "mi-expand_more"
    },
    {
        name: "va-arrow-up",
        to: "mi-expand_less"
    },
    {
        name: "va-calendar",
        to: "mi-calendar_today"
    },
    {
        name: "va-delete",
        to: "mi-delete_outline"
    },
    {
        name: "va-check",
        to: "mi-check"
    },
    {
        name: "va-check-circle",
        to: "mi-check_circle"
    },
    {
        name: "va-warning",
        to: "mi-warning"
    },
    {
        name: "va-clear",
        to: "mi-highlight_off"
    },
    {
        name: "va-close",
        to: "mi-close"
    },
    {
        name: "va-loading",
        to: "mi-loop"
    },
    {
        name: "va-plus",
        to: "add"
    },
    {
        name: "va-minus",
        to: "remove"
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lBy3n":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VuesticIconFonts);
const VuesticIconFonts = [
    {
        name: "mi-{icon}",
        class: "material-icons",
        resolve: ({ icon })=>({
                content: icon
            })
    },
    // Fallback
    {
        name: "{icon}",
        class: "material-icons",
        resolve: ({ icon })=>({
                content: icon
            })
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9ZPKE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "g", ()=>getComponentsDefaultConfig);
const getComponentsDefaultConfig = ()=>// TODO: Should be handled in size service
    ({
        VaIcon: {
            sizesConfig: {
                defaultSize: 18,
                sizes: {
                    small: 14,
                    medium: 18,
                    large: 24
                }
            }
        },
        VaRating: {
            sizesConfig: {
                defaultSize: 18,
                sizes: {
                    small: 14,
                    medium: 18,
                    large: 24
                }
            }
        },
        all: {},
        presets: {
            VaButton: {
                default: {
                    backgroundOpacity: 1,
                    hoverBehavior: "mask",
                    hoverOpacity: 0.15,
                    pressedBehavior: "mask",
                    pressedOpacity: 0.13
                },
                primary: {
                    backgroundOpacity: 0.1,
                    hoverBehavior: "opacity",
                    hoverOpacity: 0.07,
                    pressedBehavior: "opacity",
                    pressedOpacity: 0.13
                },
                secondary: {
                    backgroundOpacity: 0,
                    hoverBehavior: "opacity",
                    hoverOpacity: 0.07,
                    pressedBehavior: "opacity",
                    pressedOpacity: 0.13
                },
                plain: {
                    plain: true,
                    hoverBehavior: "mask",
                    hoverOpacity: 0.15,
                    pressedBehavior: "mask",
                    pressedOpacity: 0.13
                },
                plainOpacity: {
                    plain: true,
                    textOpacity: 0.6,
                    hoverBehavior: "opacity",
                    hoverOpacity: 1,
                    pressedBehavior: "opacity",
                    pressedOpacity: 0.9
                }
            },
            VaInputWrapper: {
                solid: {
                    background: "backgroundElement"
                },
                bordered: {
                    class: "va-input-wrapper--bordered",
                    background: "backgroundElement"
                }
            },
            VaCheckbox: {
                solid: {
                    style: "--va-checkbox-background: var(--va-background-element)"
                }
            },
            VaRadio: {
                solid: {
                    style: "--va-radio-background: var(--va-background-element)"
                }
            },
            VaMenu: {
                context: {
                    cursor: true,
                    placement: "right-start",
                    trigger: "right-click"
                }
            }
        }
    });

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dmUSQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "g", ()=>getI18nConfigDefaults);
const getI18nConfigDefaults = ()=>({
        // PROPS
        /** Select search field default text */ search: "Search",
        /** Select no options text */ noOptions: "Items not found",
        /** Modal Ok button default text */ ok: "OK",
        /** Modal Cancel button default text */ cancel: "Cancel",
        /** FileUpload default button text */ uploadFile: "Upload file",
        /** FileUpload default undo button text */ undo: "Undo",
        /** FileUpload default dropzone text */ dropzone: "Drop files here to upload",
        /** FileUpload default file deleted alert text */ fileDeleted: "File deleted",
        // Aria attributes
        /** Alert close button aria-label */ closeAlert: "close alert",
        backToTop: "back to top",
        toggleDropdown: "toggle dropdown",
        carousel: "carousel",
        goPreviousSlide: "go previous slide",
        goNextSlide: "go next slide",
        goSlide: "go slide {index}",
        slideOf: "slide {index} of {length}",
        close: "close",
        openColorPicker: "open color picker",
        colorSelection: "color selection",
        colorName: "color {color}",
        decreaseCounter: "decrease counter",
        increaseCounter: "increase counter",
        selectAllRows: "select all rows",
        sortColumnBy: "sort column by {name}",
        selectRowByIndex: "select row {index}",
        resetDate: "reset date",
        nextPeriod: "next period",
        switchView: "switch view",
        previousPeriod: "previous period",
        removeFile: "remove file",
        reset: "reset",
        pagination: "pagination",
        goToTheFirstPage: "go to the first page",
        goToPreviousPage: "go to the previous page",
        goToSpecificPage: "go to the {page} page",
        goToSpecificPageInput: "enter the page number to go",
        goNextPage: "go next page",
        goLastPage: "go last page",
        /** Rating aria-label */ currentRating: "current rating {value} of {max}",
        /** Rating item aria-label */ voteRating: "vote rating {value} of {max}",
        /** Select search input aria-label */ optionsFilter: "options filter",
        splitPanels: "split panels",
        movePaginationLeft: "move pagination left",
        movePaginationRight: "move pagination right",
        resetTime: "reset time",
        closeToast: "close toast",
        /**
   * Select aria-label selected option prefix
   *
   * @example
   *
   * `Selected option: {option}` or `Selected option: Animal`
   */ selectedOption: "Selected option",
        /** Select aria-label if no option is selected */ noSelectedOption: "Option is not selected",
        breadcrumbs: "breadcrumbs",
        counterValue: "counter value",
        selectedDate: "selected date",
        selectedTime: "selected time",
        progressState: "progress state",
        color: "color",
        /** Stepper next button text */ next: "Next",
        /** Stepper previous button text */ back: "Previous",
        /** Stepper finish button text */ finish: "Finish",
        step: "step",
        progress: "progress",
        /** Skeleton aria label */ loading: "Loading",
        /** Slider aria label */ sliderValue: "Current slider value is {value}",
        /** Switch aria label */ switch: "Switch",
        /** Input aria label */ inputField: "Input field"
    });

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8g95K":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../vendor.js");
var _useSizeJs = require("../../composables/useSize.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useIconJs = require("../../composables/useIcon.js");
var _useColorsJs = require("../../composables/useColors.js");
var _vaIconCss = require("../../../VaIcon.css");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaIcon",
    __name: "VaIcon",
    props: {
        ...(0, _useSizeJs.u),
        ...(0, _useComponentPresetJs.u),
        name: {
            type: String,
            default: ""
        },
        tag: {
            type: String
        },
        component: {
            type: Object
        },
        color: {
            type: String
        },
        rotation: {
            type: [
                String,
                Number
            ]
        },
        spin: {
            type: [
                String,
                Boolean
            ]
        },
        flip: {
            type: String,
            default: "off",
            validator: (value)=>[
                    "off",
                    "horizontal",
                    "vertical",
                    "both"
                ].includes(value)
        }
    },
    setup (__props) {
        const props = __props;
        const { getColor } = (0, _useColorsJs.u)();
        const { sizeComputed } = (0, _useSizeJs.a)(props);
        const { getIcon } = (0, _useIconJs.u)();
        const iconConfig = (0, _vue.computed)(()=>getIcon(props.name));
        const computedTag = (0, _vue.computed)(()=>props.component || props.tag || iconConfig.value.component || iconConfig.value.tag || "i");
        const attrs = (0, _vue.useAttrs)();
        const computedAttrs = (0, _vue.computed)(()=>({
                ...iconConfig.value.attrs,
                ...(0, _vendorJs.o)(attrs, [
                    "class"
                ])
            }));
        const getSpinClass = (spin)=>{
            if (spin === void 0 || spin === false) return;
            return spin === "counter-clockwise" ? "va-icon--spin-reverse" : "va-icon--spin";
        };
        const computedClass = (0, _vue.computed)(()=>[
                iconConfig.value.class,
                getSpinClass(props.spin ?? iconConfig.value.spin)
            ]);
        const transformStyle = (0, _vue.computed)(()=>{
            const rotation = props.rotation ? `rotate(${props.rotation}deg)` : "";
            const flipY = props.flip === "vertical" || props.flip === "both" ? -1 : 1;
            const flipX = props.flip === "horizontal" || props.flip === "both" ? -1 : 1;
            const scale = props.flip === "off" ? "" : `scale(${flipY}, ${flipX})`;
            return `${scale} ${rotation}`.trim();
        });
        const computedStyle = (0, _vue.computed)(()=>({
                transform: transformStyle.value,
                cursor: attrs.onClick ? "pointer" : null,
                color: props.color ? getColor(props.color, void 0, true) : iconConfig.value.color,
                fontSize: sizeComputed.value,
                height: sizeComputed.value,
                lineHeight: sizeComputed.value
            }));
        const tabindexComputed = (0, _vue.computed)(()=>attrs.tabindex ?? -1);
        const ariaHiddenComputed = (0, _vue.computed)(()=>attrs.role !== "button" || tabindexComputed.value < 0);
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.resolveDynamicComponent)(computedTag.value), (0, _vue.mergeProps)({
                class: [
                    "va-icon",
                    computedClass.value
                ],
                style: computedStyle.value,
                "aria-hidden": ariaHiddenComputed.value,
                notranslate: ""
            }, computedAttrs.value), {
                default: (0, _vue.withCtx)(()=>[
                        (0, _vue.renderSlot)(_ctx.$slots, "default", {}, ()=>[
                                iconConfig.value.content ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                                    key: 0
                                }, [
                                    (0, _vue.createTextVNode)((0, _vue.toDisplayString)(iconConfig.value.content), 1)
                                ], 64)) : (0, _vue.createCommentVNode)("", true)
                            ])
                    ]),
                _: 3
            }, 16, [
                "class",
                "style",
                "aria-hidden"
            ]);
        };
    }
});

},{"vue":"gzxs9","../../../vendor.js":"l6TAc","../../composables/useSize.js":"d4gWT","../../composables/useComponentPreset.js":"2HoaT","../../composables/useIcon.js":"i8JAe","../../composables/useColors.js":"a4Qgv","../../../VaIcon.css":"hJBX6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d4gWT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useSize);
parcelHelpers.export(exports, "b", ()=>useSizeRef);
parcelHelpers.export(exports, "u", ()=>useSizeProps);
var _vue = require("vue");
var _vendorJs = require("../../vendor.js");
var _useGlobalConfigJs = require("./useGlobalConfig.js");
const sizesConfig = {
    defaultSize: 48,
    sizes: {
        small: 32,
        medium: 48,
        large: 64
    }
};
const fontSizesConfig = {
    defaultSize: 1,
    sizes: {
        small: 0.75,
        medium: 1,
        large: 1.25
    }
};
const useSizeProps = {
    size: {
        type: [
            String,
            Number
        ],
        default: "",
        validator: (size)=>{
            return typeof size === "string" || typeof size === "number";
        }
    },
    sizesConfig: {
        type: Object,
        default: ()=>sizesConfig
    },
    fontSizesConfig: {
        type: Object,
        default: ()=>fontSizesConfig
    }
};
const fontRegex = /(?<fontSize>\d+)(?<extension>px|rem)/i;
const convertToRem = (px)=>px / 16 - 0.5;
const sizeToAbsolute = (size)=>{
    if (typeof size === "number") return `${size}px`;
    return String(size);
};
const doHaveSizesConfig = (props)=>"sizesConfig" in props;
const useSizeRef = (props)=>{
    const sizePropName = "size";
    return (0, _vue.computed)(()=>{
        let sizePropValue = props[sizePropName];
        if (doHaveSizesConfig(props)) {
            const { defaultSize, sizes } = props.sizesConfig;
            if ((0, _vendorJs.i)(sizePropValue)) sizePropValue = defaultSize;
            if (sizes) {
                const sizeFromConfig = sizes[sizePropValue];
                if (sizeFromConfig) return sizeToAbsolute(sizeFromConfig);
            }
        }
        return sizeToAbsolute(sizePropValue);
    });
};
const useSize = (props, componentName = ((_a)=>(_a = (0, _vue.getCurrentInstance)()) == null ? void 0 : _a.type.name)())=>{
    const { getGlobalConfig } = (0, _useGlobalConfigJs.u)();
    const sizesConfigGlobal = (0, _vue.computed)(()=>{
        var _a2, _b;
        return componentName ? (_b = (_a2 = getGlobalConfig().components) == null ? void 0 : _a2[componentName]) == null ? void 0 : _b.sizesConfig : void 0;
    });
    const sizeComputed = (0, _vue.computed)(()=>{
        var _a2, _b, _c;
        const { defaultSize, sizes } = props.sizesConfig;
        const defaultSizeGlobal = (_a2 = sizesConfigGlobal.value) == null ? void 0 : _a2.defaultSize;
        if (!props.size) return `${defaultSize || defaultSizeGlobal}px`;
        if (typeof props.size === "string") {
            const sizeFromGlobalConfig = (_c = (_b = sizesConfigGlobal.value) == null ? void 0 : _b.sizes) == null ? void 0 : _c[props.size];
            const sizeFromProps = sizes[props.size];
            if (sizeFromProps) return `${sizeFromProps}px`;
            if (sizeFromGlobalConfig) return `${sizeFromGlobalConfig}px`;
            return props.size;
        }
        return `${props.size}px`;
    });
    const fontSizeInRem = (0, _vue.computed)(()=>{
        const { defaultSize, sizes } = props.fontSizesConfig;
        if (!props.size) return defaultSize;
        if (typeof props.size === "string") {
            if (props.size in sizes) return sizes[props.size];
            const fontSizeParsed = props.size.match(fontRegex);
            if (!fontSizeParsed || !fontSizeParsed.groups) throw new Error("Size prop should be either valid string or number");
            const { extension, fontSize } = fontSizeParsed.groups;
            return extension === "rem" ? +fontSize : convertToRem(+fontSize);
        }
        return convertToRem(props.size);
    });
    const fontSizeComputed = (0, _vue.computed)(()=>`${fontSizeInRem.value}rem`);
    return {
        sizeComputed,
        fontSizeComputed,
        fontSizeInRem
    };
};

},{"vue":"gzxs9","../../vendor.js":"l6TAc","./useGlobalConfig.js":"8pVeR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2HoaT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useComponentPresetProp);
const useComponentPresetProp = {
    preset: {
        type: String,
        default: void 0
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i8JAe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useIcon);
var _getIconConfigurationJs = require("../services/icon/utils/get-icon-configuration.js");
var _useGlobalConfigJs = require("./useGlobalConfig.js");
const useIcon = ()=>{
    const { globalConfig } = (0, _useGlobalConfigJs.u)();
    return {
        getIcon: (name)=>(0, _getIconConfigurationJs.g)(name, globalConfig.value.icons)
    };
};

},{"../services/icon/utils/get-icon-configuration.js":"kUw5h","./useGlobalConfig.js":"8pVeR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kUw5h":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "g", ()=>getIconConfiguration);
var _vendorJs = require("../../../../vendor.js");
var _dynamicSegmentJs = require("./dynamic-segment.js");
var _regexJs = require("./regex.js");
var _typesJs = require("../types.js");
const isMatchConfiguration = (iconName, iconConfiguration)=>{
    if ((0, _typesJs.i)(iconConfiguration)) return (0, _dynamicSegmentJs.i)(iconName, iconConfiguration.name);
    if ((0, _typesJs.a)(iconConfiguration)) return (0, _regexJs.i)(iconName, iconConfiguration.name);
    return false;
};
const resolveIconConfigurationString = (iconName, iconConfiguration)=>{
    const args = (0, _dynamicSegmentJs.d)(iconName, iconConfiguration.name);
    return iconConfiguration.resolve && iconConfiguration.resolve(args);
};
const resolveIconConfigurationRegex = (iconName, iconConfig)=>{
    if (iconConfig.name.global) throw new Error(`Bad icon config with name ${iconConfig.name}. Please, don't use global regex as name.`);
    const args = (0, _regexJs.r)(iconName, iconConfig.name);
    return iconConfig.resolveFromRegex && iconConfig.resolveFromRegex(...args);
};
const resolveIconConfiguration = (iconName, iconConfiguration)=>{
    if ((0, _typesJs.i)(iconConfiguration)) return resolveIconConfigurationString(iconName, iconConfiguration);
    if ((0, _typesJs.a)(iconConfiguration)) return resolveIconConfigurationRegex(iconName, iconConfiguration);
    throw Error("Unknown icon config");
};
const findMatchedIconConfiguration = (iconName, globalIconConfig, namesToIgnore = [])=>{
    const matchedConfig = globalIconConfig.find((config)=>{
        if (namesToIgnore.includes(config.name.toString())) return false;
        return isMatchConfiguration(iconName, config);
    });
    if (!matchedConfig) throw new Error(`Can not find icon config from ${iconName}. Please provide default config.`);
    return matchedConfig;
};
const findIconConfiguration = (iconName, globalIconConfig, namesToIgnore = [])=>{
    if (!iconName) return;
    const matchedIconConfiguration = findMatchedIconConfiguration(iconName, globalIconConfig, namesToIgnore);
    const resolvedIconConfiguration = (0, _vendorJs.m)(resolveIconConfiguration(iconName, matchedIconConfiguration), matchedIconConfiguration);
    namesToIgnore = [
        ...namesToIgnore,
        matchedIconConfiguration.name.toString()
    ];
    return (0, _vendorJs.m)(findIconConfiguration(resolvedIconConfiguration.to, globalIconConfig, namesToIgnore), resolvedIconConfiguration);
};
const iconPropsFromIconConfiguration = (iconConfiguration)=>{
    const junkKeys = [
        "name",
        "to",
        "resolve",
        "resolveFromRegex"
    ];
    const configuration = iconConfiguration;
    junkKeys.forEach((key)=>{
        delete configuration[key];
    });
    return configuration;
};
const getIconConfiguration = (name, iconConfig)=>{
    const configuration = findIconConfiguration(name, iconConfig);
    if (configuration === void 0) return {};
    return iconPropsFromIconConfiguration(configuration);
};

},{"../../../../vendor.js":"l6TAc","./dynamic-segment.js":"bcZe4","./regex.js":"7Pajd","../types.js":"109Zp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bcZe4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "d", ()=>dynamicSegments);
parcelHelpers.export(exports, "i", ()=>isMatchDynamicSegments);
var _regexJs = require("./regex.js");
const dynamicSegmentRegex = /{[^}]*}/g;
const dynamicSegmentStringToRegex = (template)=>{
    return template.replace(dynamicSegmentRegex, "(.*)");
};
const dynamicSegmentsNames = (template)=>{
    return (template.match(dynamicSegmentRegex) || []).map((g)=>g.replace(/{|}/g, ""));
};
const dynamicSegmentsValues = (str, template)=>{
    return (0, _regexJs.r)(str, dynamicSegmentStringToRegex(template));
};
const dynamicSegments = (str, template)=>{
    const params = dynamicSegmentsNames(template);
    const values = dynamicSegmentsValues(str, template);
    return params.reduce((acc, paramValue, i)=>({
            ...acc,
            [paramValue]: values[i]
        }), {});
};
const strictMatch = (str, regex)=>{
    return (str.match(regex) || [])[0] === str;
};
const isMatchDynamicSegments = (str, template)=>{
    const templateRegex = dynamicSegmentStringToRegex(template);
    return strictMatch(str, new RegExp(templateRegex));
};

},{"./regex.js":"7Pajd","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7Pajd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "i", ()=>isMatchRegex);
parcelHelpers.export(exports, "r", ()=>regexGroupsValues);
const isMatchRegex = (str, regex)=>{
    return regex.test(str);
};
const regexGroupsValues = (str, regex)=>{
    if (typeof regex !== "string" && regex.global) return [
        ...str.matchAll(regex)
    ].map((g)=>g.slice(1));
    const match = str.match(regex) || [];
    if (!match) return [];
    if (match.length > 1) return match.slice(1);
    return match;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"109Zp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>isIconConfigurationRegex);
parcelHelpers.export(exports, "i", ()=>isIconConfigurationString);
const isIconConfigurationString = (config)=>{
    return typeof config.name === "string";
};
const isIconConfigurationRegex = (config)=>{
    return config.name instanceof RegExp;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a4Qgv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useColorProps);
parcelHelpers.export(exports, "u", ()=>useColors);
var _vue = require("vue");
var _consoleJs = require("../utils/console.js");
var _useCacheJs = require("./useCache.js");
var _useReactiveComputedJs = require("./useReactiveComputed.js");
var _utilsJs = require("../services/color/utils.js");
var _vendorJs = require("../../vendor.js");
var _useGlobalConfigJs = require("./useGlobalConfig.js");
const useColorProps = {
    color: {
        type: String,
        default: ""
    }
};
const useColors = ()=>{
    const gc = (0, _useGlobalConfigJs.u)();
    if (!gc) throw new Error("useColors must be used in setup function or Vuestic GlobalConfigPlugin is not registered!");
    const { globalConfig } = gc;
    const colors = (0, _useReactiveComputedJs.u)({
        get: ()=>globalConfig.value.colors.presets[globalConfig.value.colors.currentPresetName],
        set: (v)=>{
            setColors(v);
        }
    });
    const setColors = (colors2)=>{
        globalConfig.value.colors.presets[globalConfig.value.colors.currentPresetName] = {
            ...globalConfig.value.colors.variables,
            ...colors2
        };
    };
    const getColors = ()=>{
        return colors;
    };
    const getColor = (prop, defaultColor, preferVariables)=>{
        if (!defaultColor) defaultColor = colors.primary;
        if (prop === "transparent") return "#ffffff00";
        if (prop === "currentColor") return prop;
        if (prop == null ? void 0 : prop.startsWith("on")) {
            const colorName = prop.slice(2);
            if (colors[(0, _utilsJs.n)(colorName)]) return getColor(getTextColor(getColor(colorName)), void 0, preferVariables);
        }
        if (!prop) prop = getColor(defaultColor);
        const colorValue = colors[prop] || colors[(0, _utilsJs.n)(prop)];
        if (colorValue) return preferVariables ? `var(${(0, _utilsJs.j)(prop)})` : colorValue;
        if ((0, _utilsJs.k)(prop)) return prop;
        if (preferVariables && (0, _utilsJs.l)(prop)) return prop;
        (0, _consoleJs.w)(`'${prop}' is not a proper color! Use HEX or default color themes
      names (https://vuestic.dev/en/styles/colors#default-color-themes)`);
        return getColor(defaultColor);
    };
    const getComputedColor = (color)=>{
        return (0, _vue.computed)({
            get () {
                return getColor(color);
            },
            set (v) {
                setColors({
                    [color]: v
                });
            }
        });
    };
    const colorsToCSSVariable = (colors2, prefix = "va")=>{
        return Object.keys(colors2).filter((key)=>colors2[key] !== void 0).reduce((acc, colorName)=>{
            acc[`--${prefix}-${(0, _vendorJs.k)(colorName)}`] = getColor(colors2[colorName], void 0, true);
            acc[`--${prefix}-on-${(0, _vendorJs.k)(colorName)}`] = getColor(getTextColor(getColor(colors2[colorName])), void 0, true);
            return acc;
        }, {});
    };
    const cache = (0, _useCacheJs.u)();
    const getColorLightnessFromCache = (color)=>{
        if (typeof color !== "string") return (0, _utilsJs.m)(color);
        if (!cache.colorContrast[color]) cache.colorContrast[color] = (0, _utilsJs.m)(color);
        return cache.colorContrast[color];
    };
    const computedDarkColor = (0, _vue.computed)(()=>{
        return getColorLightnessFromCache(getColor("textPrimary")) > 127.5 ? "textInverted" : "textPrimary";
    });
    const computedLightColor = (0, _vue.computed)(()=>{
        return getColorLightnessFromCache(getColor("textPrimary")) > 127.5 ? "textPrimary" : "textInverted";
    });
    const getTextColor = (color, darkColor, lightColor)=>{
        const onColorName = `on${(0, _vue.capitalize)(String(color))}`;
        if (colors[onColorName]) return colors[onColorName];
        darkColor = darkColor || computedDarkColor.value;
        lightColor = lightColor || computedLightColor.value;
        return getColorLightnessFromCache(color) > globalConfig.value.colors.threshold ? darkColor : lightColor;
    };
    const currentPresetName = (0, _vue.computed)({
        get: ()=>globalConfig.value.colors.currentPresetName,
        set: (v)=>{
            applyPreset(v);
        }
    });
    const presets = (0, _vue.computed)(()=>globalConfig.value.colors.presets);
    const applyPreset = (presetName)=>{
        globalConfig.value.colors.currentPresetName = presetName;
        if (!globalConfig.value.colors.presets[presetName]) return (0, _consoleJs.w)(`Preset ${presetName} does not exist`);
    };
    return {
        colors,
        currentPresetName,
        presets,
        applyPreset,
        setColors,
        getColors,
        getColor,
        getComputedColor,
        getBoxShadowColor: (0, _utilsJs.a),
        getBoxShadowColorFromBg: (0, _utilsJs.f),
        getHoverColor: (0, _utilsJs.c),
        getFocusColor: (0, _utilsJs.b),
        getGradientBackground: (0, _utilsJs.g),
        getTextColor,
        shiftHSLAColor: (0, _utilsJs.s),
        setHSLAColor: (0, _utilsJs.h),
        colorsToCSSVariable,
        colorToRgba: (0, _utilsJs.d),
        getStateMaskGradientBackground: (0, _utilsJs.i)
    };
};

},{"vue":"gzxs9","../utils/console.js":"58L6z","./useCache.js":"9X4dW","./useReactiveComputed.js":"4FIgk","../services/color/utils.js":"4SMXK","../../vendor.js":"l6TAc","./useGlobalConfig.js":"8pVeR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9X4dW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useCache);
var _currentAppJs = require("../services/current-app.js");
var _indexJs = require("../services/cache/plugin/index.js");
const useCache = ()=>{
    const cache = (0, _currentAppJs.i)((0, _indexJs.V));
    if (!cache) return {
        colorContrast: {}
    };
    return cache;
};

},{"../services/current-app.js":"eBy1M","../services/cache/plugin/index.js":"6oFzX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6oFzX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "C", ()=>CachePlugin);
parcelHelpers.export(exports, "V", ()=>VaAppCachePluginKey);
var _defineVuesticPluginJs = require("../../vue-plugin/utils/define-vuestic-plugin.js");
const VaAppCachePluginKey = Symbol("VaAppCachePlugin");
const CachePlugin = (0, _defineVuesticPluginJs.d)(()=>({
        install (app) {
            const cache = {
                colorContrast: {}
            };
            app.provide(VaAppCachePluginKey, cache);
        }
    }));

},{"../../vue-plugin/utils/define-vuestic-plugin.js":"5M143","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5M143":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "d", ()=>defineVuesticPlugin);
const defineVuesticPlugin = (fabric)=>fabric;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4FIgk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useReactiveComputed);
var _vue = require("vue");
const useReactiveComputed = (obj)=>{
    const objectRef = typeof obj === "function" ? (0, _vue.computed)(obj) : (0, _vue.computed)(obj);
    const proxy = new Proxy(objectRef, {
        get (target, p, receiver) {
            if (typeof objectRef.value !== "object") return void 0;
            return (0, _vue.unref)(Reflect.get(objectRef.value, p, receiver));
        },
        set (target, p, value) {
            if ((0, _vue.isRef)(objectRef.value[p]) && !(0, _vue.isRef)(value)) objectRef.value[p].value = value;
            else objectRef.value[p] = value;
            return true;
        },
        deleteProperty (target, p) {
            return Reflect.deleteProperty(objectRef.value, p);
        },
        has (target, p) {
            if (typeof objectRef.value !== "object") return false;
            return Reflect.has(objectRef.value, p);
        },
        ownKeys () {
            if (typeof objectRef.value !== "object") return [];
            return Object.keys(objectRef.value);
        },
        getOwnPropertyDescriptor () {
            return {
                enumerable: true,
                configurable: true
            };
        }
    });
    return (0, _vue.reactive)(proxy);
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4SMXK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>getBoxShadowColor);
parcelHelpers.export(exports, "b", ()=>getFocusColor);
parcelHelpers.export(exports, "c", ()=>getHoverColor);
parcelHelpers.export(exports, "d", ()=>colorToRgba);
parcelHelpers.export(exports, "e", ()=>applyColors);
parcelHelpers.export(exports, "f", ()=>getBoxShadowColorFromBg);
parcelHelpers.export(exports, "g", ()=>getGradientBackground);
parcelHelpers.export(exports, "h", ()=>setHSLAColor);
parcelHelpers.export(exports, "i", ()=>getStateMaskGradientBackground);
parcelHelpers.export(exports, "j", ()=>cssVariableName);
parcelHelpers.export(exports, "k", ()=>isColor);
parcelHelpers.export(exports, "l", ()=>isCSSVariable);
parcelHelpers.export(exports, "m", ()=>getColorLightness);
parcelHelpers.export(exports, "n", ()=>normalizeColorName);
parcelHelpers.export(exports, "o", ()=>isColorTransparent);
parcelHelpers.export(exports, "s", ()=>shiftHSLAColor);
var _vendorJs = require("../../../vendor.js");
var _colortranslator = require("colortranslator");
const makeColor = (color)=>{
    try {
        return new (0, _colortranslator.ColorTranslator)(color);
    } catch (e) {
        throw new Error(`Color ${color} is not valid. Please, provide valid color.`, {
            cause: e
        });
    }
};
const isCSSVariable = (strColor)=>/var\(--.+\)/.test(strColor);
const cssVariableName = (colorName)=>`--va-${(0, _vendorJs.k)(colorName)}`;
const normalizeColorName = (colorName)=>(0, _vendorJs.j)(colorName);
const colorToRgba = (color, opacity)=>{
    return makeColor(color).setA(opacity).RGBA;
};
const getColorLightness = (color)=>{
    const { R, G, B } = makeColor(color);
    return Math.sqrt(R * R * 0.241 + G * G * 0.691 + B * B * 0.068);
};
const getBoxShadowColor = (color, opacity = 0.4)=>{
    return makeColor(color).setA(opacity).RGBA;
};
const getBoxShadowColorFromBg = (background, opacity = 0.4)=>{
    return makeColor(background).setA(opacity).RGBA;
};
const getHoverColor = (color, opacity = 0.2)=>{
    return makeColor(color).setA(opacity).RGBA;
};
const getFocusColor = (color, opacity = 0.3)=>{
    return makeColor(color).setA(opacity).RGBA;
};
const shiftHSLAColor = (color, offset)=>{
    const result = makeColor(color);
    if (offset.h) result.setH(result.H + offset.h);
    if (offset.s) result.setS(result.S + offset.s);
    if (offset.l) result.setL(result.L + offset.l);
    if (offset.a) result.setA(result.A + offset.a);
    return result.HSLA;
};
const setHSLAColor = (color, newColor)=>{
    const result = makeColor(color);
    if (newColor.h !== void 0) result.setH(newColor.h);
    if (newColor.s !== void 0) result.setS(newColor.s);
    if (newColor.l !== void 0) result.setL(newColor.l);
    if (newColor.a !== void 0) result.setA(newColor.a);
    return result.HSLA;
};
const shiftGradientColor = (color)=>{
    const newColor = (0, _colortranslator.ColorTranslator).toHSLA(color, false);
    if (newColor.s < 10) return shiftHSLAColor(newColor, {
        h: 2,
        s: 5,
        l: 10
    });
    if (newColor.s < 30) return shiftHSLAColor(newColor, {
        s: -14,
        l: 11
    });
    if (newColor.h >= 0 && newColor.h < 44 || newColor.h >= 285) return shiftHSLAColor(newColor, {
        h: 11,
        s: 27,
        l: 8
    });
    if (newColor.h >= 44 && newColor.h < 85) return shiftHSLAColor(newColor, {
        h: 3,
        l: 9
    });
    if (newColor.h >= 85 && newColor.h < 165) return shiftHSLAColor(newColor, {
        h: 16,
        l: 14
    });
    if (newColor.h >= 165 && newColor.h < 285) return shiftHSLAColor(newColor, {
        h: -15,
        s: 3,
        l: 2
    });
    throw new Error("This method should handle all colors. But it didn't for some reason.");
};
const getGradientBackground = (color)=>{
    const colorLeft = shiftGradientColor(color);
    const colorRight = (0, _colortranslator.ColorTranslator).toHSLA(color);
    return `linear-gradient(to right, ${colorLeft}, ${colorRight})`;
};
const getStateMaskGradientBackground = (color, maskColor, maskOpacity)=>{
    const mask = colorToRgba(maskColor, maskOpacity);
    return `linear-gradient(0deg, ${mask}, ${mask}), ${color}`;
};
const isColor = (strColor)=>{
    const cssColorRegex = /^#([\da-f]{3}){1,2}$|^#([\da-f]{4}){1,2}$|(rgb|hsl)a?\((\s*-?\d+%?\s*,){2}(\s*-?\d+%?\s*,?\s*\)?)(,\s*(0?\.\d+)?|1)?\)/;
    return cssColorRegex.test(strColor.toLocaleLowerCase());
};
const applyColors = (color1, color2)=>{
    const c1 = makeColor(color1);
    const c2 = makeColor(color2);
    const weight = c2.A;
    if (weight === 1) return c2.RGBA;
    if (weight === 0) return c1.RGBA;
    c1.setR(Math.round(c1.R * (1 - weight) + c2.R * weight));
    c1.setG(Math.round(c1.G * (1 - weight) + c2.G * weight));
    c1.setB(Math.round(c1.B * (1 - weight) + c2.B * weight));
    return c1.RGBA;
};
const isColorTransparent = (color)=>{
    if (!color) return false;
    if (color === "transparent") return true;
    return makeColor(color).A <= 0.1;
};

},{"../../../vendor.js":"l6TAc","colortranslator":"gwMdh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gwMdh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ColorTranslator", ()=>rt);
parcelHelpers.export(exports, "Harmony", ()=>e);
parcelHelpers.export(exports, "Mix", ()=>r);
var t, e, r, n, o = function() {
    return o = Object.assign || function(t) {
        for(var e, r = 1, n = arguments.length; r < n; r++)for(var o in e = arguments[r])Object.prototype.hasOwnProperty.call(e, o) && (t[o] = e[o]);
        return t;
    }, o.apply(this, arguments);
};
function i(t, e, r) {
    if (r || 2 === arguments.length) for(var n, o = 0, i = e.length; o < i; o++)!n && o in e || (n || (n = Array.prototype.slice.call(e, 0, o)), n[o] = e[o]);
    return t.concat(n || Array.prototype.slice.call(e));
}
!function(t) {
    t.HEX = "HEX", t.RGB = "RGB", t.RGBA = "RGBA", t.HSL = "HSL", t.HSLA = "HSLA", t.CMYK = "CMYK";
}(t || (t = {})), function(t) {
    t.ANALOGOUS = "ANALOGOUS", t.COMPLEMENTARY = "COMPLEMENTARY", t.SPLIT_COMPLEMENTARY = "SPLIT_COMPLEMENTARY", t.TRIADIC = "TRIADIC", t.TETRADIC = "TETRADIC", t.SQUARE = "SQUARE";
}(e || (e = {})), function(t) {
    t.ADDITIVE = "ADDITIVE", t.SUBTRACTIVE = "SUBTRACTIVE";
}(r || (r = {})), function(t) {
    t.black = "#000000", t.silver = "#C0C0C0", t.gray = "#808080", t.white = "#FFFFFF", t.maroon = "#800000", t.red = "#FF0000", t.purple = "#800080", t.fuchsia = "#FF00FF", t.green = "#008000", t.lime = "#00FF00", t.olive = "#808000", t.yellow = "#FFFF00", t.navy = "#000080", t.blue = "#0000FF", t.teal = "#008080", t.aqua = "#00FFFF", t.orange = "#FFA500", t.aliceblue = "#F0F8FF", t.antiquewhite = "#FAEBD7", t.aquamarine = "#7FFFD4", t.azure = "#F0FFFF", t.beige = "#F5F5DC", t.bisque = "#FFE4C4", t.blanchedalmond = "#FFEBCD", t.blueviolet = "#8A2BE2", t.brown = "#A52A2A", t.burlywood = "#DEB887", t.cadetblue = "#5F9EA0", t.chartreuse = "#7FFF00", t.chocolate = "#D2691E", t.coral = "#FF7F50", t.cornflowerblue = "#6495ED", t.cornsilk = "#FFF8DC", t.crimson = "#DC143C", t.cyan = "#00FFFF", t.darkblue = "#00008B", t.darkcyan = "#008B8B", t.darkgoldenrod = "#B8860B", t.darkgray = "#A9A9A9", t.darkgreen = "#006400", t.darkgrey = "#A9A9A9", t.darkkhaki = "#BDB76B", t.darkmagenta = "#8B008B", t.darkolivegreen = "#556B2F", t.darkorange = "#FF8C00", t.darkorchid = "#9932CC", t.darkred = "#8B0000", t.darksalmon = "#E9967A", t.darkseagreen = "#8FBC8F", t.darkslateblue = "#483D8B", t.darkslategray = "#2F4F4F", t.darkslategrey = "#2F4F4F", t.darkturquoise = "#00CED1", t.darkviolet = "#9400D3", t.deeppink = "#FF1493", t.deepskyblue = "#00BFFF", t.dimgray = "#696969", t.dimgrey = "#696969", t.dodgerblue = "#1E90FF", t.firebrick = "#B22222", t.floralwhite = "#FFFAF0", t.forestgreen = "#228B22", t.gainsboro = "#DCDCDC", t.ghostwhite = "#F8F8FF", t.gold = "#FFD700", t.goldenrod = "#DAA520", t.greenyellow = "#ADFF2F", t.grey = "#808080", t.honeydew = "#F0FFF0", t.hotpink = "#FF69B4", t.indianred = "#CD5C5C", t.indigo = "#4B0082", t.ivory = "#FFFFF0", t.khaki = "#F0E68C", t.lavender = "#E6E6FA", t.lavenderblush = "#FFF0F5", t.lawngreen = "#7CFC00", t.lemonchiffon = "#FFFACD", t.lightblue = "#ADD8E6", t.lightcoral = "#F08080", t.lightcyan = "#E0FFFF", t.lightgoldenrodyellow = "#FAFAD2", t.lightgray = "#D3D3D3", t.lightgreen = "#90EE90", t.lightgrey = "#D3D3D3", t.lightpink = "#FFB6C1", t.lightsalmon = "#FFA07A", t.lightseagreen = "#20B2AA", t.lightskyblue = "#87CEFA", t.lightslategray = "#778899", t.lightslategrey = "#778899", t.lightsteelblue = "#B0C4DE", t.lightyellow = "#FFFFE0", t.limegreen = "#32CD32", t.linen = "#FAF0E6", t.magenta = "#FF00FF", t.mediumaquamarine = "#66CDAA", t.mediumblue = "#0000CD", t.mediumorchid = "#BA55D3", t.mediumpurple = "#9370DB", t.mediumseagreen = "#3CB371", t.mediumslateblue = "#7B68EE", t.mediumspringgreen = "#00FA9A", t.mediumturquoise = "#48D1CC", t.mediumvioletred = "#C71585", t.midnightblue = "#191970", t.mintcream = "#F5FFFA", t.mistyrose = "#FFE4E1", t.moccasin = "#FFE4B5", t.navajowhite = "#FFDEAD", t.oldlace = "#FDF5E6", t.olivedrab = "#6B8E23", t.orangered = "#FF4500", t.orchid = "#DA70D6", t.palegoldenrod = "#EEE8AA", t.palegreen = "#98FB98", t.paleturquoise = "#AFEEEE", t.palevioletred = "#DB7093", t.papayawhip = "#FFEFD5", t.peachpuff = "#FFDAB9", t.peru = "#CD853F", t.pink = "#FFC0CB", t.plum = "#DDA0DD", t.powderblue = "#B0E0E6", t.rosybrown = "#BC8F8F", t.royalblue = "#4169E1", t.saddlebrown = "#8B4513", t.salmon = "#FA8072", t.sandybrown = "#F4A460", t.seagreen = "#2E8B57", t.seashell = "#FFF5EE", t.sienna = "#A0522D", t.skyblue = "#87CEEB", t.slateblue = "#6A5ACD", t.slategray = "#708090", t.slategrey = "#708090", t.snow = "#FFFAFA", t.springgreen = "#00FF7F", t.steelblue = "#4682B4", t.tan = "#D2B48C", t.thistle = "#D8BFD8", t.tomato = "#FF6347", t.turquoise = "#40E0D0", t.violet = "#EE82EE", t.wheat = "#F5DEB3", t.whitesmoke = "#F5F5F5", t.yellowgreen = "#9ACD32", t.rebeccapurple = "#663399";
}(n || (n = {}));
var a, u, c, s, d, f, h, l = Object.keys(n), p = ((a = {})[t.HEX] = /^#(?:([a-f\d])([a-f\d])([a-f\d])([a-f\d])?|([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?)$/i, a[t.RGB] = /^rgb\s*\(\s*(?:(\d+%)\s*,\s*(\d+%)\s*,\s*(\d+%)|(\d+)\s*,\s*(\d+)\s*,\s*(\d+))\s*\)$/, a[t.RGBA] = /^rgba\s*\(\s*(?:(\d+%)\s*,\s*(\d+%)\s*,\s*(\d+%)|(\d+)\s*,\s*(\d+)\s*,\s*(\d+))\s*,\s*(\d\.?\d*)\s*\)$/, a[t.HSL] = /^hsl\s*\(\s*(-?\d+\.?\d*)\s*,\s*(\d+\.?\d*)%\s*,\s*(\d+\.?\d*)%s*\)$/, a[t.HSLA] = /^hsla\s*\(\s*(-?\d+\.?\d*)\s*,\s*(\d+\.?\d*)%\s*,\s*(\d+\.?\d*)%\s*,\s*(\d\.?\d*)\s*\)$/, a[t.CMYK] = /^(?:device-cmyk|cmyk)\s*\(\s*(?:(\d+\.?\d*%)\s*,\s*(\d+\.?\d*%)\s*,\s*(\d+\.?\d*%)\s*,\s*(\d+\.?\d*%)|(\d\.?\d*)\s*,\s*(\d\.?\d*)\s*,\s*(\d\.?\d*)\s*,\s*(\d\.?\d*))\s*\)$/, a), g = /^(\d+(?:\.\d+)?|\.\d+)%$/, b = /^0x([a-f\d]{1,2})$/i, F = "The provided string color doesn't have a correct format", A = "The provided color object doesn't have the proper keys or format", m = function(t, e, r) {
    return r < 0 && (r += 6), r >= 6 && (r -= 6), r < 1 ? Math.round(255 * ((e - t) * r + t)) : r < 3 ? Math.round(255 * e) : r < 4 ? Math.round(255 * ((e - t) * (4 - r) + t)) : Math.round(255 * t);
}, y = function(t, e, r) {
    e /= 100;
    var n = (r /= 100) <= .5 ? r * (e + 1) : r + e - r * e, o = 2 * r - n;
    return {
        r: m(o, n, (t /= 60) + 2),
        g: m(o, n, t),
        b: m(o, n, t - 2)
    };
}, E = function(t, e, r, n) {
    return n = 1 - n, {
        r: Math.round(255 * (1 - t) * n),
        g: Math.round(255 * (1 - e) * n),
        b: Math.round(255 * (1 - r) * n)
    };
}, H = function(t, e, r) {
    t /= 255, e /= 255, r /= 255;
    var n = 1 - Math.max(t, e, r), o = 1 - n, i = (o - t) / o, a = (o - e) / o, u = (o - r) / o;
    return {
        c: Math.round(100 * i),
        m: Math.round(100 * a),
        y: Math.round(100 * u),
        k: Math.round(100 * n)
    };
}, B = function(t, e, r, n) {
    void 0 === n && (n = 1), t /= 255, e /= 255, r /= 255, n = Math.min(n, 1);
    var o = Math.max(t, e, r), i = Math.min(t, e, r), a = o - i, u = 0, c = 0, s = (o + i) / 2;
    if (0 === a) u = 0, c = 0;
    else {
        switch(o){
            case t:
                u = (e - r) / a % 6;
                break;
            case e:
                u = (r - t) / a + 2;
                break;
            case r:
                u = (t - e) / a + 4;
        }
        (u = Math.round(60 * u)) < 0 && (u += 360), c = a / (1 - Math.abs(2 * s - 1));
    }
    return {
        h: u,
        s: Math.round(100 * c),
        l: Math.round(100 * s),
        a: n
    };
}, v = function(t, e) {
    if (t < 0 && (t += 360), t > 360 && (t -= 360), 360 === t || 0 === t) return t;
    var r = [
        [
            0,
            120
        ],
        [
            120,
            180
        ],
        [
            180,
            240
        ],
        [
            240,
            360
        ]
    ], n = [
        [
            0,
            60
        ],
        [
            60,
            120
        ],
        [
            120,
            240
        ],
        [
            240,
            360
        ]
    ], o = e ? n : r, i = 0, a = 0, u = 0, c = 0;
    return (e ? r : n).find(function(e, r) {
        return t >= e[0] && t < e[1] && (i = e[0], a = e[1], u = o[r][0], c = o[r][1], !0);
    }), u + (c - u) / (a - i) * (t - i);
}, M = function(t, e) {
    return Object.prototype.hasOwnProperty.call(t, e);
}, R = function(t) {
    return g.test("".concat(t)) ? +"".concat(t).replace(g, "$1") : Math.min(+t, 100);
}, S = function(t) {
    return 1 === t.length && (t += t), parseInt(t, 16);
}, C = function(t) {
    var e = parseInt("".concat(t)).toString(16).toUpperCase();
    return 1 === e.length ? "0x0".concat(e) : "0x".concat(e);
}, L = function(t) {
    var e = parseInt("".concat(t)).toString(16).toUpperCase();
    return 1 === e.length && (e = "0".concat(e)), e;
}, D = function(t, e) {
    return void 0 === e && (e = !1), !e && g.test(t) ? Math.min(255 * +t.replace(g, "$1") / 100, 255) : b.test(t) ? 3 === t.length ? e ? parseInt(t + t.slice(-1)) / 255 : parseInt(t + t.slice(-1)) : e ? parseInt(t) / 255 : parseInt(t) : Math.min(+t, e ? 1 : 255);
}, G = function(t) {
    return Math.min(g.test(t) ? +t.replace(g, "$1") / 100 : +t, 1);
}, k = function(t) {
    return t.sort().join().toUpperCase();
}, O = function(t, e) {
    void 0 === e && (e = 0);
    var r = Math.pow(10, e);
    return Math.round(+t * r) / r;
}, X = function(t, e, r) {
    return Math.max(e, Math.min(t, r));
}, I = ((u = {})[t.HEX] = function(t) {
    return "#".concat(L(t.r)).concat(L(t.g)).concat(L(t.b)).concat(M(t, "a") && L(t.a) || "");
}, u[t.RGB] = function(t) {
    return "rgb".concat(M(t, "a") ? "a" : "", "(").concat(O(t.r), ",").concat(O(t.g), ",").concat(O(t.b)).concat(M(t, "a") && ",".concat(O(t.a, 2)) || "", ")");
}, u[t.HSL] = function(t) {
    return "hsl".concat(M(t, "a") ? "a" : "", "(").concat(O(t.h), ",").concat(O(t.s), "%,").concat(O(t.l), "%").concat(M(t, "a") && ",".concat(O(t.a, 2)) || "", ")");
}, u[t.CMYK] = function(t) {
    return "cmyk(".concat(O(t.c), "%,").concat(O(t.m), "%,").concat(O(t.y), "%,").concat(O(t.k), "%)");
}, u), j = function(t) {
    return (t > 360 || t < 0) && (t -= 360 * Math.floor(t / 360)), t;
}, T = function(t) {
    return isNaN(+t) || t > 1 ? 1 : O(t, 2);
}, Y = function(t, e, n) {
    return e.reduce(function(e, a) {
        return i(i([], e, !0), [
            o(o({}, t), {
                h: n === r.ADDITIVE ? j(t.h + a) : j(v(v(t.h, !1) + a, !0))
            })
        ], !1);
    }, [
        o({}, t)
    ]);
}, P = function(t, e) {
    return Y(t, [
        30,
        -30
    ], e);
}, w = function(t, e) {
    return Y(t, [
        180
    ], e);
}, K = function(t, e) {
    return Y(t, [
        150,
        -150
    ], e);
}, x = function(t, e) {
    return Y(t, [
        120,
        -120
    ], e);
}, N = function(t, e) {
    return Y(t, [
        60,
        -120,
        180
    ], e);
}, V = function(t, e) {
    return Y(t, [
        90,
        -90,
        180
    ], e);
}, U = function(e) {
    return "string" == typeof e ? function(e) {
        var r;
        if (Object.keys(t).some(function(t) {
            if (p[t].test(e)) return r = t, !0;
        }), !r && ~l.indexOf(e) && (r = t.HEX), !r) throw new Error(F);
        return r;
    }(e) : function(e) {
        var r, n = !1, o = k(Object.keys(e));
        if (Object.keys(t).filter(function(e) {
            return e !== t.HEX;
        }).some(function(t) {
            if (k(t.split("")) === o) return r = t, !0;
        }), r && r === t.RGB || r === t.RGBA) {
            var i = Object.entries(e).map(function(t) {
                return b.test("".concat(t[1]));
            }), a = Object.entries(e).map(function(t) {
                return g.test("".concat(t[1])) || !b.test("".concat(t[1])) && !isNaN(+t[1]) && +t[1] <= 255;
            }), u = i.some(function(t, e) {
                return e > 0 && t !== i[e - 1];
            }), c = a.some(function(t, e) {
                return e > 0 && t !== a[e - 1];
            });
            !(n = u || c || !i[0] && !a[0]) && i[0] && (r = t.HEX);
        }
        if (!r || n) throw new Error(A);
        return r;
    }(e);
}, $ = ((c = {})[t.HEX] = function(t) {
    var e = (~l.indexOf(t) ? n[t] : t).match(p.HEX), r = {
        r: S(e[1] || e[5]),
        g: S(e[2] || e[6]),
        b: S(e[3] || e[7])
    }, o = e[4] || e[8];
    return void 0 !== o && (r.a = S(o) / 255), r;
}, c[t.RGB] = function(t) {
    var e = t.match(p.RGB), r = D(e[1] || e[4]), n = D(e[2] || e[5]), o = D(e[3] || e[6]);
    return {
        r: Math.min(r, 255),
        g: Math.min(n, 255),
        b: Math.min(o, 255)
    };
}, c[t.RGBA] = function(t) {
    var e = t.match(p.RGBA), r = D(e[1] || e[4]), n = D(e[2] || e[5]), o = D(e[3] || e[6]), i = +e[7];
    return {
        r: Math.min(r, 255),
        g: Math.min(n, 255),
        b: Math.min(o, 255),
        a: T(i)
    };
}, c[t.HSL] = function(t) {
    var e = t.match(p.HSL), r = j(+e[1]), n = R(e[2]), o = R(e[3]);
    return y(r, n, o);
}, c[t.HSLA] = function(t) {
    var e = t.match(p.HSLA), r = j(+e[1]), n = R(e[2]), o = R(e[3]), i = +e[4], a = y(r, n, o);
    return a.a = T(i), a;
}, c[t.CMYK] = function(t) {
    var e = t.match(p.CMYK), r = G(e[1] || e[5]), n = G(e[2] || e[6]), o = G(e[3] || e[7]), i = G(e[4] || e[8]);
    return E(r, n, o, i);
}, c), q = ((s = {})[t.HEX] = function(t) {
    var e = {
        r: D("".concat(t.r)),
        g: D("".concat(t.g)),
        b: D("".concat(t.b))
    };
    return e.a = M(t, "a") ? Math.min(D("".concat(t.a), !0), 1) : 1, e;
}, s[t.RGB] = function(t) {
    var e = this.HEX(t);
    return delete e.a, e;
}, s[t.RGBA] = function(t) {
    return this.HEX(t);
}, s[t.HSL] = function(t) {
    var e = R("".concat(t.s)), r = R("".concat(t.l));
    return y(j(t.h), e, r);
}, s[t.HSLA] = function(t) {
    var e = this.HSL(t);
    return e.a = T(t.a), e;
}, s[t.CMYK] = function(t) {
    var e = G("".concat(t.c)), r = G("".concat(t.m)), n = G("".concat(t.y)), o = G("".concat(t.k));
    return E(e, r, n, o);
}, s), Q = function(t, e) {
    return void 0 === e && (e = U(t)), "string" == typeof t ? $[e](t) : q[e](t);
}, _ = ((d = {})[t.HEX] = function(t) {
    return {
        r: C(t.r),
        g: C(t.g),
        b: C(t.b)
    };
}, d.HEXA = function(t) {
    var e = _.HEX(t);
    return e.a = M(t, "a") ? C(255 * t.a) : "0xFF", e;
}, d[t.RGB] = function(t) {
    return M(t, "a") && delete t.a, t;
}, d[t.RGBA] = function(t) {
    return t.a = M(t, "a") ? O(t.a, 2) : 1, t;
}, d[t.HSL] = function(t) {
    var e = B(t.r, t.g, t.b);
    return delete e.a, e;
}, d[t.HSLA] = function(t) {
    var e = _.HSL(t);
    return e.a = M(t, "a") ? O(t.a, 2) : 1, e;
}, d[t.CMYK] = function(t) {
    return H(t.r, t.g, t.b);
}, d), z = function(e, r, n) {
    var i = U(e), a = "string" == typeof e, u = Q(e, i), c = "string" == typeof e && M(u, "a") || "string" != typeof e && M(e, "a"), s = B(u.r, u.g, u.b, u.a);
    c || delete s.a;
    var d = n ? s.l / (r + 1) : (100 - s.l) / (r + 1), f = Array(r).fill(null).map(function(t, e) {
        return o(o({}, s), {
            l: s.l + d * (e + 1) * (1 - 2 * +n)
        });
    });
    switch(i){
        case t.HEX:
        default:
            return f.map(function(t) {
                var e = y(t.h, t.s, t.l);
                return c && (e.a = t.a), a ? c ? I.HEX(o(o({}, e), {
                    a: O(255 * e.a, 2)
                })) : I.HEX(e) : c ? _.HEXA(e) : _.HEX(e);
            });
        case t.RGB:
        case t.RGBA:
            return f.map(function(t) {
                var e = y(t.h, t.s, t.l);
                return c && (e.a = t.a), a ? I.RGB(e) : c ? _.RGBA(e) : _.RGB(e);
            });
        case t.HSL:
        case t.HSLA:
            return f.map(function(t) {
                return a ? I.HSL(t) : c ? _.HSLA(o(o({}, y(t.h, t.s, t.l)), {
                    a: t.a
                })) : _.HSL(y(t.h, t.s, t.l));
            });
    }
}, J = ((f = {
    buildHarmony: function(e, r, n) {
        var o = U(e), i = Q(e, o), a = B(i.r, i.g, i.b, i.a), u = "string" == typeof e && M(i, "a") || "string" != typeof e && M(e, "a"), c = "string" == typeof e;
        switch(o){
            case t.HEX:
            default:
                return u ? this.HEXA(a, r, n, c) : this.HEX(a, r, n, c);
            case t.HSL:
                return this.HSL(a, r, n, c);
            case t.HSLA:
                return this.HSLA(a, r, n, c);
            case t.RGB:
                return this.RGB(a, r, n, c);
            case t.RGBA:
                return this.RGBA(a, r, n, c);
        }
    }
})[t.HEX] = function(t, e, r, n) {
    return e(t, r).map(function(t) {
        return n ? I.HEX(y(t.h, t.s, t.l)) : _.HEX(y(t.h, t.s, t.l));
    });
}, f.HEXA = function(t, e, r, n) {
    return e(t, r).map(function(t) {
        return n ? I.HEX(o(o({}, y(t.h, t.s, t.l)), {
            a: 255 * T(t.a)
        })) : _.HEXA(o(o({}, y(t.h, t.s, t.l)), {
            a: T(t.a)
        }));
    });
}, f[t.RGB] = function(t, e, r, n) {
    return e(t, r).map(function(t) {
        return n ? I.RGB(y(t.h, t.s, t.l)) : _.RGB(y(t.h, t.s, t.l));
    });
}, f[t.RGBA] = function(t, e, r, n) {
    return e(t, r).map(function(t) {
        return n ? I.RGB(o(o({}, y(t.h, t.s, t.l)), {
            a: T(t.a)
        })) : _.RGBA(o(o({}, y(t.h, t.s, t.l)), {
            a: T(t.a)
        }));
    });
}, f[t.HSL] = function(t, e, r, n) {
    return e(t, r).map(function(t) {
        return n ? I.HSL({
            h: t.h,
            s: t.s,
            l: t.l
        }) : _.HSL(y(t.h, t.s, t.l));
    });
}, f[t.HSLA] = function(t, e, r, n) {
    return e(t, r).map(function(t) {
        return n ? I.HSL(o(o({}, t), {
            a: T(t.a)
        })) : _.HSLA(o(o({}, y(t.h, t.s, t.l)), {
            a: T(t.a)
        }));
    });
}, f), W = ((h = {
    mix: function(t, e) {
        var n, i, a, u, c, s, d, f, h, l, p, g, b, F, A, m = t.map(function(t) {
            var e = U(t);
            return Q(t, e);
        }), y = e === r.SUBTRACTIVE ? m.map(function(t) {
            var e, r, n, o, i, a, u, c, s, d, f, h, l, p, g = (e = t.r, r = t.g, n = t.b, o = Math.min(e, r, n), i = Math.min(255 - e, 255 - r, 255 - n), a = e - o, u = r - o, c = n - o, s = Math.min(a, u), d = a - s, f = (u + s) / 2, h = (c + u - s) / 2, l = Math.max(d, f, h) / Math.max(a, u, c), p = isNaN(l) || l === 1 / 0 || l <= 0 ? 1 : l, {
                r: d / p + i,
                y: f / p + i,
                b: h / p + i
            });
            return M(t, "a") && (g.a = t.a), g;
        }) : null;
        function E(t) {
            var n = e === r.ADDITIVE ? {
                r: 0,
                g: 0,
                b: 0,
                a: 0
            } : {
                r: 0,
                y: 0,
                b: 0,
                a: 0
            };
            return t.reduce(function(t, n) {
                var i = M(n, "a") ? n.a : 1, a = {
                    r: Math.min(t.r + n.r * i, 255),
                    b: Math.min(t.b + n.b * i, 255),
                    a: 1 - (1 - i) * (1 - t.a)
                }, u = "g" in t ? t.g : t.y, c = "g" in n ? n.g : n.y;
                return o(o({}, a), e === r.ADDITIVE ? {
                    g: Math.min(u + c * i, 255)
                } : {
                    y: Math.min(u + c * i, 255)
                });
            }, n);
        }
        if (e === r.ADDITIVE) n = E(m);
        else {
            var H = E(y);
            i = H.r, a = H.y, u = H.b, c = Math.min(i, a, u), s = Math.min(255 - i, 255 - a, 255 - u), d = i - c, f = a - c, h = u - c, l = Math.min(f, h), p = d + f - l, g = f + 2 * l, b = 2 * (h - l), F = Math.max(p, g, b) / Math.max(d, f, h), A = isNaN(F) || F === 1 / 0 || F <= 0 ? 1 : F, (n = {
                r: p / A + s,
                g: g / A + s,
                b: b / A + s
            }).a = H.a;
        }
        return {
            r: O(n.r, 2),
            g: O(n.g, 2),
            b: O(n.b, 2),
            a: X(n.a, 0, 1)
        };
    }
})[t.HEX] = function(t, e, r) {
    var n = this.mix(t, e);
    return delete n.a, r ? I.HEX(n) : _.HEX(n);
}, h.HEXA = function(t, e, r) {
    var n = this.mix(t, e);
    return n.a = r ? 255 * T(n.a) : T(n.a), r ? I.HEX(n) : _.HEXA(n);
}, h[t.RGB] = function(t, e, r) {
    var n = this.mix(t, e);
    return delete n.a, r ? I.RGB(n) : _.RGB(n);
}, h[t.RGBA] = function(t, e, r) {
    var n = this.mix(t, e);
    return r ? I.RGB(n) : _.RGBA(n);
}, h[t.HSL] = function(t, e, r) {
    var n = this.mix(t, e), o = B(n.r, n.g, n.b);
    return delete n.a, delete o.a, r ? I.HSL(o) : _.HSL(n);
}, h[t.HSLA] = function(t, e, r) {
    var n = this.mix(t, e), o = B(n.r, n.g, n.b, n.a);
    return r ? I.HSL(o) : _.HSLA(n);
}, h), Z = function(t, e) {
    return "string" == typeof t && e || "object" == typeof t && !e;
}, tt = function(t, e, r, n, o) {
    var i = n(Q(t, e));
    return r ? o(i) : i;
}, et = function(t, e, r, n, o, i) {
    r < 1 && (r = 5);
    var a = function(t, e, r) {
        var n = r - 1, o = (e.r - t.r) / n, i = (e.g - t.g) / n, a = (e.b - t.b) / n, u = T(t.a), c = (T(e.a) - u) / n;
        return Array(r).fill(null).map(function(r, s) {
            return 0 === s ? t : s === n ? e : {
                r: O(t.r + o * s),
                g: O(t.g + i * s),
                b: O(t.b + a * s),
                a: O(u + c * s, 2)
            };
        });
    }(Q(t), Q(e), r);
    return a.map(function(t) {
        var e = o(t);
        return n ? i(e) : e;
    });
}, rt = function() {
    function n(t) {
        this.rgb = Q(t), this.updateHSL(), this.updateCMYK();
    }
    return n.prototype.updateRGB = function() {
        this.rgb = o(o({}, y(this.hsl.h, this.hsl.s, this.hsl.l)), {
            a: this.hsl.a
        });
    }, n.prototype.updateRGBFromCMYK = function() {
        this.rgb = o(o({}, E(this.cmyk.c, this.cmyk.m, this.cmyk.y, this.cmyk.k)), {
            a: this.rgb.a
        });
    }, n.prototype.updateHSL = function() {
        this.hsl = B(this.rgb.r, this.rgb.g, this.rgb.b, this.rgb.a);
    }, n.prototype.updateCMYK = function() {
        this.cmyk = H(this.rgb.r, this.rgb.g, this.rgb.b);
    }, n.prototype.updateRGBAndCMYK = function() {
        return this.updateRGB(), this.updateCMYK(), this;
    }, n.prototype.updateHSLAndCMYK = function() {
        return this.updateHSL(), this.updateCMYK(), this;
    }, n.prototype.updateRGBAndHSL = function() {
        return this.updateRGBFromCMYK(), this.updateHSL(), this;
    }, n.prototype.setH = function(t) {
        return this.hsl.h = j(t), this.updateRGBAndCMYK();
    }, n.prototype.setS = function(t) {
        return this.hsl.s = X(t, 0, 100), this.updateRGBAndCMYK();
    }, n.prototype.setL = function(t) {
        return this.hsl.l = X(t, 0, 100), this.updateRGBAndCMYK();
    }, n.prototype.setR = function(t) {
        return this.rgb.r = X(t, 0, 255), this.updateHSLAndCMYK();
    }, n.prototype.setG = function(t) {
        return this.rgb.g = X(t, 0, 255), this.updateHSLAndCMYK();
    }, n.prototype.setB = function(t) {
        return this.rgb.b = X(t, 0, 255), this.updateHSLAndCMYK();
    }, n.prototype.setA = function(t) {
        return this.hsl.a = this.rgb.a = X(t, 0, 1), this;
    }, n.prototype.setC = function(t) {
        return this.cmyk.c = X(t, 0, 100), this.updateRGBAndHSL();
    }, n.prototype.setM = function(t) {
        return this.cmyk.m = X(t, 0, 100), this.updateRGBAndHSL();
    }, n.prototype.setY = function(t) {
        return this.cmyk.y = X(t, 0, 100), this.updateRGBAndHSL();
    }, n.prototype.setK = function(t) {
        return this.cmyk.k = X(t, 0, 100), this.updateRGBAndHSL();
    }, Object.defineProperty(n.prototype, "H", {
        get: function() {
            return O(this.hsl.h);
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "S", {
        get: function() {
            return O(this.hsl.s);
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "L", {
        get: function() {
            return O(this.hsl.l);
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "R", {
        get: function() {
            return O(this.rgb.r);
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "G", {
        get: function() {
            return O(this.rgb.g);
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "B", {
        get: function() {
            return O(this.rgb.b);
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "A", {
        get: function() {
            return O(this.hsl.a, 2);
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "C", {
        get: function() {
            return O(this.cmyk.c);
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "M", {
        get: function() {
            return O(this.cmyk.m);
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "Y", {
        get: function() {
            return O(this.cmyk.y);
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "K", {
        get: function() {
            return O(this.cmyk.k);
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "HEXObject", {
        get: function() {
            return _.HEX(this.rgb);
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "HEXAObject", {
        get: function() {
            return _.HEXA(this.rgb);
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "RGBObject", {
        get: function() {
            return {
                r: this.R,
                g: this.G,
                b: this.B
            };
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "RGBAObject", {
        get: function() {
            return o(o({}, this.RGBObject), {
                a: this.A
            });
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "HSLObject", {
        get: function() {
            return {
                h: this.H,
                s: this.S,
                l: this.L
            };
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "HSLAObject", {
        get: function() {
            return o(o({}, this.HSLObject), {
                a: this.A
            });
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "CMYKObject", {
        get: function() {
            return {
                c: this.C,
                m: this.M,
                y: this.Y,
                k: this.K
            };
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "HEX", {
        get: function() {
            var t = this.rgb, e = {
                r: t.r,
                g: t.g,
                b: t.b
            };
            return I.HEX(e);
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "HEXA", {
        get: function() {
            var t = this.rgb, e = {
                r: t.r,
                g: t.g,
                b: t.b,
                a: 255 * this.A
            };
            return I.HEX(e);
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "RGB", {
        get: function() {
            var t = this.rgb, e = {
                r: t.r,
                g: t.g,
                b: t.b
            };
            return I.RGB(e);
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "RGBA", {
        get: function() {
            var t = this.rgb, e = {
                r: t.r,
                g: t.g,
                b: t.b,
                a: this.A
            };
            return I.RGB(e);
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "HSL", {
        get: function() {
            var t = this.hsl, e = {
                h: t.h,
                s: t.s,
                l: t.l
            };
            return I.HSL(e);
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "HSLA", {
        get: function() {
            return I.HSL(this.hsl);
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "CMYK", {
        get: function() {
            return I.CMYK(this.cmyk);
        },
        enumerable: !1,
        configurable: !0
    }), n.toHEX = function(t, e) {
        void 0 === e && (e = !0);
        var r = U(t);
        return tt(t, r, e, _.HEX, I.HEX);
    }, n.toHEXA = function(t, e) {
        void 0 === e && (e = !0);
        var r = U(t);
        return tt(t, r, e, _.HEXA, I.HEX);
    }, n.toRGB = function(t, e) {
        void 0 === e && (e = !0);
        var r = U(t);
        return tt(t, r, e, _.RGB, I.RGB);
    }, n.toRGBA = function(t, e) {
        void 0 === e && (e = !0);
        var r = U(t);
        return tt(t, r, e, _.RGBA, I.RGB);
    }, n.toHSL = function(e, r) {
        void 0 === r && (r = !0);
        var n = U(e);
        return n === t.HSL && Z(e, r) ? e : tt(e, n, r, _.HSL, I.HSL);
    }, n.toHSLA = function(e, r) {
        void 0 === r && (r = !0);
        var n = U(e);
        return n === t.HSLA && Z(e, r) ? e : tt(e, n, r, _.HSLA, I.HSL);
    }, n.toCMYK = function(e, r) {
        void 0 === r && (r = !0);
        var n = U(e);
        return n === t.CMYK && Z(e, r) ? e : tt(e, n, r, _.CMYK, I.CMYK);
    }, n.getBlendHEX = function(t, e, r, n) {
        return void 0 === r && (r = 5), void 0 === n && (n = !0), et(t, e, r, n, _.HEX, I.HEX);
    }, n.getBlendHEXA = function(t, e, r, n) {
        return void 0 === r && (r = 5), void 0 === n && (n = !0), et(t, e, r, n, _.HEXA, I.HEX);
    }, n.getBlendRGB = function(t, e, r, n) {
        return void 0 === r && (r = 5), void 0 === n && (n = !0), et(t, e, r, n, _.RGB, I.RGB);
    }, n.getBlendRGBA = function(t, e, r, n) {
        return void 0 === r && (r = 5), void 0 === n && (n = !0), et(t, e, r, n, _.RGBA, I.RGB);
    }, n.getBlendHSL = function(t, e, r, n) {
        return void 0 === r && (r = 5), void 0 === n && (n = !0), et(t, e, r, n, _.HSL, I.HSL);
    }, n.getBlendHSLA = function(t, e, r, n) {
        return void 0 === r && (r = 5), void 0 === n && (n = !0), et(t, e, r, n, _.HSLA, I.HSL);
    }, n.getMixHEX = function(t, e, n) {
        return void 0 === e && (e = r.ADDITIVE), void 0 === n && (n = !0), W.HEX(t, e, n);
    }, n.getMixHEXA = function(t, e, n) {
        return void 0 === e && (e = r.ADDITIVE), void 0 === n && (n = !0), W.HEXA(t, e, n);
    }, n.getMixRGB = function(t, e, n) {
        return void 0 === e && (e = r.ADDITIVE), void 0 === n && (n = !0), W.RGB(t, e, n);
    }, n.getMixRGBA = function(t, e, n) {
        return void 0 === e && (e = r.ADDITIVE), void 0 === n && (n = !0), W.RGBA(t, e, n);
    }, n.getMixHSL = function(t, e, n) {
        return void 0 === e && (e = r.ADDITIVE), void 0 === n && (n = !0), W.HSL(t, e, n);
    }, n.getMixHSLA = function(t, e, n) {
        return void 0 === e && (e = r.ADDITIVE), void 0 === n && (n = !0), W.HSLA(t, e, n);
    }, n.getShades = function(t, e) {
        return z(t, e, !0);
    }, n.getTints = function(t, e) {
        return z(t, e, !1);
    }, n.getHarmony = function(t, n, o) {
        switch(void 0 === n && (n = e.COMPLEMENTARY), void 0 === o && (o = r.ADDITIVE), n){
            case e.ANALOGOUS:
                return J.buildHarmony(t, P, o);
            case e.SPLIT_COMPLEMENTARY:
                return J.buildHarmony(t, K, o);
            case e.TRIADIC:
                return J.buildHarmony(t, x, o);
            case e.TETRADIC:
                return J.buildHarmony(t, N, o);
            case e.SQUARE:
                return J.buildHarmony(t, V, o);
            default:
                return J.buildHarmony(t, w, o);
        }
    }, n;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hJBX6":[function() {},{}],"75Exv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useMessageListAria);
var _vue = require("vue");
var _useComponentUuidJs = require("../../../composables/useComponentUuid.js");
const useMessageListAria = (props)=>{
    const id = (0, _useComponentUuidJs.u)();
    const messageListId = `message-list-${id}`;
    const messageListAttributes = (0, _vue.computed)(()=>({
            id: messageListId,
            role: "alert"
        }));
    const doHaveMessages = (0, _vue.computed)(()=>{
        if (typeof props.modelValue === "string" && props.modelValue.length > 0) return true;
        if (Array.isArray(props.modelValue) && props.modelValue.length > 0) return true;
        return false;
    });
    const childAttributes = (0, _vue.computed)(()=>({
            "aria-describedby": doHaveMessages.value ? messageListId : void 0,
            "aria-invalid": props.hasError
        }));
    return {
        messageListAttributes,
        childAttributes
    };
};

},{"vue":"gzxs9","../../../composables/useComponentUuid.js":"cuNNa","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cuNNa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useComponentUuid);
var _vue = require("vue");
var _useAppGlobalJs = require("./useAppGlobal.js");
const useComponentUuid = ()=>{
    const vm = (0, _vue.getCurrentInstance)();
    const counter = (0, _useAppGlobalJs.u)("uuidCounter", 0);
    vm.$vaUuid = vm.$vaUuid || `va-${counter.value++}`;
    return `va-${counter.value}`;
};

},{"vue":"gzxs9","./useAppGlobal.js":"7iRcm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7iRcm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useAppGlobal);
var _vue = require("vue");
const getGlobalObject = ()=>{
    const vm = (0, _vue.getCurrentInstance)();
    const app = vm == null ? void 0 : vm.appContext.app;
    const { globalProperties } = app.config;
    if ("$vaGlobalVariable" in globalProperties) return globalProperties.$vaGlobalVariable;
    globalProperties.$vaGlobalVariable = (0, _vue.reactive)({});
    return globalProperties.$vaGlobalVariable;
};
const useAppGlobal = (key, defaultValue)=>{
    const globalObject = getGlobalObject();
    if (!(key in globalObject)) globalObject[key] = defaultValue;
    return (0, _vue.computed)({
        get: ()=>globalObject[key],
        set: (value)=>{
            globalObject[key] = value;
        }
    });
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f9kzg":[function() {},{}],"f9kzg":[function() {},{}],"iFHh2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useValidation);
parcelHelpers.export(exports, "b", ()=>useValidationProps);
parcelHelpers.export(exports, "u", ()=>useValidationEmits);
var _vue = require("vue");
var _vendorJs = require("../../vendor.js");
var _useSyncPropJs = require("./useSyncProp.js");
var _watchSetterJs = require("../utils/watch-setter.js");
var _useFormChildJs = require("./useForm/useFormChild.js");
const normalizeValidationRules = (rules = [], callArguments = null)=>{
    if ((0, _vendorJs.f)(rules)) rules = [
        rules
    ];
    return rules.map((rule)=>(0, _vendorJs.g)(rule) ? rule(callArguments) : rule);
};
const useValidationProps = {
    name: {
        type: String,
        default: void 0
    },
    rules: {
        type: Array,
        default: ()=>[]
    },
    dirty: {
        type: Boolean,
        default: false
    },
    error: {
        type: Boolean,
        default: void 0
    },
    errorMessages: {
        type: [
            Array,
            String
        ],
        default: void 0
    },
    errorCount: {
        type: [
            String,
            Number
        ],
        default: 1
    },
    success: {
        type: Boolean,
        default: false
    },
    messages: {
        type: [
            Array,
            String
        ],
        default: ()=>[]
    },
    immediateValidation: {
        type: Boolean,
        default: false
    },
    modelValue: {}
};
const useValidationEmits = [
    "update:error",
    "update:errorMessages",
    "update:dirty"
];
const isPromise = (value)=>{
    return typeof value === "object" && typeof value.then === "function";
};
const useDirtyValue = (value, props, emit)=>{
    const isDirty = (0, _vue.ref)(props.dirty || false);
    (0, _watchSetterJs.w)(value, ()=>{
        isDirty.value = true;
        emit("update:dirty", true);
    });
    (0, _vue.watch)(value, (newValue, oldValue)=>{
        if (newValue === oldValue) isDirty.value = true;
    }, {
        deep: true
    });
    (0, _vue.watch)(()=>props.dirty, (newValue)=>{
        if (isDirty.value === newValue) return;
        isDirty.value = newValue;
    });
    return {
        isDirty
    };
};
const useTouched = ()=>{
    const isTouched = (0, _vue.ref)(false);
    const onBlur = ()=>{
        isTouched.value = true;
    };
    return {
        isTouched,
        onBlur
    };
};
const useOncePerTick = (fn)=>{
    let canBeCalled = true;
    return (...args)=>{
        if (!canBeCalled) return;
        canBeCalled = false;
        const result = fn(...args);
        (0, _vue.nextTick)(()=>{
            canBeCalled = true;
        });
        return result;
    };
};
const useValidation = (props, emit, options)=>{
    const { reset, focus } = options;
    const [isError] = (0, _useSyncPropJs.u)("error", props, emit, false);
    const [errorMessages] = (0, _useSyncPropJs.u)("errorMessages", props, emit, []);
    const isLoading = (0, _vue.ref)(false);
    const { isTouched, onBlur } = useTouched();
    const validationAriaAttributes = (0, _vue.computed)(()=>({
            "aria-invalid": isError.value,
            "aria-errormessage": typeof errorMessages.value === "string" ? errorMessages.value : errorMessages.value.join(", ")
        }));
    const resetValidation = ()=>{
        errorMessages.value = [];
        isError.value = false;
        isDirty.value = false;
        isTouched.value = false;
        isLoading.value = false;
    };
    const processResults = (results)=>{
        let error = false;
        let eMessages = [];
        results.forEach((result)=>{
            if ((0, _vendorJs.f)(result)) {
                eMessages = [
                    ...eMessages,
                    result
                ];
                error = true;
            } else if (result === false) error = true;
        });
        errorMessages.value = eMessages;
        isError.value = error;
        return !error;
    };
    const validateAsync = async ()=>{
        if (!props.rules || !props.rules.length) return true;
        const results = normalizeValidationRules((0, _vendorJs.h)(props.rules), options.value.value);
        const asyncPromiseResults = results.filter((result)=>isPromise(result));
        const syncRules = results.filter((result)=>!isPromise(result));
        if (!asyncPromiseResults.length) return processResults(syncRules);
        isLoading.value = true;
        return Promise.all(asyncPromiseResults).then((asyncResults)=>{
            isLoading.value = false;
            return processResults([
                ...syncRules,
                ...asyncResults
            ]);
        });
    };
    const validate = useOncePerTick(()=>{
        if (!props.rules || !props.rules.length) return true;
        const rules = (0, _vendorJs.h)(props.rules);
        const results = normalizeValidationRules(rules, options.value.value);
        const asyncPromiseResults = results.filter((result)=>isPromise(result));
        const syncRules = results.filter((result)=>!isPromise(result));
        const isSyncedError = syncRules.some((result)=>(0, _vendorJs.f)(result) ? result : result === false);
        if (asyncPromiseResults.length && !isSyncedError) {
            isLoading.value = true;
            Promise.all(asyncPromiseResults).then((asyncResults)=>{
                processResults([
                    ...syncRules,
                    ...asyncResults
                ]);
                isLoading.value = false;
            });
            return isSyncedError;
        }
        return processResults(syncRules);
    });
    (0, _vue.watchEffect)(()=>validate());
    const { isDirty } = useDirtyValue(options.value, props, emit);
    const { // Renamed to forceHideError because it's not clear what it does
    forceHideErrors, forceHideLoading, forceHideErrorMessages, forceDirty, immediate: isFormImmediate } = (0, _useFormChildJs.u)({
        isTouched,
        isDirty,
        isValid: (0, _vue.computed)(()=>!isError.value),
        isLoading,
        errorMessages,
        validate,
        validateAsync,
        resetValidation,
        focus,
        reset: ()=>{
            reset();
            resetValidation();
            validate();
        },
        value: (0, _vue.computed)(()=>options.value || props.modelValue),
        name: (0, _vue.toRef)(props, "name")
    });
    const immediateValidation = (0, _vue.computed)(()=>props.immediateValidation || isFormImmediate.value);
    let canValidate = true;
    const withoutValidation = (cb)=>{
        canValidate = false;
        cb();
        (0, _vue.nextTick)(()=>{
            canValidate = true;
        });
    };
    (0, _vue.watch)(options.value, ()=>{
        if (!canValidate) return;
        return validate();
    }, {
        immediate: immediateValidation.value
    });
    return {
        isDirty,
        isValid: (0, _vue.computed)(()=>!isError.value),
        isError,
        isTouched,
        isLoading: (0, _vue.computed)(()=>forceHideLoading.value ? false : isLoading.value),
        computedError: (0, _vue.computed)(()=>{
            if (forceHideErrors.value) return false;
            if (immediateValidation.value) return isError.value;
            if (isTouched.value || isDirty.value || forceDirty.value) return isError.value;
            return false;
        }),
        computedErrorMessages: (0, _vue.computed)(()=>forceHideErrorMessages.value ? [] : errorMessages.value),
        listeners: {
            onBlur
        },
        validate,
        resetValidation,
        withoutValidation,
        validationAriaAttributes
    };
};

},{"vue":"gzxs9","../../vendor.js":"l6TAc","./useSyncProp.js":"3q1sU","../utils/watch-setter.js":"c8ffe","./useForm/useFormChild.js":"X120o","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3q1sU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useSyncProp);
var _vue = require("vue");
function useSyncProp(propName, props, emit, defaultValue) {
    const vm = (0, _vue.getCurrentInstance)();
    const isPropPassed = (0, _vue.computed)(()=>{
        const t = props[propName];
        if (!(vm == null ? void 0 : vm.vnode.props)) return t !== void 0;
        return propName in vm.vnode.props && vm.vnode.props[propName] !== void 0;
    });
    if (defaultValue === void 0) return [
        (0, _vue.computed)({
            set (value) {
                emit(`update:${propName}`, value);
            },
            get () {
                return props[propName];
            }
        })
    ];
    const currentValue = props[propName];
    const statefulValue = (0, _vue.ref)(currentValue === void 0 ? defaultValue : currentValue);
    (0, _vue.watch)(()=>props[propName], (newVal)=>{
        if (newVal === void 0) return;
        statefulValue.value = newVal;
    });
    return [
        (0, _vue.computed)({
            set (value) {
                statefulValue.value = value;
                emit(`update:${propName}`, value);
            },
            get () {
                if (isPropPassed.value) return props[propName];
                return statefulValue.value;
            }
        })
    ];
}

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c8ffe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "w", ()=>watchSetter);
const isComputedRef = (value)=>{
    return typeof value === "object" && "_setter" in value;
};
const watchSetter = (ref, cb)=>{
    if (!isComputedRef(ref)) return;
    const originalSetter = ref._setter;
    ref._setter = (newValue)=>{
        cb(newValue);
        originalSetter(newValue);
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"X120o":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useFormChild);
var _vue = require("vue");
var _useComponentUuidJs = require("../useComponentUuid.js");
var _constsJs = require("./consts.js");
const useFormChild = (context)=>{
    const formContext = (0, _vue.inject)((0, _constsJs.F), null);
    if (!formContext) return {
        forceDirty: (0, _vue.ref)(false),
        forceHideErrorMessages: (0, _vue.ref)(false),
        forceHideErrors: (0, _vue.ref)(false),
        forceHideLoading: (0, _vue.ref)(false),
        fields: (0, _vue.computed)(()=>[]),
        registerField: ()=>{},
        unregisterField: ()=>{},
        immediate: (0, _vue.computed)(()=>false)
    };
    const uid = (0, _useComponentUuidJs.u)();
    (0, _vue.onMounted)(()=>{
        formContext.registerField(uid, context);
    });
    (0, _vue.onBeforeUnmount)(()=>{
        formContext.unregisterField(uid);
    });
    return formContext;
};

},{"vue":"gzxs9","../useComponentUuid.js":"cuNNa","./consts.js":"7hyjD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7hyjD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "F", ()=>FormServiceKey);
const FormServiceKey = Symbol("FormService");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fgand":[function() {},{}],"kIv2h":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useLocalConfigJs = require("../../composables/useLocalConfig.js");
var _useGlobalConfigProviderJs = require("./hooks/useGlobalConfigProvider.js");
var _headlessJs = require("../../utils/headless.js");
var _useColorsJs = require("../../composables/useColors.js");
const CssVarsRenderer = (0, _vue.defineComponent)({
    name: "VaCssVarsRenderer",
    inheritAttrs: false,
    setup (props, { slots, attrs }) {
        const { colorsToCSSVariable, colors } = (0, _useColorsJs.u)();
        const style = (0, _vue.computed)(()=>{
            return colorsToCSSVariable(colors);
        });
        return ()=>(0, _vue.h)((0, _vue.Fragment), attrs, (0, _headlessJs.r)(slots.default, {}, {
                style: style.value
            }) || void 0);
    }
});
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaConfig",
    inheritAttrs: false,
    __name: "VaConfig",
    props: {
        ...(0, _useComponentPresetJs.u),
        components: {
            type: Object,
            default: ()=>({})
        },
        colors: {
            type: Object
        },
        i18n: {
            type: Object
        }
    },
    setup (__props) {
        const props = __props;
        const prevChain = (0, _useLocalConfigJs.u)();
        const nextChain = (0, _vue.computed)(()=>[
                ...prevChain.value,
                props.components
            ]);
        (0, _useLocalConfigJs.p)(nextChain);
        (0, _useGlobalConfigProviderJs.u)((0, _vue.computed)(()=>{
            const config = {};
            if (props.colors) config.colors = props.colors;
            if (props.i18n) config.i18n = props.i18n;
            return config;
        }));
        const doRenderCssVars = (0, _vue.computed)(()=>{
            return Boolean(props.colors);
        });
        return (_ctx, _cache)=>{
            return doRenderCssVars.value ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)(CssVarsRenderer), (0, _vue.normalizeProps)((0, _vue.mergeProps)({
                key: 0
            }, _ctx.$attrs)), {
                default: (0, _vue.withCtx)(()=>[
                        (0, _vue.renderSlot)(_ctx.$slots, "default")
                    ]),
                _: 3
            }, 16)) : (0, _vue.renderSlot)(_ctx.$slots, "default", {
                key: 1
            });
        };
    }
});

},{"vue":"gzxs9","../../composables/useComponentPreset.js":"2HoaT","../../composables/useLocalConfig.js":"dvyav","./hooks/useGlobalConfigProvider.js":"7SZoU","../../utils/headless.js":"fM1sq","../../composables/useColors.js":"a4Qgv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7SZoU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useGlobalConfigProvider);
var _mergeDeepJs = require("../../../utils/merge-deep.js");
var _vendorJs = require("../../../../vendor.js");
var _vue = require("vue");
var _makeConfigJs = require("../../../services/color/config/make-config.js");
var _useGlobalConfigJs = require("../../../composables/useGlobalConfig.js");
var _globalConfigJs = require("../../../services/global-config/global-config.js");
const useGlobalConfigProvider = (next)=>{
    const { globalConfig, mergeGlobalConfig, setGlobalConfig, getGlobalConfig } = (0, _useGlobalConfigJs.u)();
    const nextChain = (0, _vue.computed)(()=>{
        var _a;
        const gcCopy = (0, _vendorJs.c)(globalConfig.value);
        const compiledCopy = {
            ...gcCopy,
            colors: (0, _makeConfigJs.m)(gcCopy.colors)
        };
        const config = (0, _mergeDeepJs.m)(compiledCopy, next.value);
        if ((_a = next.value.colors) == null ? void 0 : _a.variables) Object.keys(next.value.colors.variables).forEach((key)=>{
            config.colors.variables[key] = next.value.colors.variables[key];
        });
        return config;
    });
    (0, _vue.provide)((0, _globalConfigJs.G), {
        mergeGlobalConfig,
        setGlobalConfig,
        getGlobalConfig,
        globalConfig: nextChain
    });
    return nextChain;
};

},{"../../../utils/merge-deep.js":"eRzih","../../../../vendor.js":"l6TAc","vue":"gzxs9","../../../services/color/config/make-config.js":"1Uqg8","../../../composables/useGlobalConfig.js":"8pVeR","../../../services/global-config/global-config.js":"7ORqt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fM1sq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>renderSlotNode);
parcelHelpers.export(exports, "r", ()=>renderSlotNodes);
var _vue = require("vue");
const toNode = (v, attrs)=>{
    if (!v) return null;
    if (!("type" in v) || v.type === (0, _vue.Text) || typeof v === "string") return (0, _vue.h)("div", attrs, v);
    if (v.type === (0, _vue.Comment)) return v;
    if ("$el" in v) return toNode(v.$el, attrs);
    if (v.type === (0, _vue.Suspense)) return (0, _vue.h)(v.ssContent, attrs);
    if (v.type === (0, _vue.Teleport)) {
        if (v.children === null) return v;
        const anchor = toNode(v.children[0], attrs);
        if (anchor) v.children[0] = (0, _vue.h)(anchor, attrs);
        return v;
    }
    if (v.type === (0, _vue.Fragment)) {
        if (v.children === null) return v;
        if (v.children.length === 1) return (0, _vue.h)((0, _vue.Fragment), v.props, [
            toNode(v.children[0], attrs)
        ]);
        return (0, _vue.h)("div", attrs, v);
    }
    if (typeof v.type.render === "function") {
        const component = (0, _vue.h)(v);
        if (Array.isArray(component.children) && component.children.length > 1) return (0, _vue.h)("div", attrs, component.children);
    }
    return (0, _vue.h)(v, attrs);
};
const renderSlotNode = (slot, slotBind = {}, nodeAttributes = {})=>{
    const children = slot == null ? void 0 : slot(slotBind);
    if (!children) return null;
    const nonCommentChildren = children.filter((v)=>v.type !== (0, _vue.Comment));
    if (nonCommentChildren.length === 0) return null;
    if (nonCommentChildren.length === 1) return toNode(nonCommentChildren[0], nodeAttributes);
    return (0, _vue.h)("div", nodeAttributes, children);
};
const renderSlotNodes = (slot, slotBind = {}, nodeAttributes = {})=>{
    const children = slot == null ? void 0 : slot(slotBind);
    if (!children) return null;
    return children.map((v)=>toNode(v, nodeAttributes));
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g10Ia":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vaSeparatorCss = require("../../../VaSeparator.css");
const _hoisted_1 = {
    class: "va-separator",
    "aria-hidden": "true"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaSeparator",
    __name: "VaSeparator",
    setup (__props) {
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_1);
        };
    }
});

},{"vue":"gzxs9","../../../VaSeparator.css":"NcKIy","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"NcKIy":[function() {},{}],"cczXf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vaSpacerCss = require("../../../VaSpacer.css");
const _hoisted_1 = {
    class: "va-spacer",
    "aria-hidden": "true"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaSpacer",
    __name: "VaSpacer",
    setup (__props) {
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_1);
        };
    }
});

},{"vue":"gzxs9","../../../VaSpacer.css":"ilvI7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ilvI7":[function() {},{}],"eIBX9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "G", ()=>GlobalConfigPlugin);
var _globalConfigJs = require("../global-config.js");
var _globalPropertiesJs = require("../../vue-plugin/utils/global-properties.js");
var _defineVuesticPluginJs = require("../../vue-plugin/utils/define-vuestic-plugin.js");
const GlobalConfigPlugin = (0, _defineVuesticPluginJs.d)((config = {})=>({
        install (app) {
            const globalConfig = (0, _globalConfigJs.c)(config);
            if (config == null ? void 0 : config.componentsAll) console.warn("Global config -> `componentsAll` was moved to Global config -> components.all. Please replace this to make it work. More info here: https://github.com/epicmaxco/vuestic-ui/issues/1967");
            app.provide((0, _globalConfigJs.G), globalConfig);
            (0, _globalPropertiesJs.d)(app, "$vaConfig", globalConfig);
        }
    }));

},{"../global-config.js":"7ORqt","../../vue-plugin/utils/global-properties.js":"isaE8","../../vue-plugin/utils/define-vuestic-plugin.js":"5M143","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"isaE8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "d", ()=>defineGlobalProperty);
parcelHelpers.export(exports, "g", ()=>getGlobalProperty);
const extractGlobalProperties = (app)=>app.config.globalProperties;
const defineGlobalProperty = (app, key, v)=>{
    const globalProperties = extractGlobalProperties(app);
    globalProperties[key] = v;
};
const getGlobalProperty = (app, key)=>{
    return extractGlobalProperties(app)[key];
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cfBZ8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "C", ()=>ColorConfigPlugin);
var _createColorConfigPluginJs = require("./create-color-config-plugin.js");
var _defineVuesticPluginJs = require("../../vue-plugin/utils/define-vuestic-plugin.js");
var _globalPropertiesJs = require("../../vue-plugin/utils/global-properties.js");
const ColorConfigPlugin = (0, _defineVuesticPluginJs.d)((config)=>({
        install (app) {
            (0, _globalPropertiesJs.d)(app, "$vaColorConfig", (0, _createColorConfigPluginJs.c)());
        }
    }));

},{"./create-color-config-plugin.js":"bLuzP","../../vue-plugin/utils/define-vuestic-plugin.js":"5M143","../../vue-plugin/utils/global-properties.js":"isaE8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bLuzP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "c", ()=>createColorConfigPlugin);
var _vue = require("vue");
var _ssrJs = require("../../../utils/ssr.js");
var _utilsJs = require("../utils.js");
var _uuidJs = require("../../../utils/uuid.js");
var _domJs = require("../../../utils/dom.js");
var _useColorsJs = require("../../../composables/useColors.js");
const generateCSSVariable = (key, value)=>{
    return `${(0, _utilsJs.j)(key)}: ${value};
`;
};
const createColorConfigPlugin = (app, config)=>{
    const { colors: configColors, getTextColor, getColor, currentPresetName, applyPreset } = (0, _useColorsJs.u)();
    const renderCSSVariables = (colors = configColors)=>{
        if (!colors) return;
        const colorNames = Object.keys(colors);
        const renderedColors = colorNames.map((key)=>`${(0, _utilsJs.j)(key)}: ${colors[key]}`).join(";");
        const renderedOnColors = colorNames.map((key)=>`${(0, _utilsJs.j)(`on-${key}`)}: ${getColor(getTextColor(colors[key]))}`).join(";");
        return `${renderedColors};${renderedOnColors}`;
    };
    const renderCSSVariablesStyleContent = (colors = configColors)=>{
        const colorNames = Object.keys(colors);
        let result = ":root {\n";
        colorNames.forEach((key)=>{
            result += generateCSSVariable(key, colors[key]);
        });
        colorNames.forEach((key)=>{
            result += generateCSSVariable(`on-${key}`, getColor(getTextColor(colors[key])));
        });
        result += "}\n";
        return result;
    };
    const uniqueId = (0, _vue.computed)((0, _uuidJs.g));
    const updateColors = (newValue)=>{
        if (!newValue) return;
        if ((0, _ssrJs.i)()) return;
        const styleContent = renderCSSVariablesStyleContent(newValue);
        (0, _domJs.a)(`va-color-variables-${uniqueId.value}`, ()=>styleContent);
    };
    (0, _vue.watch)(configColors, (newValue)=>{
        updateColors(newValue);
    }, {
        immediate: true,
        deep: true
    });
    return {
        colors: configColors,
        currentPresetName,
        renderCSSVariables,
        updateColors,
        renderCSSVariablesStyleContent
    };
};

},{"vue":"gzxs9","../../../utils/ssr.js":"cVJXV","../utils.js":"4SMXK","../../../utils/uuid.js":"9koOy","../../../utils/dom.js":"ac5o6","../../../composables/useColors.js":"a4Qgv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cVJXV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>getGlobal);
parcelHelpers.export(exports, "b", ()=>isClient);
parcelHelpers.export(exports, "g", ()=>getWindow);
parcelHelpers.export(exports, "i", ()=>isServer);
const isServer = ()=>typeof window === "undefined";
const isClient = ()=>!isServer();
const getWindow = ()=>typeof window === "undefined" ? void 0 : window;
const fakeGlobal = {};
const getGlobal = ()=>{
    if (isServer()) {
        if (typeof globalThis === "undefined") return fakeGlobal;
        return globalThis;
    } else return window;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9koOy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "g", ()=>generateUniqueId);
let counter = 0;
const getRandomString = (stringLength = 4)=>{
    return Math.random().toString(36).substring(2, stringLength + 2);
};
const generateUniqueId = ()=>{
    return `${getRandomString(8)}-${getRandomString(4)}-${getRandomString(4)}-${++counter}`;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ac5o6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>addOrUpdateStyleElement);
var _ssrJs = require("./ssr.js");
const addOrUpdateStyleElement = (id, getStyles)=>{
    if ((0, _ssrJs.i)()) return;
    let stylesElement = document.getElementById(id);
    if (stylesElement) stylesElement.innerHTML = getStyles();
    else {
        stylesElement = document.createElement("style");
        stylesElement.setAttribute("type", "text/css");
        stylesElement.setAttribute("id", id);
        stylesElement.innerHTML = getStyles();
        document.head.append(stylesElement);
    }
};

},{"./ssr.js":"cVJXV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3E8dA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "B", ()=>BreakpointConfigPlugin);
var _createServiceJs = require("./create-service.js");
var _indexJs = require("../index.js");
var _defineVuesticPluginJs = require("../../vue-plugin/utils/define-vuestic-plugin.js");
var _globalPropertiesJs = require("../../vue-plugin/utils/global-properties.js");
const BreakpointConfigPlugin = (0, _defineVuesticPluginJs.d)(()=>({
        install (app) {
            const breakpointConfig = (0, _createServiceJs.c)(app);
            app.provide((0, _indexJs.v), breakpointConfig);
            (0, _globalPropertiesJs.d)(app, "$vaBreakpoint", breakpointConfig);
        }
    }));

},{"./create-service.js":"9E9wY","../index.js":"94cKv","../../vue-plugin/utils/define-vuestic-plugin.js":"5M143","../../vue-plugin/utils/global-properties.js":"isaE8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9E9wY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "c", ()=>createBreakpointConfigPlugin);
var _vue = require("vue");
var _ssrJs = require("../../../utils/ssr.js");
var _consoleJs = require("../../../utils/console.js");
var _uuidJs = require("../../../utils/uuid.js");
var _domJs = require("../../../utils/dom.js");
var _globalPropertiesJs = require("../../vue-plugin/utils/global-properties.js");
var _useWindowSizeJs = require("../../../composables/useWindowSize.js");
var _useReactiveComputedJs = require("../../../composables/useReactiveComputed.js");
var _useDocumentJs = require("../../../composables/useDocument.js");
const createBreakpointConfigPlugin = (app)=>{
    var _a;
    const globalConfig = (_a = (0, _globalPropertiesJs.g)(app, "$vaConfig")) == null ? void 0 : _a.globalConfig;
    if (!globalConfig) {
        (0, _consoleJs.w)("createBreakpointConfigPlugin: globalConfig is not defined!");
        return {};
    }
    const breakpointConfig = (0, _vue.computed)(()=>{
        const breakpoint = globalConfig.value.breakpoint;
        if (!breakpoint) (0, _consoleJs.w)("createBreakpointConfigPlugin: breakpointConfig is not defined!");
        return breakpoint ?? {};
    });
    if (!breakpointConfig.value.enabled) return {};
    if (!breakpointConfig.value.thresholds || !Object.values(breakpointConfig.value.thresholds).length) {
        (0, _consoleJs.w)("createBreakpointConfigPlugin: there are no defined thresholds!");
        return {};
    }
    const { windowSizes } = (0, _useWindowSizeJs.u)();
    const isMounted = (0, _vue.computed)((0, _ssrJs.b));
    const currentBreakpoint = (0, _vue.computed)(()=>{
        if (!isMounted.value || !windowSizes.width) return;
        return Object.entries(breakpointConfig.value.thresholds).reduce((acc, [key, value])=>{
            if (windowSizes.width >= value) acc = key;
            return acc;
        }, "xs");
    });
    const screenClasses = (0, _vue.computed)(()=>Object.keys(breakpointConfig.value.thresholds).reduce((acc, threshold)=>{
            acc[threshold] = `va-screen-${threshold}`;
            return acc;
        }, {}));
    const generateHelpersMediaCss = ()=>{
        let result = "";
        Object.values(breakpointConfig.value.thresholds).forEach((thresholdValue, index)=>{
            result += `@media screen and (min-width: ${thresholdValue}px) {`;
            result += `:root { --va-media-ratio: ${(index + 1) * 0.2} }`;
            result += "}\n";
        });
        return result;
    };
    const uniqueId = (0, _vue.computed)((0, _uuidJs.g));
    (0, _domJs.a)(`va-helpers-media-${uniqueId.value}`, generateHelpersMediaCss);
    const getDocument = (0, _useDocumentJs.u)();
    (0, _vue.watch)(currentBreakpoint, (newValue)=>{
        if (!newValue || !breakpointConfig.value.bodyClass || !getDocument.value) return;
        getDocument.value.body.classList.forEach((className)=>{
            if (Object.values(screenClasses.value).includes(className)) getDocument.value.body.classList.remove(className);
        });
        getDocument.value.body.classList.add(screenClasses.value[newValue]);
    }, {
        immediate: true
    });
    const breakpointHelpers = (0, _vue.computed)(()=>{
        const isXs = currentBreakpoint.value === "xs";
        const isSm = currentBreakpoint.value === "sm";
        const isMd = currentBreakpoint.value === "md";
        const isLg = currentBreakpoint.value === "lg";
        const isXl = currentBreakpoint.value === "xl";
        return {
            xs: isXs,
            sm: isSm,
            md: isMd,
            lg: isLg,
            xl: isXl,
            smUp: isSm || isMd || isLg || isXl,
            mdUp: isMd || isLg || isXl,
            lgUp: isLg || isXl,
            smDown: isXs || isSm,
            mdDown: isXs || isSm || isMd,
            lgDown: isXs || isSm || isMd || isLg
        };
    });
    return (0, _useReactiveComputedJs.u)(()=>({
            width: windowSizes.width,
            height: windowSizes.height,
            current: currentBreakpoint.value,
            thresholds: breakpointConfig.value.thresholds,
            ...breakpointHelpers.value
        }));
};

},{"vue":"gzxs9","../../../utils/ssr.js":"cVJXV","../../../utils/console.js":"58L6z","../../../utils/uuid.js":"9koOy","../../../utils/dom.js":"ac5o6","../../vue-plugin/utils/global-properties.js":"isaE8","../../../composables/useWindowSize.js":"lf5r3","../../../composables/useReactiveComputed.js":"4FIgk","../../../composables/useDocument.js":"403q6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lf5r3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useWindowSize);
var _vue = require("vue");
var _ssrJs = require("../utils/ssr.js");
var _useEventJs = require("./useEvent.js");
function useWindowSize() {
    const windowSizes = (0, _vue.reactive)({
        width: void 0,
        height: void 0
    });
    const setCurrentWindowSizes = ()=>{
        windowSizes.width = window == null ? void 0 : window.innerWidth;
        windowSizes.height = window == null ? void 0 : window.innerHeight;
    };
    const isMounted = (0, _vue.computed)((0, _ssrJs.b));
    (0, _vue.watch)(isMounted, (newValue)=>{
        if (!newValue) return;
        setCurrentWindowSizes();
    }, {
        immediate: true
    });
    (0, _useEventJs.u)("resize", setCurrentWindowSizes, true);
    return {
        windowSizes
    };
}

},{"vue":"gzxs9","../utils/ssr.js":"cVJXV","./useEvent.js":"9kzUn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9kzUn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useEvent);
var _vue = require("vue");
var _useWindowJs = require("./useWindow.js");
var _unwrapElJs = require("../utils/unwrapEl.js");
var _addEventListenerJs = require("../utils/add-event-listener.js");
const useEvent = (event, listener, target)=>{
    const source = target && typeof target !== "boolean" ? target : (0, _useWindowJs.u)();
    const capture = typeof target === "boolean" ? target : false;
    (0, _vue.watch)(source, (newValue, oldValue)=>{
        if (!Array.isArray(event)) {
            (0, _addEventListenerJs.a)((0, _unwrapElJs.u)((0, _vue.unref)(newValue)), event, listener, capture);
            (0, _addEventListenerJs.r)((0, _unwrapElJs.u)((0, _vue.unref)(oldValue)), event, listener, capture);
        } else event.forEach((e)=>{
            (0, _addEventListenerJs.a)((0, _unwrapElJs.u)((0, _vue.unref)(newValue)), e, listener, capture);
            (0, _addEventListenerJs.r)((0, _unwrapElJs.u)((0, _vue.unref)(oldValue)), e, listener, capture);
        });
    }, {
        immediate: true
    });
};

},{"vue":"gzxs9","./useWindow.js":"bOeBT","../utils/unwrapEl.js":"bYHKv","../utils/add-event-listener.js":"aMJTT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bOeBT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useWindow);
var _useClientOnlyJs = require("./useClientOnly.js");
const useWindow = ()=>(0, _useClientOnlyJs.u)(()=>window);

},{"./useClientOnly.js":"bQ8x9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bQ8x9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useClientOnly);
var _vue = require("vue");
var _ssrJs = require("../utils/ssr.js");
const useClientOnly = (cb)=>{
    const isMounted = (0, _vue.computed)((0, _ssrJs.b));
    const result = (0, _vue.ref)(null);
    (0, _vue.watch)(isMounted, ()=>{
        if (isMounted.value) result.value = cb();
    }, {
        immediate: true
    });
    return result;
};

},{"vue":"gzxs9","../utils/ssr.js":"cVJXV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bYHKv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>unwrapEl);
var _vue = require("vue");
const unwrapEl = (el)=>{
    if (!el) return;
    if (typeof el !== "object") return;
    el = (0, _vue.unref)(el);
    if (!el) return;
    if (typeof el.$el !== "undefined") return el.$el;
    return el;
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aMJTT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>addEventListener);
parcelHelpers.export(exports, "r", ()=>removeEventListener);
const addEventListener = (target, ...args)=>{
    if (!target || typeof target !== "object") return;
    if ("addEventListener" in target && typeof target.addEventListener === "function") {
        target.addEventListener(...args);
        return;
    }
    if ("parentElement" in target) addEventListener(target.parentElement, ...args);
};
const removeEventListener = (target, ...args)=>{
    if (!target || typeof target !== "object") return;
    if ("removeEventListener" in target && typeof target.removeEventListener === "function") {
        target.removeEventListener(...args);
        return;
    }
    if ("parentElement" in target) removeEventListener(target.parentElement, ...args);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"403q6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useDocument);
var _useClientOnlyJs = require("./useClientOnly.js");
const useDocument = ()=>(0, _useClientOnlyJs.u)(()=>document);

},{"./useClientOnly.js":"bQ8x9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ghhI3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaToastPlugin);
var _toastJs = require("../toast.js");
var _defineVuesticPluginJs = require("../../../services/vue-plugin/utils/define-vuestic-plugin.js");
var _globalPropertiesJs = require("../../../services/vue-plugin/utils/global-properties.js");
const createVaToastPlugin = (app)=>({
        /** Returns toast instance id */ init (options) {
            return (0, _toastJs.c)(options, app == null ? void 0 : app._context);
        },
        close (id) {
            (0, _toastJs.a)(id);
        },
        closeAll (allApps = false) {
            (0, _toastJs.b)(allApps ? void 0 : app == null ? void 0 : app._context);
        }
    });
const VaToastPlugin = (0, _defineVuesticPluginJs.d)(()=>({
        install (app) {
            (0, _globalPropertiesJs.d)(app, "$vaToast", createVaToastPlugin(app));
        }
    }));

},{"../toast.js":"euASG","../../../services/vue-plugin/utils/define-vuestic-plugin.js":"5M143","../../../services/vue-plugin/utils/global-properties.js":"isaE8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"euASG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaToast);
parcelHelpers.export(exports, "a", ()=>closeById);
parcelHelpers.export(exports, "b", ()=>closeAllNotifications);
parcelHelpers.export(exports, "c", ()=>createToastInstance);
var _vue = require("vue");
var _ssrJs = require("../../utils/ssr.js");
var _vaToastVueVueTypeScriptSetupTrueLangJs = require("./VaToast.vue_vue_type_script_setup_true_lang.js");
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
const VaToast = (0, _withConfigTransportJs.a)((0, _vaToastVueVueTypeScriptSetupTrueLangJs._));
const GAP = 5;
let seed = 1;
(0, _ssrJs.a)().vaToastInstances = [];
const getTranslateValue = (item, position)=>{
    if (item.el) {
        const direction = position.includes("bottom") ? -1 : 1;
        return (item.el.offsetHeight + GAP) * direction;
    }
    return 0;
};
const getNewTranslateValue = (transformY, redundantHeight, position)=>{
    const direction = position.includes("bottom") ? -1 : 1;
    return parseInt(transformY, 10) - (redundantHeight + GAP) * direction;
};
const getNodeProps = (vNode)=>{
    var _a;
    return ((_a = vNode.component) == null ? void 0 : _a.props) || {};
};
const closeNotification = (targetInstance, destroyElementFn)=>{
    var _a;
    if (!targetInstance) return;
    if (!(0, _ssrJs.a)().vaToastInstances.length) {
        seed = 1;
        return;
    }
    const targetInstanceIndex = (0, _ssrJs.a)().vaToastInstances.findIndex((instance)=>instance === targetInstance);
    if (targetInstanceIndex < 0) return;
    const nodeProps = getNodeProps(targetInstance);
    const { offsetX: targetOffsetX, offsetY: targetOffsetY, position: targetPosition } = nodeProps;
    const redundantHeight = (_a = targetInstance.el) == null ? void 0 : _a.offsetHeight;
    destroyElementFn();
    (0, _ssrJs.a)().vaToastInstances = (0, _ssrJs.a)().vaToastInstances.reduce((acc, instance, index)=>{
        if (instance === targetInstance) return acc;
        if (instance.component) {
            const { offsetX, offsetY, position } = getNodeProps(instance);
            const isNextInstance = index > targetInstanceIndex && targetOffsetX === offsetX && targetOffsetY === offsetY && targetPosition === position;
            if (isNextInstance && instance.el && redundantHeight) {
                const [_, transformY] = instance.el.style.transform.match(/[\d-]+(?=px)/g);
                const transformYNew = getNewTranslateValue(transformY, redundantHeight, position);
                instance.el.style.transform = `translate(0, ${transformYNew}px)`;
            }
        }
        return [
            ...acc,
            instance
        ];
    }, []);
    if (!(0, _ssrJs.a)().vaToastInstances.length) seed = 1;
};
const destroy = (el, node)=>{
    if (el) {
        (0, _vue.render)(null, el);
        el.remove();
    }
    el = null;
};
const mount = (component, { props, children, element, appContext } = {})=>{
    let el = element;
    let vNode;
    const onClose = ()=>{
        closeNotification(vNode, ()=>destroy(el));
        if (props == null ? void 0 : props.onClose) props.onClose();
    };
    vNode = (0, _vue.createVNode)(component, {
        ...props,
        onClose
    }, children);
    if (appContext) vNode.appContext = appContext;
    if (el) (0, _vue.render)(vNode, el);
    else if (typeof document !== "undefined") (0, _vue.render)(vNode, el = document.createElement("div"));
    return {
        vNode,
        el
    };
};
const closeAllNotifications = (appContext)=>{
    if (!(0, _ssrJs.a)().vaToastInstances.length) {
        seed = 1;
        return;
    }
    (0, _ssrJs.a)().vaToastInstances.forEach((instance)=>{
        if (appContext && instance.appContext !== appContext) return;
        getNodeProps(instance).onClose();
    });
};
const closeById = (id)=>{
    const targetInstance = (0, _ssrJs.a)().vaToastInstances.find((instance)=>{
        var _a;
        return ((_a = instance.el) == null ? void 0 : _a.id) === id;
    });
    if (targetInstance) {
        const nodeProps = getNodeProps(targetInstance);
        nodeProps.onClose();
    }
};
const getToastOptions = (options)=>{
    if (typeof options === "string") return {
        message: options
    };
    return options;
};
const createToastInstance = (customProps, appContext)=>{
    const { vNode, el } = mount(VaToast, {
        appContext,
        props: getToastOptions(customProps)
    });
    const nodeProps = getNodeProps(vNode);
    if (el && vNode.el && nodeProps) {
        document.body.appendChild(el.childNodes[0]);
        const { offsetX, offsetY, position } = nodeProps;
        vNode.el.style.display = "flex";
        vNode.el.id = "notification_" + seed;
        let transformY = 0;
        (0, _ssrJs.a)().vaToastInstances.filter((item)=>{
            const { offsetX: itemOffsetX, offsetY: itemOffsetY, position: itemPosition } = getNodeProps(item);
            return itemOffsetX === offsetX && itemOffsetY === offsetY && position === itemPosition;
        }).forEach((item)=>{
            transformY += getTranslateValue(item, position);
        });
        vNode.el.style.transform = `translate(0, ${transformY}px)`;
        seed += 1;
        (0, _ssrJs.a)().vaToastInstances.push(vNode);
        return vNode.el.id;
    }
    return null;
};

},{"vue":"gzxs9","../../utils/ssr.js":"cVJXV","./VaToast.vue_vue_type_script_setup_true_lang.js":"8FmCG","../../services/config-transport/withConfigTransport.js":"b7Tgy","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8FmCG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vaIconVueVueTypeScriptSetupTrueLangJs = require("../va-icon/VaIcon.vue_vue_type_script_setup_true_lang.js");
var _useTimerJs = require("../../composables/useTimer.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useTranslationJs = require("../../composables/useTranslation.js");
var _useColorsJs = require("../../composables/useColors.js");
var _useTextColorJs = require("../../composables/useTextColor.js");
var _vaToastCss = require("../../../VaToast.css");
const _hoisted_1 = [
    "role",
    "aria-live"
];
const _hoisted_2 = {
    class: "va-toast__group"
};
const _hoisted_3 = [
    "textContent"
];
const _hoisted_4 = {
    class: "va-toast__content"
};
const _hoisted_5 = [
    "innerHTML"
];
const _hoisted_6 = [
    "textContent"
];
const _hoisted_7 = {
    key: 1,
    class: "va-toast__content"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaToast",
    __name: "VaToast",
    props: {
        ...(0, _useComponentPresetJs.u),
        title: {
            type: String,
            default: ""
        },
        offsetY: {
            type: Number,
            default: 16
        },
        offsetX: {
            type: Number,
            default: 16
        },
        message: {
            type: [
                String,
                Function
            ],
            default: ""
        },
        dangerouslyUseHtmlString: {
            type: Boolean,
            default: false
        },
        icon: {
            type: String,
            default: "close"
        },
        customClass: {
            type: String,
            default: ""
        },
        duration: {
            type: Number,
            default: 5e3
        },
        color: {
            type: String,
            default: ""
        },
        closeable: {
            type: Boolean,
            default: true
        },
        onClose: {
            type: Function
        },
        onClick: {
            type: Function
        },
        multiLine: {
            type: Boolean,
            default: false
        },
        position: {
            type: String,
            default: "top-right",
            validator: (value)=>[
                    "top-right",
                    "top-left",
                    "bottom-right",
                    "bottom-left"
                ].includes(value)
        },
        render: {
            type: Function
        },
        ariaCloseLabel: {
            type: String,
            default: "$t:close"
        },
        role: {
            type: String,
            default: void 0
        },
        inline: {
            type: Boolean,
            default: false
        }
    },
    emits: [
        "on-click",
        "on-close"
    ],
    setup (__props, { emit: __emit }) {
        const VaToastRenderer = (0, _vue.defineComponent)({
            name: "VaToastRenderer",
            props: {
                render: {
                    type: Function,
                    required: true
                }
            },
            setup: (props2)=>()=>props2.render()
        });
        const { tp } = (0, _useTranslationJs.u)();
        const props = __props;
        const emit = __emit;
        const rootElement = (0, _vue.shallowRef)();
        const { getColor } = (0, _useColorsJs.u)();
        const { textColorComputed } = (0, _useTextColorJs.u)((0, _vue.computed)(()=>getColor(props.color)));
        const visible = (0, _vue.ref)(false);
        const positionX = (0, _vue.computed)(()=>{
            return props.position.includes("right") ? "right" : "left";
        });
        const positionY = (0, _vue.computed)(()=>{
            return props.position.includes("top") ? "top" : "bottom";
        });
        const toastClasses = (0, _vue.computed)(()=>[
                props.customClass,
                props.multiLine ? "va-toast--multiline" : "",
                props.inline ? "va-toast--inline" : ""
            ]);
        const toastStyles = (0, _vue.computed)(()=>({
                [positionY.value]: `${props.offsetY}px`,
                [positionX.value]: `${props.offsetX}px`,
                backgroundColor: getColor(props.color),
                color: textColorComputed.value
            }));
        const computedAriaLive = (0, _vue.computed)(()=>{
            if (props.role === "status") return "polite";
            else return "assertive";
        });
        const computedMessage = (0, _vue.computed)(()=>typeof props.message === "function" ? props.message() : props.message);
        const destroyElement = ()=>{
            var _a, _b;
            (_a = rootElement.value) == null || _a.removeEventListener("transitionend", destroyElement);
            (_b = rootElement.value) == null || _b.remove();
        };
        const onToastClick = ()=>{
            if (typeof props.onClick === "function") props.onClick();
            else emit("on-click");
        };
        const onToastClose = ()=>{
            var _a;
            visible.value = false;
            (_a = rootElement.value) == null || _a.addEventListener("transitionend", destroyElement);
            if (typeof props.onClose === "function") props.onClose();
            else emit("on-close");
        };
        const timer = (0, _useTimerJs.u)();
        const clearTimer = timer.clear;
        const startTimer = ()=>{
            if (props.duration > 0) timer.start(()=>visible.value && onToastClose(), props.duration);
        };
        (0, _vue.onMounted)(()=>{
            visible.value = true;
            startTimer();
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.Transition), {
                name: "va-toast-fade"
            }, {
                default: (0, _vue.withCtx)(()=>[
                        (0, _vue.withDirectives)((0, _vue.createElementVNode)("div", {
                            ref_key: "rootElement",
                            ref: rootElement,
                            role: _ctx.$props.role ?? _ctx.$props.closeable ? "alertdialog" : "alert",
                            "aria-live": computedAriaLive.value,
                            "aria-atomic": "true",
                            class: (0, _vue.normalizeClass)([
                                "va-toast",
                                toastClasses.value
                            ]),
                            style: (0, _vue.normalizeStyle)(toastStyles.value),
                            onMouseenter: _cache[0] || (_cache[0] = (...args)=>(0, _vue.unref)(clearTimer) && (0, _vue.unref)(clearTimer)(...args)),
                            onMouseleave: startTimer,
                            onClick: onToastClick
                        }, [
                            (0, _vue.createElementVNode)("div", _hoisted_2, [
                                _ctx.$props.title ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("h2", {
                                    key: 0,
                                    class: "va-toast__title",
                                    textContent: (0, _vue.toDisplayString)(_ctx.$props.title)
                                }, null, 8, _hoisted_3)) : (0, _vue.createCommentVNode)("", true),
                                (0, _vue.withDirectives)((0, _vue.createElementVNode)("div", _hoisted_4, [
                                    _ctx.$props.dangerouslyUseHtmlString ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                        key: 0,
                                        innerHTML: computedMessage.value
                                    }, null, 8, _hoisted_5)) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("p", {
                                        key: 1,
                                        textContent: (0, _vue.toDisplayString)(computedMessage.value)
                                    }, null, 8, _hoisted_6))
                                ], 512), [
                                    [
                                        (0, _vue.vShow),
                                        _ctx.$props.message
                                    ]
                                ]),
                                _ctx.$props.render ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_7, [
                                    (0, _vue.createVNode)((0, _vue.unref)(VaToastRenderer), {
                                        render: _ctx.$props.render
                                    }, null, 8, [
                                        "render"
                                    ])
                                ])) : (0, _vue.createCommentVNode)("", true),
                                _ctx.$props.closeable ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vaIconVueVueTypeScriptSetupTrueLangJs._), {
                                    key: 2,
                                    class: "va-toast__close-icon",
                                    role: "button",
                                    "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaCloseLabel),
                                    tabindex: "0",
                                    size: "1rem",
                                    name: _ctx.$props.icon,
                                    onClick: (0, _vue.withModifiers)(onToastClose, [
                                        "stop"
                                    ]),
                                    onKeydown: (0, _vue.withKeys)((0, _vue.withModifiers)(onToastClose, [
                                        "stop"
                                    ]), [
                                        "enter"
                                    ])
                                }, null, 8, [
                                    "aria-label",
                                    "name",
                                    "onKeydown"
                                ])) : (0, _vue.createCommentVNode)("", true)
                            ])
                        ], 46, _hoisted_1), [
                            [
                                (0, _vue.vShow),
                                visible.value
                            ]
                        ])
                    ]),
                _: 1
            });
        };
    }
});

},{"vue":"gzxs9","../va-icon/VaIcon.vue_vue_type_script_setup_true_lang.js":"8g95K","../../composables/useTimer.js":"ksH1C","../../composables/useComponentPreset.js":"2HoaT","../../composables/useTranslation.js":"7S3aV","../../composables/useColors.js":"a4Qgv","../../composables/useTextColor.js":"5pfXb","../../../VaToast.css":"bNNka","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ksH1C":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useTimer);
const useTimer = ()=>{
    let timer;
    const start = (...args)=>{
        timer = window.setTimeout(...args);
        return timer;
    };
    const clear = ()=>timer && window.clearTimeout(timer);
    return {
        start,
        clear
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7S3aV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useTranslation);
var _vue = require("vue");
var _consoleJs = require("../utils/console.js");
var _useGlobalConfigJs = require("./useGlobalConfig.js");
const applyI18nTemplate = (key, values)=>{
    if (!values) return key;
    Object.keys(values).forEach((valueKey)=>{
        key = key.replace(`{${valueKey}}`, String(values[valueKey]));
    });
    return key;
};
const useTranslation = ()=>{
    const { globalConfig } = (0, _useGlobalConfigJs.u)();
    const config = (0, _vue.computed)(()=>globalConfig.value.i18n);
    return {
        /** Translate prop. Translate only if key has `$t:` prefix */ tp: (key, values)=>{
            if (!key) return "";
            if (key.startsWith("$t:")) key = config.value[key.slice(3)] || key;
            return applyI18nTemplate(key, values) || key;
        },
        t (key, values) {
            const translated = config.value[key];
            if (!translated) {
                (0, _consoleJs.w)(`${key} not found in VuesticUI i18n config`);
                return key;
            }
            return applyI18nTemplate(translated, values) || key;
        }
    };
};

},{"vue":"gzxs9","../utils/console.js":"58L6z","./useGlobalConfig.js":"8pVeR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5pfXb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useTextColor);
var _vue = require("vue");
var _useColorsJs = require("./useColors.js");
var _utilsJs = require("../services/color/utils.js");
const useTextColor = (componentColor, isTransparent = false)=>{
    const { props } = (0, _vue.getCurrentInstance)();
    const { getColor, getTextColor } = (0, _useColorsJs.u)();
    const textColorComputed = (0, _vue.computed)(()=>{
        if (props.textColor) return getColor(props.textColor);
        const bg = componentColor ? (0, _vue.unref)(componentColor) : props.color;
        if (!bg) return "currentColor";
        const componentColorHex = getColor(bg);
        if ((0, _utilsJs.o)(componentColorHex)) return "currentColor";
        return (0, _vue.unref)(isTransparent) ? componentColorHex : getColor(getTextColor(componentColorHex));
    });
    return {
        textColorComputed
    };
};

},{"vue":"gzxs9","./useColors.js":"a4Qgv","../services/color/utils.js":"4SMXK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bNNka":[function() {},{}],"h07Ct":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaDropdownPlugin);
var _defineVuesticPluginJs = require("../../../services/vue-plugin/utils/define-vuestic-plugin.js");
var _globalPropertiesJs = require("../../../services/vue-plugin/utils/global-properties.js");
const vaDropdownPlugin = {
    closeDropdown () {
        let vm = this;
        while(vm = vm.$parent){
            const name = vm.$options.name;
            if (name === "VaDropdown") {
                vm.hide();
                break;
            }
        }
    }
};
const VaDropdownPlugin = (0, _defineVuesticPluginJs.d)(()=>({
        install (app) {
            (0, _globalPropertiesJs.d)(app, "$closeDropdown", vaDropdownPlugin.closeDropdown);
            (0, _globalPropertiesJs.d)(app, "$vaDropdown", vaDropdownPlugin);
        }
    }));

},{"../../../services/vue-plugin/utils/define-vuestic-plugin.js":"5M143","../../../services/vue-plugin/utils/global-properties.js":"isaE8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bq9KV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaModalPlugin);
var _modalJs = require("../modal.js");
var _defineVuesticPluginJs = require("../../../services/vue-plugin/utils/define-vuestic-plugin.js");
var _globalPropertiesJs = require("../../../services/vue-plugin/utils/global-properties.js");
const createVaModalPlugin = (app)=>({
        init (options) {
            return (0, _modalJs.c)(options, app == null ? void 0 : app._context);
        },
        confirm (options) {
            if (typeof options === "string") return new Promise((resolve)=>{
                (0, _modalJs.c)({
                    message: options,
                    onOk () {
                        resolve(true);
                    },
                    onCancel () {
                        resolve(false);
                    }
                }, app == null ? void 0 : app._context);
            });
            return new Promise((resolve)=>{
                (0, _modalJs.c)({
                    ...options,
                    onOk () {
                        var _a;
                        (_a = options == null ? void 0 : options.onOk) == null || _a.call(options);
                        resolve(true);
                    },
                    onCancel () {
                        var _a;
                        (_a = options == null ? void 0 : options.onCancel) == null || _a.call(options);
                        resolve(false);
                    }
                }, app == null ? void 0 : app._context);
            });
        }
    });
const VaModalPlugin = (0, _defineVuesticPluginJs.d)(()=>({
        install (app) {
            (0, _globalPropertiesJs.d)(app, "$vaModal", createVaModalPlugin(app));
        }
    }));

},{"../modal.js":"45JiY","../../../services/vue-plugin/utils/define-vuestic-plugin.js":"5M143","../../../services/vue-plugin/utils/global-properties.js":"isaE8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"45JiY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "c", ()=>createModalInstance);
var _vaModalJs = require("./VaModal.js");
var _vue = require("vue");
const getNodeProps = (vNode)=>{
    var _a;
    return ((_a = vNode.component) == null ? void 0 : _a.props) || {};
};
const destroy = (el, vNode)=>{
    if (el) {
        (0, _vue.render)(null, el);
        el.remove();
    }
    el = null;
};
const mount = (component, { props, appContext } = {})=>{
    const el = document == null ? void 0 : document.createElement("div");
    let vNode;
    const onClose = (event)=>{
        var _a;
        (_a = props == null ? void 0 : props.onClose) == null || _a.call(props, event);
        destroy(el);
    };
    const onUpdateModelValue = (value)=>{
        var _a;
        (_a = props == null ? void 0 : props["onUpdate:modelValue"]) == null || _a.call(props, value);
        if ((props == null ? void 0 : props.withoutTransitions) && !value) (0, _vue.nextTick)(()=>{
            destroy(el);
        });
    };
    vNode = (0, _vue.h)(component, {
        ...props,
        stateful: (props == null ? void 0 : props.stateful) ?? true,
        modelValue: true,
        onClose,
        "onUpdate:modelValue": onUpdateModelValue
    });
    if (appContext) vNode.appContext = appContext;
    if (el) (0, _vue.render)(vNode, el);
    return {
        vNode,
        el
    };
};
const getModalOptions = (options)=>typeof options === "string" ? {
        message: options
    } : options;
const createModalInstance = (customProps, appContext)=>{
    const { vNode, el } = mount((0, _vaModalJs.V), {
        appContext,
        props: getModalOptions(customProps)
    });
    if (el && vNode.el && getNodeProps(vNode)) document.body.appendChild(el.childNodes[0]);
    return vNode;
};

},{"./VaModal.js":"g5tjq","vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g5tjq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaModal);
var _vaModalVueVueTypeScriptSetupTrueLangJs = require("./VaModal.vue_vue_type_script_setup_true_lang.js");
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaModalCss = require("../../../VaModal.css");
const VaModal_vue_vue_type_style_index_0_lang = "";
const VaModal = (0, _withConfigTransportJs.w)((0, _vaModalVueVueTypeScriptSetupTrueLangJs._));

},{"./VaModal.vue_vue_type_script_setup_true_lang.js":"hASbT","../../services/config-transport/withConfigTransport.js":"b7Tgy","../../../VaModal.css":"kfqni","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hASbT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _indexJs = require("../va-button/index.js");
var _indexJs1 = require("../va-icon/index.js");
var _useBlurJs = require("./hooks/useBlur.js");
var _useZIndexJs = require("../../composables/useZIndex.js");
var _useChildComponentsJs = require("../../composables/useChildComponents.js");
var _useStatefulJs = require("../../composables/useStateful.js");
var _useTrapFocusJs = require("../../composables/useTrapFocus.js");
var _useModalLevelJs = require("../../composables/useModalLevel.js");
var _useSizeJs = require("../../composables/useSize.js");
var _useWindowJs = require("../../composables/useWindow.js");
var _useTeleportedJs = require("../../composables/useTeleported.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useColorsJs = require("../../composables/useColors.js");
var _useTextColorJs = require("../../composables/useTextColor.js");
var _useClickOutsideJs = require("../../composables/useClickOutside.js");
var _useDocumentJs = require("../../composables/useDocument.js");
var _useTranslationJs = require("../../composables/useTranslation.js");
var _vaModalCss = require("../../../VaModal.css");
const _hoisted_1 = [
    "aria-labelledby"
];
const _hoisted_2 = {
    key: 2,
    class: "va-modal__inner"
};
const _hoisted_3 = {
    class: "va-modal__header"
};
const _hoisted_4 = {
    key: 0,
    class: "va-modal__message"
};
const _hoisted_5 = {
    key: 1,
    class: "va-modal__message"
};
const _hoisted_6 = {
    key: 2,
    class: "va-modal__footer"
};
const _hoisted_7 = {
    key: 3,
    class: "va-modal__footer"
};
const WithTransition = (0, _vue.defineComponent)({
    name: "ModalElement",
    inheritAttrs: false,
    props: {
        ...(0, _useComponentPresetJs.u),
        isTransition: {
            type: Boolean,
            default: true
        }
    },
    setup: (props, { slots, attrs })=>()=>{
            var _a;
            return props.isTransition ? (0, _vue.h)((0, _vue.Transition), {
                ...attrs
            }, slots) : (_a = slots.default) == null ? void 0 : _a.call(slots, attrs);
        }
});
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaModal",
    inheritAttrs: false,
    __name: "VaModal",
    props: {
        ...(0, _useChildComponentsJs.d)({
            cancelButton: (0, _indexJs.V),
            okButton: (0, _indexJs.V),
            closeButton: (0, _indexJs1.V)
        }),
        ...(0, _useStatefulJs.u),
        modelValue: {
            type: Boolean,
            default: false
        },
        attachElement: {
            type: String,
            default: "body"
        },
        allowBodyScroll: {
            type: Boolean,
            default: false
        },
        disableAttachment: {
            type: Boolean,
            default: false
        },
        title: {
            type: String,
            default: ""
        },
        message: {
            type: String,
            default: ""
        },
        okText: {
            type: String,
            default: "$t:ok"
        },
        cancelText: {
            type: String,
            default: "$t:cancel"
        },
        hideDefaultActions: {
            type: Boolean,
            default: false
        },
        fullscreen: {
            type: Boolean,
            default: false
        },
        closeButton: {
            type: Boolean,
            default: false
        },
        mobileFullscreen: {
            type: Boolean,
            default: true
        },
        noDismiss: {
            type: Boolean,
            default: false
        },
        noOutsideDismiss: {
            type: Boolean,
            default: false
        },
        noEscDismiss: {
            type: Boolean,
            default: false
        },
        maxWidth: {
            type: String,
            default: ""
        },
        maxHeight: {
            type: String,
            default: ""
        },
        anchorClass: {
            type: String
        },
        size: {
            type: String,
            default: "medium"
        },
        sizesConfig: {
            type: Object,
            default: ()=>({
                    defaultSize: "medium",
                    sizes: {
                        small: 576,
                        medium: 768,
                        large: 992,
                        auto: "max-content"
                    }
                })
        },
        fixedLayout: {
            type: Boolean,
            default: false
        },
        withoutTransitions: {
            type: Boolean,
            default: false
        },
        overlay: {
            type: Boolean,
            default: true
        },
        overlayOpacity: {
            type: [
                Number,
                String
            ],
            default: 0.6
        },
        showNestedOverlay: {
            type: Boolean,
            default: false
        },
        blur: {
            type: Boolean,
            default: false
        },
        zIndex: {
            type: [
                Number,
                String
            ],
            default: void 0
        },
        backgroundColor: {
            type: String,
            default: "background-secondary"
        },
        noPadding: {
            type: Boolean,
            default: false
        },
        beforeClose: {
            type: Function
        },
        beforeOk: {
            type: Function
        },
        beforeCancel: {
            type: Function
        },
        ariaCloseLabel: {
            type: String,
            default: "$t:close"
        }
    },
    emits: [
        ...(0, _useStatefulJs.a),
        "cancel",
        "ok",
        "before-open",
        "open",
        "before-close",
        "close",
        "click-outside"
    ],
    setup (__props, { expose: __expose, emit: __emit }) {
        const props = __props;
        (0, _useChildComponentsJs.u)(props);
        const emit = __emit;
        const rootElement = (0, _vue.shallowRef)();
        const modalDialog = (0, _vue.shallowRef)();
        const { trapFocusIn, freeFocus } = (0, _useTrapFocusJs.u)();
        const { registerModal, unregisterModal, isTopLevelModal, isLowestLevelModal } = (0, _useModalLevelJs.u)();
        const { getColor } = (0, _useColorsJs.u)();
        const { textColorComputed } = (0, _useTextColorJs.u)((0, _vue.toRef)(props, "backgroundColor"));
        const { valueComputed } = (0, _useStatefulJs.b)(props, emit);
        const computedClass = (0, _vue.computed)(()=>({
                "va-modal--fullscreen": props.fullscreen,
                "va-modal--mobile-fullscreen": props.mobileFullscreen,
                "va-modal--fixed-layout": props.fixedLayout,
                "va-modal--no-padding": props.noPadding
            }));
        const { zIndex: zIndexInherited } = (0, _useZIndexJs.u)(valueComputed);
        const zIndexComputed = (0, _vue.computed)(()=>{
            if (props.zIndex) return Number(props.zIndex);
            return zIndexInherited.value;
        });
        const sizeComputed = (0, _useSizeJs.b)(props);
        const computedDialogStyle = (0, _vue.computed)(()=>({
                maxWidth: props.maxWidth || sizeComputed.value,
                maxHeight: props.maxHeight,
                color: textColorComputed.value,
                background: getColor(props.backgroundColor)
            }));
        const computedOverlayClass = (0, _vue.computed)(()=>({
                "va-modal__overlay--lowest": isLowestLevelModal.value,
                "va-modal__overlay--top": isTopLevelModal.value
            }));
        const getOverlayOpacity = ()=>{
            if (props.showNestedOverlay && !isLowestLevelModal.value) return "var(--va-modal-overlay-nested-opacity)";
            return "var(--va-modal-overlay-opacity)";
        };
        const computedOverlayStyles = (0, _vue.computed)(()=>{
            if (!props.overlay) return;
            if (isTopLevelModal.value || props.showNestedOverlay) return {
                "background-color": "var(--va-modal-overlay-color)",
                opacity: getOverlayOpacity()
            };
            return "";
        });
        const show = ()=>{
            valueComputed.value = true;
        };
        const hide = (cb)=>{
            const _hide = ()=>{
                valueComputed.value = false;
                cb == null || cb();
            };
            props.beforeClose ? props.beforeClose(_hide) : _hide();
        };
        const toggle = ()=>{
            valueComputed.value = !valueComputed.value;
        };
        const cancel = ()=>{
            const _hide = ()=>{
                hide(()=>emit("cancel"));
            };
            props.beforeCancel ? props.beforeCancel(_hide) : _hide();
        };
        const ok = ()=>{
            const _hide = ()=>{
                hide(()=>emit("ok"));
            };
            props.beforeOk ? props.beforeOk(_hide) : _hide();
        };
        const trapFocusInModal = ()=>{
            (0, _vue.nextTick)(()=>{
                if (modalDialog.value) trapFocusIn(modalDialog.value);
            });
        };
        const onBeforeEnterTransition = (el)=>emit("before-open", el);
        const onAfterEnterTransition = (el)=>emit("open", el);
        const onBeforeLeaveTransition = (el)=>emit("before-close", el);
        const onAfterLeaveTransition = (el)=>emit("close", el);
        const listenKeyUp = (e)=>{
            const hideModal = ()=>{
                if (e.code === "Escape" && !props.noEscDismiss && !props.noDismiss && isTopLevelModal.value) cancel();
            };
            setTimeout(hideModal);
        };
        (0, _useClickOutsideJs.u)([
            modalDialog
        ], ()=>{
            if (!valueComputed.value || props.noOutsideDismiss || props.noDismiss || !isTopLevelModal.value) return;
            emit("click-outside");
            cancel();
        });
        const window = (0, _useWindowJs.u)();
        (0, _vue.watchEffect)(()=>{
            var _a, _b;
            if (valueComputed.value) (_a = window.value) == null || _a.addEventListener("keyup", listenKeyUp);
            else (_b = window.value) == null || _b.removeEventListener("keyup", listenKeyUp);
        });
        (0, _useBlurJs.u)((0, _vue.toRef)(props, "blur"), valueComputed);
        const documentRef = (0, _useDocumentJs.u)();
        const setBodyOverflow = (overflow)=>{
            if (!documentRef.value || props.allowBodyScroll) return;
            if (overflow === "hidden") documentRef.value.body.classList.add("va-modal-open");
            else documentRef.value.body.classList.remove("va-modal-open");
        };
        const onShow = ()=>{
            registerModal();
            setBodyOverflow("hidden");
        };
        const onHide = ()=>{
            if (isLowestLevelModal.value) {
                freeFocus();
                setBodyOverflow("");
            }
            unregisterModal();
        };
        (0, _vue.watch)(valueComputed, (newValue)=>{
            if (newValue) onShow();
            else onHide();
        });
        (0, _vue.onMounted)(()=>{
            if (valueComputed.value) onShow();
            if (isTopLevelModal.value) trapFocusInModal();
        });
        (0, _vue.onBeforeUnmount)(()=>{
            onHide();
        });
        (0, _vue.watch)(isTopLevelModal, (newIsTopLevelModal)=>{
            if (newIsTopLevelModal) trapFocusInModal();
        }, {
            immediate: true
        });
        __expose({
            show,
            hide,
            toggle,
            cancel,
            ok,
            onBeforeEnterTransition,
            onAfterEnterTransition,
            onBeforeLeaveTransition,
            onAfterLeaveTransition,
            listenKeyUp
        });
        const { tp } = (0, _useTranslationJs.u)();
        const { teleportFromAttrs, teleportedAttrs } = (0, _useTeleportedJs.u)();
        const slotBind = {
            show,
            hide,
            toggle,
            cancel,
            ok
        };
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                ref_key: "rootElement",
                ref: rootElement,
                class: (0, _vue.normalizeClass)([
                    "va-modal-entry",
                    _ctx.$props.anchorClass
                ])
            }, [
                _ctx.$slots.anchor ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", (0, _vue.mergeProps)({
                    key: 0,
                    class: "va-modal__anchor"
                }, (0, _vue.unref)(teleportFromAttrs)), [
                    (0, _vue.renderSlot)(_ctx.$slots, "anchor", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(slotBind)))
                ], 16)) : (0, _vue.createCommentVNode)("", true),
                ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.Teleport), {
                    to: __props.attachElement,
                    disabled: _ctx.$props.disableAttachment
                }, [
                    (0, _vue.createVNode)((0, _vue.unref)(WithTransition), (0, _vue.mergeProps)({
                        name: "va-modal",
                        isTransition: !_ctx.$props.withoutTransitions,
                        duration: 300,
                        style: {
                            zIndex: zIndexComputed.value
                        },
                        appear: ""
                    }, {
                        ..._ctx.$attrs,
                        ...(0, _vue.unref)(teleportedAttrs)
                    }, {
                        onBeforeEnter: onBeforeEnterTransition,
                        onAfterEnter: onAfterEnterTransition,
                        onBeforeLeave: onBeforeLeaveTransition,
                        onAfterLeave: onAfterLeaveTransition
                    }), {
                        default: (0, _vue.withCtx)(()=>[
                                (0, _vue.unref)(valueComputed) ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                    key: 0,
                                    "aria-labelledby": __props.title,
                                    class: (0, _vue.normalizeClass)([
                                        computedClass.value,
                                        "va-modal"
                                    ]),
                                    role: "dialog",
                                    "aria-modal": "true"
                                }, [
                                    _ctx.$props.overlay ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                        key: 0,
                                        class: (0, _vue.normalizeClass)([
                                            "va-modal__overlay",
                                            computedOverlayClass.value
                                        ]),
                                        style: (0, _vue.normalizeStyle)(computedOverlayStyles.value)
                                    }, null, 6)) : (0, _vue.createCommentVNode)("", true),
                                    (0, _vue.createElementVNode)("div", {
                                        ref_key: "modalDialog",
                                        ref: modalDialog,
                                        class: "va-modal__dialog",
                                        style: (0, _vue.normalizeStyle)([
                                            computedDialogStyle.value
                                        ])
                                    }, [
                                        _ctx.$props.fullscreen || _ctx.$props.closeButton ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs1.V)), {
                                            key: 0,
                                            "va-child": "closeButton",
                                            class: (0, _vue.normalizeClass)([
                                                {
                                                    "va-modal__close--fullscreen": _ctx.$props.fullscreen
                                                },
                                                "va-modal__close"
                                            ]),
                                            "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaCloseLabel),
                                            role: "button",
                                            tabindex: "0",
                                            name: "va-close",
                                            onClick: cancel,
                                            onKeydown: [
                                                (0, _vue.withKeys)(cancel, [
                                                    "space"
                                                ]),
                                                (0, _vue.withKeys)(cancel, [
                                                    "enter"
                                                ])
                                            ]
                                        }, null, 8, [
                                            "class",
                                            "aria-label"
                                        ])) : (0, _vue.createCommentVNode)("", true),
                                        _ctx.$slots.content ? (0, _vue.renderSlot)(_ctx.$slots, "content", (0, _vue.normalizeProps)((0, _vue.mergeProps)({
                                            key: 1
                                        }, slotBind))) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_2, [
                                            (0, _vue.createElementVNode)("div", _hoisted_3, [
                                                (0, _vue.renderSlot)(_ctx.$slots, "header", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(slotBind)), ()=>[
                                                        __props.title ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                                            key: 0,
                                                            class: "va-modal__title",
                                                            style: (0, _vue.normalizeStyle)({
                                                                color: (0, _vue.unref)(getColor)("primary")
                                                            })
                                                        }, (0, _vue.toDisplayString)(_ctx.$props.title), 5)) : (0, _vue.createCommentVNode)("", true)
                                                    ])
                                            ]),
                                            _ctx.$props.message ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_4, (0, _vue.toDisplayString)(_ctx.$props.message), 1)) : (0, _vue.createCommentVNode)("", true),
                                            _ctx.$slots.default ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_5, [
                                                (0, _vue.renderSlot)(_ctx.$slots, "default", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(slotBind)))
                                            ])) : (0, _vue.createCommentVNode)("", true),
                                            (_ctx.$props.cancelText || _ctx.$props.okText) && !_ctx.$props.hideDefaultActions ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_6, [
                                                _ctx.$props.cancelText ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), {
                                                    key: 0,
                                                    "va-child": "cancelButton",
                                                    preset: "secondary",
                                                    color: "secondary",
                                                    class: "va-modal__default-cancel-button",
                                                    onClick: cancel
                                                }, {
                                                    default: (0, _vue.withCtx)(()=>[
                                                            (0, _vue.createTextVNode)((0, _vue.toDisplayString)((0, _vue.unref)(tp)(_ctx.$props.cancelText)), 1)
                                                        ]),
                                                    _: 1
                                                })) : (0, _vue.createCommentVNode)("", true),
                                                (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs.V)), {
                                                    "va-child": "okButton",
                                                    onClick: ok
                                                }, {
                                                    default: (0, _vue.withCtx)(()=>[
                                                            (0, _vue.createTextVNode)((0, _vue.toDisplayString)((0, _vue.unref)(tp)(_ctx.$props.okText)), 1)
                                                        ]),
                                                    _: 1
                                                })
                                            ])) : (0, _vue.createCommentVNode)("", true),
                                            _ctx.$slots.footer ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_7, [
                                                (0, _vue.renderSlot)(_ctx.$slots, "footer", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(slotBind)))
                                            ])) : (0, _vue.createCommentVNode)("", true)
                                        ]))
                                    ], 4)
                                ], 10, _hoisted_1)) : (0, _vue.createCommentVNode)("", true)
                            ]),
                        _: 3
                    }, 16, [
                        "isTransition",
                        "style"
                    ])
                ], 8, [
                    "to",
                    "disabled"
                ]))
            ], 2);
        };
    }
});

},{"vue":"gzxs9","../va-button/index.js":"2vhcC","../va-icon/index.js":"82tPo","./hooks/useBlur.js":"9nyWZ","../../composables/useZIndex.js":"kgPYx","../../composables/useChildComponents.js":"gy3gn","../../composables/useStateful.js":"h9zUi","../../composables/useTrapFocus.js":"gBu8E","../../composables/useModalLevel.js":"8k5zP","../../composables/useSize.js":"d4gWT","../../composables/useWindow.js":"bOeBT","../../composables/useTeleported.js":"66noR","../../composables/useComponentPreset.js":"2HoaT","../../composables/useColors.js":"a4Qgv","../../composables/useTextColor.js":"5pfXb","../../composables/useClickOutside.js":"4ZW8J","../../composables/useDocument.js":"403q6","../../composables/useTranslation.js":"7S3aV","../../../VaModal.css":"kfqni","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2vhcC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaButton);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaButtonVueVueTypeScriptSetupTrueLangJs = require("./VaButton.vue_vue_type_script_setup_true_lang.js");
const VaButton = (0, _withConfigTransportJs.w)((0, _vaButtonVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaButton.vue_vue_type_script_setup_true_lang.js":"8aoke","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8aoke":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../vendor.js");
var _useButtonBackgroundJs = require("./hooks/useButtonBackground.js");
var _useButtonAttributesJs = require("./hooks/useButtonAttributes.js");
var _useButtonTextColorJs = require("./hooks/useButtonTextColor.js");
var _indexJs = require("../va-icon/index.js");
var _indexJs1 = require("../va-progress-circle/index.js");
var _useHoverStyleJs = require("../../composables/useHoverStyle.js");
var _usePressedStyleJs = require("../../composables/usePressedStyle.js");
var _useLoadingJs = require("../../composables/useLoading.js");
var _useRouterLinkJs = require("../../composables/useRouterLink.js");
var _useFocusJs = require("../../composables/useFocus.js");
var _useHoverJs = require("../../composables/useHover.js");
var _usePressedJs = require("../../composables/usePressed.js");
var _useSlotPassedJs = require("../../composables/useSlotPassed.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useSizeJs = require("../../composables/useSize.js");
var _useColorsJs = require("../../composables/useColors.js");
var _useBemJs = require("../../composables/useBem.js");
var _useTextColorJs = require("../../composables/useTextColor.js");
var _vaButtonCss = require("../../../VaButton.css");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaButton",
    __name: "VaButton",
    props: {
        ...(0, _useComponentPresetJs.u),
        ...(0, _useSizeJs.u),
        ...(0, _useHoverStyleJs.u),
        ...(0, _usePressedStyleJs.u),
        ...(0, _useLoadingJs.u),
        ...(0, _useRouterLinkJs.u),
        tag: {
            type: String,
            default: "button"
        },
        type: {
            type: String,
            default: "button"
        },
        block: {
            type: Boolean,
            default: false
        },
        disabled: {
            type: Boolean,
            default: false
        },
        color: {
            type: String,
            default: "primary"
        },
        textColor: {
            type: String,
            default: ""
        },
        textOpacity: {
            type: Number,
            default: 1
        },
        backgroundOpacity: {
            type: Number,
            default: 1
        },
        borderColor: {
            type: String,
            default: ""
        },
        // only for filled bg state
        gradient: {
            type: Boolean,
            default: false
        },
        plain: {
            type: Boolean,
            default: false
        },
        round: {
            type: Boolean,
            default: false
        },
        size: {
            type: String,
            default: "medium",
            validator: (v)=>[
                    "small",
                    "medium",
                    "large"
                ].includes(v)
        },
        icon: {
            type: String,
            default: ""
        },
        iconRight: {
            type: String,
            default: ""
        },
        iconColor: {
            type: String,
            default: ""
        }
    },
    setup (__props, { expose: __expose }) {
        const props = __props;
        const { getColor } = (0, _useColorsJs.u)();
        const colorComputed = (0, _vue.computed)(()=>getColor(props.color));
        const { sizeComputed } = (0, _useSizeJs.a)(props);
        const iconSizeComputed = (0, _vue.computed)(()=>{
            const size = /([0-9]*)(px)/.exec(sizeComputed.value);
            return size ? `${+size[1] / 2}${size[2]}` : sizeComputed.value;
        });
        const { tagComputed } = (0, _useRouterLinkJs.a)(props);
        const attributesComputed = (0, _useButtonAttributesJs.u)(props);
        const { disabled } = (0, _vue.toRefs)(props);
        const button = (0, _vue.shallowRef)();
        const { focus, blur } = (0, _useFocusJs.u)(button);
        const { isHovered } = (0, _useHoverJs.u)(button, disabled);
        const { isPressed } = (0, _usePressedJs.u)(button);
        const iconColorComputed = (0, _vue.computed)(()=>props.iconColor ? getColor(props.iconColor) : textColorComputed.value);
        const iconAttributesComputed = (0, _vue.computed)(()=>({
                color: iconColorComputed.value,
                size: props.size
            }));
        const wrapperClassComputed = (0, _vue.computed)(()=>({
                "va-button__content--loading": props.loading
            }));
        const isSlotContentPassed = (0, _useSlotPassedJs.u)();
        const isOneIcon = (0, _vue.computed)(()=>!!(props.iconRight && !props.icon || !props.iconRight && props.icon));
        const isOnlyIcon = (0, _vue.computed)(()=>!isSlotContentPassed.value && isOneIcon.value);
        const computedClass = (0, _useBemJs.u)("va-button", ()=>({
                ...(0, _vendorJs.p)(props, [
                    "disabled",
                    "block",
                    "loading",
                    "round",
                    "plain"
                ]),
                small: props.size === "small",
                normal: !props.size || props.size === "medium",
                large: props.size === "large",
                opacity: props.textOpacity < 1,
                bordered: !!props.borderColor,
                iconOnly: isOnlyIcon.value,
                leftIcon: !isOnlyIcon.value && !!props.icon && !props.iconRight,
                rightIcon: !isOnlyIcon.value && !props.icon && !!props.iconRight
            }));
        const isTransparentBg = (0, _vue.computed)(()=>props.plain || props.backgroundOpacity < 0.5);
        const { textColorComputed } = (0, _useTextColorJs.u)(colorComputed, isTransparentBg);
        const { backgroundColor, backgroundColorOpacity, backgroundMaskOpacity, backgroundMaskColor } = (0, _useButtonBackgroundJs.u)(colorComputed, isPressed, isHovered);
        const contentColorComputed = (0, _useButtonTextColorJs.u)(textColorComputed, colorComputed, isPressed, isHovered);
        const computedStyle = (0, _vue.computed)(()=>({
                borderColor: props.borderColor ? getColor(props.borderColor) : "transparent",
                ...contentColorComputed.value
            }));
        __expose({
            focus,
            blur
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.resolveDynamicComponent)((0, _vue.unref)(tagComputed)), (0, _vue.mergeProps)({
                ref_key: "button",
                ref: button,
                class: [
                    "va-button",
                    (0, _vue.unref)(computedClass)
                ],
                style: [
                    computedStyle.value,
                    `--va-background-color: ${String((0, _vue.unref)(backgroundColor))};--va-background-color-opacity: ${String((0, _vue.unref)(backgroundColorOpacity))};--va-background-mask-color: ${String((0, _vue.unref)(backgroundMaskColor))};--va-background-mask-opacity: ${String((0, _vue.unref)(backgroundMaskOpacity))}`
                ]
            }, (0, _vue.unref)(attributesComputed)), {
                default: (0, _vue.withCtx)(()=>[
                        (0, _vue.createElementVNode)("span", {
                            class: (0, _vue.normalizeClass)([
                                "va-button__content",
                                wrapperClassComputed.value
                            ])
                        }, [
                            (0, _vue.renderSlot)(_ctx.$slots, "prepend", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                icon: __props.icon,
                                iconAttributes: iconAttributesComputed.value
                            })), ()=>[
                                    __props.icon ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), (0, _vue.mergeProps)({
                                        key: 0,
                                        class: "va-button__left-icon",
                                        name: __props.icon
                                    }, iconAttributesComputed.value), null, 16, [
                                        "name"
                                    ])) : (0, _vue.createCommentVNode)("", true)
                                ]),
                            (0, _vue.renderSlot)(_ctx.$slots, "default"),
                            (0, _vue.renderSlot)(_ctx.$slots, "append", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                icon: __props.iconRight,
                                iconAttributes: iconAttributesComputed.value
                            })), ()=>[
                                    __props.iconRight ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), (0, _vue.mergeProps)({
                                        key: 0,
                                        class: "va-button__right-icon",
                                        name: __props.iconRight
                                    }, iconAttributesComputed.value), null, 16, [
                                        "name"
                                    ])) : (0, _vue.createCommentVNode)("", true)
                                ])
                        ], 2),
                        _ctx.loading ? (0, _vue.renderSlot)(_ctx.$slots, "loading", (0, _vue.normalizeProps)((0, _vue.mergeProps)({
                            key: 0
                        }, {
                            size: iconSizeComputed.value,
                            color: (0, _vue.unref)(textColorComputed)
                        })), ()=>[
                                (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs1.V)), {
                                    class: "va-button__loader",
                                    size: iconSizeComputed.value,
                                    color: (0, _vue.unref)(textColorComputed),
                                    thickness: 0.15,
                                    indeterminate: ""
                                }, null, 8, [
                                    "size",
                                    "color"
                                ])
                            ]) : (0, _vue.createCommentVNode)("", true)
                    ]),
                _: 3
            }, 16, [
                "class",
                "style"
            ]);
        };
    }
});

},{"vue":"gzxs9","../../../vendor.js":"l6TAc","./hooks/useButtonBackground.js":"fROu9","./hooks/useButtonAttributes.js":"abMCA","./hooks/useButtonTextColor.js":"47l3D","../va-icon/index.js":"82tPo","../va-progress-circle/index.js":"dZCnz","../../composables/useHoverStyle.js":"f01QI","../../composables/usePressedStyle.js":"jeZaZ","../../composables/useLoading.js":"jYmWj","../../composables/useRouterLink.js":"bep51","../../composables/useFocus.js":"8TBqW","../../composables/useHover.js":"6F99t","../../composables/usePressed.js":"1aeh4","../../composables/useSlotPassed.js":"7ndFG","../../composables/useComponentPreset.js":"2HoaT","../../composables/useSize.js":"d4gWT","../../composables/useColors.js":"a4Qgv","../../composables/useBem.js":"igmjV","../../composables/useTextColor.js":"5pfXb","../../../VaButton.css":"29bIk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fROu9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useButtonBackground);
var _vue = require("vue");
var _useColorsJs = require("../../../composables/useColors.js");
const useButtonBackground = (colorComputed, isPressed, isHovered)=>{
    const instance = (0, _vue.getCurrentInstance)();
    if (!instance) throw new Error("`useButtonBackground` hook must be used only inside of setup function!");
    const props = instance.props;
    const { getColor, getGradientBackground } = (0, _useColorsJs.u)();
    const backgroundColor = (0, _vue.computed)(()=>{
        if (props.plain) return "transparent";
        return props.gradient ? getGradientBackground(colorComputed.value) : colorComputed.value;
    });
    const hoveredBgState = (0, _vue.computed)(()=>!props.plain && isHovered.value);
    const pressedBgState = (0, _vue.computed)(()=>!props.plain && isPressed.value);
    const backgroundColorOpacity = (0, _vue.computed)(()=>{
        if (pressedBgState.value && props.pressedBehavior === "opacity") return props.pressedOpacity;
        if (hoveredBgState.value && props.hoverBehavior === "opacity") return Number(props.hoverOpacity);
        return Number(props.backgroundOpacity);
    });
    const hoveredMaskState = (0, _vue.computed)(()=>hoveredBgState.value && props.hoverBehavior === "mask");
    const pressedMaskState = (0, _vue.computed)(()=>pressedBgState.value && props.pressedBehavior === "mask");
    const backgroundMaskOpacity = (0, _vue.computed)(()=>{
        if (pressedMaskState.value) return props.pressedOpacity;
        if (hoveredMaskState.value) return Number(props.hoverOpacity);
        return 0;
    });
    const backgroundMaskColor = (0, _vue.computed)(()=>{
        if (pressedMaskState.value) return getColor(props.pressedMaskColor);
        if (hoveredMaskState.value) return getColor(props.hoverMaskColor);
        return "transparent";
    });
    return {
        backgroundColor,
        backgroundColorOpacity,
        backgroundMaskOpacity,
        backgroundMaskColor
    };
};

},{"vue":"gzxs9","../../../composables/useColors.js":"a4Qgv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"abMCA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useButtonAttributes);
var _vue = require("vue");
var _useRouterLinkJs = require("../../../composables/useRouterLink.js");
const useButtonAttributes = (props)=>{
    const { linkAttributesComputed, isLinkTag } = (0, _useRouterLinkJs.a)(props);
    const typeComputed = (0, _vue.computed)(()=>isLinkTag.value ? void 0 : props.type);
    const buttonAttributesComputed = (0, _vue.computed)(()=>{
        const disabledAttributes = {
            "aria-disabled": !!props.disabled,
            disabled: !!props.disabled
        };
        if (isLinkTag.value) return disabledAttributes;
        return {
            type: typeComputed.value,
            tabindex: props.loading || props.disabled ? -1 : 0,
            ...disabledAttributes
        };
    });
    return (0, _vue.computed)(()=>({
            ...linkAttributesComputed.value,
            ...buttonAttributesComputed.value
        }));
};

},{"vue":"gzxs9","../../../composables/useRouterLink.js":"bep51","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bep51":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useRouterLink);
parcelHelpers.export(exports, "u", ()=>useRouterLinkProps);
var _vue = require("vue");
var _useGlobalConfigJs = require("./useGlobalConfig.js");
const useRouterLinkProps = {
    tag: {
        type: String,
        default: "span"
    },
    to: {
        type: [
            String,
            Object
        ],
        default: void 0
    },
    replace: {
        type: Boolean,
        default: void 0
    },
    append: {
        type: Boolean,
        default: void 0
    },
    exact: {
        type: Boolean,
        default: void 0
    },
    activeClass: {
        type: String,
        default: void 0
    },
    exactActiveClass: {
        type: String,
        default: void 0
    },
    href: {
        type: String,
        default: void 0
    },
    target: {
        type: String,
        default: void 0
    },
    disabled: {
        type: Boolean,
        default: false
    }
};
const useRouterLink = (props)=>{
    const currentInstance = (0, _vue.getCurrentInstance)();
    const globalProperties = (0, _vue.computed)(()=>currentInstance == null ? void 0 : currentInstance.appContext.config.globalProperties);
    const vueRouter = (0, _vue.computed)(()=>{
        var _a;
        return (_a = globalProperties.value) == null ? void 0 : _a.$router;
    });
    const vueRoute = (0, _vue.computed)(()=>{
        var _a;
        return (_a = globalProperties.value) == null ? void 0 : _a.$route;
    });
    const { getGlobalConfig } = (0, _useGlobalConfigJs.u)();
    const tagComputed = (0, _vue.computed)(()=>{
        if (props.disabled) return props.tag;
        if (props.href && !props.to) return "a";
        const globalConfig = getGlobalConfig();
        if (globalConfig.routerComponent && props.to) return globalConfig.routerComponent;
        if (props.to) return "router-link";
        return props.tag || "div";
    });
    const isLinkTag = (0, _vue.computed)(()=>{
        if (props.disabled) return false;
        return Boolean(props.href || props.to);
    });
    const linkAttributesComputed = (0, _vue.computed)(()=>{
        if (!isLinkTag.value) return {};
        return tagComputed.value === "a" ? {
            target: props.target,
            href: hrefComputed.value
        } : {
            target: props.target,
            to: props.to,
            replace: props.replace,
            append: props.append,
            activeClass: props.activeClass,
            exact: props.exact,
            exactActiveClass: props.exactActiveClass
        };
    });
    const isActiveRouterLink = (0, _vue.computed)(()=>{
        if (!vueRouter.value || !props.to) return false;
        const to = vueRouter.value.resolve(props.to).href;
        const currentHref = vueRouter.value.currentRoute.value.path;
        return to.replace("#", "") === currentHref.replace("#", "");
    });
    const hrefComputed = (0, _vue.computed)(()=>{
        var _a;
        return props.href || (props.to ? (_a = vueRouter.value) == null ? void 0 : _a.resolve(props.to, vueRoute.value).href : void 0);
    });
    return {
        isLinkTag,
        tagComputed,
        hrefComputed,
        isActiveRouterLink,
        linkAttributesComputed
    };
};

},{"vue":"gzxs9","./useGlobalConfig.js":"8pVeR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"47l3D":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useButtonTextColor);
var _vue = require("vue");
var _ssrJs = require("../../../utils/ssr.js");
var _useColorsJs = require("../../../composables/useColors.js");
const getOpacity = (opacity)=>{
    var _a, _b, _c;
    if ((0, _ssrJs.i)()) return opacity;
    if (opacity > 0) {
        const userAgent = (_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent;
        const isSafari = userAgent && /^((?!chrome|android).)*safari/i.test((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.userAgent);
        const isLatestSafari = userAgent && /(version.)15|16/i.test((_c = window == null ? void 0 : window.navigator) == null ? void 0 : _c.userAgent);
        if (isSafari && !isLatestSafari) return opacity < 1 ? 1 - opacity : opacity;
    }
    return opacity;
};
const useButtonTextColor = (textColorComputed, colorComputed, isPressed, isHovered)=>{
    const instance = (0, _vue.getCurrentInstance)();
    if (!instance) throw new Error("`useButtonTextColor` hook must be used only inside of setup function!");
    const props = instance.props;
    const { getColor, colorToRgba, getStateMaskGradientBackground } = (0, _useColorsJs.u)();
    const plainColorStyles = (0, _vue.computed)(()=>({
            background: "transparent",
            color: textColorComputed.value,
            "-webkit-background-clip": "text",
            "background-clip": "text",
            opacity: getPlainTextOpacity.value
        }));
    const getStateColor = (maskColor, stateOpacity, stateBehavior)=>{
        const maskStateColor = getColor(maskColor);
        let stateStyles;
        if (stateBehavior === "opacity") stateStyles = {
            color: colorToRgba(textColorComputed.value, stateOpacity)
        };
        else stateStyles = {
            background: getStateMaskGradientBackground(colorComputed.value, maskStateColor, stateOpacity),
            color: stateOpacity < 1 ? colorToRgba(textColorComputed.value, getOpacity(stateOpacity)) : maskStateColor
        };
        return {
            ...plainColorStyles.value,
            ...stateStyles
        };
    };
    const hoverTextColorComputed = (0, _vue.computed)(()=>{
        return getStateColor(props.hoverMaskColor, Number(props.hoverOpacity), props.hoverBehavior);
    });
    const pressedTextColorComputed = (0, _vue.computed)(()=>{
        return getStateColor(props.pressedMaskColor, props.pressedOpacity, props.pressedBehavior);
    });
    const getPlainTextOpacity = (0, _vue.computed)(()=>{
        if (props.disabled) return void 0;
        if (props.textOpacity === 1 || isHovered.value && !isPressed.value) return 1;
        return isPressed.value ? 0.9 : props.textOpacity;
    });
    return (0, _vue.computed)(()=>{
        const defaultColorStyles = {
            color: textColorComputed.value,
            background: "transparent"
        };
        props.plain && Object.assign(defaultColorStyles, plainColorStyles.value, {
            background: textColorComputed.value
        });
        if (!props.plain) return defaultColorStyles;
        if (isPressed.value) return pressedTextColorComputed.value;
        if (isHovered.value) return hoverTextColorComputed.value;
        return defaultColorStyles;
    });
};

},{"vue":"gzxs9","../../../utils/ssr.js":"cVJXV","../../../composables/useColors.js":"a4Qgv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dZCnz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaProgressCircle);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaProgressCircleVueVueTypeScriptSetupTrueLangJs = require("./VaProgressCircle.vue_vue_type_script_setup_true_lang.js");
const VaProgressCircle = (0, _withConfigTransportJs.w)((0, _vaProgressCircleVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaProgressCircle.vue_vue_type_script_setup_true_lang.js":"kmzTe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kmzTe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../vendor.js");
var _useSizeJs = require("../../composables/useSize.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useColorsJs = require("../../composables/useColors.js");
var _useTranslationJs = require("../../composables/useTranslation.js");
var _vaProgressCircleCss = require("../../../VaProgressCircle.css");
const _hoisted_1 = {
    class: "va-progress-circle__wrapper",
    viewBox: "0 0 40 40"
};
const _hoisted_2 = [
    "r",
    "stroke",
    "stroke-width",
    "stroke-dasharray",
    "stroke-dashoffset"
];
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaProgressCircle",
    __name: "VaProgressCircle",
    props: {
        ...(0, _useSizeJs.u),
        ...(0, _useComponentPresetJs.u),
        modelValue: {
            type: [
                Number,
                String
            ],
            default: 0
        },
        indeterminate: {
            type: Boolean,
            default: false
        },
        thickness: {
            type: [
                Number,
                String
            ],
            default: 0.06
        },
        color: {
            type: String,
            default: "primary"
        },
        ariaLabel: {
            type: String,
            default: "$t:progressState"
        }
    },
    setup (__props) {
        const props = __props;
        const { getColor } = (0, _useColorsJs.u)();
        const { sizeComputed } = (0, _useSizeJs.a)(props);
        const cappedThickness = (0, _vue.computed)(()=>(0, _vendorJs.b)(Number(props.thickness), 0, 1) / 2 * 100);
        const radius = (0, _vue.computed)(()=>20 - 20 * cappedThickness.value / 100);
        const dasharray = (0, _vue.computed)(()=>2 * Math.PI * radius.value);
        const dashoffset = (0, _vue.computed)(()=>dasharray.value * (1 - (0, _vendorJs.b)(Number(props.modelValue), 0, 100) / 100));
        const colorComputed = (0, _vue.computed)(()=>getColor(props.color, void 0, true));
        const { tp } = (0, _useTranslationJs.u)();
        const infoStyle = (0, _vue.computed)(()=>({
                color: colorComputed.value
            }));
        const rootStyle = (0, _vue.computed)(()=>({
                width: sizeComputed.value,
                height: sizeComputed.value
            }));
        const rootClass = (0, _vue.computed)(()=>({
                "va-progress-circle--indeterminate": props.indeterminate
            }));
        const ariaAttributesComputed = (0, _vue.computed)(()=>({
                role: "progressbar",
                "aria-label": tp(props.ariaLabel),
                "aria-valuenow": !props.indeterminate ? props.modelValue : void 0
            }));
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", (0, _vue.mergeProps)({
                class: [
                    "va-progress-circle",
                    rootClass.value
                ],
                style: rootStyle.value
            }, ariaAttributesComputed.value), [
                ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("svg", _hoisted_1, [
                    (0, _vue.createElementVNode)("circle", {
                        class: "va-progress-circle__overlay",
                        cx: "50%",
                        cy: "50%",
                        r: radius.value,
                        fill: "none",
                        stroke: colorComputed.value,
                        "stroke-width": cappedThickness.value + "%",
                        "stroke-dasharray": dasharray.value,
                        "stroke-dashoffset": dashoffset.value
                    }, null, 8, _hoisted_2)
                ])),
                _ctx.$slots.default ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                    key: 0,
                    style: (0, _vue.normalizeStyle)(infoStyle.value),
                    class: "va-progress-circle__info"
                }, [
                    (0, _vue.renderSlot)(_ctx.$slots, "default")
                ], 4)) : (0, _vue.createCommentVNode)("", true)
            ], 16);
        };
    }
});

},{"vue":"gzxs9","../../../vendor.js":"l6TAc","../../composables/useSize.js":"d4gWT","../../composables/useComponentPreset.js":"2HoaT","../../composables/useColors.js":"a4Qgv","../../composables/useTranslation.js":"7S3aV","../../../VaProgressCircle.css":"6QWhH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6QWhH":[function() {},{}],"f01QI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useHoverStyleProps);
const useHoverStyleProps = {
    hoverBehavior: {
        type: String,
        default: "mask",
        validator: (value)=>[
                "opacity",
                "mask"
            ].includes(value)
    },
    hoverOpacity: {
        type: [
            Number,
            String
        ],
        default: 0.15
    },
    hoverMaskColor: {
        type: String,
        default: "textInverted"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jeZaZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>usePressedStyleProps);
const usePressedStyleProps = {
    pressedBehavior: {
        type: String,
        default: "mask",
        validator: (value)=>[
                "opacity",
                "mask"
            ].includes(value)
    },
    pressedOpacity: {
        type: Number,
        default: 0.13
    },
    pressedMaskColor: {
        type: String,
        default: "textPrimary"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jYmWj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useLoadingProps);
const useLoadingProps = {
    loading: {
        type: Boolean,
        default: false
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8TBqW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useFocusEmits);
parcelHelpers.export(exports, "u", ()=>useFocus);
var _unwrapElJs = require("../utils/unwrapEl.js");
var _focusJs = require("../utils/focus.js");
var _vue = require("vue");
var _useEventJs = require("./useEvent.js");
var _useActiveElementJs = require("./useActiveElement.js");
var _vendorJs = require("../../vendor.js");
const useFocusEmits = [
    "focus",
    "blur"
];
function useFocus(el, emit) {
    const activeElement = (0, _useActiveElementJs.u)();
    const isFocused = (0, _vue.computed)({
        get: ()=>{
            if ((0, _vendorJs.i)(activeElement.value)) return false;
            if ((0, _vendorJs.i)(el == null ? void 0 : el.value)) return false;
            return activeElement.value === (el == null ? void 0 : el.value);
        },
        set: (value)=>{
            if (value) focus();
            else blur();
        }
    });
    const onFocus = (e)=>{
        emit == null || emit("focus", e);
    };
    const onBlur = (e)=>{
        emit == null || emit("blur", e);
    };
    const focus = ()=>{
        if (!(el == null ? void 0 : el.value)) return;
        (0, _focusJs.a)((0, _unwrapElJs.u)(el == null ? void 0 : el.value));
    };
    const blur = ()=>{
        if (!(el == null ? void 0 : el.value)) return;
        (0, _focusJs.b)((0, _unwrapElJs.u)(el == null ? void 0 : el.value));
    };
    (0, _useEventJs.u)("focus", onFocus, el);
    (0, _useEventJs.u)("blur", onBlur, el);
    return {
        isFocused,
        onFocus,
        onBlur,
        focus,
        blur
    };
}

},{"../utils/unwrapEl.js":"bYHKv","../utils/focus.js":"e1Xlj","vue":"gzxs9","./useEvent.js":"9kzUn","./useActiveElement.js":"3ucTg","../../vendor.js":"l6TAc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e1Xlj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>focusElement);
parcelHelpers.export(exports, "b", ()=>blurElement);
parcelHelpers.export(exports, "f", ()=>focusFirstFocusableChild);
const isHTMLElement = (el)=>{
    return el instanceof HTMLElement;
};
const focusElement = (el)=>{
    if (!el || !isHTMLElement(el)) return;
    el.focus();
    el.dispatchEvent(new FocusEvent("focus", {
        bubbles: true
    }));
};
const blurElement = (el)=>{
    if (!el || !isHTMLElement(el)) return;
    el.blur();
    el.dispatchEvent(new Event("blur", {
        bubbles: true
    }));
};
const focusFirstFocusableChild = (el)=>{
    if (el.tabIndex !== -1) {
        focusElement(el);
        return;
    }
    const focusable = el.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
    if (focusable) focusElement(focusable);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3ucTg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useActiveElement);
var _vue = require("vue");
var _useCaptureEventJs = require("./useCaptureEvent.js");
const useActiveElement = ()=>{
    const activeEl = (0, _vue.shallowRef)();
    const updateActiveElement = ()=>{
        activeEl.value = document.activeElement;
    };
    (0, _vue.onMounted)(updateActiveElement);
    (0, _useCaptureEventJs.u)("focus", updateActiveElement);
    (0, _useCaptureEventJs.u)("blur", updateActiveElement);
    return activeEl;
};

},{"vue":"gzxs9","./useCaptureEvent.js":"lkMm9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lkMm9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useCaptureEvent);
var _vue = require("vue");
const useCaptureEvent = (event, cb, options = {})=>{
    (0, _vue.onMounted)(()=>window.addEventListener(event, cb, {
            capture: true,
            ...options
        }));
    (0, _vue.onBeforeUnmount)(()=>window.removeEventListener(event, cb, {
            capture: true,
            ...options
        }));
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6F99t":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useHover);
var _vue = require("vue");
var _useHTMLElementJs = require("./useHTMLElement.js");
var _useEventJs = require("./useEvent.js");
function useHover(el, disabled) {
    const isHovered = (0, _vue.ref)(false);
    const onMouseEnter = ()=>{
        isHovered.value = true;
    };
    const onMouseLeave = ()=>{
        isHovered.value = false;
    };
    disabled && (0, _vue.watch)(disabled, (v)=>{
        if (v) isHovered.value = false;
    });
    const target = (0, _useHTMLElementJs.u)(el);
    (0, _useEventJs.u)("mouseenter", onMouseEnter, target);
    (0, _useEventJs.u)("mouseleave", onMouseLeave, target);
    return {
        isHovered,
        onMouseEnter,
        onMouseLeave
    };
}

},{"vue":"gzxs9","./useHTMLElement.js":"1Yk4Z","./useEvent.js":"9kzUn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Yk4Z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useHTMLElement);
var _vue = require("vue");
var _unwrapElJs = require("../utils/unwrapEl.js");
var _useTemplateRefJs = require("./useTemplateRef.js");
const useHTMLElement = (key)=>{
    if ((0, _vue.isRef)(key)) return (0, _vue.computed)({
        get () {
            return (0, _unwrapElJs.u)(key.value);
        },
        set (value) {
            key.value = value;
        }
    });
    if (key) {
        const el2 = (0, _useTemplateRefJs.u)(key);
        return (0, _vue.computed)({
            get () {
                return (0, _unwrapElJs.u)(el2.value);
            },
            set (value) {
                el2.value = value;
            }
        });
    }
    const el = (0, _vue.shallowRef)();
    return (0, _vue.computed)({
        set (value) {
            el.value = (0, _unwrapElJs.u)(value);
        },
        get () {
            return el.value;
        }
    });
};

},{"vue":"gzxs9","../utils/unwrapEl.js":"bYHKv","./useTemplateRef.js":"7NOsO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7NOsO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useTemplateRef);
var _vue = require("vue");
const useTemplateRef = (key)=>{
    const vm = (0, _vue.getCurrentInstance)();
    const el = (0, _vue.shallowRef)();
    const updateEl = ()=>{
        var _a;
        el.value = (_a = vm.proxy) == null ? void 0 : _a.$refs[key];
    };
    (0, _vue.onMounted)(updateEl);
    (0, _vue.onUpdated)(updateEl);
    (0, _vue.onBeforeUnmount)(updateEl);
    return el;
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1aeh4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>usePressed);
var _vue = require("vue");
var _useHTMLElementJs = require("./useHTMLElement.js");
var _useEventJs = require("./useEvent.js");
function usePressed(el) {
    const isPressed = (0, _vue.ref)(false);
    const onMouseDown = ()=>{
        isPressed.value = true;
    };
    const onMouseUp = ()=>{
        isPressed.value = false;
    };
    const target = (0, _useHTMLElementJs.u)(el);
    (0, _useEventJs.u)([
        "mousedown",
        "touchstart",
        "dragstart"
    ], onMouseDown, target);
    (0, _useEventJs.u)([
        "mouseup",
        "mouseleave",
        "touchend",
        "touchcancel",
        "drop",
        "dragend"
    ], onMouseUp, true);
    return {
        isPressed,
        onMouseDown,
        onMouseUp
    };
}

},{"vue":"gzxs9","./useHTMLElement.js":"1Yk4Z","./useEvent.js":"9kzUn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7ndFG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useSlotPassed);
var _vendorJs = require("../../vendor.js");
var _vue = require("vue");
const checkSlotChildrenDeep = (v, initial = true)=>{
    var _a;
    if ((0, _vue.isVNode)(v)) return true;
    if (!v || initial && (!(0, _vendorJs.g)(v) || !((_a = v()) == null ? void 0 : _a.length))) return false;
    const slotData = initial ? v() : v;
    if (Array.isArray(slotData)) return slotData.some((el)=>{
        return Array.isArray(el.children) ? checkSlotChildrenDeep(el.children, false) : el.children || el.props;
    });
    return !!slotData.children;
};
const useSlotPassed = (name = "default")=>{
    const { slots } = (0, _vue.getCurrentInstance)();
    return (0, _vue.computed)(()=>checkSlotChildrenDeep(slots[name]));
};

},{"../../vendor.js":"l6TAc","vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"igmjV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useBem);
var _vue = require("vue");
var _vendorJs = require("../../vendor.js");
var _envJs = require("../utils/env.js");
const useBem = (prefix, modifiers)=>{
    if ((0, _envJs.i) && !prefix) console.warn('You must pass the @param "prefix" to the useBem hook!');
    const modifiersList = (0, _vue.computed)(()=>(0, _vendorJs.g)(modifiers) ? modifiers() : (0, _vue.unref)(modifiers));
    const computedBemClassesObject = (0, _vue.computed)(()=>{
        return Object.entries((0, _vue.unref)(modifiersList)).reduce((classesObj, [modifierName, value])=>{
            if (value) classesObj[`${prefix}--${(0, _vendorJs.k)(modifierName)}`] = true;
            return classesObj;
        }, {});
    });
    const computedBemClassesArray = (0, _vue.computed)(()=>Object.keys(computedBemClassesObject.value));
    const computedBemClassesString = (0, _vue.computed)(()=>computedBemClassesArray.value.join(" "));
    return new Proxy({}, {
        ownKeys () {
            return Reflect.ownKeys(computedBemClassesObject.value);
        },
        getOwnPropertyDescriptor (_, key) {
            return Reflect.getOwnPropertyDescriptor(computedBemClassesObject.value, key);
        },
        get (_, key, receiver) {
            switch(key){
                case "asArray":
                    return computedBemClassesArray;
                case "asString":
                    return computedBemClassesString;
                case "asObject":
                    return computedBemClassesObject;
                default:
                    return Reflect.get(computedBemClassesObject.value, key, receiver);
            }
        }
    });
};

},{"vue":"gzxs9","../../vendor.js":"l6TAc","../utils/env.js":"Fmkmq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"29bIk":[function() {},{}],"9nyWZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useBlur);
var _vue = require("vue");
var _useCurrentComponentIdJs = require("../../../composables/useCurrentComponentId.js");
var _useDocumentJs = require("../../../composables/useDocument.js");
const openedModals = [];
const useBlur = (shouldBlur, isModalShown)=>{
    const id = (0, _useCurrentComponentIdJs.u)();
    const document = (0, _useDocumentJs.u)();
    const blur = ()=>{
        var _a;
        if (openedModals.includes(id)) return;
        openedModals.push(id);
        (_a = document.value) == null || _a.body.classList.add("va-modal-overlay-background--blurred");
    };
    const removeBlur = ()=>{
        var _a;
        const modalIndex = openedModals.indexOf(id);
        if (modalIndex === -1) return;
        openedModals.splice(modalIndex, 1);
        if (openedModals.length === 0) (_a = document.value) == null || _a.body.classList.remove("va-modal-overlay-background--blurred");
    };
    (0, _vue.watchEffect)(()=>{
        if (!shouldBlur.value) return;
        if (isModalShown.value) blur();
        else removeBlur();
    });
    (0, _vue.onBeforeUnmount)(removeBlur);
};

},{"vue":"gzxs9","../../../composables/useCurrentComponentId.js":"h1t7S","../../../composables/useDocument.js":"403q6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h1t7S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useCurrentComponentId);
var _vue = require("vue");
const useCurrentComponentId = ()=>{
    const instance = (0, _vue.getCurrentInstance)();
    if (!instance.appContext.app) return String(instance.uid);
    return `${instance.appContext.app._uid}_${instance.uid}`;
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kgPYx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useZIndex);
var _vue = require("vue");
var _uuidJs = require("../utils/uuid.js");
const createInstance = ()=>{
    return (0, _uuidJs.g)();
};
const zIndexStack = (0, _vue.shallowReactive)([]);
const useZIndex = (isVisible)=>{
    const instance = createInstance();
    const register = ()=>{
        if (zIndexStack.includes(instance)) return;
        zIndexStack.push(instance);
    };
    const unregister = ()=>{
        const index = zIndexStack.findIndex((item)=>item === instance);
        if (index !== -1) zIndexStack.splice(index, 1);
    };
    const zIndex = (0, _vue.computed)(()=>{
        const index = zIndexStack.findIndex((item)=>item === instance);
        if (index === -1) return -1;
        return index + 1;
    });
    const isTop = (0, _vue.computed)(()=>zIndex.value === zIndexStack.length - 1);
    const isLowest = (0, _vue.computed)(()=>zIndex.value === 0);
    (0, _vue.onMounted)(()=>{
        if (isVisible.value) register();
    });
    (0, _vue.onBeforeUnmount)(()=>{
        unregister();
    });
    (0, _vue.watch)(isVisible, (value)=>{
        if (value) register();
        else unregister();
    });
    return {
        zIndex,
        isTop,
        isLowest,
        register,
        unregister
    };
};

},{"vue":"gzxs9","../utils/uuid.js":"9koOy","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h9zUi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useStatefulEmits);
parcelHelpers.export(exports, "b", ()=>useStateful);
parcelHelpers.export(exports, "c", ()=>createStatefulProps);
parcelHelpers.export(exports, "u", ()=>useStatefulProps);
var _vue = require("vue");
var _useUserProvidedPropJs = require("./useUserProvidedProp.js");
const useStatefulProps = {
    stateful: {
        type: Boolean,
        default: false
    },
    modelValue: {
        type: void 0
    }
};
const createStatefulProps = (statefulDefault = false)=>{
    return {
        stateful: {
            type: Boolean,
            default: statefulDefault
        }
    };
};
const useStatefulEmits = [
    "update:modelValue"
];
const useStateful = (props, emit, key = "modelValue", options = {})=>{
    const { eventName, defaultValue } = options;
    const event = eventName || `update:${key.toString()}`;
    const passedProp = (0, _useUserProvidedPropJs.u)(key, props);
    const defaultValuePassed = "defaultValue" in options;
    const valueState = (0, _vue.ref)(passedProp.value === (0, _useUserProvidedPropJs.N) ? defaultValuePassed ? defaultValue : props[key] : passedProp.value);
    let unwatchModelValue;
    const watchModelValue = ()=>{
        unwatchModelValue = (0, _vue.watch)(()=>props[key], (modelValue)=>{
            valueState.value = modelValue;
        });
    };
    (0, _vue.watch)(()=>props.stateful, (stateful)=>{
        stateful ? watchModelValue() : unwatchModelValue == null || unwatchModelValue();
    }, {
        immediate: true
    });
    const valueComputed = (0, _vue.computed)({
        get: ()=>{
            if (props.stateful) return valueState.value;
            return props[key];
        },
        set: (value)=>{
            if (props.stateful) valueState.value = value;
            emit(event, value);
        }
    });
    Object.defineProperty(valueComputed, "stateful", {
        get: ()=>props.stateful
    });
    Object.defineProperty(valueComputed, "userProvided", {
        get: ()=>passedProp.value !== (0, _useUserProvidedPropJs.N)
    });
    return {
        valueComputed
    };
};

},{"vue":"gzxs9","./useUserProvidedProp.js":"9bERq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9bERq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "N", ()=>NOT_PROVIDED);
parcelHelpers.export(exports, "u", ()=>useUserProvidedProp);
var _vue = require("vue");
const NOT_PROVIDED = Symbol("NOT_PROVIDED");
const useUserProvidedProp = (propName, props)=>{
    const vm = (0, _vue.getCurrentInstance)();
    return (0, _vue.computed)(()=>{
        if (!(vm == null ? void 0 : vm.vnode.props)) return NOT_PROVIDED;
        const originalProp = props[propName];
        return propName in vm.vnode.props ? originalProp : NOT_PROVIDED;
    });
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gBu8E":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useTrapFocus);
var _useAppGlobalJs = require("./useAppGlobal.js");
var _useDocumentJs = require("./useDocument.js");
var _useWindowJs = require("./useWindow.js");
const FOCUSABLE_ELEMENTS_SELECTOR = ":where(a, button, input, textarea, select):not([disabled]), *[tabindex]";
const useTrapFocus = ()=>{
    const document = (0, _useDocumentJs.u)();
    const window = (0, _useWindowJs.u)();
    const trapInEl = (0, _useAppGlobalJs.u)("trapInEl", null);
    let focusableElements = [];
    let firstFocusableElement = null;
    let lastFocusableElement = null;
    const isFocusIn = (evt)=>{
        var _a;
        return ((_a = trapInEl.value) == null ? void 0 : _a.contains(evt.target)) || false;
    };
    const focusFirstElement = ()=>{
        firstFocusableElement == null || firstFocusableElement.focus();
    };
    const focusLastElement = ()=>{
        lastFocusableElement == null || lastFocusableElement.focus();
    };
    const onKeydown = (evt)=>{
        var _a, _b;
        const isTabPressed = evt.code === "Tab";
        const isShiftPressed = evt.shiftKey;
        if (!isTabPressed) return;
        if (!isFocusIn(evt)) {
            evt.preventDefault();
            isShiftPressed ? focusLastElement() : focusFirstElement();
            return;
        }
        if (((_a = document.value) == null ? void 0 : _a.activeElement) === lastFocusableElement && !isShiftPressed) {
            evt.preventDefault();
            focusFirstElement();
            return;
        }
        if (((_b = document.value) == null ? void 0 : _b.activeElement) === firstFocusableElement && isShiftPressed) {
            evt.preventDefault();
            focusLastElement();
        }
    };
    const trapFocusIn = (el)=>{
        trapInEl.value = el;
        freeFocus();
        trapFocus();
    };
    const trapFocus = ()=>{
        var _a;
        if (!trapInEl.value) return;
        focusableElements = Array.from(trapInEl.value.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR));
        firstFocusableElement = focusableElements[0];
        lastFocusableElement = focusableElements[focusableElements.length - 1];
        (_a = window.value) == null || _a.addEventListener("keydown", onKeydown);
    };
    const freeFocus = ()=>{
        var _a;
        focusableElements = [];
        firstFocusableElement = null;
        lastFocusableElement = null;
        (_a = window.value) == null || _a.removeEventListener("keydown", onKeydown);
    };
    return {
        trapFocus,
        freeFocus,
        trapFocusIn
    };
};

},{"./useAppGlobal.js":"7iRcm","./useDocument.js":"403q6","./useWindow.js":"bOeBT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8k5zP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useModalLevel);
var _vue = require("vue");
var _useComponentUuidJs = require("./useComponentUuid.js");
const modalsStack = (0, _vue.shallowReactive)([]);
const useModalLevel = ()=>{
    const modalId = (0, _useComponentUuidJs.u)();
    const modalLevel = (0, _vue.computed)(()=>modalsStack.findIndex(({ id })=>id === String(modalId)));
    const registerModal = ()=>{
        if (modalLevel.value !== -1) return;
        modalsStack.push({
            id: String(modalId)
        });
    };
    const unregisterModal = ()=>{
        if (modalLevel.value === -1) return;
        modalsStack.splice(modalLevel.value, 1);
    };
    const isTopLevelModal = (0, _vue.computed)(()=>modalLevel.value !== -1 && modalLevel.value === modalsStack.length - 1);
    const isLowestLevelModal = (0, _vue.computed)(()=>modalLevel.value === 0);
    const isMoreThenOneModalOpen = (0, _vue.computed)(()=>modalsStack.length > 1);
    return {
        modalId,
        modalLevel,
        registerModal,
        unregisterModal,
        isTopLevelModal,
        isLowestLevelModal,
        isMoreThenOneModalOpen
    };
};

},{"vue":"gzxs9","./useComponentUuid.js":"cuNNa","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"66noR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "f", ()=>findTeleportedFrom);
parcelHelpers.export(exports, "u", ()=>useTeleported);
var _vue = require("vue");
var _useCurrentComponentIdJs = require("./useCurrentComponentId.js");
const TELEPORT_FROM_ATTR = "data-va-teleported-from";
const TELEPORT_ATTR = "data-va-teleported";
const findTeleportedFrom = (el)=>{
    if (!el) return null;
    const teleportId = el.getAttribute(TELEPORT_ATTR);
    if (teleportId === null) return findTeleportedFrom(el.parentElement);
    return document.querySelector(`[${TELEPORT_FROM_ATTR}="${teleportId}"]`);
};
const useTeleported = ()=>{
    var _a;
    const componentId = (0, _useCurrentComponentIdJs.u)();
    const scopedDataV = (_a = (0, _vue.getCurrentInstance)()) == null ? void 0 : _a.vnode.scopeId;
    return {
        teleportFromAttrs: {
            [TELEPORT_FROM_ATTR]: componentId
        },
        teleportedAttrs: {
            [TELEPORT_ATTR]: componentId,
            [`data-v-${scopedDataV}`]: ""
        },
        findTeleportedFrom
    };
};

},{"vue":"gzxs9","./useCurrentComponentId.js":"h1t7S","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4ZW8J":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useClickOutside);
var _vue = require("vue");
var _useCaptureEventJs = require("./useCaptureEvent.js");
var _useTeleportedJs = require("./useTeleported.js");
var _unwrapElJs = require("../utils/unwrapEl.js");
const checkIfElementChild = (parent, child)=>{
    if (!child) return false;
    if (child.parentElement === parent) return true;
    return parent.contains(child);
};
const safeArray = (a)=>Array.isArray(a) ? a : [
        a
    ];
const useClickOutside = (elements, cb)=>{
    (0, _useCaptureEventJs.u)("mousedown", (event)=>{
        const clickTarget = event.target;
        if (event.target.shadowRoot) return;
        const teleportParent = (0, _useTeleportedJs.f)(clickTarget);
        const isClickInside = safeArray(elements).some((element)=>{
            const el = (0, _unwrapElJs.u)((0, _vue.unref)(element));
            if (!el) return false;
            if (!teleportParent) return checkIfElementChild(el, clickTarget);
            return checkIfElementChild(el, clickTarget) || checkIfElementChild(el, teleportParent);
        });
        if (!isClickInside) cb(clickTarget);
    });
};

},{"vue":"gzxs9","./useCaptureEvent.js":"lkMm9","./useTeleported.js":"66noR","../utils/unwrapEl.js":"bYHKv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kfqni":[function() {},{}],"kfqni":[function() {},{}],"kimwh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "C", ()=>ColorsClassesPlugin);
var _vue = require("vue");
var _ssrJs = require("../../../utils/ssr.js");
var _useGlobalConfigJs = require("../../../composables/useGlobalConfig.js");
var _domJs = require("../../../utils/dom.js");
var _defineVuesticPluginJs = require("../../vue-plugin/utils/define-vuestic-plugin.js");
var _globalPropertiesJs = require("../../vue-plugin/utils/global-properties.js");
const getColorsClassesHelpers = (helpers, colors)=>{
    const colorsEntries = Object.entries(colors);
    return helpers.reduce((acc, helper)=>acc.concat(colorsEntries.map(([colorName, colorValue])=>({
                ...helper,
                postfix: helper.postfix ?? colorName,
                value: helper.value ?? colorValue
            }))), []);
};
const getColorsClassesStyles = (helpers)=>{
    return helpers.reduce((styles, helper)=>{
        const style = [
            helper.property
        ].flat().map((prop)=>`${prop}: ${helper.value};`).join("");
        styles += `.va-${helper.prefix}--${helper.postfix} { ${style} }`;
        return styles;
    }, "");
};
const handleConfigUpdate = (helpers, colors)=>{
    const coloredHelpers = getColorsClassesHelpers(helpers, colors);
    (0, _domJs.a)("va-color-helpers", ()=>getColorsClassesStyles(coloredHelpers));
};
const createColorHelpersPlugin = ()=>{
    if ((0, _ssrJs.i)()) return;
    const { globalConfig } = (0, _useGlobalConfigJs.u)();
    (0, _vue.watch)(()=>globalConfig.value.colorsClasses, (newHelpers)=>{
        if (newHelpers.length) handleConfigUpdate(newHelpers, globalConfig.value.colors.variables);
    }, {
        immediate: true,
        deep: true
    });
    (0, _vue.watch)(()=>globalConfig.value.colors.variables, (newColors)=>{
        if (!newColors) return;
        handleConfigUpdate(globalConfig.value.colorsClasses, newColors);
    }, {
        immediate: true,
        deep: true
    });
    return {
        renderColorHelpers: ()=>{
            const coloredHelpers = getColorsClassesHelpers(globalConfig.value.colorsClasses, globalConfig.value.colors.variables);
            return getColorsClassesStyles(coloredHelpers);
        }
    };
};
const ColorsClassesPlugin = (0, _defineVuesticPluginJs.d)(()=>({
        install (app) {
            (0, _globalPropertiesJs.d)(app, "$vaColorsClasses", createColorHelpersPlugin());
        }
    }));

},{"vue":"gzxs9","../../../utils/ssr.js":"cVJXV","../../../composables/useGlobalConfig.js":"8pVeR","../../../utils/dom.js":"ac5o6","../../vue-plugin/utils/define-vuestic-plugin.js":"5M143","../../vue-plugin/utils/global-properties.js":"isaE8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1T9zx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "c", ()=>createVuestic);
var _componentsJs = require("../components.js");
var _currentAppJs = require("../../current-app.js");
var _usePluginJs = require("../utils/use-plugin.js");
var _indexJs = require("../../global-config/plugin/index.js");
var _indexJs1 = require("../../color/plugin/index.js");
var _indexJs2 = require("../../cache/plugin/index.js");
var _indexJs3 = require("../../colors-classes/plugin/index.js");
var _indexJs4 = require("../../breakpoint/plugin/index.js");
var _indexJs5 = require("../../../components/va-dropdown/plugin/index.js");
var _indexJs6 = require("../../../components/va-toast/plugin/index.js");
var _indexJs7 = require("../../../components/va-modal/plugin/index.js");
var _defineVuesticPluginJs = require("../utils/define-vuestic-plugin.js");
const createVuestic = (0, _defineVuesticPluginJs.d)((options = {})=>({
        install (app) {
            const { config } = options;
            (0, _currentAppJs.s)(app);
            Object.entries((0, _componentsJs.v)).forEach(([name, component])=>{
                app.component(name, component);
            });
            (0, _usePluginJs.u)(app, (0, _indexJs.G)(config));
            (0, _usePluginJs.u)(app, (0, _indexJs2.C));
            (0, _usePluginJs.u)(app, (0, _indexJs1.C)(config));
            (0, _usePluginJs.u)(app, (0, _indexJs3.C));
            (0, _usePluginJs.u)(app, (0, _indexJs4.B));
            (0, _usePluginJs.u)(app, (0, _indexJs5.V));
            (0, _usePluginJs.u)(app, (0, _indexJs6.V));
            (0, _usePluginJs.u)(app, (0, _indexJs7.V));
            (0, _currentAppJs.s)(null);
        }
    }));

},{"../components.js":"d4bOh","../../current-app.js":"eBy1M","../utils/use-plugin.js":"lUxGX","../../global-config/plugin/index.js":"eIBX9","../../color/plugin/index.js":"cfBZ8","../../cache/plugin/index.js":"6oFzX","../../colors-classes/plugin/index.js":"kimwh","../../breakpoint/plugin/index.js":"3E8dA","../../../components/va-dropdown/plugin/index.js":"h07Ct","../../../components/va-toast/plugin/index.js":"ghhI3","../../../components/va-modal/plugin/index.js":"bq9KV","../utils/define-vuestic-plugin.js":"5M143","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d4bOh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "v", ()=>vuesticComponents);
var _indexJs = require("../../components/va-accordion/index.js");
var _indexJs1 = require("../../components/va-affix/index.js");
var _indexJs2 = require("../../components/va-alert/index.js");
var _indexJs3 = require("../../components/va-app-bar/index.js");
var _indexJs4 = require("../../components/va-aspect-ratio/index.js");
var _indexJs5 = require("../../components/va-avatar/index.js");
var _indexJs6 = require("../../components/va-avatar-group/index.js");
var _indexJs7 = require("../../components/va-backtop/index.js");
var _indexJs8 = require("../../components/va-badge/index.js");
var _indexJs9 = require("../../components/va-breadcrumbs/index.js");
var _indexJs10 = require("../../components/va-button/index.js");
var _indexJs11 = require("../../components/va-button-dropdown/index.js");
var _indexJs12 = require("../../components/va-button-group/index.js");
var _indexJs13 = require("../../components/va-button-toggle/index.js");
var _indexJs14 = require("../../components/va-card/index.js");
var _indexJs15 = require("../../components/va-carousel/index.js");
var _indexJs16 = require("../../components/va-checkbox/index.js");
var _indexJs17 = require("../../components/va-chip/index.js");
var _indexJs18 = require("../../components/va-collapse/index.js");
var _indexJs19 = require("../../components/va-color-indicator/index.js");
var _indexJs20 = require("../../components/va-color-input/index.js");
var _indexJs21 = require("../../components/va-color-palette/index.js");
var _vaConfigVueVueTypeScriptSetupTrueLangJs = require("../../components/va-config/VaConfig.vue_vue_type_script_setup_true_lang.js");
var _indexJs22 = require("../../components/va-content/index.js");
var _indexJs23 = require("../../components/va-counter/index.js");
var _indexJs24 = require("../../components/va-data-table/index.js");
var _indexJs25 = require("../../components/va-date-input/index.js");
var _indexJs26 = require("../../components/va-date-picker/index.js");
var _indexJs27 = require("../../components/va-divider/index.js");
var _indexJs28 = require("../../components/va-dropdown/index.js");
var _indexJs29 = require("../../components/va-dropdown/components/VaDropdownContent/index.js");
var _indexJs30 = require("../../components/va-fallback/index.js");
var _indexJs31 = require("../../components/va-file-upload/index.js");
var _indexJs32 = require("../../components/va-form/index.js");
var _indexJs33 = require("../../components/va-hover/index.js");
var _indexJs34 = require("../../components/va-icon/index.js");
var _indexJs35 = require("../../components/va-image/index.js");
var _indexJs36 = require("../../components/va-infinite-scroll/index.js");
var _indexJs37 = require("../../components/va-inner-loading/index.js");
var _indexJs38 = require("../../components/va-input/index.js");
var _indexJs39 = require("../../components/va-layout/index.js");
var _indexJs40 = require("../../components/va-input-wrapper/index.js");
var _indexJs41 = require("../../components/va-list/index.js");
var _vaMessageListJs = require("../../components/va-message-list/VaMessageList.js");
var _vaModalJs = require("../../components/va-modal/VaModal.js");
var _indexJs42 = require("../../components/va-navbar/index.js");
var _indexJs43 = require("../../components/va-option-list/index.js");
var _indexJs44 = require("../../components/va-pagination/index.js");
var _indexJs45 = require("../../components/va-parallax/index.js");
var _indexJs46 = require("../../components/va-popover/index.js");
var _indexJs47 = require("../../components/va-progress-bar/index.js");
var _indexJs48 = require("../../components/va-progress-circle/index.js");
var _indexJs49 = require("../../components/va-radio/index.js");
var _indexJs50 = require("../../components/va-rating/index.js");
var _indexJs51 = require("../../components/va-select/index.js");
var _vaSeparatorVueVueTypeScriptSetupTrueLangJs = require("../../components/va-separator/VaSeparator.vue_vue_type_script_setup_true_lang.js");
var _indexJs52 = require("../../components/va-skeleton/index.js");
var _indexJs53 = require("../../components/va-sidebar/index.js");
var _indexJs54 = require("../../components/va-sidebar/VaSidebarItem/index.js");
var _indexJs55 = require("../../components/va-slider/index.js");
var _vaSpacerVueVueTypeScriptSetupTrueLangJs = require("../../components/va-spacer/VaSpacer.vue_vue_type_script_setup_true_lang.js");
var _indexJs56 = require("../../components/va-split/index.js");
var _indexJs57 = require("../../components/va-switch/index.js");
var _indexJs58 = require("../../components/va-tabs/index.js");
var _indexJs59 = require("../../components/va-tabs/components/VaTab/index.js");
var _indexJs60 = require("../../components/va-stepper/index.js");
var _indexJs61 = require("../../components/va-time-input/index.js");
var _indexJs62 = require("../../components/va-timeline/index.js");
var _indexJs63 = require("../../components/va-timeline/VaTimelineItem/index.js");
var _indexJs64 = require("../../components/va-time-picker/index.js");
var _toastJs = require("../../components/va-toast/toast.js");
var _indexJs65 = require("../../components/va-tree-view/index.js");
var _indexJs66 = require("../../components/va-scroll-container/index.js");
var _indexJs67 = require("../../components/va-viewer/index.js");
var _indexJs68 = require("../../components/va-value/index.js");
var _indexJs69 = require("../../components/va-virtual-scroller/index.js");
var _indexJs70 = require("../../components/va-textarea/index.js");
var _vaMenuJs = require("../../components/va-menu/va-menu.js");
var _indexJs71 = require("../../components/va-menu-list/index.js");
var _indexJs72 = require("../../components/va-form-field/index.js");
const vuesticComponents = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    VaAccordion: (0, _indexJs.V),
    VaAffix: (0, _indexJs1.V),
    VaAlert: (0, _indexJs2.V),
    VaAppBar: (0, _indexJs3.V),
    VaAspectRatio: (0, _indexJs4.V),
    VaAvatar: (0, _indexJs5.V),
    VaAvatarGroup: (0, _indexJs6.V),
    VaBacktop: (0, _indexJs7.V),
    VaBadge: (0, _indexJs8.V),
    VaBreadcrumbs: (0, _indexJs9.a),
    VaBreadcrumbsItem: (0, _indexJs9.V),
    VaButton: (0, _indexJs10.V),
    VaButtonDropdown: (0, _indexJs11.V),
    VaButtonGroup: (0, _indexJs12.V),
    VaButtonToggle: (0, _indexJs13.V),
    VaCard: (0, _indexJs14.d),
    VaCardActions: (0, _indexJs14.b),
    VaCardBlock: (0, _indexJs14.c),
    VaCardContent: (0, _indexJs14.V),
    VaCardTitle: (0, _indexJs14.a),
    VaCarousel: (0, _indexJs15.V),
    VaCheckbox: (0, _indexJs16.V),
    VaChip: (0, _indexJs17.V),
    VaCollapse: (0, _indexJs18.V),
    VaColorIndicator: (0, _indexJs19.V),
    VaColorInput: (0, _indexJs20.V),
    VaColorPalette: (0, _indexJs21.V),
    VaConfig: (0, _vaConfigVueVueTypeScriptSetupTrueLangJs._),
    VaContent: (0, _indexJs22.V),
    VaCounter: (0, _indexJs23.V),
    VaDataTable: (0, _indexJs24.V),
    VaDateInput: (0, _indexJs25.V),
    VaDatePicker: (0, _indexJs26.V),
    VaDivider: (0, _indexJs27.V),
    VaDropdown: (0, _indexJs28.V),
    VaDropdownContent: (0, _indexJs29.V),
    VaFallback: (0, _indexJs30.V),
    VaFileUpload: (0, _indexJs31.V),
    VaForm: (0, _indexJs32.V),
    VaFormField: (0, _indexJs72.V),
    VaHover: (0, _indexJs33.V),
    VaIcon: (0, _indexJs34.V),
    VaImage: (0, _indexJs35.V),
    VaInfiniteScroll: (0, _indexJs36.V),
    VaInnerLoading: (0, _indexJs37.V),
    VaInput: (0, _indexJs38.V),
    VaInputWrapper: (0, _indexJs40.V),
    VaLayout: (0, _indexJs39.V),
    VaList: (0, _indexJs41.b),
    VaListItem: (0, _indexJs41.V),
    VaListItemLabel: (0, _indexJs41.d),
    VaListItemSection: (0, _indexJs41.a),
    VaListLabel: (0, _indexJs41.c),
    VaListSeparator: (0, _indexJs41.e),
    VaMenu: (0, _vaMenuJs.V),
    VaMenuGroup: (0, _indexJs71.b),
    VaMenuItem: (0, _indexJs71.a),
    VaMenuList: (0, _indexJs71.V),
    VaMessageList: (0, _vaMessageListJs.V),
    VaModal: (0, _vaModalJs.V),
    VaNavbar: (0, _indexJs42.V),
    VaNavbarItem: (0, _indexJs42.a),
    VaOptionList: (0, _indexJs43.V),
    VaPagination: (0, _indexJs44.V),
    VaParallax: (0, _indexJs45.V),
    VaPopover: (0, _indexJs46.V),
    VaProgressBar: (0, _indexJs47.V),
    VaProgressCircle: (0, _indexJs48.V),
    VaRadio: (0, _indexJs49.V),
    VaRating: (0, _indexJs50.V),
    VaScrollContainer: (0, _indexJs66.V),
    VaSelect: (0, _indexJs51.V),
    VaSeparator: (0, _vaSeparatorVueVueTypeScriptSetupTrueLangJs._),
    VaSidebar: (0, _indexJs53.V),
    VaSidebarItem: (0, _indexJs54.V),
    VaSidebarItemContent: (0, _indexJs54.a),
    VaSidebarItemTitle: (0, _indexJs54.b),
    VaSkeleton: (0, _indexJs52.V),
    VaSkeletonGroup: (0, _indexJs52.a),
    VaSlider: (0, _indexJs55.V),
    VaSpacer: (0, _vaSpacerVueVueTypeScriptSetupTrueLangJs._),
    VaSplit: (0, _indexJs56.V),
    VaStepper: (0, _indexJs60.V),
    VaSwitch: (0, _indexJs57.V),
    VaTab: (0, _indexJs59.V),
    VaTabs: (0, _indexJs58.V),
    VaTextarea: (0, _indexJs70.V),
    VaTimeInput: (0, _indexJs61.V),
    VaTimePicker: (0, _indexJs64.V),
    VaTimeline: (0, _indexJs62.V),
    VaTimelineItem: (0, _indexJs63.V),
    VaToast: (0, _toastJs.V),
    VaTreeView: (0, _indexJs65.V),
    VaValue: (0, _indexJs68.V),
    VaViewer: (0, _indexJs67.V),
    VaVirtualScroller: (0, _indexJs69.V)
}, Symbol.toStringTag, {
    value: "Module"
}));

},{"../../components/va-accordion/index.js":"j0Gl4","../../components/va-affix/index.js":"8Ux9z","../../components/va-alert/index.js":"7MlIN","../../components/va-app-bar/index.js":"8Y6wY","../../components/va-aspect-ratio/index.js":"k7XDA","../../components/va-avatar/index.js":"gmzbe","../../components/va-avatar-group/index.js":"2I43b","../../components/va-backtop/index.js":"2A28I","../../components/va-badge/index.js":"aHODx","../../components/va-breadcrumbs/index.js":"73olY","../../components/va-button/index.js":"2vhcC","../../components/va-button-dropdown/index.js":"jkfpb","../../components/va-button-group/index.js":"5oEPw","../../components/va-button-toggle/index.js":"WnZ9t","../../components/va-card/index.js":"jR3tW","../../components/va-carousel/index.js":"jZbtW","../../components/va-checkbox/index.js":"w8J04","../../components/va-chip/index.js":"9Dcs3","../../components/va-collapse/index.js":"2GF8q","../../components/va-color-indicator/index.js":"euOOk","../../components/va-color-input/index.js":"fbL1A","../../components/va-color-palette/index.js":"72GfW","../../components/va-config/VaConfig.vue_vue_type_script_setup_true_lang.js":"kIv2h","../../components/va-content/index.js":"lYcyd","../../components/va-counter/index.js":"4iuxZ","../../components/va-data-table/index.js":"3rH5r","../../components/va-date-input/index.js":"bfPrQ","../../components/va-date-picker/index.js":"2GBIc","../../components/va-divider/index.js":"wiQvd","../../components/va-dropdown/index.js":"2ag98","../../components/va-dropdown/components/VaDropdownContent/index.js":"eUpbA","../../components/va-fallback/index.js":"3inAD","../../components/va-file-upload/index.js":"8rtbN","../../components/va-form/index.js":"2IflX","../../components/va-hover/index.js":"f04ha","../../components/va-icon/index.js":"82tPo","../../components/va-image/index.js":"a8Pl8","../../components/va-infinite-scroll/index.js":"b3W1W","../../components/va-inner-loading/index.js":"9vecB","../../components/va-input/index.js":"qwNV2","../../components/va-layout/index.js":"jq32I","../../components/va-input-wrapper/index.js":"7MuId","../../components/va-list/index.js":"iaP6m","../../components/va-message-list/VaMessageList.js":"kMkwf","../../components/va-modal/VaModal.js":"g5tjq","../../components/va-navbar/index.js":"hIuhr","../../components/va-option-list/index.js":"15vCn","../../components/va-pagination/index.js":"dctxF","../../components/va-parallax/index.js":"4st8C","../../components/va-popover/index.js":"cTbKH","../../components/va-progress-bar/index.js":"3h0vS","../../components/va-progress-circle/index.js":"dZCnz","../../components/va-radio/index.js":"9hzhI","../../components/va-rating/index.js":"ihXDw","../../components/va-select/index.js":"7ypmM","../../components/va-separator/VaSeparator.vue_vue_type_script_setup_true_lang.js":"g10Ia","../../components/va-skeleton/index.js":"bljVI","../../components/va-sidebar/index.js":"1Qb9Q","../../components/va-sidebar/VaSidebarItem/index.js":"5vyTd","../../components/va-slider/index.js":"4lRy1","../../components/va-spacer/VaSpacer.vue_vue_type_script_setup_true_lang.js":"cczXf","../../components/va-split/index.js":"7GFfZ","../../components/va-switch/index.js":"3NSps","../../components/va-tabs/index.js":"6zoJR","../../components/va-tabs/components/VaTab/index.js":"3xTrP","../../components/va-stepper/index.js":"4Z50z","../../components/va-time-input/index.js":"jofdb","../../components/va-timeline/index.js":"jGtdD","../../components/va-timeline/VaTimelineItem/index.js":"gL62Z","../../components/va-time-picker/index.js":"iUilR","../../components/va-toast/toast.js":"euASG","../../components/va-tree-view/index.js":"1JPW1","../../components/va-scroll-container/index.js":"kLo8x","../../components/va-viewer/index.js":"lhYsR","../../components/va-value/index.js":"lL9OB","../../components/va-virtual-scroller/index.js":"cvrbR","../../components/va-textarea/index.js":"fwDgH","../../components/va-menu/va-menu.js":"5U4oY","../../components/va-menu-list/index.js":"3V4NA","../../components/va-form-field/index.js":"ewKGs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j0Gl4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaAccordion);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaAccordionVueVueTypeScriptSetupTrueLangJs = require("./VaAccordion.vue_vue_type_script_setup_true_lang.js");
const VaAccordion = (0, _withConfigTransportJs.w)((0, _vaAccordionVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaAccordion.vue_vue_type_script_setup_true_lang.js":"7nlPa","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7nlPa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useAccordionJs = require("./hooks/useAccordion.js");
var _useStatefulJs = require("../../composables/useStateful.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _vaAccordionCss = require("../../../VaAccordion.css");
const _hoisted_1 = {
    class: "va-accordion"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaAccordion",
    __name: "VaAccordion",
    props: {
        ...(0, _useStatefulJs.u),
        ...(0, _useComponentPresetJs.u),
        modelValue: {
            type: Array,
            default: ()=>[]
        },
        multiple: {
            type: Boolean,
            default: false
        },
        inset: {
            type: Boolean,
            default: false
        },
        stateful: {
            type: Boolean,
            default: true
        },
        popout: {
            type: Boolean,
            default: false
        }
    },
    emits: [
        ...(0, _useStatefulJs.a)
    ],
    setup (__props, { expose: __expose, emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const { valueComputed } = (0, _useStatefulJs.b)(props, emit, "modelValue");
        const { items } = (0, _useAccordionJs.u)(props, valueComputed);
        const collapses = items;
        const value = valueComputed;
        __expose({
            collapses,
            value
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_1, [
                (0, _vue.renderSlot)(_ctx.$slots, "default")
            ]);
        };
    }
});

},{"vue":"gzxs9","./hooks/useAccordion.js":"9PX6J","../../composables/useStateful.js":"h9zUi","../../composables/useComponentPreset.js":"2HoaT","../../../VaAccordion.css":"lTBH3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9PX6J":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useAccordionItem);
parcelHelpers.export(exports, "u", ()=>useAccordion);
var _vue = require("vue");
var _consoleJs = require("../../../utils/console.js");
const AccordionServiceKey = Symbol("AccordionService");
const useAccordion = (props, state)=>{
    const items = (0, _vue.ref)([]);
    const makeState = ()=>{
        const correctItemsCount = Math.max(items.value.length, state.value.length);
        return Array.from({
            length: correctItemsCount
        }, (_, index)=>{
            return state.value[index] ?? false;
        });
    };
    const getItemValue = (item)=>{
        return state.value[items.value.indexOf(item)] ?? false;
    };
    const onItemsChanged = ()=>{
        state.value = makeState();
    };
    const registerItem = (item)=>{
        items.value.push(item);
        onItemsChanged();
    };
    const unregisterItem = (item)=>{
        items.value = items.value.filter((i)=>i !== item);
        (0, _vue.nextTick)(onItemsChanged);
    };
    const setItemValue = (item, value)=>{
        const index = items.value.indexOf(item);
        if (index === -1) {
            (0, _consoleJs.w)("Accordion item is not registered yet");
            return;
        }
        if (!props.multiple) state.value = makeState().map((el, i)=>{
            if (i === index) return value;
            return false;
        });
        else state.value[index] = value;
    };
    (0, _vue.provide)(AccordionServiceKey, {
        registerItem,
        unregisterItem,
        getItemValue,
        setItemValue,
        props: (0, _vue.computed)(()=>props)
    });
    return {
        items
    };
};
const useAccordionItem = ()=>{
    const accordion = (0, _vue.inject)(AccordionServiceKey, void 0);
    if (!accordion) return {
        accordionProps: (0, _vue.ref)({})
    };
    const item = {};
    accordion.registerItem(item);
    (0, _vue.onBeforeUnmount)(()=>accordion.unregisterItem(item));
    const accordionItemValue = (0, _vue.computed)({
        get: ()=>accordion.getItemValue(item),
        set: (value)=>accordion.setItemValue(item, value)
    });
    return {
        accordionItemValue,
        accordionProps: accordion.props
    };
};

},{"vue":"gzxs9","../../../utils/console.js":"58L6z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lTBH3":[function() {},{}],"8Ux9z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaAffix);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaAffixVueVueTypeScriptSetupTrueLangJs = require("./VaAffix.vue_vue_type_script_setup_true_lang.js");
const VaAffix = (0, _withConfigTransportJs.w)((0, _vaAffixVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaAffix.vue_vue_type_script_setup_true_lang.js":"1cBUf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1cBUf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../vendor.js");
var _ssrJs = require("../../utils/ssr.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _vaAffixUtilsJs = require("./VaAffix-utils.js");
var _vaAffixCss = require("../../../VaAffix.css");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaAffix",
    __name: "VaAffix",
    props: {
        ...(0, _useComponentPresetJs.u),
        offsetTop: {
            type: Number,
            default: void 0
        },
        offsetBottom: {
            type: Number,
            default: void 0
        },
        target: {
            type: [
                Object,
                Function
            ],
            default: (0, _ssrJs.g)
        }
    },
    emits: [
        "change"
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const element = (0, _vue.shallowRef)();
        const getTargetElement = ()=>typeof props.target === "function" ? props.target() : props.target;
        const isAffixed = (0, _vue.computed)(()=>state.value.isTopAffixed || state.value.isBottomAffixed);
        const state = (0, _vue.ref)({
            isTopAffixed: false,
            isBottomAffixed: false
        });
        const getState = ()=>state.value;
        const setState = (newState)=>{
            state.value = newState;
            emit("change", isAffixed);
        };
        const calculateTop = ()=>{
            const target = getTargetElement();
            if (!target) return 0;
            if (props.offsetTop === void 0) return;
            if (!(target instanceof Window)) {
                const { top } = target.getBoundingClientRect();
                return top + props.offsetTop;
            }
            return props.offsetTop;
        };
        const calculateBottom = ()=>{
            const target = getTargetElement();
            if (!target) return 0;
            if (props.offsetBottom === void 0) return;
            if (!(target instanceof Window)) {
                const { bottom } = target.getBoundingClientRect();
                const { borderTopWidth, borderBottomWidth } = getComputedStyle(target);
                const { offsetHeight, clientHeight } = target;
                const scrollBarHeight = offsetHeight - clientHeight - parseInt(borderTopWidth) - parseInt(borderBottomWidth);
                return (0, _vaAffixUtilsJs.g)() - (bottom - props.offsetBottom) + scrollBarHeight;
            }
            return props.offsetBottom;
        };
        const convertToPixels = (calculate)=>{
            const result = calculate();
            return result === void 0 ? void 0 : `${result}px`;
        };
        const computedClass = (0, _vue.computed)(()=>[
                {
                    "va-affix--affixed": isAffixed
                }
            ]);
        const computedStyle = (0, _vue.computed)(()=>({
                top: state.value.isTopAffixed ? convertToPixels(calculateTop) : void 0,
                bottom: state.value.isBottomAffixed ? convertToPixels(calculateBottom) : void 0,
                width: `${state.value.width}px`
            }));
        const initialPosition = (0, _vue.ref)();
        const throttledEventHandler = (eventName, event)=>{
            const context = {
                ...props,
                initialPosition: initialPosition.value,
                element: element.value,
                target: getTargetElement(),
                setState,
                getState
            };
            if (!eventName || eventName === "resize") (0, _vaAffixUtilsJs.h)(eventName, context);
            else if (event && event.target) {
                const target = getTargetElement();
                if (target === event.target || target instanceof Window) (0, _vaAffixUtilsJs.h)(eventName, context);
                else setState({
                    isBottomAffixed: false,
                    isTopAffixed: false
                });
            }
        };
        let clearEventListeners = (0, _vendorJs.n);
        (0, _vue.onMounted)(()=>{
            var _a;
            initialPosition.value = (_a = element.value) == null ? void 0 : _a.getBoundingClientRect();
            const events = [
                "scroll",
                "resize"
            ];
            clearEventListeners = (0, _vaAffixUtilsJs.u)(events, {
                handler: throttledEventHandler
            });
            (0, _vue.nextTick)(()=>{
                throttledEventHandler(null);
            });
        });
        (0, _vue.onBeforeUnmount)(clearEventListeners);
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                ref_key: "element",
                ref: element,
                class: "va-affix"
            }, [
                (0, _vue.createElementVNode)("div", {
                    style: (0, _vue.normalizeStyle)({
                        visibility: isAffixed.value ? "hidden" : "inherit"
                    })
                }, [
                    (0, _vue.renderSlot)(_ctx.$slots, "default")
                ], 4),
                isAffixed.value ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                    key: 0,
                    class: (0, _vue.normalizeClass)(computedClass.value),
                    style: (0, _vue.normalizeStyle)(computedStyle.value)
                }, [
                    (0, _vue.renderSlot)(_ctx.$slots, "default")
                ], 6)) : (0, _vue.createCommentVNode)("", true)
            ], 512);
        };
    }
});

},{"vue":"gzxs9","../../../vendor.js":"l6TAc","../../utils/ssr.js":"cVJXV","../../composables/useComponentPreset.js":"2HoaT","./VaAffix-utils.js":"dc9ce","../../../VaAffix.css":"6gG04","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dc9ce":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "g", ()=>getWindowHeight);
parcelHelpers.export(exports, "h", ()=>handleThrottledEvent);
parcelHelpers.export(exports, "u", ()=>useEventsHandlerWithThrottle);
var _vendorJs = require("../../../vendor.js");
function getWindowHeight() {
    return document.documentElement.clientHeight || window.innerHeight || document.body.clientHeight;
}
function computeAffixedState({ coordinates, offsetTop, offsetBottom, target }) {
    let isTopAffixed = false;
    let isBottomAffixed = false;
    const windowHeight = getWindowHeight();
    if (offsetTop != null && windowHeight) {
        if (target === window) isTopAffixed = coordinates.top <= offsetTop;
        else {
            const { top } = target.getBoundingClientRect();
            isTopAffixed = coordinates.top - top <= offsetTop;
        }
    }
    if (offsetBottom != null && windowHeight) {
        if (target === window) isBottomAffixed = coordinates.bottom >= windowHeight - offsetBottom;
        else {
            const { bottom } = target.getBoundingClientRect();
            isBottomAffixed = bottom - coordinates.bottom <= offsetBottom;
        }
    }
    return {
        isTopAffixed,
        isBottomAffixed
    };
}
function checkAffixedStateChange(currentState, nextState) {
    return currentState.isTopAffixed !== nextState.isTopAffixed || currentState.isBottomAffixed !== nextState.isBottomAffixed;
}
function handleThrottledEvent(eventName, context) {
    const { target, element, offsetTop, offsetBottom, setState, getState, initialPosition } = context;
    if (!element) return;
    const isInitialCall = !eventName;
    const coordinates = element.getBoundingClientRect();
    const options = {
        offsetBottom,
        offsetTop,
        target
    };
    const nextState = isInitialCall && initialPosition ? computeAffixedState({
        coordinates: initialPosition,
        ...options
    }) : computeAffixedState({
        coordinates,
        ...options
    });
    const prevState = getState();
    if (checkAffixedStateChange(prevState, nextState)) setState({
        ...nextState,
        width: coordinates.width
    });
    else if (prevState.width !== coordinates.width) setState({
        ...prevState,
        width: coordinates.width
    });
}
function useCaptureDefault(eventName) {
    return eventName === "scroll";
}
function useEventsHandlerWithThrottle(events, { handler, useCapture = useCaptureDefault, wait = 50 }) {
    const clearHandlersArray = events.map((eventName)=>{
        const _handler = (0, _vendorJs.t)((event)=>handler(eventName, event), wait);
        window.addEventListener(eventName, _handler, useCapture(eventName));
        return ()=>window.removeEventListener(eventName, _handler, useCapture(eventName));
    });
    return ()=>clearHandlersArray.forEach((clear)=>clear());
}

},{"../../../vendor.js":"l6TAc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6gG04":[function() {},{}],"7MlIN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaAlert);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaAlertVueVueTypeScriptSetupTrueLangJs = require("./VaAlert.vue_vue_type_script_setup_true_lang.js");
const VaAlert = (0, _withConfigTransportJs.w)((0, _vaAlertVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaAlert.vue_vue_type_script_setup_true_lang.js":"9dXfy","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9dXfy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useAlertStylesJs = require("./useAlertStyles.js");
var _indexJs = require("../va-icon/index.js");
var _useStatefulJs = require("../../composables/useStateful.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useTranslationJs = require("../../composables/useTranslation.js");
var _vaAlertCss = require("../../../VaAlert.css");
const _hoisted_1 = {
    key: 1,
    class: "va-alert__close"
};
const _hoisted_2 = [
    "aria-label"
];
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaAlert",
    __name: "VaAlert",
    props: {
        ...(0, _useStatefulJs.u),
        ...(0, _useComponentPresetJs.u),
        modelValue: {
            type: Boolean,
            default: true
        },
        stateful: {
            type: Boolean,
            default: true
        },
        color: {
            type: String,
            default: "primary"
        },
        textColor: {
            type: String,
            default: ""
        },
        title: {
            type: String,
            default: ""
        },
        description: {
            type: String,
            default: ""
        },
        icon: {
            type: String,
            default: ""
        },
        closeText: {
            type: String,
            default: ""
        },
        closeIcon: {
            type: String,
            default: "close"
        },
        closeable: {
            type: Boolean,
            default: false
        },
        dense: {
            type: Boolean,
            default: false
        },
        outline: {
            type: Boolean,
            default: false
        },
        center: {
            type: Boolean,
            default: false
        },
        borderColor: {
            type: String,
            default: ""
        },
        border: {
            type: String,
            default: "",
            validator: (value)=>[
                    "top",
                    "right",
                    "bottom",
                    "left",
                    ""
                ].includes(value)
        }
    },
    emits: [
        ...(0, _useStatefulJs.a)
    ],
    setup (__props, { expose: __expose, emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const { contentStyle, titleStyle, alertStyle, borderStyle } = (0, _useAlertStylesJs.u)(props);
        const { valueComputed } = (0, _useStatefulJs.b)(props, emit);
        const hide = ()=>{
            valueComputed.value = false;
        };
        const show = ()=>{
            valueComputed.value = true;
        };
        const slots = (0, _vue.useSlots)();
        const hasIcon = (0, _vue.computed)(()=>props.icon || slots.icon);
        const hasTitle = (0, _vue.computed)(()=>props.title || slots.title);
        const borderClass = (0, _vue.computed)(()=>`va-alert__border--${props.border}`);
        const { tp, t } = (0, _useTranslationJs.u)();
        __expose({
            hide,
            show
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.Transition), {
                name: "fade"
            }, {
                default: (0, _vue.withCtx)(()=>[
                        (0, _vue.unref)(valueComputed) ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                            key: 0,
                            class: "va-alert",
                            style: (0, _vue.normalizeStyle)((0, _vue.unref)(alertStyle)),
                            role: "alert"
                        }, [
                            (0, _vue.createElementVNode)("div", {
                                style: (0, _vue.normalizeStyle)((0, _vue.unref)(borderStyle)),
                                class: (0, _vue.normalizeClass)([
                                    borderClass.value,
                                    "va-alert__border"
                                ])
                            }, null, 6),
                            hasIcon.value ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                key: 0,
                                style: (0, _vue.normalizeStyle)((0, _vue.unref)(contentStyle)),
                                class: "va-alert__icon",
                                "aria-hidden": "true"
                            }, [
                                (0, _vue.renderSlot)(_ctx.$slots, "icon", {}, ()=>[
                                        (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs.V)), {
                                            name: __props.icon
                                        }, null, 8, [
                                            "name"
                                        ])
                                    ])
                            ], 4)) : (0, _vue.createCommentVNode)("", true),
                            (0, _vue.createElementVNode)("div", {
                                style: (0, _vue.normalizeStyle)((0, _vue.unref)(contentStyle)),
                                class: "va-alert__content"
                            }, [
                                hasTitle.value ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                    key: 0,
                                    style: (0, _vue.normalizeStyle)((0, _vue.unref)(titleStyle)),
                                    class: "va-alert__title"
                                }, [
                                    (0, _vue.renderSlot)(_ctx.$slots, "title", {}, ()=>[
                                            (0, _vue.createTextVNode)((0, _vue.toDisplayString)(__props.title), 1)
                                        ])
                                ], 4)) : (0, _vue.createCommentVNode)("", true),
                                (0, _vue.createElementVNode)("span", null, [
                                    (0, _vue.renderSlot)(_ctx.$slots, "default", {}, ()=>[
                                            (0, _vue.createTextVNode)((0, _vue.toDisplayString)(_ctx.$props.description), 1)
                                        ])
                                ])
                            ], 4),
                            __props.closeable ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_1, [
                                (0, _vue.createElementVNode)("div", {
                                    role: "button",
                                    class: "va-alert__close--closeable",
                                    tabindex: "0",
                                    "aria-label": __props.closeText || (0, _vue.unref)(t)("closeAlert"),
                                    style: (0, _vue.normalizeStyle)((0, _vue.unref)(contentStyle)),
                                    onClick: hide,
                                    onKeydown: [
                                        (0, _vue.withKeys)(hide, [
                                            "space"
                                        ]),
                                        (0, _vue.withKeys)(hide, [
                                            "enter"
                                        ])
                                    ]
                                }, [
                                    (0, _vue.renderSlot)(_ctx.$slots, "close", {}, ()=>[
                                            !__props.closeText ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), {
                                                key: 0,
                                                name: __props.closeIcon
                                            }, null, 8, [
                                                "name"
                                            ])) : (0, _vue.createCommentVNode)("", true),
                                            (0, _vue.createTextVNode)(" " + (0, _vue.toDisplayString)(__props.closeText), 1)
                                        ])
                                ], 44, _hoisted_2)
                            ])) : (0, _vue.createCommentVNode)("", true)
                        ], 4)) : (0, _vue.createCommentVNode)("", true)
                    ]),
                _: 3
            });
        };
    }
});

},{"vue":"gzxs9","./useAlertStyles.js":"ex1AY","../va-icon/index.js":"82tPo","../../composables/useStateful.js":"h9zUi","../../composables/useComponentPreset.js":"2HoaT","../../composables/useTranslation.js":"7S3aV","../../../VaAlert.css":"8HXor","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ex1AY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useAlertStyles);
var _vue = require("vue");
var _useElementTextColorJs = require("../../composables/useElementTextColor.js");
var _useElementBackgroundJs = require("../../composables/useElementBackground.js");
var _useCurrentElementJs = require("../../composables/useCurrentElement.js");
var _useColorsJs = require("../../composables/useColors.js");
var _useTextColorJs = require("../../composables/useTextColor.js");
const useAlertStyles = (props)=>{
    const { getColor } = (0, _useColorsJs.u)();
    const isTransparentBackground = (0, _vue.computed)(()=>Boolean(props.outline || props.border));
    const { textColorComputed } = (0, _useTextColorJs.u)((0, _vue.toRef)(props, "color"), isTransparentBackground);
    const colorComputed = (0, _vue.computed)(()=>getColor(props.color));
    const alertStyle = (0, _vue.computed)(()=>{
        let background = colorComputed.value;
        let boxShadow = "none";
        if (props.outline) background = "transparent";
        if (props.border) {
            background = "var(--va-background-primary)";
            boxShadow = "var(--va-alert-box-shadow)";
        }
        return {
            border: props.outline ? `1px solid ${colorComputed.value}` : "",
            padding: props.dense ? "var(--va-alert-padding-y-dense) var(--va-alert-padding-x)" : "",
            backgroundColor: background,
            boxShadow
        };
    });
    const currentColor = (0, _useElementTextColorJs.u)((0, _useElementBackgroundJs.u)((0, _useCurrentElementJs.u)()));
    const contentStyle = (0, _vue.computed)(()=>{
        return {
            alignItems: props.center ? "center" : "",
            color: props.border || props.outline ? currentColor.value : textColorComputed.value
        };
    });
    const titleStyle = (0, _vue.computed)(()=>{
        return {
            color: textColorComputed.value
        };
    });
    const borderStyle = (0, _vue.computed)(()=>({
            backgroundColor: props.borderColor ? getColor(props.borderColor) : colorComputed.value
        }));
    return {
        alertStyle,
        contentStyle,
        titleStyle,
        borderStyle
    };
};

},{"vue":"gzxs9","../../composables/useElementTextColor.js":"kLVMS","../../composables/useElementBackground.js":"8MRId","../../composables/useCurrentElement.js":"iOsak","../../composables/useColors.js":"a4Qgv","../../composables/useTextColor.js":"5pfXb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kLVMS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useElementTextColor);
var _useTextColorJs = require("./useTextColor.js");
const useElementTextColor = (background)=>{
    const { textColorComputed } = (0, _useTextColorJs.u)(background);
    return textColorComputed;
};

},{"./useTextColor.js":"5pfXb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8MRId":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useElementBackground);
var _vue = require("vue");
const parseRgba = (rgba)=>{
    let values;
    if (rgba.startsWith("rgba")) values = rgba.substring(5, rgba.length - 1).split(",");
    else values = rgba.substring(4, rgba.length - 1).split(",");
    values[0] = Number(values[0]);
    values[1] = Number(values[1]);
    values[2] = Number(values[2]);
    if (values[3] === void 0) values[3] = 1;
    else values[3] = Number(values[3]);
    return values;
};
const toHex = (color)=>{
    return "#" + (color[0] | 256).toString(16).slice(1) + (color[1] | 256).toString(16).slice(1) + (color[2] | 256).toString(16).slice(1) + (color[3] * 255 | 256).toString(16).slice(1);
};
const getParentsWithBackground = (el)=>{
    const parents = [];
    let currentEl = el;
    while(currentEl){
        if (!(currentEl instanceof HTMLElement) || !currentEl) return parents;
        const { backgroundColor, willChange } = window.getComputedStyle(currentEl);
        const bgWillChange = willChange.includes("background");
        const parsedColor = parseRgba(backgroundColor);
        if (parsedColor[3] === 1 && !bgWillChange) {
            parents.push(currentEl);
            return parents;
        }
        if (parsedColor[3] !== 0 || bgWillChange) parents.push(currentEl);
        currentEl = currentEl.parentElement;
    }
    return parents;
};
const WATCHER_CLASS = "va-background-watcher";
const watchElementBackground = (el, cb)=>{
    el.className = WATCHER_CLASS + " " + el.className;
    el.addEventListener("transitionend", (e)=>{
        if (e.target !== el) return;
        cb();
    });
    return ()=>{
        el.className = el.className.replace(WATCHER_CLASS, "");
        el.removeEventListener("transitionend", cb);
    };
};
const watchElementsBackground = (els, cb)=>{
    const unwatchers = els.map((el)=>watchElementBackground(el, cb));
    return ()=>{
        unwatchers.forEach((unwatch)=>unwatch());
    };
};
const applyColors = (color1, color2)=>{
    const weight = color2[3];
    if (weight === 1) return color2;
    if (weight === 0) return color1;
    const c1 = Math.round(color1[0] * (1 - weight) + color2[0] * weight);
    const c2 = Math.round(color1[1] * (1 - weight) + color2[1] * weight);
    const c3 = Math.round(color1[2] * (1 - weight) + color2[2] * weight);
    return [
        c1,
        c2,
        c3,
        1
    ];
};
const getColorFromElements = (els)=>{
    let currentColor = [
        0,
        0,
        0,
        0
    ];
    for(let i = els.length - 1; i >= 0; i--)currentColor = applyColors(currentColor, parseRgba(window.getComputedStyle(els[i]).backgroundColor));
    return currentColor;
};
const useElementBackground = (el)=>{
    const color = (0, _vue.ref)("#000000");
    let unWatchAll = ()=>void 0;
    (0, _vue.watchEffect)(()=>{
        unWatchAll();
        if (el.value) {
            const parents = getParentsWithBackground(el.value);
            unWatchAll = watchElementsBackground(parents, ()=>{
                color.value = toHex(getColorFromElements(parents));
            });
            color.value = toHex(getColorFromElements(parents));
        }
    });
    return color;
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iOsak":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useCurrentElement);
var _vue = require("vue");
const useCurrentElement = (el)=>{
    if (el) return el;
    const vm = (0, _vue.getCurrentInstance)();
    const currentEl = (0, _vue.shallowRef)();
    (0, _vue.onMounted)(()=>{
        currentEl.value = vm.proxy.$el ?? void 0;
    });
    (0, _vue.onUpdated)(()=>{
        currentEl.value = vm.proxy.$el ?? void 0;
    });
    (0, _vue.onBeforeUnmount)(()=>{
        currentEl.value = vm.proxy.$el ?? void 0;
    });
    return currentEl;
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8HXor":[function() {},{}],"8Y6wY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaAppBar);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaAppBarVueVueTypeScriptSetupTrueLangJs = require("./VaAppBar.vue_vue_type_script_setup_true_lang.js");
const VaAppBar = (0, _withConfigTransportJs.w)((0, _vaAppBarVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaAppBar.vue_vue_type_script_setup_true_lang.js":"13MUV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"13MUV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useFixedBarJs = require("../../composables/useFixedBar.js");
var _useScrollJs = require("../../composables/useScroll.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useColorsJs = require("../../composables/useColors.js");
var _useTextColorJs = require("../../composables/useTextColor.js");
var _vaAppBarCss = require("../../../VaAppBar.css");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaAppBar",
    __name: "VaAppBar",
    props: {
        ...(0, _useFixedBarJs.u),
        ...(0, _useComponentPresetJs.u),
        gradient: {
            type: Boolean,
            default: false
        },
        target: {
            type: [
                Object,
                String
            ],
            default: ""
        },
        shadowOnScroll: {
            type: Boolean,
            default: false
        },
        shadowColor: {
            type: String,
            default: ""
        },
        color: {
            type: String,
            default: "primary"
        }
    },
    setup (__props) {
        const props = __props;
        const { scrollRoot, isScrolledDown } = (0, _useScrollJs.s)(props.fixed, props.target);
        const { fixedBarStyleComputed } = (0, _useFixedBarJs.a)(props, isScrolledDown);
        const { getColor, getGradientBackground, getBoxShadowColor } = (0, _useColorsJs.u)();
        const colorComputed = (0, _vue.computed)(()=>getColor(props.color));
        const { textColorComputed } = (0, _useTextColorJs.u)((0, _vue.toRef)(props, "color"));
        const showShadowComputed = (0, _vue.computed)(()=>isScrolledDown.value ? !!props.shadowOnScroll : false);
        const shadowColorComputed = (0, _vue.computed)(()=>getColor(props.shadowColor, colorComputed.value));
        const computedShadow = (0, _vue.computed)(()=>{
            const shadow = getBoxShadowColor(props.shadowColor ? shadowColorComputed.value : colorComputed.value);
            return showShadowComputed.value ? `var(--va-app-bar-shadow) ${shadow}` : "";
        });
        const computedStyle = (0, _vue.computed)(()=>({
                ...fixedBarStyleComputed.value,
                background: props.gradient ? getGradientBackground(colorComputed.value) : colorComputed.value,
                boxShadow: computedShadow.value,
                color: textColorComputed.value
            }));
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("header", {
                ref_key: "scrollRoot",
                ref: scrollRoot,
                role: "toolbar",
                class: "va-app-bar",
                style: (0, _vue.normalizeStyle)(computedStyle.value)
            }, [
                (0, _vue.renderSlot)(_ctx.$slots, "default")
            ], 4);
        };
    }
});

},{"vue":"gzxs9","../../composables/useFixedBar.js":"2bcxS","../../composables/useScroll.js":"dESBl","../../composables/useComponentPreset.js":"2HoaT","../../composables/useColors.js":"a4Qgv","../../composables/useTextColor.js":"5pfXb","../../../VaAppBar.css":"jcqbN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2bcxS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useFixedBar);
parcelHelpers.export(exports, "u", ()=>useFixedBarProps);
var _vue = require("vue");
const useFixedBarProps = {
    hideOnScroll: {
        type: Boolean,
        default: false
    },
    fixed: {
        type: Boolean,
        default: false
    },
    bottom: {
        type: Boolean,
        default: false
    }
};
function useFixedBar(props, isScrolledDown) {
    const isHiddenComputed = (0, _vue.computed)(()=>isScrolledDown.value ? !!props.hideOnScroll : false);
    const transformComputed = (0, _vue.computed)(()=>{
        if (!props.bottom && !isHiddenComputed.value) return;
        if (props.bottom && isHiddenComputed.value) return "translateY(100%)";
        if (props.bottom) return props.fixed ? "translateY(-100%)" : "translateY(0)";
        return "translateY(-100%)";
    });
    const positionComputed = (0, _vue.computed)(()=>{
        if (props.fixed) return "fixed";
        return isHiddenComputed.value ? "absolute" : void 0;
    });
    const fixedBarStyleComputed = (0, _vue.computed)(()=>{
        const result = {
            top: props.bottom && (isHiddenComputed.value || props.fixed) ? "100%" : void 0,
            transform: props.hideOnScroll || props.fixed ? transformComputed.value : void 0
        };
        positionComputed.value && Object.assign(result, {
            position: positionComputed.value
        });
        return result;
    });
    return {
        fixedBarStyleComputed
    };
}

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dESBl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "s", ()=>setupScroll);
var _vue = require("vue");
function getTargetElement(target) {
    if (!target) throw new Error("No target was provided for `useScroll` hook!");
    return typeof target === "string" ? document.querySelector(target) : target;
}
function setupScroll(fixed, target) {
    const scrollRoot = (0, _vue.shallowRef)();
    let targetElement;
    const isScrolledDown = (0, _vue.ref)(false);
    const prevScrollPosition = (0, _vue.ref)(0);
    const onScroll = (e)=>{
        const target2 = e.target;
        const scrollValue = e.target instanceof Window ? target2.scrollY : target2.scrollTop;
        isScrolledDown.value = prevScrollPosition.value < scrollValue;
        prevScrollPosition.value = scrollValue;
    };
    (0, _vue.onMounted)(()=>{
        targetElement = fixed ? window : getTargetElement(target || scrollRoot.value);
        targetElement == null || targetElement.addEventListener("scroll", onScroll, fixed);
    });
    (0, _vue.onBeforeUnmount)(()=>{
        targetElement == null || targetElement.removeEventListener("scroll", onScroll);
    });
    return {
        scrollRoot,
        isScrolledDown
    };
}

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jcqbN":[function() {},{}],"k7XDA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaAspectRatio);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaAspectRatioVueVueTypeScriptSetupTrueLangJs = require("./VaAspectRatio.vue_vue_type_script_setup_true_lang.js");
const VaAspectRatio = (0, _withConfigTransportJs.w)((0, _vaAspectRatioVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaAspectRatio.vue_vue_type_script_setup_true_lang.js":"92CpE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"92CpE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _vaAspectRatioCss = require("../../../VaAspectRatio.css");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaAspectRatio",
    __name: "VaAspectRatio",
    props: {
        ...(0, _useComponentPresetJs.u),
        ratio: {
            type: [
                Number,
                String
            ],
            default: "auto"
        },
        contentHeight: {
            type: Number,
            default: 1
        },
        contentWidth: {
            type: Number,
            default: 1
        },
        maxWidth: {
            type: [
                Number,
                String
            ],
            default: 0,
            validator: (v)=>Number(v) >= 0
        }
    },
    setup (__props) {
        const props = __props;
        const aspectRatio = (0, _vue.computed)(()=>{
            if (props.ratio === "auto" && props.contentHeight === 1 && props.contentWidth === 1) return 0;
            if (!isNaN(+props.ratio)) return props.ratio;
            return props.contentWidth / props.contentHeight;
        });
        const stylesComputed = (0, _vue.computed)(()=>{
            if (!aspectRatio.value) return;
            return {
                paddingBottom: `${1 / aspectRatio.value * 100}%`
            };
        });
        const maxWidthComputed = (0, _vue.computed)(()=>props.maxWidth ? `${props.maxWidth}px` : void 0);
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: "va-aspect-ratio",
                style: (0, _vue.normalizeStyle)(`--va-max-width-computed: ${String(maxWidthComputed.value)}`)
            }, [
                stylesComputed.value ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                    key: 0,
                    style: (0, _vue.normalizeStyle)(stylesComputed.value)
                }, null, 4)) : (0, _vue.createCommentVNode)("", true),
                (0, _vue.renderSlot)(_ctx.$slots, "default")
            ], 4);
        };
    }
});

},{"vue":"gzxs9","../../composables/useComponentPreset.js":"2HoaT","../../../VaAspectRatio.css":"14p4Z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"14p4Z":[function() {},{}],"gmzbe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaAvatar);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaAvatarVueVueTypeScriptSetupTrueLangJs = require("./VaAvatar.vue_vue_type_script_setup_true_lang.js");
const VaAvatar = (0, _withConfigTransportJs.w)((0, _vaAvatarVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaAvatar.vue_vue_type_script_setup_true_lang.js":"66Ogp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"66Ogp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../vendor.js");
var _indexJs = require("../va-progress-circle/index.js");
var _indexJs1 = require("../va-fallback/index.js");
var _indexJs2 = require("../va-icon/index.js");
var _extractComponentOptionsJs = require("../../utils/component-options/extract-component-options.js");
var _useLoadingJs = require("../../composables/useLoading.js");
var _useSizeJs = require("../../composables/useSize.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useColorsJs = require("../../composables/useColors.js");
var _useTextColorJs = require("../../composables/useTextColor.js");
var _useBemJs = require("../../composables/useBem.js");
var _filterPropsJs = require("../../utils/component-options/filter-props.js");
var _vaAvatarCss = require("../../../VaAvatar.css");
const _hoisted_1 = [
    "src",
    "alt"
];
const VaFallbackPropsDeclaration = (0, _extractComponentOptionsJs.e)((0, _indexJs1.V));
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaAvatar",
    __name: "VaAvatar",
    props: {
        ...(0, _useLoadingJs.u),
        ...(0, _useSizeJs.u),
        ...(0, _useComponentPresetJs.u),
        ...VaFallbackPropsDeclaration,
        color: {
            type: String,
            default: "primary"
        },
        textColor: {
            type: String
        },
        square: {
            type: Boolean,
            default: false
        },
        fontSize: {
            type: String,
            default: ""
        },
        src: {
            type: String,
            default: null
        },
        icon: {
            type: String,
            default: ""
        },
        alt: {
            type: String,
            default: ""
        }
    },
    emits: [
        "error",
        "fallback"
    ],
    setup (__props, { expose: __expose, emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const { getColor } = (0, _useColorsJs.u)();
        const colorComputed = (0, _vue.computed)(()=>getColor(props.color));
        const backgroundColorComputed = (0, _vue.computed)(()=>{
            if (props.loading || props.src && !hasLoadError.value) return void 0;
            return colorComputed.value;
        });
        const { sizeComputed, fontSizeComputed } = (0, _useSizeJs.a)(props, "VaAvatar");
        const { textColorComputed } = (0, _useTextColorJs.u)(backgroundColorComputed);
        const computedStyle = (0, _vue.computed)(()=>({
                fontSize: props.fontSize || fontSizeComputed.value
            }));
        const classesComputed = (0, _useBemJs.u)("va-avatar", ()=>({
                ...(0, _vendorJs.p)(props, [
                    "square"
                ])
            }));
        const hasLoadError = (0, _vue.ref)(false);
        const onLoadError = (event)=>{
            hasLoadError.value = true;
            emit("error", event);
        };
        (0, _vue.watch)(()=>props.src, ()=>{
            hasLoadError.value = false;
        });
        const avatarOptions = (0, _vue.computed)(()=>({
                hasError: hasLoadError.value,
                onError: onLoadError
            }));
        const VaFallbackProps = (0, _filterPropsJs.f)(VaFallbackPropsDeclaration);
        __expose({
            hasLoadError
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: (0, _vue.normalizeClass)([
                    "va-avatar",
                    (0, _vue.unref)(classesComputed)
                ]),
                style: (0, _vue.normalizeStyle)([
                    computedStyle.value,
                    `--va-background-color-computed: ${String(backgroundColorComputed.value)};--va-text-color-computed: ${String((0, _vue.unref)(textColorComputed))};--va-size-computed: ${String((0, _vue.unref)(sizeComputed))}`
                ])
            }, [
                _ctx.$props.loading ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), {
                    key: 0,
                    size: (0, _vue.unref)(sizeComputed),
                    color: colorComputed.value,
                    indeterminate: ""
                }, null, 8, [
                    "size",
                    "color"
                ])) : (0, _vue.renderSlot)(_ctx.$slots, "default", (0, _vue.normalizeProps)((0, _vue.mergeProps)({
                    key: 1
                }, avatarOptions.value)), ()=>[
                        _ctx.$props.src && !hasLoadError.value ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("img", {
                            key: 0,
                            src: _ctx.$props.src,
                            alt: _ctx.$props.alt,
                            onError: onLoadError
                        }, null, 40, _hoisted_1)) : hasLoadError.value && _ctx.$props.src ? (0, _vue.renderSlot)(_ctx.$slots, "fallback", {
                            key: 1
                        }, ()=>[
                                (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs1.V)), (0, _vue.mergeProps)((0, _vue.unref)(VaFallbackProps), {
                                    onFallback: _cache[0] || (_cache[0] = ($event)=>_ctx.$emit("fallback"))
                                }), null, 16)
                            ]) : _ctx.$props.icon ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs2.V)), {
                            key: 2,
                            name: _ctx.$props.icon
                        }, null, 8, [
                            "name"
                        ])) : (0, _vue.renderSlot)(_ctx.$slots, "fallback", {
                            key: 3
                        }, ()=>[
                                (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs1.V)), (0, _vue.mergeProps)((0, _vue.unref)(VaFallbackProps), {
                                    onFallback: _cache[1] || (_cache[1] = ($event)=>_ctx.$emit("fallback"))
                                }), null, 16)
                            ])
                    ])
            ], 6);
        };
    }
});

},{"vue":"gzxs9","../../../vendor.js":"l6TAc","../va-progress-circle/index.js":"dZCnz","../va-fallback/index.js":"3inAD","../va-icon/index.js":"82tPo","../../utils/component-options/extract-component-options.js":"1ODzH","../../composables/useLoading.js":"jYmWj","../../composables/useSize.js":"d4gWT","../../composables/useComponentPreset.js":"2HoaT","../../composables/useColors.js":"a4Qgv","../../composables/useTextColor.js":"5pfXb","../../composables/useBem.js":"igmjV","../../utils/component-options/filter-props.js":"4HycW","../../../VaAvatar.css":"1xRJ1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3inAD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaFallback);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaFallbackVueVueTypeScriptLangJs = require("./VaFallback.vue_vue_type_script_lang.js");
const VaFallback = (0, _withConfigTransportJs.w)((0, _vaFallbackVueVueTypeScriptLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaFallback.vue_vue_type_script_lang.js":"c0kmv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c0kmv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _indexJs = require("../va-icon/index.js");
const _sfc_main = (0, _vue.defineComponent)({
    name: "VaFallback",
    props: {
        fallbackSrc: {
            type: String
        },
        fallbackText: {
            type: String
        },
        fallbackIcon: {
            type: String
        },
        fallbackRender: {
            type: Function
        }
    },
    components: {
        VaIcon: (0, _indexJs.V)
    },
    emits: [
        "fallback"
    ],
    setup (props, { emit }) {
        (0, _vue.onMounted)(()=>{
            emit("fallback");
        });
        if (props.fallbackIcon) return ()=>(0, _vue.h)((0, _indexJs.V), {
                name: props.fallbackIcon
            });
        if (props.fallbackSrc) return ()=>(0, _vue.h)("img", {
                src: props.fallbackSrc
            });
        if (props.fallbackRender) return ()=>{
            var _a;
            return (0, _vue.h)((_a = props.fallbackRender) == null ? void 0 : _a.call(props));
        };
        return ()=>(0, _vue.h)("span", props.fallbackText);
    }
});

},{"vue":"gzxs9","../va-icon/index.js":"82tPo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1ODzH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>extractComponentEmits);
parcelHelpers.export(exports, "e", ()=>extractComponentProps);
var _resolveComponentPropsJs = require("./resolve-component-props.js");
function extractComponentProps(component, ignoreProps) {
    const props = (0, _resolveComponentPropsJs.g)(component);
    if (ignoreProps) return Object.keys(props).reduce((acc, propName)=>{
        if (ignoreProps.includes(propName)) return acc;
        if (props[propName] === void 0) return acc;
        acc[propName] = typeof props[propName] === "string" ? {} : props[propName];
        return acc;
    }, {});
    return props;
}
function extractComponentEmits(component) {
    return [
        ...new Set(component.emits)
    ];
}

},{"./resolve-component-props.js":"giXBP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"giXBP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "g", ()=>getComponentProps);
function normalizeProps(props) {
    switch(true){
        case Array.isArray(props):
            return props.reduce((acc, prop)=>({
                    ...acc,
                    [prop]: null
                }), {});
        case typeof props === "object" && props !== null:
            return props;
        default:
            return {};
    }
}
function mergeProps(to, from, optionsType = "props") {
    const { mixins, extends: extendsOptions } = from;
    extendsOptions && mergeProps(to, extendsOptions, optionsType);
    mixins && mixins.forEach((m)=>mergeProps(to, m, optionsType));
    const props = normalizeProps(from[optionsType]);
    for(const key in props)to[key] = props[key];
}
function getComponentOptions(component) {
    if (component.options) return component.options;
    if (component.__vccOpts || component.__b) return {
        ...component.__vccOpts,
        ...component.__b
    };
    return component;
}
function resolveProps(options, optionsType = "props") {
    const mixins = options.mixins ?? [];
    const extendsOptions = options.extends ?? [];
    const result = {};
    mergeProps(result, extendsOptions, optionsType);
    for(let i = 0; i < mixins.length; i++)mergeProps(result, mixins[i], optionsType);
    Object.assign(result, normalizeProps(options[optionsType]));
    return result;
}
const getComponentProps = (component)=>{
    return resolveProps(getComponentOptions(component));
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4HycW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "f", ()=>filterComponentProps);
var _vue = require("vue");
const filterComponentProps = (childProps)=>{
    const { props } = (0, _vue.getCurrentInstance)();
    return (0, _vue.computed)(()=>{
        return Object.keys(childProps).reduce((acc, propName)=>{
            acc[propName] = props[propName];
            return acc;
        }, {});
    });
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1xRJ1":[function() {},{}],"2I43b":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaAvatarGroup);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaAvatarGroupVueVueTypeScriptSetupTrueLangJs = require("./VaAvatarGroup.vue_vue_type_script_setup_true_lang.js");
const VaAvatarGroup = (0, _withConfigTransportJs.w)((0, _vaAvatarGroupVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaAvatarGroup.vue_vue_type_script_setup_true_lang.js":"tNql5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"tNql5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _indexJs = require("../va-avatar/index.js");
var _vendorJs = require("../../../vendor.js");
var _extractComponentOptionsJs = require("../../utils/component-options/extract-component-options.js");
var _useSizeJs = require("../../composables/useSize.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useBemJs = require("../../composables/useBem.js");
var _filterPropsJs = require("../../utils/component-options/filter-props.js");
var _vaAvatarGroupCss = require("../../../VaAvatarGroup.css");
const VaAvatarProps = (0, _extractComponentOptionsJs.e)((0, _indexJs.V));
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaAvatarGroup",
    __name: "VaAvatarGroup",
    props: {
        ...(0, _useSizeJs.u),
        ...(0, _useComponentPresetJs.u),
        ...VaAvatarProps,
        max: {
            type: Number,
            default: 0
        },
        vertical: {
            type: Boolean,
            default: false
        },
        options: {
            type: Array,
            default: ()=>[]
        },
        /** If there are more avatars that can be displayed we show rest number. This prop changes color of rest indicator. */ restColor: {
            type: String,
            default: "secondary"
        }
    },
    setup (__props) {
        const props = __props;
        const classComputed = (0, _useBemJs.u)("va-avatar-group", ()=>({
                ...(0, _vendorJs.p)(props, [
                    "vertical"
                ])
            }));
        const maxOptions = (0, _vue.computed)(()=>props.max && props.max <= props.options.length ? props.options.slice(0, props.max) : props.options);
        const restOptionsCount = (0, _vue.computed)(()=>{
            const hasOptions = props.options.length > 0;
            const canAddMoreOptions = maxOptions.value.length < props.options.length;
            const remainingOptions = props.options.length - (props.max || 0);
            return hasOptions && canAddMoreOptions ? remainingOptions : 0;
        });
        const { sizeComputed, fontSizeComputed } = (0, _useSizeJs.a)(props, "VaAvatarGroup");
        const filteredAvatarProps = (0, _filterPropsJs.f)(VaAvatarProps);
        const avatarProps = (0, _vue.computed)(()=>({
                ...filteredAvatarProps.value,
                fontSize: fontSizeComputed.value,
                size: sizeComputed.value
            }));
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: (0, _vue.normalizeClass)([
                    "va-avatar-group",
                    (0, _vue.unref)(classComputed)
                ]),
                role: "list"
            }, [
                ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)(maxOptions.value, (option, idx)=>{
                    return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), (0, _vue.mergeProps)({
                        key: idx
                    }, {
                        ...avatarProps.value,
                        ...option
                    }, {
                        role: "listitem"
                    }), null, 16);
                }), 128)),
                restOptionsCount.value > 0 ? (0, _vue.renderSlot)(_ctx.$slots, "rest", (0, _vue.normalizeProps)((0, _vue.mergeProps)({
                    key: 0
                }, avatarProps.value)), ()=>[
                        (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs.V)), (0, _vue.mergeProps)(avatarProps.value, {
                            color: __props.restColor,
                            class: "va-avatar-group__rest",
                            role: "listitem"
                        }), {
                            default: (0, _vue.withCtx)(()=>[
                                    (0, _vue.createTextVNode)(" +" + (0, _vue.toDisplayString)(restOptionsCount.value), 1)
                                ]),
                            _: 1
                        }, 16, [
                            "color"
                        ])
                    ]) : (0, _vue.createCommentVNode)("", true)
            ], 2);
        };
    }
});

},{"vue":"gzxs9","../va-avatar/index.js":"gmzbe","../../../vendor.js":"l6TAc","../../utils/component-options/extract-component-options.js":"1ODzH","../../composables/useSize.js":"d4gWT","../../composables/useComponentPreset.js":"2HoaT","../../composables/useBem.js":"igmjV","../../utils/component-options/filter-props.js":"4HycW","../../../VaAvatarGroup.css":"cRjl5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cRjl5":[function() {},{}],"2A28I":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaBacktop);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaBacktopVueVueTypeScriptSetupTrueLangJs = require("./VaBacktop.vue_vue_type_script_setup_true_lang.js");
const VaBacktop = (0, _withConfigTransportJs.w)((0, _vaBacktopVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaBacktop.vue_vue_type_script_setup_true_lang.js":"5ajmj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5ajmj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _indexJs = require("../va-button/index.js");
var _ssrJs = require("../../utils/ssr.js");
var _consoleJs = require("../../utils/console.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useTranslationJs = require("../../composables/useTranslation.js");
var _vaBacktopCss = require("../../../VaBacktop.css");
const _hoisted_1 = [
    "aria-label",
    "onKeydown"
];
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaBacktop",
    __name: "VaBacktop",
    props: {
        ...(0, _useComponentPresetJs.u),
        target: {
            type: [
                Object,
                String
            ],
            default: void 0
        },
        visibilityHeight: {
            type: Number,
            default: 300
        },
        speed: {
            type: Number,
            default: 50
        },
        verticalOffset: {
            type: String,
            default: "1rem"
        },
        horizontalOffset: {
            type: String,
            default: "1rem"
        },
        color: {
            type: String,
            default: ""
        },
        horizontalPosition: {
            type: String,
            default: "right",
            validator: (value)=>[
                    "right",
                    "left"
                ].includes(value)
        },
        verticalPosition: {
            type: String,
            default: "bottom",
            validator: (value)=>[
                    "bottom",
                    "top"
                ].includes(value)
        },
        ariaLabel: {
            type: String,
            default: "$t:backToTop"
        }
    },
    setup (__props) {
        const props = __props;
        const targetScrollValue = (0, _vue.ref)(0);
        const computedStyle = (0, _vue.computed)(()=>({
                [props.verticalPosition]: props.verticalOffset,
                [props.horizontalPosition]: props.horizontalOffset
            }));
        let targetElement;
        const getTargetElement = ()=>{
            if (!props.target) return window;
            if (typeof props.target === "string") {
                const target = document.querySelector(props.target);
                if (!target) {
                    (0, _consoleJs.w)(`Target element [${props.target}] is not found, falling back to window.`);
                    return window;
                }
                return target;
            }
            return props.target;
        };
        const scrolled = (0, _vue.ref)(false);
        const interval = (0, _vue.ref)(0);
        const scrollToTop = ()=>{
            if (scrolled.value) return;
            scrolled.value = true;
            if (targetElement instanceof Window) {
                window.scrollTo({
                    top: 0,
                    behavior: "smooth"
                });
                return;
            }
            interval.value = window.setInterval(()=>{
                if (targetElement instanceof Element) {
                    if (targetElement.scrollTop === 0) {
                        clearInterval(interval.value);
                        scrolled.value = false;
                    } else {
                        const next = Math.floor(targetElement.scrollTop - props.speed);
                        targetElement.scrollTo(0, next);
                    }
                }
            }, 15);
        };
        const handleScroll = ()=>{
            targetScrollValue.value = targetElement instanceof Window ? targetElement.scrollY : targetElement.scrollTop;
        };
        const server = (0, _ssrJs.i)();
        const visible = (0, _vue.computed)(()=>{
            if (server) return false;
            return targetScrollValue.value > props.visibilityHeight;
        });
        if (!server) {
            (0, _vue.onMounted)(()=>{
                targetElement = getTargetElement();
                targetElement.addEventListener("scroll", handleScroll, true);
            });
            (0, _vue.onBeforeUnmount)(()=>targetElement == null ? void 0 : targetElement.removeEventListener("scroll", handleScroll));
        }
        const { tp, t } = (0, _useTranslationJs.u)();
        return (_ctx, _cache)=>{
            return visible.value ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                key: 0,
                class: "va-backtop",
                role: "button",
                "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaLabel),
                tabindex: "1",
                style: (0, _vue.normalizeStyle)(computedStyle.value),
                onClick: scrollToTop,
                onKeydown: (0, _vue.withKeys)((0, _vue.withModifiers)(scrollToTop, [
                    "stop"
                ]), [
                    "enter"
                ])
            }, [
                (0, _vue.renderSlot)(_ctx.$slots, "default", {}, ()=>[
                        (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs.V)), {
                            "aria-hidden": "true",
                            icon: "va-arrow-up",
                            color: __props.color
                        }, null, 8, [
                            "color"
                        ])
                    ])
            ], 44, _hoisted_1)) : (0, _vue.createCommentVNode)("", true);
        };
    }
});

},{"vue":"gzxs9","../va-button/index.js":"2vhcC","../../utils/ssr.js":"cVJXV","../../utils/console.js":"58L6z","../../composables/useComponentPreset.js":"2HoaT","../../composables/useTranslation.js":"7S3aV","../../../VaBacktop.css":"lPPEG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lPPEG":[function() {},{}],"aHODx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaBadge);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaBadgeVueVueTypeScriptSetupTrueLangJs = require("./VaBadge.vue_vue_type_script_setup_true_lang.js");
const VaBadge = (0, _withConfigTransportJs.w)((0, _vaBadgeVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaBadge.vue_vue_type_script_setup_true_lang.js":"e3HP9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e3HP9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../vendor.js");
var _useFloatingPositionStylesJs = require("./hooks/useFloatingPositionStyles.js");
var _useDeprecatedJs = require("../../composables/useDeprecated.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useBemJs = require("../../composables/useBem.js");
var _useColorsJs = require("../../composables/useColors.js");
var _useTextColorJs = require("../../composables/useTextColor.js");
var _vaBadgeCss = require("../../../VaBadge.css");
const _hoisted_1 = [
    "aria-labelledby"
];
const _hoisted_2 = {
    class: "va-badge__text"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaBadge",
    __name: "VaBadge",
    props: {
        ...(0, _useComponentPresetJs.u),
        ...(0, _useFloatingPositionStylesJs.u),
        color: {
            type: String,
            default: "danger"
        },
        textColor: {
            type: String
        },
        text: {
            type: [
                String,
                Number
            ],
            default: ""
        },
        multiLine: {
            type: Boolean,
            default: false
        },
        visibleEmpty: {
            type: Boolean,
            default: false
        },
        dot: {
            type: Boolean,
            default: false
        },
        // TODO: Remove after 1.8.0
        transparent: {
            type: Boolean,
            default: false
        }
    },
    setup (__props) {
        const props = __props;
        (0, _useDeprecatedJs.u)([
            "transparent"
        ]);
        const slots = (0, _vue.useSlots)();
        const isEmpty = (0, _vue.computed)(()=>!(props.text || props.visibleEmpty || props.dot || slots.text));
        const isFloating = (0, _vue.computed)(()=>!!(slots.default || props.dot));
        const badgeClass = (0, _useBemJs.u)("va-badge", ()=>({
                ...(0, _vendorJs.p)(props, [
                    "visibleEmpty",
                    "dot",
                    "multiLine"
                ]),
                empty: isEmpty.value,
                floating: isFloating.value
            }));
        const { getColor } = (0, _useColorsJs.u)();
        const colorComputed = (0, _vue.computed)(()=>getColor(props.color));
        const { textColorComputed } = (0, _useTextColorJs.u)(colorComputed);
        const positionStylesComputed = (0, _useFloatingPositionStylesJs.a)(props, isFloating);
        const stylesComputed = (0, _vue.computed)(()=>({
                color: textColorComputed.value,
                borderColor: colorComputed.value,
                backgroundColor: colorComputed.value,
                opacity: props.transparent ? 0.5 : 1,
                ...(0, _vue.unref)(positionStylesComputed)
            }));
        const ariaLabelledByComputed = (0, _vue.computed)(()=>props.text ? String(props.text) : void 0);
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: (0, _vue.normalizeClass)([
                    "va-badge",
                    (0, _vue.unref)(badgeClass)
                ]),
                role: "status",
                "aria-labelledby": ariaLabelledByComputed.value
            }, [
                (0, _vue.createElementVNode)("span", {
                    class: "va-badge__text-wrapper",
                    style: (0, _vue.normalizeStyle)(stylesComputed.value)
                }, [
                    (0, _vue.createElementVNode)("span", _hoisted_2, [
                        (0, _vue.renderSlot)(_ctx.$slots, "text", {}, ()=>[
                                (0, _vue.createTextVNode)((0, _vue.toDisplayString)(__props.text), 1)
                            ])
                    ])
                ], 4),
                (0, _vue.renderSlot)(_ctx.$slots, "default")
            ], 10, _hoisted_1);
        };
    }
});

},{"vue":"gzxs9","../../../vendor.js":"l6TAc","./hooks/useFloatingPositionStyles.js":"ep4z2","../../composables/useDeprecated.js":"lOwaK","../../composables/useComponentPreset.js":"2HoaT","../../composables/useBem.js":"igmjV","../../composables/useColors.js":"a4Qgv","../../composables/useTextColor.js":"5pfXb","../../../VaBadge.css":"ctfM4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ep4z2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useFloatingPosition);
parcelHelpers.export(exports, "u", ()=>useFloatingPositionProps);
var _vue = require("vue");
var _usePlacementAliasesJs = require("../../../composables/usePlacementAliases.js");
var _useParsableMeasureJs = require("../../../composables/useParsableMeasure.js");
const { isParsableMeasure, parseSizeValue } = (0, _useParsableMeasureJs.u)();
const useFloatingPositionProps = {
    overlap: {
        type: Boolean,
        default: false
    },
    placement: {
        type: String,
        default: "top-end",
        validator: (position)=>(0, _usePlacementAliasesJs.p).includes(position)
    },
    offset: {
        type: [
            Number,
            String,
            Array
        ],
        default: 0,
        validator: (value)=>{
            if (Array.isArray(value)) return value.every(isParsableMeasure);
            if (typeof value === "string") return isParsableMeasure(value);
            return !isNaN(value);
        }
    }
};
const useFloatingPosition = (props, floating)=>{
    if (!floating.value) return {};
    const { position, align } = (0, _usePlacementAliasesJs.u)(props);
    const alignmentShiftComputed = (0, _vue.computed)(()=>{
        const alignOptions = {
            start: props.overlap ? "-50%" : "-100%",
            center: "-50%",
            end: props.overlap ? "-50%" : "0%"
        };
        return alignOptions[align.value];
    });
    const offsetMarginComputed = (0, _vue.computed)(()=>{
        if (!props.offset) return {};
        const mainAxis = [
            "left",
            "right"
        ].includes(position.value) ? "top" : "left";
        const crossAxis = mainAxis === "top" ? "left" : "top";
        if (Array.isArray(props.offset)) {
            const [x, y] = props.offset.map(parseSizeValue);
            return {
                [`margin-${mainAxis}`]: `${x}px`,
                [`margin-${crossAxis}`]: `${y}px`
            };
        }
        const offset = parseSizeValue(props.offset);
        return {
            [`margin-${crossAxis}`]: `${offset}px`
        };
    });
    const alignmentComputed = (0, _vue.computed)(()=>{
        const mainAxis = [
            "left",
            "right"
        ].includes(position.value) ? "top" : "left";
        const crossAxis = mainAxis === "top" ? "left" : "top";
        let shiftValue = "0%";
        if (crossAxis === "top" && position.value === "bottom") shiftValue = "100%";
        if (crossAxis === "left" && position.value === "right") shiftValue = "100%";
        const alignmentOptions = {
            start: {
                [mainAxis]: "0%",
                [crossAxis]: shiftValue
            },
            center: {
                [mainAxis]: "50%",
                [crossAxis]: shiftValue
            },
            end: {
                [mainAxis]: "100%",
                [crossAxis]: shiftValue
            }
        };
        return alignmentOptions[align.value];
    });
    const transformComputed = (0, _vue.computed)(()=>{
        const coords = {
            top: {
                x: alignmentShiftComputed.value,
                y: props.overlap ? "-50%" : "-100%"
            },
            bottom: {
                x: alignmentShiftComputed.value,
                y: props.overlap ? "-50%" : "0%"
            },
            left: {
                x: props.overlap ? "-50%" : "-100%",
                y: alignmentShiftComputed.value
            },
            right: {
                x: props.overlap ? "-50%" : "0%",
                y: alignmentShiftComputed.value
            }
        };
        const { x, y } = coords[position.value];
        return {
            transform: `translate(${x}, ${y})`
        };
    });
    return (0, _vue.computed)(()=>({
            ...alignmentComputed.value,
            ...transformComputed.value,
            ...offsetMarginComputed.value
        }));
};

},{"vue":"gzxs9","../../../composables/usePlacementAliases.js":"9AS66","../../../composables/useParsableMeasure.js":"3bLfO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9AS66":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>usePlacementAliasesProps);
parcelHelpers.export(exports, "p", ()=>placementsPositionsWithAliases);
parcelHelpers.export(exports, "u", ()=>usePlacementAliases);
var _vue = require("vue");
const verticalPlacement = [
    "top",
    "bottom"
];
const horizontalPlacement = [
    "left",
    "right"
];
const placementPosition = [
    ...verticalPlacement,
    ...horizontalPlacement
];
const placementAlignment = [
    "start",
    "end",
    "center"
];
const placementsPositions = placementPosition.reduce((acc, position)=>{
    acc.push(position);
    placementAlignment.forEach((alignment)=>acc.push(`${position}-${alignment}`));
    return acc;
}, [
    "auto"
]);
const placementAliasesPositions = verticalPlacement.reduce((acc, yPosition)=>{
    horizontalPlacement.forEach((xPosition)=>{
        acc.push(`${yPosition}-${xPosition}`);
        acc.push(`${xPosition}-${yPosition}`);
    });
    return acc;
}, []);
const placementsPositionsWithAliases = [
    ...placementsPositions,
    ...placementAliasesPositions
];
const aliasToPlacement = {
    "top-left": "top-start",
    "left-top": "top-start",
    "top-right": "top-end",
    "right-top": "top-end",
    "bottom-left": "bottom-start",
    "left-bottom": "bottom-start",
    "bottom-right": "bottom-end",
    "right-bottom": "bottom-end"
};
const usePlacementAliasesProps = {
    placement: {
        type: String,
        default: "auto",
        validator: (position)=>placementsPositionsWithAliases.includes(position)
    }
};
const usePlacementAliases = (props)=>{
    const placementArray = (0, _vue.computed)(()=>{
        const placement = aliasToPlacement[props.placement] || props.placement;
        return placement.split("-");
    });
    const position = (0, _vue.computed)(()=>{
        const position2 = placementArray.value[0];
        return position2 === "auto" ? "bottom" : position2;
    });
    const align = (0, _vue.computed)(()=>{
        return placementArray.value[1] || "center";
    });
    return {
        position,
        align
    };
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3bLfO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useParsableMeasure);
var _vue = require("vue");
const useParsableMeasure = ()=>{
    const isParsableMeasure = (value)=>{
        if (typeof value === "string") return !isNaN(+value) || value.endsWith("px") || value.endsWith("rem");
        return false;
    };
    const isParsablePositiveMeasure = (value)=>{
        if (typeof value === "number") return value >= 0;
        return isParsableMeasure(value) && parseInt(value) >= 0;
    };
    const parseSizeValue = (value, pageFontSize = 16)=>{
        const valueUnref = (0, _vue.unref)(value);
        if (typeof valueUnref === "string") {
            const parsedValue = parseInt(valueUnref);
            if (isNaN(parsedValue)) return 0;
            return valueUnref.endsWith("rem") ? parsedValue * (0, _vue.unref)(pageFontSize) : parsedValue;
        }
        return valueUnref;
    };
    return {
        isParsableMeasure,
        isParsablePositiveMeasure,
        parseSizeValue
    };
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lOwaK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useDeprecated);
var _vue = require("vue");
var _envJs = require("../utils/env.js");
const OPTIONS_LIST = {
    props: "prop",
    attrs: "prop",
    slots: "slot"
};
const useDeprecated = (deprecatedList, deprecationSource = [
    "props",
    "attrs"
])=>{
    if (!(0, _envJs.i)) return void 0;
    const instance = (0, _vue.getCurrentInstance)();
    if (!instance) throw new Error("`useDeprecated` hook must be used only inside of setup function!");
    const instanceName = instance.type.name;
    const deprecatedItems = (0, _vue.unref)(deprecatedList);
    deprecationSource.every((source)=>{
        var _a;
        const option = OPTIONS_LIST[source];
        const throwWarning = (key)=>console.warn(`The '${key}' ${option} (${instanceName} component) is deprecated! Please, check the documentation.`);
        if (source === "props") {
            const propsOptions = ((_a = instance.propsOptions) == null ? void 0 : _a[0]) || {};
            const propsValues = instance.props || {};
            deprecatedItems.forEach((propName)=>{
                propsOptions[propName] && propsValues[propName] !== propsOptions[propName].default && throwWarning(propName);
            });
            return true;
        }
        Object.keys({
            ...instance[source]
        }).forEach((key)=>{
            if (deprecatedItems.includes(key)) throwWarning(key);
        });
        return true;
    });
};

},{"vue":"gzxs9","../utils/env.js":"Fmkmq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ctfM4":[function() {},{}],"73olY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaBreadcrumbsItem);
parcelHelpers.export(exports, "a", ()=>VaBreadcrumbs);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaBreadcrumbsVueVueTypeScriptLangJs = require("./VaBreadcrumbs.vue_vue_type_script_lang.js");
var _vaBreadcrumbsItemVueVueTypeScriptSetupTrueLangJs = require("./VaBreadcrumbsItem/VaBreadcrumbsItem.vue_vue_type_script_setup_true_lang.js");
const VaBreadcrumbsItem = (0, _withConfigTransportJs.w)((0, _vaBreadcrumbsItemVueVueTypeScriptSetupTrueLangJs._));
const VaBreadcrumbs = (0, _withConfigTransportJs.w)((0, _vaBreadcrumbsVueVueTypeScriptLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaBreadcrumbs.vue_vue_type_script_lang.js":"c6fsH","./VaBreadcrumbsItem/VaBreadcrumbsItem.vue_vue_type_script_setup_true_lang.js":"4KTDd","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c6fsH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _hasOwnPropertyJs = require("../../utils/has-own-property.js");
var _resolveSlotJs = require("../../utils/resolveSlot.js");
var _useAlignJs = require("../../composables/useAlign.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useColorsJs = require("../../composables/useColors.js");
var _useTranslationJs = require("../../composables/useTranslation.js");
var _vaBreadcrumbsCss = require("../../../VaBreadcrumbs.css");
const _sfc_main = (0, _vue.defineComponent)({
    name: "VaBreadcrumbs",
    props: {
        ...(0, _useAlignJs.u),
        ...(0, _useComponentPresetJs.u),
        separator: {
            type: String,
            default: "/"
        },
        color: {
            type: String,
            default: null
        },
        disabledColor: {
            type: String,
            default: "secondary"
        },
        activeColor: {
            type: String,
            default: null
        },
        separatorColor: {
            type: String,
            default: null
        },
        ariaLabel: {
            type: String,
            default: "$t:breadcrumbs"
        }
    },
    setup (props, { slots }) {
        const { alignComputed } = (0, _useAlignJs.a)(props);
        const { getColor } = (0, _useColorsJs.u)();
        const computedThemesSeparatorColor = (0, _vue.computed)(()=>{
            return props.separatorColor ? getColor(props.separatorColor) : null;
        });
        const computedThemesColor = (0, _vue.computed)(()=>props.color ? getColor(props.color) : null);
        const computedThemesActiveColor = (0, _vue.computed)(()=>{
            return props.activeColor ? getColor(props.activeColor) : null;
        });
        const childNodeFilter = (result, node)=>{
            const nodes = node && node.type === (0, _vue.Fragment) && node.children ? node.children : [
                node
            ];
            return [
                ...result,
                ...nodes.filter((node2)=>{
                    var _a, _b;
                    return !!((_b = (_a = node2 == null ? void 0 : node2.type) == null ? void 0 : _a.name) == null ? void 0 : _b.match(/VaBreadcrumbsItem$/));
                })
            ];
        };
        const createSeparatorComponent = ()=>{
            const separatorNode = (0, _resolveSlotJs.r)(slots.separator) || [
                props.separator
            ];
            return (0, _vue.h)("span", {
                "aria-hidden": true,
                class: [
                    "va-breadcrumbs__separator"
                ],
                style: [
                    {
                        color: computedThemesSeparatorColor.value
                    }
                ]
            }, separatorNode);
        };
        const isDisabledChild = (child)=>{
            const childPropData = child == null ? void 0 : child.props;
            if (!childPropData || !(0, _hasOwnPropertyJs.h)(childPropData, "disabled")) return false;
            if (childPropData.disabled === "") return true;
            return Boolean(childPropData.disabled);
        };
        const isAllChildLinks = (0, _vue.ref)(true);
        const getChildren = ()=>{
            const defaultSlotContent = (0, _resolveSlotJs.r)(slots.default);
            if (!defaultSlotContent) return;
            const childNodes = defaultSlotContent.reduce(childNodeFilter, []) || [];
            const childNodesLength = childNodes.length;
            const isLastIndexChildNodes = (index)=>index === childNodesLength - 1;
            const isChildLink = (child)=>{
                const childPropData = child == null ? void 0 : child.props;
                if (!childPropData || !(0, _hasOwnPropertyJs.h)(childPropData, "to")) return false;
                return !!(childPropData.to && !childPropData.disabled);
            };
            const createChildComponent = (child, index)=>(0, _vue.h)("span", {
                    class: [
                        "va-breadcrumbs__item",
                        {
                            "va-breadcrumbs__item--disabled": isDisabledChild(child)
                        }
                    ],
                    "aria-current": isLastIndexChildNodes(index) && isChildLink(child) ? "location" : false,
                    style: {
                        color: isDisabledChild(child) ? getColor(props.disabledColor) : isLastIndexChildNodes(index) ? computedThemesActiveColor.value : computedThemesColor.value
                    }
                }, [
                    child
                ]);
            const children = [];
            if (childNodesLength) childNodes.forEach((child, index)=>{
                if (isAllChildLinks.value && !isChildLink(child)) isAllChildLinks.value = false;
                children.push(createChildComponent(child, index));
                if (!isLastIndexChildNodes(index)) children.push(createSeparatorComponent());
            });
            return children;
        };
        const { tp } = (0, _useTranslationJs.u)();
        return ()=>(0, _vue.h)("div", {
                class: "va-breadcrumbs",
                style: alignComputed.value,
                role: isAllChildLinks.value ? "navigation" : void 0,
                "aria-label": isAllChildLinks.value ? tp(props.ariaLabel) : void 0
            }, getChildren());
    }
});

},{"vue":"gzxs9","../../utils/has-own-property.js":"l9rEc","../../utils/resolveSlot.js":"felzQ","../../composables/useAlign.js":"9mhWL","../../composables/useComponentPreset.js":"2HoaT","../../composables/useColors.js":"a4Qgv","../../composables/useTranslation.js":"7S3aV","../../../VaBreadcrumbs.css":"2JZD0","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l9rEc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "h", ()=>hasOwnProperty);
const hasOwnProperty = (object, key)=>{
    return Object.prototype.hasOwnProperty.call(object, key);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"felzQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "r", ()=>resolveSlot);
var _vendorJs = require("../../vendor.js");
const resolveSlot = (slot)=>{
    return slot && (0, _vendorJs.g)(slot) ? slot() : slot;
};

},{"../../vendor.js":"l6TAc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9mhWL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useAlign);
parcelHelpers.export(exports, "u", ()=>useAlignProps);
var _vue = require("vue");
const useAlignProps = {
    align: {
        type: String,
        default: "left"
    },
    vertical: {
        type: Boolean,
        default: false
    }
};
const horizontalMap = {
    left: "flex-start",
    center: "center",
    right: "flex-end",
    between: "space-between",
    around: "space-around"
};
const verticalMap = {
    left: "flex-start",
    center: "center",
    right: "flex-end",
    stretch: "stretch"
};
const justify = (align, vertical)=>{
    return vertical ? "center" : align ? horizontalMap[align] : "flex-start";
};
const items = (align, vertical)=>{
    return vertical ? verticalMap[align] : "center";
};
function useAlign(props) {
    const alignComputed = (0, _vue.computed)(()=>{
        return {
            display: "flex",
            flexDirection: props.vertical ? "column" : "row",
            justifyContent: justify(props.align, props.vertical),
            alignItems: items(props.align, props.vertical)
        };
    });
    return {
        alignComputed
    };
}

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2JZD0":[function() {},{}],"4KTDd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useRouterLinkJs = require("../../../composables/useRouterLink.js");
var _vaBreadcrumbsItemCss = require("../../../../VaBreadcrumbsItem.css");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaBreadcrumbsItem",
    __name: "VaBreadcrumbsItem",
    props: {
        ...(0, _useRouterLinkJs.u),
        disabled: {
            type: Boolean,
            default: false
        },
        label: {
            type: String,
            default: ""
        }
    },
    setup (__props) {
        const props = __props;
        const { tagComputed, hrefComputed, isLinkTag } = (0, _useRouterLinkJs.a)(props);
        const classComputed = (0, _vue.computed)(()=>({
                "va-breadcrumb-item--link": isLinkTag.value
            }));
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.resolveDynamicComponent)((0, _vue.unref)(tagComputed)), {
                class: (0, _vue.normalizeClass)([
                    "va-breadcrumb-item",
                    classComputed.value
                ]),
                "active-class": _ctx.$props.activeClass,
                href: (0, _vue.unref)(hrefComputed),
                to: _ctx.$props.to,
                target: _ctx.$props.target,
                replace: _ctx.$props.replace,
                append: _ctx.$props.append,
                exact: _ctx.$props.exact,
                "exact-active-class": _ctx.$props.exactActiveClass
            }, {
                default: (0, _vue.withCtx)(()=>[
                        (0, _vue.renderSlot)(_ctx.$slots, "default", {}, ()=>[
                                (0, _vue.createTextVNode)((0, _vue.toDisplayString)(__props.label), 1)
                            ])
                    ]),
                _: 3
            }, 8, [
                "class",
                "active-class",
                "href",
                "to",
                "target",
                "replace",
                "append",
                "exact",
                "exact-active-class"
            ]);
        };
    }
});

},{"vue":"gzxs9","../../../composables/useRouterLink.js":"bep51","../../../../VaBreadcrumbsItem.css":"gz9MK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gz9MK":[function() {},{}],"jkfpb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaButtonDropdown);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaButtonDropdownVueVueTypeScriptSetupTrueLangJs = require("./VaButtonDropdown.vue_vue_type_script_setup_true_lang.js");
const VaButtonDropdown = (0, _withConfigTransportJs.w)((0, _vaButtonDropdownVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaButtonDropdown.vue_vue_type_script_setup_true_lang.js":"8OOvs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8OOvs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../vendor.js");
var _indexJs = require("../va-button/index.js");
var _indexJs1 = require("../va-button-group/index.js");
var _indexJs2 = require("../va-dropdown/index.js");
var _indexJs3 = require("../va-dropdown/components/VaDropdownContent/index.js");
var _extractComponentOptionsJs = require("../../utils/component-options/extract-component-options.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useStatefulJs = require("../../composables/useStateful.js");
var _usePlacementAliasesJs = require("../../composables/usePlacementAliases.js");
var _useBemJs = require("../../composables/useBem.js");
var _filterPropsJs = require("../../utils/component-options/filter-props.js");
var _useTranslationJs = require("../../composables/useTranslation.js");
var _useEmitProxyJs = require("../../composables/useEmitProxy.js");
var _vaButtonDropdownCss = require("../../../VaButtonDropdown.css");
const { createEmits, createVOnListeners: createListeners } = (0, _useEmitProxyJs.u)([
    "click"
]);
const { createEmits: createMainButtonEmits, createVOnListeners: createMainButtonListeners } = (0, _useEmitProxyJs.u)([
    {
        listen: "click",
        emit: "main-button-click"
    }
]);
const VaButtonProps = (0, _vendorJs.o)((0, _extractComponentOptionsJs.e)((0, _indexJs.V)), [
    "iconRight",
    "block"
]);
const VaDropdownProps = (0, _extractComponentOptionsJs.e)((0, _indexJs2.V));
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaButtonDropdown",
    __name: "VaButtonDropdown",
    props: {
        ...(0, _useComponentPresetJs.u),
        ...VaButtonProps,
        ...VaDropdownProps,
        ...(0, _useStatefulJs.u),
        ...(0, _usePlacementAliasesJs.a),
        modelValue: {
            type: Boolean,
            default: false
        },
        stateful: {
            type: Boolean,
            default: true
        },
        icon: {
            type: String,
            default: "va-arrow-down"
        },
        openedIcon: {
            type: String,
            default: "va-arrow-up"
        },
        hideIcon: {
            type: Boolean,
            default: false
        },
        leftIcon: {
            type: Boolean,
            default: false
        },
        iconColor: {
            type: String,
            default: ""
        },
        disabled: {
            type: Boolean,
            default: false
        },
        disableButton: {
            type: Boolean,
            default: false
        },
        disableDropdown: {
            type: Boolean,
            default: false
        },
        offset: {
            type: [
                Number,
                Array
            ],
            default: 2
        },
        keepAnchorWidth: {
            type: Boolean,
            default: false
        },
        closeOnContentClick: {
            type: Boolean,
            default: true
        },
        split: {
            type: Boolean
        },
        splitTo: {
            type: String,
            default: ""
        },
        splitHref: {
            type: String,
            default: ""
        },
        loading: {
            type: Boolean,
            default: false
        },
        label: {
            type: String
        },
        ariaLabel: {
            type: String,
            default: "$t:toggleDropdown"
        }
    },
    emits: [
        "update:modelValue",
        ...createEmits(),
        ...createMainButtonEmits()
    ],
    setup (__props, { expose: __expose, emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const { valueComputed } = (0, _useStatefulJs.b)(props, emit);
        const computedIcon = (0, _vue.computed)(()=>valueComputed.value ? props.openedIcon : props.icon);
        const computedClass = (0, _useBemJs.u)("va-button-dropdown", ()=>({
                split: props.split
            }));
        const slots = (0, _vue.useSlots)();
        const computedButtonIcons = (0, _vue.computed)(()=>{
            if (props.hideIcon) return {};
            const propName = (props.label || slots.label) && !props.leftIcon ? "icon-right" : "icon";
            return {
                [propName]: computedIcon.value
            };
        });
        const buttonPropsFiltered = (0, _vue.computed)(()=>{
            let ignoredProps = [
                "to",
                "href",
                "loading",
                "icon"
            ];
            const presetProps = [
                "plain",
                "textOpacity",
                "backgroundOpacity",
                "hoverOpacity",
                "hoverBehavior",
                "hoverOpacity",
                "pressedOpacity",
                "pressedBehavior",
                "pressedOpacity"
            ];
            if (props.preset) ignoredProps = [
                ...ignoredProps,
                ...presetProps
            ];
            const filteredProps = (0, _vendorJs.o)(VaButtonProps, ignoredProps);
            return Object.keys(filteredProps);
        });
        const buttonPropsComputed = (0, _vue.computed)(()=>Object.entries(props).filter(([key, _])=>buttonPropsFiltered.value.includes(key)).reduce((acc, [key, value])=>{
                Object.assign(acc, {
                    [key]: value
                });
                return acc;
            }, {}));
        const computedMainButtonProps = (0, _vue.computed)(()=>({
                to: props.splitTo,
                href: props.splitHref,
                loading: props.loading
            }));
        const hideDropdown = ()=>{
            valueComputed.value = false;
        };
        const vaDropdownProps = (0, _filterPropsJs.f)(VaDropdownProps);
        const listeners = createListeners(emit);
        const mainButtonListeners = createMainButtonListeners(emit);
        const { t, tp } = (0, _useTranslationJs.u)();
        __expose({
            hideDropdown
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: (0, _vue.normalizeClass)([
                    "va-button-dropdown",
                    (0, _vue.unref)(computedClass)
                ])
            }, [
                !_ctx.$props.split ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs2.V)), (0, _vue.mergeProps)({
                    key: 0
                }, (0, _vue.unref)(vaDropdownProps), {
                    modelValue: (0, _vue.unref)(valueComputed),
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event)=>(0, _vue.isRef)(valueComputed) ? valueComputed.value = $event : null),
                    disabled: _ctx.$props.disabled || _ctx.$props.disableDropdown
                }), {
                    anchor: (0, _vue.withCtx)(()=>[
                            (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs.V)), (0, _vue.mergeProps)({
                                "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaLabel)
                            }, {
                                ...computedButtonIcons.value,
                                ...buttonPropsComputed.value
                            }, (0, _vue.toHandlers)((0, _vue.unref)(listeners))), {
                                default: (0, _vue.withCtx)(()=>[
                                        (0, _vue.renderSlot)(_ctx.$slots, "label", {}, ()=>[
                                                (0, _vue.createTextVNode)((0, _vue.toDisplayString)(__props.label), 1)
                                            ])
                                    ]),
                                _: 3
                            }, 16, [
                                "aria-label"
                            ])
                        ]),
                    default: (0, _vue.withCtx)(()=>[
                            (0, _vue.renderSlot)(_ctx.$slots, "content", {}, ()=>[
                                    (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs3.V)), null, {
                                        default: (0, _vue.withCtx)(()=>[
                                                (0, _vue.renderSlot)(_ctx.$slots, "default")
                                            ]),
                                        _: 3
                                    })
                                ])
                        ]),
                    _: 3
                }, 16, [
                    "modelValue",
                    "disabled"
                ])) : ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs1.V)), (0, _vue.normalizeProps)((0, _vue.mergeProps)({
                    key: 1
                }, buttonPropsComputed.value)), {
                    default: (0, _vue.withCtx)(()=>[
                            !_ctx.$props.leftIcon ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), (0, _vue.mergeProps)({
                                key: 0,
                                disabled: _ctx.$props.disabled || _ctx.$props.disableButton
                            }, computedMainButtonProps.value, (0, _vue.toHandlers)((0, _vue.unref)(mainButtonListeners))), {
                                default: (0, _vue.withCtx)(()=>[
                                        (0, _vue.renderSlot)(_ctx.$slots, "label", {}, ()=>[
                                                (0, _vue.createTextVNode)((0, _vue.toDisplayString)(__props.label), 1)
                                            ])
                                    ]),
                                _: 3
                            }, 16, [
                                "disabled"
                            ])) : (0, _vue.createCommentVNode)("", true),
                            (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs2.V)), (0, _vue.mergeProps)((0, _vue.unref)(vaDropdownProps), {
                                modelValue: (0, _vue.unref)(valueComputed),
                                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event)=>(0, _vue.isRef)(valueComputed) ? valueComputed.value = $event : null),
                                disabled: _ctx.$props.disabled || _ctx.$props.disableDropdown,
                                teleport: _ctx.$el
                            }), {
                                anchor: (0, _vue.withCtx)(()=>[
                                        (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs.V)), (0, _vue.mergeProps)({
                                            "aria-label": _ctx.$props.ariaLabel || (0, _vue.unref)(t)("toggleDropdown"),
                                            disabled: _ctx.$props.disabled || _ctx.$props.disableDropdown,
                                            icon: computedIcon.value,
                                            "icon-color": _ctx.$props.iconColor
                                        }, (0, _vue.toHandlers)((0, _vue.unref)(listeners)), {
                                            onKeydown: (0, _vue.withKeys)((0, _vue.withModifiers)(hideDropdown, [
                                                "prevent"
                                            ]), [
                                                "esc"
                                            ])
                                        }), null, 16, [
                                            "aria-label",
                                            "disabled",
                                            "icon",
                                            "icon-color",
                                            "onKeydown"
                                        ])
                                    ]),
                                default: (0, _vue.withCtx)(()=>[
                                        (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs3.V)), null, {
                                            default: (0, _vue.withCtx)(()=>[
                                                    (0, _vue.renderSlot)(_ctx.$slots, "default")
                                                ]),
                                            _: 3
                                        })
                                    ]),
                                _: 3
                            }, 16, [
                                "modelValue",
                                "disabled",
                                "teleport"
                            ]),
                            _ctx.$props.leftIcon ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), (0, _vue.mergeProps)({
                                key: 1,
                                disabled: _ctx.$props.disabled || _ctx.$props.disableButton
                            }, computedMainButtonProps.value, (0, _vue.toHandlers)((0, _vue.unref)(mainButtonListeners))), {
                                default: (0, _vue.withCtx)(()=>[
                                        (0, _vue.renderSlot)(_ctx.$slots, "label", {}, ()=>[
                                                (0, _vue.createTextVNode)((0, _vue.toDisplayString)(__props.label), 1)
                                            ])
                                    ]),
                                _: 3
                            }, 16, [
                                "disabled"
                            ])) : (0, _vue.createCommentVNode)("", true)
                        ]),
                    _: 3
                }, 16))
            ], 2);
        };
    }
});

},{"vue":"gzxs9","../../../vendor.js":"l6TAc","../va-button/index.js":"2vhcC","../va-button-group/index.js":"5oEPw","../va-dropdown/index.js":"2ag98","../va-dropdown/components/VaDropdownContent/index.js":"eUpbA","../../utils/component-options/extract-component-options.js":"1ODzH","../../composables/useComponentPreset.js":"2HoaT","../../composables/useStateful.js":"h9zUi","../../composables/usePlacementAliases.js":"9AS66","../../composables/useBem.js":"igmjV","../../utils/component-options/filter-props.js":"4HycW","../../composables/useTranslation.js":"7S3aV","../../composables/useEmitProxy.js":"koywY","../../../VaButtonDropdown.css":"aKvZ6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5oEPw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaButtonGroup);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaButtonGroupVueVueTypeScriptSetupTrueLangJs = require("./VaButtonGroup.vue_vue_type_script_setup_true_lang.js");
const VaButtonGroup = (0, _withConfigTransportJs.w)((0, _vaButtonGroupVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaButtonGroup.vue_vue_type_script_setup_true_lang.js":"20Z6H","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"20Z6H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../vendor.js");
var _indexJs = require("../va-button/index.js");
var _vaConfigVueVueTypeScriptSetupTrueLangJs = require("../va-config/VaConfig.vue_vue_type_script_setup_true_lang.js");
var _extractComponentOptionsJs = require("../../utils/component-options/extract-component-options.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useColorsJs = require("../../composables/useColors.js");
var _useTextColorJs = require("../../composables/useTextColor.js");
var _filterPropsJs = require("../../utils/component-options/filter-props.js");
var _useBemJs = require("../../composables/useBem.js");
var _vaButtonGroupCss = require("../../../VaButtonGroup.css");
const VaButtonProps = (0, _vendorJs.o)((0, _extractComponentOptionsJs.e)((0, _indexJs.V)), [
    "block",
    "gradient"
]);
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaButtonGroup",
    __name: "VaButtonGroup",
    props: {
        ...VaButtonProps,
        ...(0, _useComponentPresetJs.u),
        grow: {
            type: Boolean,
            default: false
        },
        gradient: {
            type: Boolean,
            default: false
        }
    },
    setup (__props) {
        const props = __props;
        const { getColor, getGradientBackground } = (0, _useColorsJs.u)();
        const colorComputed = (0, _vue.computed)(()=>getColor(props.color));
        const { textColorComputed } = (0, _useTextColorJs.u)(colorComputed);
        const filteredProps = (0, _filterPropsJs.f)(VaButtonProps);
        const buttonConfig = (0, _vue.computed)(()=>({
                VaButton: {
                    ...filteredProps.value,
                    ...props.gradient && {
                        color: "#00000000",
                        textColor: textColorComputed.value
                    }
                }
            }));
        const computedClass = (0, _useBemJs.u)("va-button-group", ()=>({
                square: !props.round,
                grow: props.grow,
                small: props.size === "small",
                large: props.size === "large"
            }));
        const backgroundColor = (0, _vue.computed)(()=>props.gradient ? getGradientBackground(colorComputed.value) : "transparent");
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: (0, _vue.normalizeClass)([
                    "va-button-group",
                    (0, _vue.unref)(computedClass)
                ]),
                style: (0, _vue.normalizeStyle)(`--va-background-color: ${String(backgroundColor.value)}`)
            }, [
                (0, _vue.createVNode)((0, _vue.unref)((0, _vaConfigVueVueTypeScriptSetupTrueLangJs._)), {
                    components: buttonConfig.value
                }, {
                    default: (0, _vue.withCtx)(()=>[
                            (0, _vue.renderSlot)(_ctx.$slots, "default")
                        ]),
                    _: 3
                }, 8, [
                    "components"
                ])
            ], 6);
        };
    }
});

},{"vue":"gzxs9","../../../vendor.js":"l6TAc","../va-button/index.js":"2vhcC","../va-config/VaConfig.vue_vue_type_script_setup_true_lang.js":"kIv2h","../../utils/component-options/extract-component-options.js":"1ODzH","../../composables/useComponentPreset.js":"2HoaT","../../composables/useColors.js":"a4Qgv","../../composables/useTextColor.js":"5pfXb","../../utils/component-options/filter-props.js":"4HycW","../../composables/useBem.js":"igmjV","../../../VaButtonGroup.css":"5h5t2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5h5t2":[function() {},{}],"2ag98":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaDropdown);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaDropdownVueVueTypeScriptLangJs = require("./VaDropdown.vue_vue_type_script_lang.js");
const VaDropdown = (0, _withConfigTransportJs.w)((0, _vaDropdownVueVueTypeScriptLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaDropdown.vue_vue_type_script_lang.js":"jUSur","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jUSur":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../vendor.js");
var _headlessJs = require("../../utils/headless.js");
var _useDropdownNavigationJs = require("./hooks/useDropdownNavigation.js");
var _useAnchorSelectorJs = require("./hooks/useAnchorSelector.js");
var _useCursorAnchorJs = require("./hooks/useCursorAnchor.js");
var _useDropdownJs = require("./hooks/useDropdown.js");
var _consoleJs = require("../../utils/console.js");
var _useFocusOutsideJs = require("../../composables/useFocusOutside.js");
var _useTeleportedJs = require("../../composables/useTeleported.js");
var _useZIndexJs = require("../../composables/useZIndex.js");
var _focusJs = require("../../utils/focus.js");
var _unwrapElJs = require("../../utils/unwrapEl.js");
var _usePlacementAliasesJs = require("../../composables/usePlacementAliases.js");
var _useStatefulJs = require("../../composables/useStateful.js");
var _useHTMLElementSelectorJs = require("../../composables/useHTMLElementSelector.js");
var _useBemJs = require("../../composables/useBem.js");
var _useClickOutsideJs = require("../../composables/useClickOutside.js");
var _useTranslationJs = require("../../composables/useTranslation.js");
var _useIsMountedJs = require("../../composables/useIsMounted.js");
var _useHTMLElementJs = require("../../composables/useHTMLElement.js");
var _vaDropdownCss = require("../../../VaDropdown.css");
const _sfc_main = (0, _vue.defineComponent)({
    name: "VaDropdown",
    props: {
        ...(0, _usePlacementAliasesJs.a),
        ...(0, _useStatefulJs.c)(true),
        modelValue: {
            type: Boolean,
            default: false
        },
        anchor: {
            type: [
                String,
                Object
            ],
            default: void 0
        },
        anchorSelector: {
            type: String,
            default: ""
        },
        innerAnchorSelector: {
            type: String,
            default: ""
        },
        trigger: {
            type: [
                String,
                Array
            ],
            default: ()=>[
                    "click",
                    "space",
                    "enter",
                    "arrow-down",
                    "arrow-up"
                ]
        },
        disabled: {
            type: Boolean
        },
        readonly: {
            type: Boolean
        },
        closeOnClickOutside: {
            type: Boolean,
            default: true
        },
        closeOnFocusOutside: {
            type: Boolean,
            default: true
        },
        closeOnAnchorClick: {
            type: Boolean,
            default: true
        },
        closeOnContentClick: {
            type: Boolean,
            default: true
        },
        hoverOverTimeout: {
            type: Number,
            default: 30
        },
        hoverOutTimeout: {
            type: Number,
            default: 200
        },
        isContentHoverable: {
            type: Boolean,
            default: true
        },
        offset: {
            type: [
                Array,
                Number
            ],
            default: 0
        },
        keepAnchorWidth: {
            type: Boolean,
            default: false
        },
        verticalScrollOnOverflow: {
            type: Boolean,
            default: true
        },
        cursor: {
            type: [
                Boolean,
                Object
            ],
            default: false
        },
        autoPlacement: {
            type: Boolean,
            default: true
        },
        stickToEdges: {
            type: Boolean,
            default: false
        },
        /** Viewport where dropdown will be rendered. Autoplacement will be calculated relative to `target` */ target: {
            type: [
                String,
                Object
            ],
            default: void 0
        },
        /** Element where dropdown content will be rendered. */ teleport: {
            type: [
                String,
                Object
            ],
            default: void 0
        },
        /** Not reactive */ keyboardNavigation: {
            type: Boolean,
            default: true
        },
        ariaLabel: {
            type: String,
            default: "$t:toggleDropdown"
        },
        role: {
            type: String,
            default: "button"
        }
    },
    emits: [
        ...(0, _useStatefulJs.a),
        "anchor-click",
        "anchor-right-click",
        "content-click",
        "click-outside",
        "focus-outside",
        "close",
        "open",
        "anchor-dblclick"
    ],
    setup (props, { emit }) {
        const { valueComputed } = (0, _useStatefulJs.b)(props, emit, "modelValue");
        (0, _vue.watch)(valueComputed, (isOpened)=>{
            if (isOpened) emit("open");
            else emit("close");
        });
        const isMounted = (0, _useIsMountedJs.u)();
        const { anchorRef } = (0, _useAnchorSelectorJs.u)(props);
        const cursorAnchor = (0, _useCursorAnchorJs.u)(anchorRef, (0, _vue.computed)(()=>Boolean(props.cursor)));
        const floating = (0, _useHTMLElementJs.u)("floating");
        const body = (0, _useHTMLElementSelectorJs.u)((0, _vue.ref)("body"));
        const target = (0, _useHTMLElementSelectorJs.u)((0, _vue.computed)(()=>props.target));
        const teleport = (0, _useHTMLElementSelectorJs.u)((0, _vue.computed)(()=>props.teleport));
        const anchorClass = (0, _useBemJs.u)("va-dropdown", ()=>(0, _vendorJs.p)(props, [
                "disabled"
            ]));
        const teleportTarget = (0, _vue.computed)(()=>{
            if (teleport.value) return teleport.value;
            if (target.value) return target.value;
            if (anchorRef.value) {
                const root = anchorRef.value.getRootNode();
                if (root instanceof ShadowRoot) {
                    const el = [
                        ...root.children
                    ].find((c)=>c.tagName !== "STYLE");
                    if (el) return el;
                }
            }
            return body.value;
        });
        const showFloating = (0, _vue.computed)(()=>isMounted.value && valueComputed.value);
        (0, _useDropdownNavigationJs.u)(valueComputed, anchorRef, floating, props);
        const emitAndClose = (eventName, close, e)=>{
            emit(eventName, e);
            if (close) valueComputed.value = false;
        };
        (0, _useClickOutsideJs.u)([
            anchorRef,
            floating
        ], ()=>{
            if (props.closeOnClickOutside && valueComputed.value) emitAndClose("click-outside", props.closeOnClickOutside);
        });
        (0, _useFocusOutsideJs.u)([
            floating
        ], ()=>{
            if (props.closeOnFocusOutside && valueComputed.value) emitAndClose("focus-outside", props.closeOnFocusOutside);
        }, {
            onlyKeyboard: true
        });
        const anchorComputed = (0, _vue.computed)(()=>{
            if (typeof props.cursor === "object") return props.cursor;
            return props.cursor ? cursorAnchor.value : anchorRef.value;
        });
        const { floatingStyles } = (0, _useDropdownJs.u)(anchorComputed, floating, target, (0, _vue.computed)(()=>({
                placement: props.placement,
                offset: props.offset,
                autoPlacement: props.autoPlacement,
                stickToEdges: props.stickToEdges,
                keepAnchorWidth: props.keepAnchorWidth,
                verticalScrollOnOverflow: props.verticalScrollOnOverflow
            })));
        const hide = ()=>{
            valueComputed.value = false;
        };
        const show = ()=>{
            valueComputed.value = true;
        };
        const { zIndex } = (0, _useZIndexJs.u)(valueComputed);
        (0, _vue.watch)(valueComputed, (isOpened)=>{
            if (!props.keyboardNavigation) return;
            if (isOpened) (0, _vue.nextTick)(()=>{
                const el = (0, _unwrapElJs.u)(floating.value);
                if (!el) return;
                (0, _focusJs.f)(el);
            });
            else {
                if (!anchorRef.value) return;
                (0, _focusJs.f)(anchorRef.value);
            }
        });
        return {
            ...(0, _useTranslationJs.u)(),
            ...(0, _useTeleportedJs.u)(),
            anchorRef,
            anchorClass,
            floating,
            floatingStyles,
            showFloating,
            teleportTarget,
            isMounted,
            valueComputed,
            hide,
            show,
            zIndex
        };
    },
    render () {
        const slotBind = {
            isOpened: this.valueComputed,
            hide: this.hide,
            show: this.show,
            toggle: ()=>this.valueComputed ? this.hide() : this.show(),
            getAnchorWidth: ()=>{
                var _a;
                return ((_a = this.anchorRef) == null ? void 0 : _a.offsetWidth) + "px";
            },
            getAnchorHeight: ()=>{
                var _a;
                return ((_a = this.anchorRef) == null ? void 0 : _a.offsetHeight) + "px";
            }
        };
        const floatingSlotNode = this.showFloating && (0, _headlessJs.a)(this.$slots.default, slotBind, {
            ref: "floating",
            class: "va-dropdown__content-wrapper",
            style: [
                this.floatingStyles,
                {
                    zIndex: this.zIndex
                }
            ],
            ...this.teleportedAttrs
        });
        const anchorSlotVNode = (0, _headlessJs.a)(this.$slots.anchor, slotBind, {
            ref: "anchorRef",
            role: this.$props.role,
            class: [
                "va-dropdown",
                ...this.anchorClass.asArray.value
            ],
            style: {
                position: "relative"
            },
            "aria-label": this.tp(this.$props.ariaLabel),
            "aria-disabled": this.$props.disabled,
            "aria-expanded": this.$props.role && this.$props.role !== "none" ? !!this.showFloating : void 0,
            ...this.teleportFromAttrs,
            ...this.$attrs
        });
        if (typeof this.$props.cursor === "object" && floatingSlotNode) return (0, _vue.h)((0, _vue.Teleport), {
            to: this.teleportTarget,
            disabled: this.$props.disabled
        }, [
            floatingSlotNode
        ]);
        if (!this.$props.anchorSelector && !anchorSlotVNode) {
            (0, _consoleJs.w)("VaDropdown: #anchor slot is missing");
            return;
        }
        if (this.showFloating && !floatingSlotNode) {
            (0, _consoleJs.w)("VaDropdown: default slot is missing");
            return;
        }
        return (0, _vue.h)((0, _vue.Fragment), {}, [
            anchorSlotVNode,
            floatingSlotNode && (0, _vue.h)((0, _vue.Teleport), {
                to: this.teleportTarget,
                disabled: this.$props.disabled
            }, [
                floatingSlotNode
            ])
        ]);
    }
});

},{"vue":"gzxs9","../../../vendor.js":"l6TAc","../../utils/headless.js":"fM1sq","./hooks/useDropdownNavigation.js":"iWPMz","./hooks/useAnchorSelector.js":"alUIJ","./hooks/useCursorAnchor.js":"21r0l","./hooks/useDropdown.js":"568GX","../../utils/console.js":"58L6z","../../composables/useFocusOutside.js":"72qWX","../../composables/useTeleported.js":"66noR","../../composables/useZIndex.js":"kgPYx","../../utils/focus.js":"e1Xlj","../../utils/unwrapEl.js":"bYHKv","../../composables/usePlacementAliases.js":"9AS66","../../composables/useStateful.js":"h9zUi","../../composables/useHTMLElementSelector.js":"hUyn3","../../composables/useBem.js":"igmjV","../../composables/useClickOutside.js":"4ZW8J","../../composables/useTranslation.js":"7S3aV","../../composables/useIsMounted.js":"dEE9p","../../composables/useHTMLElement.js":"1Yk4Z","../../../VaDropdown.css":"212pc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iWPMz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useNavigation);
var _vue = require("vue");
var _useDebounceJs = require("../../../composables/useDebounce.js");
var _useEventJs = require("../../../composables/useEvent.js");
const isTyping = (e)=>{
    const target = e.target;
    if (!(target.tagName === "INPUT" || target.tagName === "TEXTAREA")) return false;
    if (target.attributes.getNamedItem("readonly")) return false;
    return true;
};
const isReadonlyArray = (arr)=>{
    return Array.isArray(arr);
};
const useNavigation = (isOpen, anchorRef, contentRef, props)=>{
    const normalizeTriggerName = (t)=>{
        t = t.replace(/-/g, "").toLowerCase();
        if (t === "space") return " ";
        if (t === "rightclick") return "contextmenu";
        return t;
    };
    const normalizedTriggers = (0, _vue.computed)(()=>{
        if (isReadonlyArray(props.trigger)) return props.trigger.map((t)=>normalizeTriggerName(t));
        return [
            normalizeTriggerName(props.trigger)
        ];
    });
    (0, _useEventJs.u)("keydown", (e)=>{
        if (props.disabled) return;
        if (e.key === "Escape" && isOpen.value) {
            isOpen.value = false;
            e.preventDefault();
        }
        if (isTyping(e)) return;
        if (normalizedTriggers.value.includes(normalizeTriggerName(e.key))) {
            isOpen.value = !isOpen.value;
            e.preventDefault();
        }
    }, anchorRef);
    (0, _useEventJs.u)("keydown", (e)=>{
        if (props.disabled) return;
        if (e.key === "Escape" && isOpen.value) {
            isOpen.value = false;
            e.preventDefault();
        }
    }, contentRef);
    (0, _useEventJs.u)([
        "click",
        "contextmenu",
        "dblclick"
    ], (e)=>{
        if (props.disabled) return;
        if (isTyping(e)) return;
        if (normalizedTriggers.value.includes(normalizeTriggerName(e.type))) {
            e.preventDefault();
            if (isOpen.value && props.closeOnAnchorClick) {
                isOpen.value = false;
                if (props.cursor) setTimeout(()=>{
                    isOpen.value = true;
                }, 16);
            } else isOpen.value = true;
        }
    }, anchorRef);
    (0, _useEventJs.u)([
        "click",
        "contextmenu",
        "dblclick"
    ], (e)=>{
        if (props.closeOnContentClick) isOpen.value = false;
    }, contentRef);
    const { debounced: debounceHover, cancel: cancelHoverDebounce } = (0, _useDebounceJs.u)((0, _vue.toRef)(props, "hoverOverTimeout"));
    const { debounced: debounceUnHover, cancel: cancelUnHoverDebounce } = (0, _useDebounceJs.u)((0, _vue.toRef)(props, "hoverOutTimeout"));
    const onMouseHover = (e)=>{
        if (props.disabled) return;
        if (!normalizedTriggers.value.includes("hover")) return;
        if (e.type === "mouseleave") {
            cancelHoverDebounce();
            if (!props.isContentHoverable) {
                isOpen.value = false;
                return;
            }
            debounceUnHover(()=>{
                isOpen.value = false;
            });
        } else {
            cancelUnHoverDebounce();
            debounceHover(()=>{
                isOpen.value = true;
            });
        }
    };
    (0, _useEventJs.u)([
        "mouseleave",
        "mouseenter"
    ], onMouseHover, anchorRef);
    (0, _useEventJs.u)([
        "mouseleave",
        "mouseenter"
    ], onMouseHover, contentRef);
};

},{"vue":"gzxs9","../../../composables/useDebounce.js":"bbX3Y","../../../composables/useEvent.js":"9kzUn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bbX3Y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useDebounceFn);
var _vue = require("vue");
var _vendorJs = require("../../vendor.js");
const useDebounceFn = (timeout)=>{
    let callback = null;
    const createDebounced = ()=>{
        return (0, _vendorJs.d)(()=>{
            callback == null || callback();
            callback = null;
        }, (0, _vue.unref)(timeout));
    };
    let debounced = createDebounced();
    if ((0, _vue.isRef)(timeout)) (0, _vue.watch)(timeout, ()=>{
        debounced = createDebounced();
    });
    return {
        // todo check if we need to create proxy here
        debounced: (cb)=>{
            callback = cb;
            debounced();
        },
        cancel: ()=>debounced.cancel()
    };
};

},{"vue":"gzxs9","../../vendor.js":"l6TAc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"alUIJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useAnchorSelector);
var _vue = require("vue");
var _unwrapElJs = require("../../../utils/unwrapEl.js");
var _useDocumentJs = require("../../../composables/useDocument.js");
var _useIsMountedJs = require("../../../composables/useIsMounted.js");
const useAnchorSelector = (props)=>{
    const anchorRef = (0, _vue.ref)();
    const document = (0, _useDocumentJs.u)();
    const isMounted = (0, _useIsMountedJs.u)();
    const computedAnchorRef = (0, _vue.computed)({
        set (v) {
            anchorRef.value = (0, _unwrapElJs.u)(v);
        },
        get () {
            var _a, _b, _c;
            isMounted.value;
            if (typeof props.anchor === "string") return ((_a = document.value) == null ? void 0 : _a.querySelector(props.anchor)) ?? anchorRef.value;
            if (typeof props.anchor === "object") return props.anchor;
            if (props.anchorSelector) return ((_b = document.value) == null ? void 0 : _b.querySelector(props.anchorSelector)) ?? anchorRef.value;
            else if (props.innerAnchorSelector && anchorRef.value) return ((_c = anchorRef.value) == null ? void 0 : _c.querySelector(props.innerAnchorSelector)) ?? anchorRef.value;
            return anchorRef.value;
        }
    });
    return {
        anchorRef: computedAnchorRef
    };
};

},{"vue":"gzxs9","../../../utils/unwrapEl.js":"bYHKv","../../../composables/useDocument.js":"403q6","../../../composables/useIsMounted.js":"dEE9p","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dEE9p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useIsMounted);
var _vue = require("vue");
const useIsMounted = ()=>{
    const isMounted = (0, _vue.ref)(false);
    (0, _vue.onMounted)(()=>{
        isMounted.value = true;
    });
    (0, _vue.onBeforeUnmount)(()=>{
        isMounted.value = false;
    });
    return isMounted;
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"21r0l":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useCursorAnchor);
var _vue = require("vue");
var _useEventJs = require("../../../composables/useEvent.js");
const useCursorAnchor = (anchorRef, enabled)=>{
    const position = (0, _vue.reactive)({
        x: 0,
        y: 0
    });
    (0, _useEventJs.u)([
        "mousemove",
        "mousedown",
        "mouseup"
    ], (e)=>{
        var _a;
        if (!enabled.value) return;
        const { x, y } = ((_a = anchorRef.value) == null ? void 0 : _a.getBoundingClientRect()) ?? {
            x: 0,
            y: 0
        };
        position.x = e.clientX - x;
        position.y = e.clientY - y;
    }, anchorRef);
    return (0, _vue.computed)(()=>{
        return {
            getBoundingClientRect () {
                var _a;
                const { x, y } = ((_a = anchorRef.value) == null ? void 0 : _a.getBoundingClientRect()) ?? {
                    x: 0,
                    y: 0
                };
                const resX = position.x + x;
                const resY = position.y + y;
                return {
                    width: 0,
                    height: 0,
                    x: resX,
                    y: resY,
                    top: resY,
                    right: resX,
                    bottom: resY,
                    left: resX
                };
            },
            contextElement: anchorRef.value
        };
    });
};

},{"vue":"gzxs9","../../../composables/useEvent.js":"9kzUn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"568GX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useDropdown);
var _vue = require("vue");
var _vue1 = require("@floating-ui/vue");
var _usePlacementAliasesJs = require("../../../composables/usePlacementAliases.js");
const useDropdown = (anchorComputed, floating, target, options)=>{
    const placementComputed = (0, _vue.computed)(()=>{
        const { position, align } = (0, _usePlacementAliasesJs.u)({
            placement: options.value.placement
        });
        return `${position.value}-${align.value}`;
    });
    const offsetComputed = (0, _vue.computed)(()=>{
        const dropdownOffset = options.value.offset;
        const result = {
            mainAxis: 0,
            crossAxis: 0
        };
        if (Array.isArray(dropdownOffset)) {
            result.mainAxis = dropdownOffset[0];
            result.crossAxis = dropdownOffset[1];
        }
        if (typeof dropdownOffset === "number") result.mainAxis = dropdownOffset;
        return result;
    });
    const middlewareComputed = (0, _vue.computed)(()=>{
        const { autoPlacement, stickToEdges, keepAnchorWidth, verticalScrollOnOverflow } = options.value;
        const result = [
            (0, _vue1.offset)(offsetComputed.value)
        ];
        if (autoPlacement) result.push(// boundary doesn't work with ssr (trying to access document)
        (0, _vue1.flip)({
            boundary: target.value
        }));
        if (stickToEdges) result.push((0, _vue1.shift)());
        if (keepAnchorWidth || verticalScrollOnOverflow) result.push((0, _vue1.size)({
            apply ({ elements, availableHeight }) {
                if (keepAnchorWidth) {
                    const reference = elements.reference;
                    const availableWidth = reference.getBoundingClientRect().width;
                    Object.assign(elements.floating.style, {
                        // Don't set width here, because some plugin applies width 100% and it breaks layout
                        maxWidth: `${availableWidth}px`,
                        minWidth: `${availableWidth}px`
                    });
                }
                if (verticalScrollOnOverflow) Object.assign(elements.floating.style, {
                    maxHeight: `${availableHeight}px`
                });
            }
        }));
        return result;
    });
    const { floatingStyles, isPositioned } = typeof document === "undefined" ? {
        floatingStyles: {},
        isPositioned: (0, _vue.ref)(false)
    } : (0, _vue1.useFloating)(anchorComputed, floating, {
        placement: placementComputed,
        whileElementsMounted: (0, _vue1.autoUpdate),
        middleware: middlewareComputed,
        transform: true
    });
    return {
        // Because floating ui by default set top and left to 0 before position calculated, dropdown jumps to the left top corner
        // If user wants to make focus on el as soon as Dropdown is opened, page will be scrolled on the left top corner
        floatingStyles: (0, _vue.computed)(()=>{
            if (!isPositioned.value) return {
                position: "fixed"
            };
            return floatingStyles.value;
        }),
        isPositioned
    };
};

},{"vue":"gzxs9","@floating-ui/vue":"8X8fs","../../../composables/usePlacementAliases.js":"9AS66","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8X8fs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "autoPlacement", ()=>(0, _dom.autoPlacement));
parcelHelpers.export(exports, "autoUpdate", ()=>(0, _dom.autoUpdate));
parcelHelpers.export(exports, "computePosition", ()=>(0, _dom.computePosition));
parcelHelpers.export(exports, "detectOverflow", ()=>(0, _dom.detectOverflow));
parcelHelpers.export(exports, "flip", ()=>(0, _dom.flip));
parcelHelpers.export(exports, "getOverflowAncestors", ()=>(0, _dom.getOverflowAncestors));
parcelHelpers.export(exports, "hide", ()=>(0, _dom.hide));
parcelHelpers.export(exports, "inline", ()=>(0, _dom.inline));
parcelHelpers.export(exports, "limitShift", ()=>(0, _dom.limitShift));
parcelHelpers.export(exports, "offset", ()=>(0, _dom.offset));
parcelHelpers.export(exports, "platform", ()=>(0, _dom.platform));
parcelHelpers.export(exports, "shift", ()=>(0, _dom.shift));
parcelHelpers.export(exports, "size", ()=>(0, _dom.size));
parcelHelpers.export(exports, "arrow", ()=>arrow);
parcelHelpers.export(exports, "useFloating", ()=>useFloating);
var _dom = require("@floating-ui/dom");
var _vueDemi = require("vue-demi");
var _dom1 = require("@floating-ui/utils/dom");
function isComponentPublicInstance(target) {
    return target != null && typeof target === "object" && "$el" in target;
}
function unwrapElement(target) {
    if (isComponentPublicInstance(target)) {
        const element = target.$el;
        return (0, _dom1.isNode)(element) && (0, _dom1.getNodeName)(element) === "#comment" ? null : element;
    }
    return target;
}
/**
 * Positions an inner element of the floating element such that it is centered to the reference element.
 * @param options The arrow options.
 * @see https://floating-ui.com/docs/arrow
 */ function arrow(options) {
    return {
        name: "arrow",
        options,
        fn (args) {
            const element = unwrapElement((0, _vueDemi.unref)(options.element));
            if (element == null) return {};
            return (0, _dom.arrow)({
                element,
                padding: options.padding
            }).fn(args);
        }
    };
}
function getDPR(element) {
    if (typeof window === "undefined") return 1;
    const win = element.ownerDocument.defaultView || window;
    return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
    const dpr = getDPR(element);
    return Math.round(value * dpr) / dpr;
}
/**
 * Computes the `x` and `y` coordinates that will place the floating element next to a reference element when it is given a certain CSS positioning strategy.
 * @param reference The reference template ref.
 * @param floating The floating template ref.
 * @param options The floating options.
 * @see https://floating-ui.com/docs/vue
 */ function useFloating(reference, floating, options) {
    if (options === void 0) options = {};
    const whileElementsMountedOption = options.whileElementsMounted;
    const openOption = (0, _vueDemi.computed)(()=>{
        var _unref;
        return (_unref = (0, _vueDemi.unref)(options.open)) != null ? _unref : true;
    });
    const middlewareOption = (0, _vueDemi.computed)(()=>(0, _vueDemi.unref)(options.middleware));
    const placementOption = (0, _vueDemi.computed)(()=>{
        var _unref2;
        return (_unref2 = (0, _vueDemi.unref)(options.placement)) != null ? _unref2 : "bottom";
    });
    const strategyOption = (0, _vueDemi.computed)(()=>{
        var _unref3;
        return (_unref3 = (0, _vueDemi.unref)(options.strategy)) != null ? _unref3 : "absolute";
    });
    const transformOption = (0, _vueDemi.computed)(()=>{
        var _unref4;
        return (_unref4 = (0, _vueDemi.unref)(options.transform)) != null ? _unref4 : true;
    });
    const referenceElement = (0, _vueDemi.computed)(()=>unwrapElement(reference.value));
    const floatingElement = (0, _vueDemi.computed)(()=>unwrapElement(floating.value));
    const x = (0, _vueDemi.ref)(0);
    const y = (0, _vueDemi.ref)(0);
    const strategy = (0, _vueDemi.ref)(strategyOption.value);
    const placement = (0, _vueDemi.ref)(placementOption.value);
    const middlewareData = (0, _vueDemi.shallowRef)({});
    const isPositioned = (0, _vueDemi.ref)(false);
    const floatingStyles = (0, _vueDemi.computed)(()=>{
        const initialStyles = {
            position: strategy.value,
            left: "0",
            top: "0"
        };
        if (!floatingElement.value) return initialStyles;
        const xVal = roundByDPR(floatingElement.value, x.value);
        const yVal = roundByDPR(floatingElement.value, y.value);
        if (transformOption.value) return {
            ...initialStyles,
            transform: "translate(" + xVal + "px, " + yVal + "px)",
            ...getDPR(floatingElement.value) >= 1.5 && {
                willChange: "transform"
            }
        };
        return {
            position: strategy.value,
            left: xVal + "px",
            top: yVal + "px"
        };
    });
    let whileElementsMountedCleanup;
    function update() {
        if (referenceElement.value == null || floatingElement.value == null) return;
        (0, _dom.computePosition)(referenceElement.value, floatingElement.value, {
            middleware: middlewareOption.value,
            placement: placementOption.value,
            strategy: strategyOption.value
        }).then((position)=>{
            x.value = position.x;
            y.value = position.y;
            strategy.value = position.strategy;
            placement.value = position.placement;
            middlewareData.value = position.middlewareData;
            isPositioned.value = true;
        });
    }
    function cleanup() {
        if (typeof whileElementsMountedCleanup === "function") {
            whileElementsMountedCleanup();
            whileElementsMountedCleanup = undefined;
        }
    }
    function attach() {
        cleanup();
        if (whileElementsMountedOption === undefined) {
            update();
            return;
        }
        if (referenceElement.value != null && floatingElement.value != null) {
            whileElementsMountedCleanup = whileElementsMountedOption(referenceElement.value, floatingElement.value, update);
            return;
        }
    }
    function reset() {
        if (!openOption.value) isPositioned.value = false;
    }
    (0, _vueDemi.watch)([
        middlewareOption,
        placementOption,
        strategyOption
    ], update, {
        flush: "sync"
    });
    (0, _vueDemi.watch)([
        referenceElement,
        floatingElement
    ], attach, {
        flush: "sync"
    });
    (0, _vueDemi.watch)(openOption, reset, {
        flush: "sync"
    });
    if ((0, _vueDemi.getCurrentScope)()) (0, _vueDemi.onScopeDispose)(cleanup);
    return {
        x: (0, _vueDemi.shallowReadonly)(x),
        y: (0, _vueDemi.shallowReadonly)(y),
        strategy: (0, _vueDemi.shallowReadonly)(strategy),
        placement: (0, _vueDemi.shallowReadonly)(placement),
        middlewareData: (0, _vueDemi.shallowReadonly)(middlewareData),
        isPositioned: (0, _vueDemi.shallowReadonly)(isPositioned),
        floatingStyles,
        update
    };
}

},{"@floating-ui/dom":"1xb7B","vue-demi":"aJ86l","@floating-ui/utils/dom":"aBFfa","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1xb7B":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "detectOverflow", ()=>(0, _core.detectOverflow));
parcelHelpers.export(exports, "offset", ()=>(0, _core.offset));
parcelHelpers.export(exports, "getOverflowAncestors", ()=>(0, _dom.getOverflowAncestors));
parcelHelpers.export(exports, "arrow", ()=>arrow);
parcelHelpers.export(exports, "autoPlacement", ()=>autoPlacement);
parcelHelpers.export(exports, "autoUpdate", ()=>autoUpdate);
parcelHelpers.export(exports, "computePosition", ()=>computePosition);
parcelHelpers.export(exports, "flip", ()=>flip);
parcelHelpers.export(exports, "hide", ()=>hide);
parcelHelpers.export(exports, "inline", ()=>inline);
parcelHelpers.export(exports, "limitShift", ()=>limitShift);
parcelHelpers.export(exports, "platform", ()=>platform);
parcelHelpers.export(exports, "shift", ()=>shift);
parcelHelpers.export(exports, "size", ()=>size);
var _core = require("@floating-ui/core");
var _utils = require("@floating-ui/utils");
var _dom = require("@floating-ui/utils/dom");
function getCssDimensions(element) {
    const css = (0, _dom.getComputedStyle)(element);
    // In testing environments, the `width` and `height` properties are empty
    // strings for SVG elements, returning NaN. Fallback to `0` in this case.
    let width = parseFloat(css.width) || 0;
    let height = parseFloat(css.height) || 0;
    const hasOffset = (0, _dom.isHTMLElement)(element);
    const offsetWidth = hasOffset ? element.offsetWidth : width;
    const offsetHeight = hasOffset ? element.offsetHeight : height;
    const shouldFallback = (0, _utils.round)(width) !== offsetWidth || (0, _utils.round)(height) !== offsetHeight;
    if (shouldFallback) {
        width = offsetWidth;
        height = offsetHeight;
    }
    return {
        width,
        height,
        $: shouldFallback
    };
}
function unwrapElement(element) {
    return !(0, _dom.isElement)(element) ? element.contextElement : element;
}
function getScale(element) {
    const domElement = unwrapElement(element);
    if (!(0, _dom.isHTMLElement)(domElement)) return (0, _utils.createCoords)(1);
    const rect = domElement.getBoundingClientRect();
    const { width, height, $ } = getCssDimensions(domElement);
    let x = ($ ? (0, _utils.round)(rect.width) : rect.width) / width;
    let y = ($ ? (0, _utils.round)(rect.height) : rect.height) / height;
    // 0, NaN, or Infinity should always fallback to 1.
    if (!x || !Number.isFinite(x)) x = 1;
    if (!y || !Number.isFinite(y)) y = 1;
    return {
        x,
        y
    };
}
const noOffsets = /*#__PURE__*/ (0, _utils.createCoords)(0);
function getVisualOffsets(element) {
    const win = (0, _dom.getWindow)(element);
    if (!(0, _dom.isWebKit)() || !win.visualViewport) return noOffsets;
    return {
        x: win.visualViewport.offsetLeft,
        y: win.visualViewport.offsetTop
    };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
    if (isFixed === void 0) isFixed = false;
    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== (0, _dom.getWindow)(element)) return false;
    return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
    if (includeScale === void 0) includeScale = false;
    if (isFixedStrategy === void 0) isFixedStrategy = false;
    const clientRect = element.getBoundingClientRect();
    const domElement = unwrapElement(element);
    let scale = (0, _utils.createCoords)(1);
    if (includeScale) {
        if (offsetParent) {
            if ((0, _dom.isElement)(offsetParent)) scale = getScale(offsetParent);
        } else scale = getScale(element);
    }
    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : (0, _utils.createCoords)(0);
    let x = (clientRect.left + visualOffsets.x) / scale.x;
    let y = (clientRect.top + visualOffsets.y) / scale.y;
    let width = clientRect.width / scale.x;
    let height = clientRect.height / scale.y;
    if (domElement) {
        const win = (0, _dom.getWindow)(domElement);
        const offsetWin = offsetParent && (0, _dom.isElement)(offsetParent) ? (0, _dom.getWindow)(offsetParent) : offsetParent;
        let currentWin = win;
        let currentIFrame = currentWin.frameElement;
        while(currentIFrame && offsetParent && offsetWin !== currentWin){
            const iframeScale = getScale(currentIFrame);
            const iframeRect = currentIFrame.getBoundingClientRect();
            const css = (0, _dom.getComputedStyle)(currentIFrame);
            const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
            const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
            x *= iframeScale.x;
            y *= iframeScale.y;
            width *= iframeScale.x;
            height *= iframeScale.y;
            x += left;
            y += top;
            currentWin = (0, _dom.getWindow)(currentIFrame);
            currentIFrame = currentWin.frameElement;
        }
    }
    return (0, _core.rectToClientRect)({
        width,
        height,
        x,
        y
    });
}
const topLayerSelectors = [
    ":popover-open",
    ":modal"
];
function isTopLayer(floating) {
    return topLayerSelectors.some((selector)=>{
        try {
            return floating.matches(selector);
        } catch (e) {
            return false;
        }
    });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
    let { elements, rect, offsetParent, strategy } = _ref;
    const isFixed = strategy === "fixed";
    const documentElement = (0, _dom.getDocumentElement)(offsetParent);
    const topLayer = elements ? isTopLayer(elements.floating) : false;
    if (offsetParent === documentElement || topLayer && isFixed) return rect;
    let scroll = {
        scrollLeft: 0,
        scrollTop: 0
    };
    let scale = (0, _utils.createCoords)(1);
    const offsets = (0, _utils.createCoords)(0);
    const isOffsetParentAnElement = (0, _dom.isHTMLElement)(offsetParent);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if ((0, _dom.getNodeName)(offsetParent) !== "body" || (0, _dom.isOverflowElement)(documentElement)) scroll = (0, _dom.getNodeScroll)(offsetParent);
        if ((0, _dom.isHTMLElement)(offsetParent)) {
            const offsetRect = getBoundingClientRect(offsetParent);
            scale = getScale(offsetParent);
            offsets.x = offsetRect.x + offsetParent.clientLeft;
            offsets.y = offsetRect.y + offsetParent.clientTop;
        }
    }
    return {
        width: rect.width * scale.x,
        height: rect.height * scale.y,
        x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
        y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
    };
}
function getClientRects(element) {
    return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
    // If <html> has a CSS width greater than the viewport, then this will be
    // incorrect for RTL.
    return getBoundingClientRect((0, _dom.getDocumentElement)(element)).left + (0, _dom.getNodeScroll)(element).scrollLeft;
}
// Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable.
function getDocumentRect(element) {
    const html = (0, _dom.getDocumentElement)(element);
    const scroll = (0, _dom.getNodeScroll)(element);
    const body = element.ownerDocument.body;
    const width = (0, _utils.max)(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
    const height = (0, _utils.max)(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
    let x = -scroll.scrollLeft + getWindowScrollBarX(element);
    const y = -scroll.scrollTop;
    if ((0, _dom.getComputedStyle)(body).direction === "rtl") x += (0, _utils.max)(html.clientWidth, body.clientWidth) - width;
    return {
        width,
        height,
        x,
        y
    };
}
function getViewportRect(element, strategy) {
    const win = (0, _dom.getWindow)(element);
    const html = (0, _dom.getDocumentElement)(element);
    const visualViewport = win.visualViewport;
    let width = html.clientWidth;
    let height = html.clientHeight;
    let x = 0;
    let y = 0;
    if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        const visualViewportBased = (0, _dom.isWebKit)();
        if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
            x = visualViewport.offsetLeft;
            y = visualViewport.offsetTop;
        }
    }
    return {
        width,
        height,
        x,
        y
    };
}
// Returns the inner client rect, subtracting scrollbars if present.
function getInnerBoundingClientRect(element, strategy) {
    const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
    const top = clientRect.top + element.clientTop;
    const left = clientRect.left + element.clientLeft;
    const scale = (0, _dom.isHTMLElement)(element) ? getScale(element) : (0, _utils.createCoords)(1);
    const width = element.clientWidth * scale.x;
    const height = element.clientHeight * scale.y;
    const x = left * scale.x;
    const y = top * scale.y;
    return {
        width,
        height,
        x,
        y
    };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
    let rect;
    if (clippingAncestor === "viewport") rect = getViewportRect(element, strategy);
    else if (clippingAncestor === "document") rect = getDocumentRect((0, _dom.getDocumentElement)(element));
    else if ((0, _dom.isElement)(clippingAncestor)) rect = getInnerBoundingClientRect(clippingAncestor, strategy);
    else {
        const visualOffsets = getVisualOffsets(element);
        rect = {
            ...clippingAncestor,
            x: clippingAncestor.x - visualOffsets.x,
            y: clippingAncestor.y - visualOffsets.y
        };
    }
    return (0, _core.rectToClientRect)(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
    const parentNode = (0, _dom.getParentNode)(element);
    if (parentNode === stopNode || !(0, _dom.isElement)(parentNode) || (0, _dom.isLastTraversableNode)(parentNode)) return false;
    return (0, _dom.getComputedStyle)(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
// A "clipping ancestor" is an `overflow` element with the characteristic of
// clipping (or hiding) child elements. This returns all clipping ancestors
// of the given element up the tree.
function getClippingElementAncestors(element, cache) {
    const cachedResult = cache.get(element);
    if (cachedResult) return cachedResult;
    let result = (0, _dom.getOverflowAncestors)(element, [], false).filter((el)=>(0, _dom.isElement)(el) && (0, _dom.getNodeName)(el) !== "body");
    let currentContainingBlockComputedStyle = null;
    const elementIsFixed = (0, _dom.getComputedStyle)(element).position === "fixed";
    let currentNode = elementIsFixed ? (0, _dom.getParentNode)(element) : element;
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
    while((0, _dom.isElement)(currentNode) && !(0, _dom.isLastTraversableNode)(currentNode)){
        const computedStyle = (0, _dom.getComputedStyle)(currentNode);
        const currentNodeIsContaining = (0, _dom.isContainingBlock)(currentNode);
        if (!currentNodeIsContaining && computedStyle.position === "fixed") currentContainingBlockComputedStyle = null;
        const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && [
            "absolute",
            "fixed"
        ].includes(currentContainingBlockComputedStyle.position) || (0, _dom.isOverflowElement)(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
        if (shouldDropCurrentNode) // Drop non-containing blocks.
        result = result.filter((ancestor)=>ancestor !== currentNode);
        else // Record last containing block for next iteration.
        currentContainingBlockComputedStyle = computedStyle;
        currentNode = (0, _dom.getParentNode)(currentNode);
    }
    cache.set(element, result);
    return result;
}
// Gets the maximum area that the element is visible in due to any number of
// clipping ancestors.
function getClippingRect(_ref) {
    let { element, boundary, rootBoundary, strategy } = _ref;
    const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
    const clippingAncestors = [
        ...elementClippingAncestors,
        rootBoundary
    ];
    const firstClippingAncestor = clippingAncestors[0];
    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor)=>{
        const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
        accRect.top = (0, _utils.max)(rect.top, accRect.top);
        accRect.right = (0, _utils.min)(rect.right, accRect.right);
        accRect.bottom = (0, _utils.min)(rect.bottom, accRect.bottom);
        accRect.left = (0, _utils.max)(rect.left, accRect.left);
        return accRect;
    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
    return {
        width: clippingRect.right - clippingRect.left,
        height: clippingRect.bottom - clippingRect.top,
        x: clippingRect.left,
        y: clippingRect.top
    };
}
function getDimensions(element) {
    const { width, height } = getCssDimensions(element);
    return {
        width,
        height
    };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
    const isOffsetParentAnElement = (0, _dom.isHTMLElement)(offsetParent);
    const documentElement = (0, _dom.getDocumentElement)(offsetParent);
    const isFixed = strategy === "fixed";
    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
    let scroll = {
        scrollLeft: 0,
        scrollTop: 0
    };
    const offsets = (0, _utils.createCoords)(0);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if ((0, _dom.getNodeName)(offsetParent) !== "body" || (0, _dom.isOverflowElement)(documentElement)) scroll = (0, _dom.getNodeScroll)(offsetParent);
        if (isOffsetParentAnElement) {
            const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
            offsets.x = offsetRect.x + offsetParent.clientLeft;
            offsets.y = offsetRect.y + offsetParent.clientTop;
        } else if (documentElement) offsets.x = getWindowScrollBarX(documentElement);
    }
    const x = rect.left + scroll.scrollLeft - offsets.x;
    const y = rect.top + scroll.scrollTop - offsets.y;
    return {
        x,
        y,
        width: rect.width,
        height: rect.height
    };
}
function getTrueOffsetParent(element, polyfill) {
    if (!(0, _dom.isHTMLElement)(element) || (0, _dom.getComputedStyle)(element).position === "fixed") return null;
    if (polyfill) return polyfill(element);
    return element.offsetParent;
}
// Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.
function getOffsetParent(element, polyfill) {
    const window = (0, _dom.getWindow)(element);
    if (!(0, _dom.isHTMLElement)(element) || isTopLayer(element)) return window;
    let offsetParent = getTrueOffsetParent(element, polyfill);
    while(offsetParent && (0, _dom.isTableElement)(offsetParent) && (0, _dom.getComputedStyle)(offsetParent).position === "static")offsetParent = getTrueOffsetParent(offsetParent, polyfill);
    if (offsetParent && ((0, _dom.getNodeName)(offsetParent) === "html" || (0, _dom.getNodeName)(offsetParent) === "body" && (0, _dom.getComputedStyle)(offsetParent).position === "static" && !(0, _dom.isContainingBlock)(offsetParent))) return window;
    return offsetParent || (0, _dom.getContainingBlock)(element) || window;
}
const getElementRects = async function(data) {
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    return {
        reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
        floating: {
            x: 0,
            y: 0,
            ...await getDimensionsFn(data.floating)
        }
    };
};
function isRTL(element) {
    return (0, _dom.getComputedStyle)(element).direction === "rtl";
}
const platform = {
    convertOffsetParentRelativeRectToViewportRelativeRect,
    getDocumentElement: (0, _dom.getDocumentElement),
    getClippingRect,
    getOffsetParent,
    getElementRects,
    getClientRects,
    getDimensions,
    getScale,
    isElement: (0, _dom.isElement),
    isRTL
};
// https://samthor.au/2021/observing-dom/
function observeMove(element, onMove) {
    let io = null;
    let timeoutId;
    const root = (0, _dom.getDocumentElement)(element);
    function cleanup() {
        var _io;
        clearTimeout(timeoutId);
        (_io = io) == null || _io.disconnect();
        io = null;
    }
    function refresh(skip, threshold) {
        if (skip === void 0) skip = false;
        if (threshold === void 0) threshold = 1;
        cleanup();
        const { left, top, width, height } = element.getBoundingClientRect();
        if (!skip) onMove();
        if (!width || !height) return;
        const insetTop = (0, _utils.floor)(top);
        const insetRight = (0, _utils.floor)(root.clientWidth - (left + width));
        const insetBottom = (0, _utils.floor)(root.clientHeight - (top + height));
        const insetLeft = (0, _utils.floor)(left);
        const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
        const options = {
            rootMargin,
            threshold: (0, _utils.max)(0, (0, _utils.min)(1, threshold)) || 1
        };
        let isFirstUpdate = true;
        function handleObserve(entries) {
            const ratio = entries[0].intersectionRatio;
            if (ratio !== threshold) {
                if (!isFirstUpdate) return refresh();
                if (!ratio) timeoutId = setTimeout(()=>{
                    refresh(false, 1e-7);
                }, 100);
                else refresh(false, ratio);
            }
            isFirstUpdate = false;
        }
        // Older browsers don't support a `document` as the root and will throw an
        // error.
        try {
            io = new IntersectionObserver(handleObserve, {
                ...options,
                // Handle <iframe>s
                root: root.ownerDocument
            });
        } catch (e) {
            io = new IntersectionObserver(handleObserve, options);
        }
        io.observe(element);
    }
    refresh(true);
    return cleanup;
}
/**
 * Automatically updates the position of the floating element when necessary.
 * Should only be called when the floating element is mounted on the DOM or
 * visible on the screen.
 * @returns cleanup function that should be invoked when the floating element is
 * removed from the DOM or hidden from the screen.
 * @see https://floating-ui.com/docs/autoUpdate
 */ function autoUpdate(reference, floating, update, options) {
    if (options === void 0) options = {};
    const { ancestorScroll = true, ancestorResize = true, elementResize = typeof ResizeObserver === "function", layoutShift = typeof IntersectionObserver === "function", animationFrame = false } = options;
    const referenceEl = unwrapElement(reference);
    const ancestors = ancestorScroll || ancestorResize ? [
        ...referenceEl ? (0, _dom.getOverflowAncestors)(referenceEl) : [],
        ...(0, _dom.getOverflowAncestors)(floating)
    ] : [];
    ancestors.forEach((ancestor)=>{
        ancestorScroll && ancestor.addEventListener("scroll", update, {
            passive: true
        });
        ancestorResize && ancestor.addEventListener("resize", update);
    });
    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
    let reobserveFrame = -1;
    let resizeObserver = null;
    if (elementResize) {
        resizeObserver = new ResizeObserver((_ref)=>{
            let [firstEntry] = _ref;
            if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
                // Prevent update loops when using the `size` middleware.
                // https://github.com/floating-ui/floating-ui/issues/1740
                resizeObserver.unobserve(floating);
                cancelAnimationFrame(reobserveFrame);
                reobserveFrame = requestAnimationFrame(()=>{
                    var _resizeObserver;
                    (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
                });
            }
            update();
        });
        if (referenceEl && !animationFrame) resizeObserver.observe(referenceEl);
        resizeObserver.observe(floating);
    }
    let frameId;
    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
    if (animationFrame) frameLoop();
    function frameLoop() {
        const nextRefRect = getBoundingClientRect(reference);
        if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) update();
        prevRefRect = nextRefRect;
        frameId = requestAnimationFrame(frameLoop);
    }
    update();
    return ()=>{
        var _resizeObserver2;
        ancestors.forEach((ancestor)=>{
            ancestorScroll && ancestor.removeEventListener("scroll", update);
            ancestorResize && ancestor.removeEventListener("resize", update);
        });
        cleanupIo == null || cleanupIo();
        (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
        resizeObserver = null;
        if (animationFrame) cancelAnimationFrame(frameId);
    };
}
/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */ const autoPlacement = (0, _core.autoPlacement);
/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */ const shift = (0, _core.shift);
/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */ const flip = (0, _core.flip);
/**
 * Provides data that allows you to change the size of the floating element 
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */ const size = (0, _core.size);
/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */ const hide = (0, _core.hide);
/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */ const arrow = (0, _core.arrow);
/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */ const inline = (0, _core.inline);
/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */ const limitShift = (0, _core.limitShift);
/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 */ const computePosition = (reference, floating, options)=>{
    // This caches the expensive `getClippingElementAncestors` function so that
    // multiple lifecycle resets re-use the same result. It only lives for a
    // single call. If other functions become expensive, we can add them as well.
    const cache = new Map();
    const mergedOptions = {
        platform,
        ...options
    };
    const platformWithCache = {
        ...mergedOptions.platform,
        _c: cache
    };
    return (0, _core.computePosition)(reference, floating, {
        ...mergedOptions,
        platform: platformWithCache
    });
};

},{"@floating-ui/core":"dgWsp","@floating-ui/utils":"cIhJF","@floating-ui/utils/dom":"aBFfa","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dgWsp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rectToClientRect", ()=>(0, _utils.rectToClientRect));
parcelHelpers.export(exports, "arrow", ()=>arrow);
parcelHelpers.export(exports, "autoPlacement", ()=>autoPlacement);
parcelHelpers.export(exports, "computePosition", ()=>computePosition);
parcelHelpers.export(exports, "detectOverflow", ()=>detectOverflow);
parcelHelpers.export(exports, "flip", ()=>flip);
parcelHelpers.export(exports, "hide", ()=>hide);
parcelHelpers.export(exports, "inline", ()=>inline);
parcelHelpers.export(exports, "limitShift", ()=>limitShift);
parcelHelpers.export(exports, "offset", ()=>offset);
parcelHelpers.export(exports, "shift", ()=>shift);
parcelHelpers.export(exports, "size", ()=>size);
var _utils = require("@floating-ui/utils");
function computeCoordsFromPlacement(_ref, placement, rtl) {
    let { reference, floating } = _ref;
    const sideAxis = (0, _utils.getSideAxis)(placement);
    const alignmentAxis = (0, _utils.getAlignmentAxis)(placement);
    const alignLength = (0, _utils.getAxisLength)(alignmentAxis);
    const side = (0, _utils.getSide)(placement);
    const isVertical = sideAxis === "y";
    const commonX = reference.x + reference.width / 2 - floating.width / 2;
    const commonY = reference.y + reference.height / 2 - floating.height / 2;
    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
    let coords;
    switch(side){
        case "top":
            coords = {
                x: commonX,
                y: reference.y - floating.height
            };
            break;
        case "bottom":
            coords = {
                x: commonX,
                y: reference.y + reference.height
            };
            break;
        case "right":
            coords = {
                x: reference.x + reference.width,
                y: commonY
            };
            break;
        case "left":
            coords = {
                x: reference.x - floating.width,
                y: commonY
            };
            break;
        default:
            coords = {
                x: reference.x,
                y: reference.y
            };
    }
    switch((0, _utils.getAlignment)(placement)){
        case "start":
            coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
            break;
        case "end":
            coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
            break;
    }
    return coords;
}
/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 *
 * This export does not have any `platform` interface logic. You will need to
 * write one for the platform you are using Floating UI with.
 */ const computePosition = async (reference, floating, config)=>{
    const { placement = "bottom", strategy = "absolute", middleware = [], platform } = config;
    const validMiddleware = middleware.filter(Boolean);
    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
    let rects = await platform.getElementRects({
        reference,
        floating,
        strategy
    });
    let { x, y } = computeCoordsFromPlacement(rects, placement, rtl);
    let statefulPlacement = placement;
    let middlewareData = {};
    let resetCount = 0;
    for(let i = 0; i < validMiddleware.length; i++){
        const { name, fn } = validMiddleware[i];
        const { x: nextX, y: nextY, data, reset } = await fn({
            x,
            y,
            initialPlacement: placement,
            placement: statefulPlacement,
            strategy,
            middlewareData,
            rects,
            platform,
            elements: {
                reference,
                floating
            }
        });
        x = nextX != null ? nextX : x;
        y = nextY != null ? nextY : y;
        middlewareData = {
            ...middlewareData,
            [name]: {
                ...middlewareData[name],
                ...data
            }
        };
        if (reset && resetCount <= 50) {
            resetCount++;
            if (typeof reset === "object") {
                if (reset.placement) statefulPlacement = reset.placement;
                if (reset.rects) rects = reset.rects === true ? await platform.getElementRects({
                    reference,
                    floating,
                    strategy
                }) : reset.rects;
                ({ x, y } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
            }
            i = -1;
        }
    }
    return {
        x,
        y,
        placement: statefulPlacement,
        strategy,
        middlewareData
    };
};
/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary on each side.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */ async function detectOverflow(state, options) {
    var _await$platform$isEle;
    if (options === void 0) options = {};
    const { x, y, platform, rects, elements, strategy } = state;
    const { boundary = "clippingAncestors", rootBoundary = "viewport", elementContext = "floating", altBoundary = false, padding = 0 } = (0, _utils.evaluate)(options, state);
    const paddingObject = (0, _utils.getPaddingObject)(padding);
    const altContext = elementContext === "floating" ? "reference" : "floating";
    const element = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = (0, _utils.rectToClientRect)(await platform.getClippingRect({
        element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating)),
        boundary,
        rootBoundary,
        strategy
    }));
    const rect = elementContext === "floating" ? {
        ...rects.floating,
        x,
        y
    } : rects.reference;
    const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));
    const offsetScale = await (platform.isElement == null ? void 0 : platform.isElement(offsetParent)) ? await (platform.getScale == null ? void 0 : platform.getScale(offsetParent)) || {
        x: 1,
        y: 1
    } : {
        x: 1,
        y: 1
    };
    const elementClientRect = (0, _utils.rectToClientRect)(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
        elements,
        rect,
        offsetParent,
        strategy
    }) : rect);
    return {
        top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
        bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
        left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
        right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
    };
}
/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */ const arrow = (options)=>({
        name: "arrow",
        options,
        async fn (state) {
            const { x, y, placement, rects, platform, elements, middlewareData } = state;
            // Since `element` is required, we don't Partial<> the type.
            const { element, padding = 0 } = (0, _utils.evaluate)(options, state) || {};
            if (element == null) return {};
            const paddingObject = (0, _utils.getPaddingObject)(padding);
            const coords = {
                x,
                y
            };
            const axis = (0, _utils.getAlignmentAxis)(placement);
            const length = (0, _utils.getAxisLength)(axis);
            const arrowDimensions = await platform.getDimensions(element);
            const isYAxis = axis === "y";
            const minProp = isYAxis ? "top" : "left";
            const maxProp = isYAxis ? "bottom" : "right";
            const clientProp = isYAxis ? "clientHeight" : "clientWidth";
            const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
            const startDiff = coords[axis] - rects.reference[axis];
            const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));
            let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
            // DOM platform can return `window` as the `offsetParent`.
            if (!clientSize || !await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent))) clientSize = elements.floating[clientProp] || rects.floating[length];
            const centerToReference = endDiff / 2 - startDiff / 2;
            // If the padding is large enough that it causes the arrow to no longer be
            // centered, modify the padding so that it is centered.
            const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
            const minPadding = (0, _utils.min)(paddingObject[minProp], largestPossiblePadding);
            const maxPadding = (0, _utils.min)(paddingObject[maxProp], largestPossiblePadding);
            // Make sure the arrow doesn't overflow the floating element if the center
            // point is outside the floating element's bounds.
            const min$1 = minPadding;
            const max = clientSize - arrowDimensions[length] - maxPadding;
            const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
            const offset = (0, _utils.clamp)(min$1, center, max);
            // If the reference is small enough that the arrow's padding causes it to
            // to point to nothing for an aligned placement, adjust the offset of the
            // floating element itself. To ensure `shift()` continues to take action,
            // a single reset is performed when this is true.
            const shouldAddOffset = !middlewareData.arrow && (0, _utils.getAlignment)(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
            const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;
            return {
                [axis]: coords[axis] + alignmentOffset,
                data: {
                    [axis]: offset,
                    centerOffset: center - offset - alignmentOffset,
                    ...shouldAddOffset && {
                        alignmentOffset
                    }
                },
                reset: shouldAddOffset
            };
        }
    });
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
    const allowedPlacementsSortedByAlignment = alignment ? [
        ...allowedPlacements.filter((placement)=>(0, _utils.getAlignment)(placement) === alignment),
        ...allowedPlacements.filter((placement)=>(0, _utils.getAlignment)(placement) !== alignment)
    ] : allowedPlacements.filter((placement)=>(0, _utils.getSide)(placement) === placement);
    return allowedPlacementsSortedByAlignment.filter((placement)=>{
        if (alignment) return (0, _utils.getAlignment)(placement) === alignment || (autoAlignment ? (0, _utils.getOppositeAlignmentPlacement)(placement) !== placement : false);
        return true;
    });
}
/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */ const autoPlacement = function(options) {
    if (options === void 0) options = {};
    return {
        name: "autoPlacement",
        options,
        async fn (state) {
            var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
            const { rects, middlewareData, placement, platform, elements } = state;
            const { crossAxis = false, alignment, allowedPlacements = (0, _utils.placements), autoAlignment = true, ...detectOverflowOptions } = (0, _utils.evaluate)(options, state);
            const placements$1 = alignment !== undefined || allowedPlacements === (0, _utils.placements) ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
            const overflow = await detectOverflow(state, detectOverflowOptions);
            const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
            const currentPlacement = placements$1[currentIndex];
            if (currentPlacement == null) return {};
            const alignmentSides = (0, _utils.getAlignmentSides)(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));
            // Make `computeCoords` start from the right place.
            if (placement !== currentPlacement) return {
                reset: {
                    placement: placements$1[0]
                }
            };
            const currentOverflows = [
                overflow[(0, _utils.getSide)(currentPlacement)],
                overflow[alignmentSides[0]],
                overflow[alignmentSides[1]]
            ];
            const allOverflows = [
                ...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [],
                {
                    placement: currentPlacement,
                    overflows: currentOverflows
                }
            ];
            const nextPlacement = placements$1[currentIndex + 1];
            // There are more placements to check.
            if (nextPlacement) return {
                data: {
                    index: currentIndex + 1,
                    overflows: allOverflows
                },
                reset: {
                    placement: nextPlacement
                }
            };
            const placementsSortedByMostSpace = allOverflows.map((d)=>{
                const alignment = (0, _utils.getAlignment)(d.placement);
                return [
                    d.placement,
                    alignment && crossAxis ? // Check along the mainAxis and main crossAxis side.
                    d.overflows.slice(0, 2).reduce((acc, v)=>acc + v, 0) : // Check only the mainAxis.
                    d.overflows[0],
                    d.overflows
                ];
            }).sort((a, b)=>a[1] - b[1]);
            const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d)=>d[2].slice(0, // Aligned placements should not check their opposite crossAxis
                // side.
                (0, _utils.getAlignment)(d[0]) ? 2 : 3).every((v)=>v <= 0));
            const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
            if (resetPlacement !== placement) return {
                data: {
                    index: currentIndex + 1,
                    overflows: allOverflows
                },
                reset: {
                    placement: resetPlacement
                }
            };
            return {};
        }
    };
};
/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */ const flip = function(options) {
    if (options === void 0) options = {};
    return {
        name: "flip",
        options,
        async fn (state) {
            var _middlewareData$arrow, _middlewareData$flip;
            const { placement, middlewareData, rects, initialPlacement, platform, elements } = state;
            const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true, fallbackPlacements: specifiedFallbackPlacements, fallbackStrategy = "bestFit", fallbackAxisSideDirection = "none", flipAlignment = true, ...detectOverflowOptions } = (0, _utils.evaluate)(options, state);
            // If a reset by the arrow was caused due to an alignment offset being
            // added, we should skip any logic now since `flip()` has already done its
            // work.
            // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643
            if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) return {};
            const side = (0, _utils.getSide)(placement);
            const isBasePlacement = (0, _utils.getSide)(initialPlacement) === initialPlacement;
            const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
            const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [
                (0, _utils.getOppositePlacement)(initialPlacement)
            ] : (0, _utils.getExpandedPlacements)(initialPlacement));
            if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") fallbackPlacements.push(...(0, _utils.getOppositeAxisPlacements)(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
            const placements = [
                initialPlacement,
                ...fallbackPlacements
            ];
            const overflow = await detectOverflow(state, detectOverflowOptions);
            const overflows = [];
            let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
            if (checkMainAxis) overflows.push(overflow[side]);
            if (checkCrossAxis) {
                const sides = (0, _utils.getAlignmentSides)(placement, rects, rtl);
                overflows.push(overflow[sides[0]], overflow[sides[1]]);
            }
            overflowsData = [
                ...overflowsData,
                {
                    placement,
                    overflows
                }
            ];
            // One or more sides is overflowing.
            if (!overflows.every((side)=>side <= 0)) {
                var _middlewareData$flip2, _overflowsData$filter;
                const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
                const nextPlacement = placements[nextIndex];
                if (nextPlacement) // Try next placement and re-run the lifecycle.
                return {
                    data: {
                        index: nextIndex,
                        overflows: overflowsData
                    },
                    reset: {
                        placement: nextPlacement
                    }
                };
                // First, find the candidates that fit on the mainAxis side of overflow,
                // then find the placement that fits the best on the main crossAxis side.
                let resetPlacement = (_overflowsData$filter = overflowsData.filter((d)=>d.overflows[0] <= 0).sort((a, b)=>a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
                // Otherwise fallback.
                if (!resetPlacement) switch(fallbackStrategy){
                    case "bestFit":
                        {
                            var _overflowsData$map$so;
                            const placement = (_overflowsData$map$so = overflowsData.map((d)=>[
                                    d.placement,
                                    d.overflows.filter((overflow)=>overflow > 0).reduce((acc, overflow)=>acc + overflow, 0)
                                ]).sort((a, b)=>a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
                            if (placement) resetPlacement = placement;
                            break;
                        }
                    case "initialPlacement":
                        resetPlacement = initialPlacement;
                        break;
                }
                if (placement !== resetPlacement) return {
                    reset: {
                        placement: resetPlacement
                    }
                };
            }
            return {};
        }
    };
};
function getSideOffsets(overflow, rect) {
    return {
        top: overflow.top - rect.height,
        right: overflow.right - rect.width,
        bottom: overflow.bottom - rect.height,
        left: overflow.left - rect.width
    };
}
function isAnySideFullyClipped(overflow) {
    return (0, _utils.sides).some((side)=>overflow[side] >= 0);
}
/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */ const hide = function(options) {
    if (options === void 0) options = {};
    return {
        name: "hide",
        options,
        async fn (state) {
            const { rects } = state;
            const { strategy = "referenceHidden", ...detectOverflowOptions } = (0, _utils.evaluate)(options, state);
            switch(strategy){
                case "referenceHidden":
                    {
                        const overflow = await detectOverflow(state, {
                            ...detectOverflowOptions,
                            elementContext: "reference"
                        });
                        const offsets = getSideOffsets(overflow, rects.reference);
                        return {
                            data: {
                                referenceHiddenOffsets: offsets,
                                referenceHidden: isAnySideFullyClipped(offsets)
                            }
                        };
                    }
                case "escaped":
                    {
                        const overflow = await detectOverflow(state, {
                            ...detectOverflowOptions,
                            altBoundary: true
                        });
                        const offsets = getSideOffsets(overflow, rects.floating);
                        return {
                            data: {
                                escapedOffsets: offsets,
                                escaped: isAnySideFullyClipped(offsets)
                            }
                        };
                    }
                default:
                    return {};
            }
        }
    };
};
function getBoundingRect(rects) {
    const minX = (0, _utils.min)(...rects.map((rect)=>rect.left));
    const minY = (0, _utils.min)(...rects.map((rect)=>rect.top));
    const maxX = (0, _utils.max)(...rects.map((rect)=>rect.right));
    const maxY = (0, _utils.max)(...rects.map((rect)=>rect.bottom));
    return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
    };
}
function getRectsByLine(rects) {
    const sortedRects = rects.slice().sort((a, b)=>a.y - b.y);
    const groups = [];
    let prevRect = null;
    for(let i = 0; i < sortedRects.length; i++){
        const rect = sortedRects[i];
        if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) groups.push([
            rect
        ]);
        else groups[groups.length - 1].push(rect);
        prevRect = rect;
    }
    return groups.map((rect)=>(0, _utils.rectToClientRect)(getBoundingRect(rect)));
}
/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */ const inline = function(options) {
    if (options === void 0) options = {};
    return {
        name: "inline",
        options,
        async fn (state) {
            const { placement, elements, rects, platform, strategy } = state;
            // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a
            // ClientRect's bounds, despite the event listener being triggered. A
            // padding of 2 seems to handle this issue.
            const { padding = 2, x, y } = (0, _utils.evaluate)(options, state);
            const nativeClientRects = Array.from(await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference)) || []);
            const clientRects = getRectsByLine(nativeClientRects);
            const fallback = (0, _utils.rectToClientRect)(getBoundingRect(nativeClientRects));
            const paddingObject = (0, _utils.getPaddingObject)(padding);
            function getBoundingClientRect() {
                // There are two rects and they are disjoined.
                if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) // Find the first rect in which the point is fully inside.
                return clientRects.find((rect)=>x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;
                // There are 2 or more connected rects.
                if (clientRects.length >= 2) {
                    if ((0, _utils.getSideAxis)(placement) === "y") {
                        const firstRect = clientRects[0];
                        const lastRect = clientRects[clientRects.length - 1];
                        const isTop = (0, _utils.getSide)(placement) === "top";
                        const top = firstRect.top;
                        const bottom = lastRect.bottom;
                        const left = isTop ? firstRect.left : lastRect.left;
                        const right = isTop ? firstRect.right : lastRect.right;
                        const width = right - left;
                        const height = bottom - top;
                        return {
                            top,
                            bottom,
                            left,
                            right,
                            width,
                            height,
                            x: left,
                            y: top
                        };
                    }
                    const isLeftSide = (0, _utils.getSide)(placement) === "left";
                    const maxRight = (0, _utils.max)(...clientRects.map((rect)=>rect.right));
                    const minLeft = (0, _utils.min)(...clientRects.map((rect)=>rect.left));
                    const measureRects = clientRects.filter((rect)=>isLeftSide ? rect.left === minLeft : rect.right === maxRight);
                    const top = measureRects[0].top;
                    const bottom = measureRects[measureRects.length - 1].bottom;
                    const left = minLeft;
                    const right = maxRight;
                    const width = right - left;
                    const height = bottom - top;
                    return {
                        top,
                        bottom,
                        left,
                        right,
                        width,
                        height,
                        x: left,
                        y: top
                    };
                }
                return fallback;
            }
            const resetRects = await platform.getElementRects({
                reference: {
                    getBoundingClientRect
                },
                floating: elements.floating,
                strategy
            });
            if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) return {
                reset: {
                    rects: resetRects
                }
            };
            return {};
        }
    };
};
// For type backwards-compatibility, the `OffsetOptions` type was also
// Derivable.
async function convertValueToCoords(state, options) {
    const { placement, platform, elements } = state;
    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
    const side = (0, _utils.getSide)(placement);
    const alignment = (0, _utils.getAlignment)(placement);
    const isVertical = (0, _utils.getSideAxis)(placement) === "y";
    const mainAxisMulti = [
        "left",
        "top"
    ].includes(side) ? -1 : 1;
    const crossAxisMulti = rtl && isVertical ? -1 : 1;
    const rawValue = (0, _utils.evaluate)(options, state);
    let { mainAxis, crossAxis, alignmentAxis } = typeof rawValue === "number" ? {
        mainAxis: rawValue,
        crossAxis: 0,
        alignmentAxis: null
    } : {
        mainAxis: 0,
        crossAxis: 0,
        alignmentAxis: null,
        ...rawValue
    };
    if (alignment && typeof alignmentAxis === "number") crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
    return isVertical ? {
        x: crossAxis * crossAxisMulti,
        y: mainAxis * mainAxisMulti
    } : {
        x: mainAxis * mainAxisMulti,
        y: crossAxis * crossAxisMulti
    };
}
/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */ const offset = function(options) {
    if (options === void 0) options = 0;
    return {
        name: "offset",
        options,
        async fn (state) {
            var _middlewareData$offse, _middlewareData$arrow;
            const { x, y, placement, middlewareData } = state;
            const diffCoords = await convertValueToCoords(state, options);
            // If the placement is the same and the arrow caused an alignment offset
            // then we don't need to change the positioning coordinates.
            if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) return {};
            return {
                x: x + diffCoords.x,
                y: y + diffCoords.y,
                data: {
                    ...diffCoords,
                    placement
                }
            };
        }
    };
};
/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */ const shift = function(options) {
    if (options === void 0) options = {};
    return {
        name: "shift",
        options,
        async fn (state) {
            const { x, y, placement } = state;
            const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = false, limiter = {
                fn: (_ref)=>{
                    let { x, y } = _ref;
                    return {
                        x,
                        y
                    };
                }
            }, ...detectOverflowOptions } = (0, _utils.evaluate)(options, state);
            const coords = {
                x,
                y
            };
            const overflow = await detectOverflow(state, detectOverflowOptions);
            const crossAxis = (0, _utils.getSideAxis)((0, _utils.getSide)(placement));
            const mainAxis = (0, _utils.getOppositeAxis)(crossAxis);
            let mainAxisCoord = coords[mainAxis];
            let crossAxisCoord = coords[crossAxis];
            if (checkMainAxis) {
                const minSide = mainAxis === "y" ? "top" : "left";
                const maxSide = mainAxis === "y" ? "bottom" : "right";
                const min = mainAxisCoord + overflow[minSide];
                const max = mainAxisCoord - overflow[maxSide];
                mainAxisCoord = (0, _utils.clamp)(min, mainAxisCoord, max);
            }
            if (checkCrossAxis) {
                const minSide = crossAxis === "y" ? "top" : "left";
                const maxSide = crossAxis === "y" ? "bottom" : "right";
                const min = crossAxisCoord + overflow[minSide];
                const max = crossAxisCoord - overflow[maxSide];
                crossAxisCoord = (0, _utils.clamp)(min, crossAxisCoord, max);
            }
            const limitedCoords = limiter.fn({
                ...state,
                [mainAxis]: mainAxisCoord,
                [crossAxis]: crossAxisCoord
            });
            return {
                ...limitedCoords,
                data: {
                    x: limitedCoords.x - x,
                    y: limitedCoords.y - y
                }
            };
        }
    };
};
/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */ const limitShift = function(options) {
    if (options === void 0) options = {};
    return {
        options,
        fn (state) {
            const { x, y, placement, rects, middlewareData } = state;
            const { offset = 0, mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true } = (0, _utils.evaluate)(options, state);
            const coords = {
                x,
                y
            };
            const crossAxis = (0, _utils.getSideAxis)(placement);
            const mainAxis = (0, _utils.getOppositeAxis)(crossAxis);
            let mainAxisCoord = coords[mainAxis];
            let crossAxisCoord = coords[crossAxis];
            const rawOffset = (0, _utils.evaluate)(offset, state);
            const computedOffset = typeof rawOffset === "number" ? {
                mainAxis: rawOffset,
                crossAxis: 0
            } : {
                mainAxis: 0,
                crossAxis: 0,
                ...rawOffset
            };
            if (checkMainAxis) {
                const len = mainAxis === "y" ? "height" : "width";
                const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
                const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
                if (mainAxisCoord < limitMin) mainAxisCoord = limitMin;
                else if (mainAxisCoord > limitMax) mainAxisCoord = limitMax;
            }
            if (checkCrossAxis) {
                var _middlewareData$offse, _middlewareData$offse2;
                const len = mainAxis === "y" ? "width" : "height";
                const isOriginSide = [
                    "top",
                    "left"
                ].includes((0, _utils.getSide)(placement));
                const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
                const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
                if (crossAxisCoord < limitMin) crossAxisCoord = limitMin;
                else if (crossAxisCoord > limitMax) crossAxisCoord = limitMax;
            }
            return {
                [mainAxis]: mainAxisCoord,
                [crossAxis]: crossAxisCoord
            };
        }
    };
};
/**
 * Provides data that allows you to change the size of the floating element 
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */ const size = function(options) {
    if (options === void 0) options = {};
    return {
        name: "size",
        options,
        async fn (state) {
            const { placement, rects, platform, elements } = state;
            const { apply = ()=>{}, ...detectOverflowOptions } = (0, _utils.evaluate)(options, state);
            const overflow = await detectOverflow(state, detectOverflowOptions);
            const side = (0, _utils.getSide)(placement);
            const alignment = (0, _utils.getAlignment)(placement);
            const isYAxis = (0, _utils.getSideAxis)(placement) === "y";
            const { width, height } = rects.floating;
            let heightSide;
            let widthSide;
            if (side === "top" || side === "bottom") {
                heightSide = side;
                widthSide = alignment === (await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
            } else {
                widthSide = side;
                heightSide = alignment === "end" ? "top" : "bottom";
            }
            const overflowAvailableHeight = height - overflow[heightSide];
            const overflowAvailableWidth = width - overflow[widthSide];
            const noShift = !state.middlewareData.shift;
            let availableHeight = overflowAvailableHeight;
            let availableWidth = overflowAvailableWidth;
            if (isYAxis) {
                const maximumClippingWidth = width - overflow.left - overflow.right;
                availableWidth = alignment || noShift ? (0, _utils.min)(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
            } else {
                const maximumClippingHeight = height - overflow.top - overflow.bottom;
                availableHeight = alignment || noShift ? (0, _utils.min)(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
            }
            if (noShift && !alignment) {
                const xMin = (0, _utils.max)(overflow.left, 0);
                const xMax = (0, _utils.max)(overflow.right, 0);
                const yMin = (0, _utils.max)(overflow.top, 0);
                const yMax = (0, _utils.max)(overflow.bottom, 0);
                if (isYAxis) availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : (0, _utils.max)(overflow.left, overflow.right));
                else availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : (0, _utils.max)(overflow.top, overflow.bottom));
            }
            await apply({
                ...state,
                availableWidth,
                availableHeight
            });
            const nextDimensions = await platform.getDimensions(elements.floating);
            if (width !== nextDimensions.width || height !== nextDimensions.height) return {
                reset: {
                    rects: true
                }
            };
            return {};
        }
    };
};

},{"@floating-ui/utils":"cIhJF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cIhJF":[function(require,module,exports) {
/**
 * Custom positioning reference element.
 * @see https://floating-ui.com/docs/virtual-elements
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "alignments", ()=>alignments);
parcelHelpers.export(exports, "clamp", ()=>clamp);
parcelHelpers.export(exports, "createCoords", ()=>createCoords);
parcelHelpers.export(exports, "evaluate", ()=>evaluate);
parcelHelpers.export(exports, "expandPaddingObject", ()=>expandPaddingObject);
parcelHelpers.export(exports, "floor", ()=>floor);
parcelHelpers.export(exports, "getAlignment", ()=>getAlignment);
parcelHelpers.export(exports, "getAlignmentAxis", ()=>getAlignmentAxis);
parcelHelpers.export(exports, "getAlignmentSides", ()=>getAlignmentSides);
parcelHelpers.export(exports, "getAxisLength", ()=>getAxisLength);
parcelHelpers.export(exports, "getExpandedPlacements", ()=>getExpandedPlacements);
parcelHelpers.export(exports, "getOppositeAlignmentPlacement", ()=>getOppositeAlignmentPlacement);
parcelHelpers.export(exports, "getOppositeAxis", ()=>getOppositeAxis);
parcelHelpers.export(exports, "getOppositeAxisPlacements", ()=>getOppositeAxisPlacements);
parcelHelpers.export(exports, "getOppositePlacement", ()=>getOppositePlacement);
parcelHelpers.export(exports, "getPaddingObject", ()=>getPaddingObject);
parcelHelpers.export(exports, "getSide", ()=>getSide);
parcelHelpers.export(exports, "getSideAxis", ()=>getSideAxis);
parcelHelpers.export(exports, "max", ()=>max);
parcelHelpers.export(exports, "min", ()=>min);
parcelHelpers.export(exports, "placements", ()=>placements);
parcelHelpers.export(exports, "rectToClientRect", ()=>rectToClientRect);
parcelHelpers.export(exports, "round", ()=>round);
parcelHelpers.export(exports, "sides", ()=>sides);
const sides = [
    "top",
    "right",
    "bottom",
    "left"
];
const alignments = [
    "start",
    "end"
];
const placements = /*#__PURE__*/ sides.reduce((acc, side)=>acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v)=>({
        x: v,
        y: v
    });
const oppositeSideMap = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
};
const oppositeAlignmentMap = {
    start: "end",
    end: "start"
};
function clamp(start, value, end) {
    return max(start, min(value, end));
}
function evaluate(value, param) {
    return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
    return placement.split("-")[0];
}
function getAlignment(placement) {
    return placement.split("-")[1];
}
function getOppositeAxis(axis) {
    return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
    return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
    return [
        "top",
        "bottom"
    ].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
    return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
    if (rtl === void 0) rtl = false;
    const alignment = getAlignment(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const length = getAxisLength(alignmentAxis);
    let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
    if (rects.reference[length] > rects.floating[length]) mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
    return [
        mainAlignmentSide,
        getOppositePlacement(mainAlignmentSide)
    ];
}
function getExpandedPlacements(placement) {
    const oppositePlacement = getOppositePlacement(placement);
    return [
        getOppositeAlignmentPlacement(placement),
        oppositePlacement,
        getOppositeAlignmentPlacement(oppositePlacement)
    ];
}
function getOppositeAlignmentPlacement(placement) {
    return placement.replace(/start|end/g, (alignment)=>oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
    const lr = [
        "left",
        "right"
    ];
    const rl = [
        "right",
        "left"
    ];
    const tb = [
        "top",
        "bottom"
    ];
    const bt = [
        "bottom",
        "top"
    ];
    switch(side){
        case "top":
        case "bottom":
            if (rtl) return isStart ? rl : lr;
            return isStart ? lr : rl;
        case "left":
        case "right":
            return isStart ? tb : bt;
        default:
            return [];
    }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
    const alignment = getAlignment(placement);
    let list = getSideList(getSide(placement), direction === "start", rtl);
    if (alignment) {
        list = list.map((side)=>side + "-" + alignment);
        if (flipAlignment) list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
    return list;
}
function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, (side)=>oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...padding
    };
}
function getPaddingObject(padding) {
    return typeof padding !== "number" ? expandPaddingObject(padding) : {
        top: padding,
        right: padding,
        bottom: padding,
        left: padding
    };
}
function rectToClientRect(rect) {
    return {
        ...rect,
        top: rect.y,
        left: rect.x,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aBFfa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getComputedStyle", ()=>getComputedStyle);
parcelHelpers.export(exports, "getContainingBlock", ()=>getContainingBlock);
parcelHelpers.export(exports, "getDocumentElement", ()=>getDocumentElement);
parcelHelpers.export(exports, "getNearestOverflowAncestor", ()=>getNearestOverflowAncestor);
parcelHelpers.export(exports, "getNodeName", ()=>getNodeName);
parcelHelpers.export(exports, "getNodeScroll", ()=>getNodeScroll);
parcelHelpers.export(exports, "getOverflowAncestors", ()=>getOverflowAncestors);
parcelHelpers.export(exports, "getParentNode", ()=>getParentNode);
parcelHelpers.export(exports, "getWindow", ()=>getWindow);
parcelHelpers.export(exports, "isContainingBlock", ()=>isContainingBlock);
parcelHelpers.export(exports, "isElement", ()=>isElement);
parcelHelpers.export(exports, "isHTMLElement", ()=>isHTMLElement);
parcelHelpers.export(exports, "isLastTraversableNode", ()=>isLastTraversableNode);
parcelHelpers.export(exports, "isNode", ()=>isNode);
parcelHelpers.export(exports, "isOverflowElement", ()=>isOverflowElement);
parcelHelpers.export(exports, "isShadowRoot", ()=>isShadowRoot);
parcelHelpers.export(exports, "isTableElement", ()=>isTableElement);
parcelHelpers.export(exports, "isWebKit", ()=>isWebKit);
function getNodeName(node) {
    if (isNode(node)) return (node.nodeName || "").toLowerCase();
    // Mocked nodes in testing environments may not be instances of Node. By
    // returning `#document` an infinite loop won't occur.
    // https://github.com/floating-ui/floating-ui/issues/2317
    return "#document";
}
function getWindow(node) {
    var _node$ownerDocument;
    return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
    var _ref;
    return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
    return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
    return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
    // Browsers without `ShadowRoot` support.
    if (typeof ShadowRoot === "undefined") return false;
    return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
    const { overflow, overflowX, overflowY, display } = getComputedStyle(element);
    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && ![
        "inline",
        "contents"
    ].includes(display);
}
function isTableElement(element) {
    return [
        "table",
        "td",
        "th"
    ].includes(getNodeName(element));
}
function isContainingBlock(element) {
    const webkit = isWebKit();
    const css = getComputedStyle(element);
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
    return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || [
        "transform",
        "perspective",
        "filter"
    ].some((value)=>(css.willChange || "").includes(value)) || [
        "paint",
        "layout",
        "strict",
        "content"
    ].some((value)=>(css.contain || "").includes(value));
}
function getContainingBlock(element) {
    let currentNode = getParentNode(element);
    while(isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)){
        if (isContainingBlock(currentNode)) return currentNode;
        else currentNode = getParentNode(currentNode);
    }
    return null;
}
function isWebKit() {
    if (typeof CSS === "undefined" || !CSS.supports) return false;
    return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
    return [
        "html",
        "body",
        "#document"
    ].includes(getNodeName(node));
}
function getComputedStyle(element) {
    return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
    if (isElement(element)) return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
    };
    return {
        scrollLeft: element.pageXOffset,
        scrollTop: element.pageYOffset
    };
}
function getParentNode(node) {
    if (getNodeName(node) === "html") return node;
    const result = // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node);
    return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
    const parentNode = getParentNode(node);
    if (isLastTraversableNode(parentNode)) return node.ownerDocument ? node.ownerDocument.body : node.body;
    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) return parentNode;
    return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
    var _node$ownerDocument2;
    if (list === void 0) list = [];
    if (traverseIframes === void 0) traverseIframes = true;
    const scrollableAncestor = getNearestOverflowAncestor(node);
    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
    const win = getWindow(scrollableAncestor);
    if (isBody) return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aJ86l":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "set", ()=>set);
parcelHelpers.export(exports, "del", ()=>del);
parcelHelpers.export(exports, "Vue", ()=>_vue);
parcelHelpers.export(exports, "Vue2", ()=>Vue2);
parcelHelpers.export(exports, "isVue2", ()=>isVue2);
parcelHelpers.export(exports, "isVue3", ()=>isVue3);
parcelHelpers.export(exports, "install", ()=>install);
var _vue = require("vue");
parcelHelpers.exportAll(_vue, exports);
var isVue2 = false;
var isVue3 = true;
var Vue2 = undefined;
function install() {}
function set(target, key, val) {
    if (Array.isArray(target)) {
        target.length = Math.max(target.length, key);
        target.splice(key, 1, val);
        return val;
    }
    target[key] = val;
    return val;
}
function del(target, key) {
    if (Array.isArray(target)) {
        target.splice(key, 1);
        return;
    }
    delete target[key];
}

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"72qWX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useFocusOutside);
var _vue = require("vue");
var _useEventJs = require("./useEvent.js");
var _unwrapElJs = require("../utils/unwrapEl.js");
const checkIfElementChild = (parent, child)=>{
    if (!child) return false;
    if (child instanceof Window) return false;
    if (child.parentElement === parent) return true;
    return parent.contains(child);
};
const safeArray = (a)=>Array.isArray(a) ? a : [
        a
    ];
const useFocusOutside = (elements, cb, options = {})=>{
    let previouslyClicked = false;
    if (options.onlyKeyboard) (0, _useEventJs.u)("mousedown", (e)=>{
        previouslyClicked = true;
        setTimeout(()=>{
            previouslyClicked = false;
        }, 200);
    }, true);
    (0, _useEventJs.u)("focus", (event)=>{
        if (options.onlyKeyboard && previouslyClicked) return;
        const focusTarget = event.target;
        if (event.target.shadowRoot) return;
        const isFocusInside = safeArray(elements).some((element)=>{
            const el = (0, _unwrapElJs.u)((0, _vue.unref)(element));
            return el && checkIfElementChild(el, focusTarget);
        });
        if (!isFocusInside) cb(focusTarget);
    }, true);
};

},{"vue":"gzxs9","./useEvent.js":"9kzUn","../utils/unwrapEl.js":"bYHKv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hUyn3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useHTMLElementSelector);
var _vue = require("vue");
var _unwrapElJs = require("../utils/unwrapEl.js");
const useHTMLElementSelector = (key)=>{
    return (0, _vue.computed)(()=>{
        if (typeof (key == null ? void 0 : key.value) === "string") return document.querySelector(key.value);
        return (0, _unwrapElJs.u)(key == null ? void 0 : key.value);
    });
};

},{"vue":"gzxs9","../utils/unwrapEl.js":"bYHKv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"212pc":[function() {},{}],"eUpbA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaDropdownContent);
var _withConfigTransportJs = require("../../../../services/config-transport/withConfigTransport.js");
var _vaDropdownContentVueVueTypeScriptSetupTrueLangJs = require("./VaDropdownContent.vue_vue_type_script_setup_true_lang.js");
const VaDropdownContent = (0, _withConfigTransportJs.w)((0, _vaDropdownContentVueVueTypeScriptSetupTrueLangJs._));

},{"../../../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaDropdownContent.vue_vue_type_script_setup_true_lang.js":"1GrJm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1GrJm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useColorsJs = require("../../../../composables/useColors.js");
var _useTextColorJs = require("../../../../composables/useTextColor.js");
var _vaDropdownContentCss = require("../../../../../VaDropdownContent.css");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaDropdownContent",
    __name: "VaDropdownContent",
    props: {
        noPadding: {
            type: Boolean,
            default: false
        },
        background: {
            type: String,
            default: "background-secondary"
        },
        textColor: {
            type: String
        }
    },
    setup (__props) {
        const props = __props;
        const { getColor } = (0, _useColorsJs.u)();
        const { textColorComputed } = (0, _useTextColorJs.u)((0, _vue.toRef)(props, "background"));
        const computedStyle = (0, _vue.computed)(()=>({
                background: getColor(props.background, void 0, true),
                color: textColorComputed.value,
                padding: props.noPadding ? 0 : void 0
            }));
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: "va-dropdown__content",
                style: (0, _vue.normalizeStyle)(computedStyle.value),
                role: "listbox"
            }, [
                (0, _vue.renderSlot)(_ctx.$slots, "default")
            ], 4);
        };
    }
});

},{"vue":"gzxs9","../../../../composables/useColors.js":"a4Qgv","../../../../composables/useTextColor.js":"5pfXb","../../../../../VaDropdownContent.css":"3Uk3I","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3Uk3I":[function() {},{}],"koywY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useEmitProxy);
const getEvent = (event)=>typeof event === "object" ? event.listen : event;
const getEmit = (event)=>typeof event === "object" ? event.emit : event;
const useEmitProxy = (events)=>{
    const createEmits = ()=>events.map(getEmit);
    const eventToListenerName = (event)=>{
        const eventName = event.charAt(0).toUpperCase() + event.slice(1);
        return `on${eventName}`;
    };
    const createListeners = (emit)=>{
        return events.reduce((acc, key)=>({
                ...acc,
                [eventToListenerName(getEvent(key))]: (...args)=>emit(getEmit(key), ...args)
            }), {});
    };
    const createVOnListeners = (emit)=>{
        return events.reduce((acc, key)=>({
                ...acc,
                [getEvent(key)]: (...args)=>emit(getEmit(key), ...args)
            }), {});
    };
    return {
        createListeners,
        createVOnListeners,
        createEmits
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aKvZ6":[function() {},{}],"WnZ9t":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaButtonToggle);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaButtonToggleVueVueTypeScriptSetupTrueLangJs = require("./VaButtonToggle.vue_vue_type_script_setup_true_lang.js");
const VaButtonToggle = (0, _withConfigTransportJs.w)((0, _vaButtonToggleVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaButtonToggle.vue_vue_type_script_setup_true_lang.js":"8yeB3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8yeB3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _indexJs = require("../va-button/index.js");
var _indexJs1 = require("../va-button-group/index.js");
var _extractComponentOptionsJs = require("../../utils/component-options/extract-component-options.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useSelectableListJs = require("../../composables/useSelectableList.js");
var _useColorsJs = require("../../composables/useColors.js");
var _filterPropsJs = require("../../utils/component-options/filter-props.js");
var _vaButtonToggleCss = require("../../../VaButtonToggle.css");
const VaButtonGroupProps = (0, _extractComponentOptionsJs.e)((0, _indexJs1.V));
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaButtonToggle",
    __name: "VaButtonToggle",
    props: {
        ...VaButtonGroupProps,
        ...(0, _useComponentPresetJs.u),
        ...(0, _useSelectableListJs.u),
        modelValue: {
            type: [
                String,
                Number,
                Boolean
            ],
            default: ""
        },
        options: {
            type: Array,
            required: true
        },
        activeButtonTextColor: {
            type: String
        },
        toggleColor: {
            type: String,
            default: ""
        },
        textBy: {
            type: [
                String,
                Function
            ],
            default: "label"
        },
        valueBy: {
            type: [
                String,
                Function
            ],
            default: "value"
        }
    },
    emits: [
        "update:modelValue"
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const { getText, getTrackBy } = (0, _useSelectableListJs.a)(props);
        const { getColor, shiftHSLAColor } = (0, _useColorsJs.u)();
        const colorComputed = (0, _vue.computed)(()=>getColor(props.color));
        const isToggled = (value)=>getTrackBy(value) === props.modelValue;
        const activeButtonColor = (0, _vue.computed)(()=>{
            if (props.toggleColor) return getColor(props.toggleColor);
            return shiftHSLAColor(colorComputed.value, {
                l: props.plain ? -16 : -6
            });
        });
        const activeButtonBackgroundOpacityComputed = (0, _vue.computed)(()=>{
            if (!props.preset || props.preset === "default") return {};
            return {
                backgroundOpacity: props.pressedOpacity
            };
        });
        const activeButtonPropsComputed = (0, _vue.computed)(()=>({
                color: activeButtonColor.value,
                textColor: props.activeButtonTextColor,
                ...activeButtonBackgroundOpacityComputed.value
            }));
        const getButtonProps = (option = {})=>{
            const iconsProps = {
                icon: option.icon,
                iconRight: option.iconRight
            };
            if (!isToggled(option)) return iconsProps;
            return {
                ...isToggled(option) && activeButtonPropsComputed.value,
                ...iconsProps
            };
        };
        const buttonGroupPropsComputed = (0, _filterPropsJs.f)(VaButtonGroupProps);
        const changeValue = (value)=>emit("update:modelValue", getTrackBy(value));
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs1.V)), (0, _vue.mergeProps)({
                class: "va-button-toggle"
            }, (0, _vue.unref)(buttonGroupPropsComputed)), {
                default: (0, _vue.withCtx)(()=>[
                        ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)(__props.options, (option)=>{
                            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), (0, _vue.mergeProps)({
                                key: (0, _vue.unref)(getTrackBy)(option),
                                "aria-pressed": isToggled(option)
                            }, getButtonProps(option), {
                                onClick: ($event)=>changeValue(option)
                            }), {
                                default: (0, _vue.withCtx)(()=>[
                                        (0, _vue.createTextVNode)((0, _vue.toDisplayString)((0, _vue.unref)(getText)(option)), 1)
                                    ]),
                                _: 2
                            }, 1040, [
                                "aria-pressed",
                                "onClick"
                            ]);
                        }), 128))
                    ]),
                _: 1
            }, 16);
        };
    }
});

},{"vue":"gzxs9","../va-button/index.js":"2vhcC","../va-button-group/index.js":"5oEPw","../../utils/component-options/extract-component-options.js":"1ODzH","../../composables/useComponentPreset.js":"2HoaT","../../composables/useSelectableList.js":"5kDaP","../../composables/useColors.js":"a4Qgv","../../utils/component-options/filter-props.js":"4HycW","../../../VaButtonToggle.css":"7UGpJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5kDaP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useSelectableList);
parcelHelpers.export(exports, "u", ()=>useSelectableListProps);
var _valueByKeyJs = require("../utils/value-by-key.js");
var _isObjectJs = require("../utils/is-object.js");
const useSelectableListProps = {
    options: {
        type: Array,
        default: ()=>[]
    },
    textBy: {
        type: [
            String,
            Function
        ],
        default: "text"
    },
    valueBy: {
        type: [
            String,
            Function
        ],
        default: ""
    },
    trackBy: {
        type: [
            String,
            Function
        ],
        default: ""
    },
    disabledBy: {
        type: [
            String,
            Function
        ],
        default: "disabled"
    },
    groupBy: {
        type: [
            String,
            Function
        ],
        default: "group"
    }
};
function useSelectableList(props) {
    const tryResolveByValue = (value)=>{
        const options = props.options;
        for(let i = 0; i < options.length; i++){
            if (getValue(options[i]) === value) return options[i];
        }
        return value;
    };
    const getOptionProperty = (option, prop)=>{
        if (!(0, _isObjectJs.i)(option)) return option;
        return (0, _valueByKeyJs.a)(option, prop);
    };
    const getTrackBy = (option)=>{
        return props.trackBy ? getOptionProperty(option, props.trackBy) : getValue(option);
    };
    const getDisabled = (option)=>{
        if (!(0, _isObjectJs.i)(option)) return false;
        return getOptionProperty(option, props.disabledBy);
    };
    const getText = (option)=>{
        const optionText = getOptionProperty(option, props.textBy);
        if ([
            "number",
            "boolean"
        ].includes(typeof optionText)) return String(optionText);
        return optionText;
    };
    const getGroupBy = (option)=>{
        if (!(0, _isObjectJs.i)(option)) return void 0;
        return getOptionProperty(option, props.groupBy);
    };
    const getValue = (option)=>getOptionProperty(option, props.valueBy);
    return {
        tryResolveByValue,
        getValue,
        getText,
        getDisabled,
        getTrackBy,
        getGroupBy
    };
}

},{"../utils/value-by-key.js":"aZDG9","../utils/is-object.js":"4iaiI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aZDG9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>getValueByKey);
parcelHelpers.export(exports, "g", ()=>getValueByPath);
var _vendorJs = require("../../vendor.js");
var _isNilValueJs = require("./isNilValue.js");
const getNestedValue = (option, propsArray)=>{
    if (propsArray.length === 0) return option;
    const nestedItem = option[propsArray[0]];
    if (!(0, _vendorJs.l)(nestedItem)) {
        if (propsArray.length === 1) return nestedItem;
        return void 0;
    }
    return getNestedValue(nestedItem, propsArray.slice(1));
};
const getValueByPath = (option, prop)=>{
    if (prop in option) return option[prop];
    prop = prop.replace(/^\./, "");
    return getNestedValue(option, prop.split("."));
};
const getValueByKey = (option, prop)=>{
    if ((0, _isNilValueJs.i)(option) || typeof option !== "object" || Array.isArray(option)) return void 0;
    if (!prop) return option;
    if (typeof prop === "string") return getValueByPath(option, prop);
    if (typeof prop === "function") return prop(option);
    return option;
};

},{"../../vendor.js":"l6TAc","./isNilValue.js":"7ZWWV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7ZWWV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "i", ()=>isNilValue);
const isNilValue = (value)=>{
    return [
        null,
        void 0,
        ""
    ].includes(value);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4iaiI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "i", ()=>isObject);
const isObject = (obj)=>{
    return obj !== null && typeof obj === "object";
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7UGpJ":[function() {},{}],"jR3tW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaCardContent);
parcelHelpers.export(exports, "a", ()=>VaCardTitle);
parcelHelpers.export(exports, "b", ()=>VaCardActions);
parcelHelpers.export(exports, "c", ()=>VaCardBlock);
parcelHelpers.export(exports, "d", ()=>VaCard);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaCardVueVueTypeScriptSetupTrueLangJs = require("./VaCard.vue_vue_type_script_setup_true_lang.js");
var _vaCardContentVueVueTypeScriptSetupTrueLangJs = require("./components/va-card-content/VaCardContent.vue_vue_type_script_setup_true_lang.js");
var _vaCardTitleJs = require("./components/va-card-title/VaCardTitle.js");
var _vaCardActionsVueVueTypeScriptSetupTrueLangJs = require("./components/va-card-actions/VaCardActions.vue_vue_type_script_setup_true_lang.js");
var _vaCardBlockVueVueTypeScriptSetupTrueLangJs = require("./components/va-card-block/VaCardBlock.vue_vue_type_script_setup_true_lang.js");
const VaCardContent = (0, _withConfigTransportJs.w)((0, _vaCardContentVueVueTypeScriptSetupTrueLangJs._));
const VaCardTitle = (0, _withConfigTransportJs.w)((0, _vaCardTitleJs.V));
const VaCardActions = (0, _withConfigTransportJs.w)((0, _vaCardActionsVueVueTypeScriptSetupTrueLangJs._));
const VaCardBlock = (0, _withConfigTransportJs.w)((0, _vaCardBlockVueVueTypeScriptSetupTrueLangJs._));
const VaCard = (0, _withConfigTransportJs.w)((0, _vaCardVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaCard.vue_vue_type_script_setup_true_lang.js":"4QjYL","./components/va-card-content/VaCardContent.vue_vue_type_script_setup_true_lang.js":"fI19z","./components/va-card-title/VaCardTitle.js":"bD7I5","./components/va-card-actions/VaCardActions.vue_vue_type_script_setup_true_lang.js":"1oZ0J","./components/va-card-block/VaCardBlock.vue_vue_type_script_setup_true_lang.js":"3xSfe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4QjYL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../vendor.js");
var _utilsJs = require("../../services/color/utils.js");
var _useRouterLinkJs = require("../../composables/useRouterLink.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useColorsJs = require("../../composables/useColors.js");
var _useTextColorJs = require("../../composables/useTextColor.js");
var _useBemJs = require("../../composables/useBem.js");
var _vaCardCss = require("../../../VaCard.css");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaCard",
    __name: "VaCard",
    props: {
        ...(0, _useRouterLinkJs.u),
        ...(0, _useComponentPresetJs.u),
        tag: {
            type: String,
            default: "div"
        },
        square: {
            type: Boolean,
            default: false
        },
        outlined: {
            type: Boolean,
            default: false
        },
        bordered: {
            type: Boolean,
            default: true
        },
        disabled: {
            type: Boolean,
            default: false
        },
        href: {
            type: String,
            default: ""
        },
        target: {
            type: String,
            default: ""
        },
        stripe: {
            type: Boolean,
            default: false
        },
        stripeColor: {
            type: String,
            default: ""
        },
        gradient: {
            type: Boolean,
            default: false
        },
        textColor: {
            type: String
        },
        color: {
            type: String,
            default: "background-secondary"
        }
    },
    setup (__props) {
        const props = __props;
        const { getColor } = (0, _useColorsJs.u)();
        const { isLinkTag, tagComputed, hrefComputed } = (0, _useRouterLinkJs.a)(props);
        const { textColorComputed } = (0, _useTextColorJs.u)((0, _vue.computed)(()=>getColor(props.color)));
        const stripeColorComputed = (0, _vue.computed)(()=>getColor(props.stripeColor));
        const classComputed = (0, _useBemJs.u)("va-card", ()=>({
                ...(0, _vendorJs.p)(props, [
                    "square",
                    "outlined",
                    "disabled",
                    "stripe"
                ]),
                noBorder: !props.bordered,
                link: isLinkTag.value
            }));
        const cardStyles = (0, _vue.computed)(()=>{
            const background = props.gradient && props.color ? (0, _utilsJs.g)(getColor(props.color)) : getColor(props.color);
            return {
                background,
                color: textColorComputed.value
            };
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.resolveDynamicComponent)((0, _vue.unref)(tagComputed)), {
                class: (0, _vue.normalizeClass)([
                    "va-card",
                    (0, _vue.unref)(classComputed)
                ]),
                style: (0, _vue.normalizeStyle)([
                    cardStyles.value,
                    `--va-stripe-color-computed: ${String(stripeColorComputed.value)}`
                ]),
                href: (0, _vue.unref)(hrefComputed),
                target: __props.target,
                to: _ctx.to,
                replace: _ctx.replace,
                exact: _ctx.exact,
                "active-class": _ctx.activeClass,
                "exact-active-class": _ctx.exactActiveClass
            }, {
                default: (0, _vue.withCtx)(()=>[
                        (0, _vue.renderSlot)(_ctx.$slots, "default")
                    ]),
                _: 3
            }, 8, [
                "class",
                "style",
                "href",
                "target",
                "to",
                "replace",
                "exact",
                "active-class",
                "exact-active-class"
            ]);
        };
    }
});

},{"vue":"gzxs9","../../../vendor.js":"l6TAc","../../services/color/utils.js":"4SMXK","../../composables/useRouterLink.js":"bep51","../../composables/useComponentPreset.js":"2HoaT","../../composables/useColors.js":"a4Qgv","../../composables/useTextColor.js":"5pfXb","../../composables/useBem.js":"igmjV","../../../VaCard.css":"7hyNR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7hyNR":[function() {},{}],"fI19z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vaCardContentCss = require("../../../../../VaCardContent.css");
const _hoisted_1 = {
    class: "va-card__content"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaCardContent",
    __name: "VaCardContent",
    setup (__props) {
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_1, [
                (0, _vue.renderSlot)(_ctx.$slots, "default")
            ]);
        };
    }
});

},{"vue":"gzxs9","../../../../../VaCardContent.css":"55dt8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"55dt8":[function() {},{}],"bD7I5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaCardTitleBase);
var _vaCardTitleVueVueTypeScriptSetupTrueLangJs = require("./VaCardTitle.vue_vue_type_script_setup_true_lang.js");
var _pluginVueExportHelperJs = require("../../../../../plugin-vue_export-helper.js");
var _vaCardTitleCss = require("../../../../../VaCardTitle.css");
const VaCardTitle_vue_vue_type_style_index_0_scoped_5cd66b25_lang = "";
const VaCardTitleBase = /* @__PURE__ */ (0, _pluginVueExportHelperJs._)((0, _vaCardTitleVueVueTypeScriptSetupTrueLangJs._), [
    [
        "__scopeId",
        "data-v-5cd66b25"
    ]
]);

},{"./VaCardTitle.vue_vue_type_script_setup_true_lang.js":"a1pMM","../../../../../plugin-vue_export-helper.js":"broGc","../../../../../VaCardTitle.css":"jFU6g","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a1pMM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useComponentPresetJs = require("../../../../composables/useComponentPreset.js");
var _useColorsJs = require("../../../../composables/useColors.js");
var _vaCardTitleCss = require("../../../../../VaCardTitle.css");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaCardTitle",
    __name: "VaCardTitle",
    props: {
        ...(0, _useComponentPresetJs.u),
        textColor: {
            type: String
        }
    },
    setup (__props) {
        const props = __props;
        const { getColor } = (0, _useColorsJs.u)();
        const titleStyles = (0, _vue.computed)(()=>({
                color: props.textColor ? getColor(props.textColor) : ""
            }));
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: "va-card-title va-card__title",
                style: (0, _vue.normalizeStyle)(titleStyles.value)
            }, [
                (0, _vue.renderSlot)(_ctx.$slots, "default", {}, void 0, true)
            ], 4);
        };
    }
});

},{"vue":"gzxs9","../../../../composables/useComponentPreset.js":"2HoaT","../../../../composables/useColors.js":"a4Qgv","../../../../../VaCardTitle.css":"jFU6g","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jFU6g":[function() {},{}],"broGc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_export_sfc);
const _export_sfc = (sfc, props)=>{
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props)target[key] = val;
    return target;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jFU6g":[function() {},{}],"1oZ0J":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../../../vendor.js");
var _useAlignJs = require("../../../../composables/useAlign.js");
var _useComponentPresetJs = require("../../../../composables/useComponentPreset.js");
var _useBemJs = require("../../../../composables/useBem.js");
var _vaCardActionsCss = require("../../../../../VaCardActions.css");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaCardActions",
    __name: "VaCardActions",
    props: {
        ...(0, _useAlignJs.u),
        ...(0, _useComponentPresetJs.u)
    },
    setup (__props) {
        const props = __props;
        const { alignComputed } = (0, _useAlignJs.a)(props);
        const classComputed = (0, _useBemJs.u)("va-card__actions", ()=>({
                ...(0, _vendorJs.p)(props, [
                    "vertical"
                ])
            }));
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: (0, _vue.normalizeClass)([
                    "va-card__actions",
                    (0, _vue.unref)(classComputed)
                ]),
                style: (0, _vue.normalizeStyle)((0, _vue.unref)(alignComputed))
            }, [
                (0, _vue.renderSlot)(_ctx.$slots, "default")
            ], 6);
        };
    }
});

},{"vue":"gzxs9","../../../../../vendor.js":"l6TAc","../../../../composables/useAlign.js":"9mhWL","../../../../composables/useComponentPreset.js":"2HoaT","../../../../composables/useBem.js":"igmjV","../../../../../VaCardActions.css":"82eJ9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"82eJ9":[function() {},{}],"3xSfe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vaCardBlockCss = require("../../../../../VaCardBlock.css");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaCardBlock",
    __name: "VaCardBlock",
    props: {
        horizontal: {
            type: Boolean,
            default: false
        }
    },
    setup (__props) {
        const props = __props;
        const classComputed = (0, _vue.computed)(()=>({
                "va-card-block--horizontal": props.horizontal
            }));
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: (0, _vue.normalizeClass)([
                    "va-card-block",
                    classComputed.value
                ])
            }, [
                (0, _vue.renderSlot)(_ctx.$slots, "default")
            ], 2);
        };
    }
});

},{"vue":"gzxs9","../../../../../VaCardBlock.css":"jzCuk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jzCuk":[function() {},{}],"jZbtW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaCarousel);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaCarouselVueVueTypeScriptSetupTrueLangJs = require("./VaCarousel.vue_vue_type_script_setup_true_lang.js");
const VaCarousel = (0, _withConfigTransportJs.w)((0, _vaCarouselVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaCarousel.vue_vue_type_script_setup_true_lang.js":"eah4I","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eah4I":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useCarouselJs = require("./hooks/useCarousel.js");
var _useCarouselAnimationJs = require("./hooks/useCarouselAnimation.js");
var _useCarouselColorsJs = require("./hooks/useCarouselColors.js");
var _indexJs = require("../va-image/index.js");
var _indexJs1 = require("../va-button/index.js");
var _indexJs2 = require("../va-hover/index.js");
var _useSwipeJs = require("../../composables/useSwipe.js");
var _extractComponentOptionsJs = require("../../utils/component-options/extract-component-options.js");
var _useStatefulJs = require("../../composables/useStateful.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useTranslationJs = require("../../composables/useTranslation.js");
var _filterPropsJs = require("../../utils/component-options/filter-props.js");
var _vaCarouselCss = require("../../../VaCarousel.css");
const _hoisted_1 = [
    "aria-label"
];
const _hoisted_2 = {
    key: 1,
    class: "va-carousel__indicators"
};
const _hoisted_3 = {
    class: "va-carousel__content"
};
const _hoisted_4 = [
    "aria-hidden",
    "aria-current",
    "aria-label"
];
const VaImageProps = (0, _extractComponentOptionsJs.e)((0, _indexJs.V), [
    "src",
    "alt"
]);
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaCarousel",
    __name: "VaCarousel",
    props: {
        ...(0, _useSwipeJs.u),
        ...(0, _useStatefulJs.u),
        ...(0, _useComponentPresetJs.u),
        ...VaImageProps,
        stateful: {
            type: Boolean,
            default: true
        },
        modelValue: {
            type: Number,
            default: 0
        },
        items: {
            type: Array,
            required: true
        },
        // Animations
        autoscroll: {
            type: Boolean,
            default: false
        },
        autoscrollInterval: {
            type: Number,
            default: 5e3
        },
        autoscrollPauseDuration: {
            type: Number,
            default: 2e3
        },
        infinite: {
            type: Boolean,
            default: true
        },
        fadeKeyframe: {
            type: String,
            default: "va-carousel-fade-appear 1s"
        },
        // Visual
        arrows: {
            type: Boolean,
            default: true
        },
        indicators: {
            type: Boolean,
            default: true
        },
        indicatorTrigger: {
            type: String,
            default: "click",
            validator: (value)=>[
                    "click",
                    "hover",
                    "none"
                ].includes(value)
        },
        vertical: {
            type: Boolean,
            default: false
        },
        height: {
            type: String,
            default: "300px"
        },
        effect: {
            type: String,
            default: "transition",
            validator: (value)=>[
                    "fade",
                    "transition"
                ].includes(value)
        },
        color: {
            type: String,
            default: "primary"
        },
        ratio: {
            type: Number
        },
        ariaLabel: {
            type: String,
            default: "$t:carousel"
        },
        ariaPreviousLabel: {
            type: String,
            default: "$t:goPreviousSlide"
        },
        ariaNextLabel: {
            type: String,
            default: "$t:goNextSlide"
        },
        ariaGoToSlideLabel: {
            type: String,
            default: "$t:goSlide"
        },
        ariaSlideOfLabel: {
            type: String,
            default: "$t:slideOf"
        }
    },
    emits: [
        ...(0, _useStatefulJs.a)
    ],
    setup (__props, { expose: __expose, emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const { valueComputed: currentSlide } = (0, _useStatefulJs.b)(props, emit, "modelValue");
        const { goTo, next, prev, doShowNextButton, doShowPrevButton, doShowDirectionButtons } = (0, _useCarouselJs.u)(props, currentSlide);
        const { withPause, computedSlidesStyle, slides } = (0, _useCarouselAnimationJs.u)(props, currentSlide);
        const isObjectSlides = (0, _vue.computed)(()=>{
            return props.items.length && props.items.every((el)=>!!el && typeof el === "object" && !!(el == null ? void 0 : el.src));
        });
        const isCurrentSlide = (index)=>index === currentSlide.value;
        const slideStyleComputed = (0, _vue.computed)(()=>({
                animation: props.effect === "fade" ? "fadeKeyframe" : void 0
            }));
        const slidesContainer = (0, _vue.shallowRef)();
        const onSwipe = (state)=>{
            switch(state.direction){
                case "right":
                case "up":
                    doShowPrevButton.value && prev();
                    break;
                case "left":
                case "down":
                    doShowNextButton.value && next();
            }
        };
        (0, _useSwipeJs.a)(props, slidesContainer, onSwipe);
        const getIndicatorEvents = (index)=>{
            if (props.indicatorTrigger === "hover") return {
                onmouseover: ()=>goTo(index)
            };
            if (props.indicatorTrigger === "click") return {
                onclick: ()=>goTo(index)
            };
            return {};
        };
        const { tp, t } = (0, _useTranslationJs.u)();
        const { computedActiveColor, computedColor, computedHoverColor } = (0, _useCarouselColorsJs.u)();
        const vaImageProps = (0, _filterPropsJs.f)(VaImageProps);
        const goToWithPause = withPause(goTo);
        const prevWithPause = withPause(prev);
        const nextWithPause = withPause(next);
        __expose({
            currentSlide,
            goTo,
            next,
            prev,
            goToWithPause,
            prevWithPause,
            nextWithPause
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: (0, _vue.normalizeClass)([
                    "va-carousel",
                    {
                        "va-carousel--vertical": _ctx.$props.vertical,
                        [`va-carousel--${_ctx.$props.effect}`]: true
                    }
                ]),
                style: (0, _vue.normalizeStyle)({
                    height: __props.ratio ? "auto" : __props.height
                }),
                role: "region",
                "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaLabel)
            }, [
                _ctx.$props.arrows && (0, _vue.unref)(doShowDirectionButtons) ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                    key: 0
                }, [
                    (0, _vue.unref)(doShowPrevButton) ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                        key: 0,
                        class: "va-carousel__arrow va-carousel__arrow--left",
                        onClick: _cache[0] || (_cache[0] = (...args)=>(0, _vue.unref)(prevWithPause) && (0, _vue.unref)(prevWithPause)(...args)),
                        onKeydown: _cache[1] || (_cache[1] = (0, _vue.withKeys)((0, _vue.withModifiers)(//@ts-ignore
                        (...args)=>(0, _vue.unref)(prevWithPause) && (0, _vue.unref)(prevWithPause)(...args), [
                            "stop"
                        ]), [
                            "enter"
                        ]))
                    }, [
                        (0, _vue.renderSlot)(_ctx.$slots, "prev-arrow", {}, ()=>[
                                (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs2.V)), {
                                    stateful: ""
                                }, {
                                    default: (0, _vue.withCtx)(({ hover })=>[
                                            (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs1.V)), {
                                                color: hover ? (0, _vue.unref)(computedHoverColor) : (0, _vue.unref)(computedColor),
                                                icon: __props.vertical ? "va-arrow-up" : "va-arrow-left",
                                                "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaPreviousLabel)
                                            }, null, 8, [
                                                "color",
                                                "icon",
                                                "aria-label"
                                            ])
                                        ]),
                                    _: 1
                                })
                            ])
                    ], 32)) : (0, _vue.createCommentVNode)("", true),
                    (0, _vue.unref)(doShowNextButton) ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                        key: 1,
                        class: "va-carousel__arrow va-carousel__arrow--right",
                        onClick: _cache[2] || (_cache[2] = (...args)=>(0, _vue.unref)(nextWithPause) && (0, _vue.unref)(nextWithPause)(...args)),
                        onKeydown: _cache[3] || (_cache[3] = (0, _vue.withKeys)((0, _vue.withModifiers)(//@ts-ignore
                        (...args)=>(0, _vue.unref)(nextWithPause) && (0, _vue.unref)(nextWithPause)(...args), [
                            "stop"
                        ]), [
                            "enter"
                        ]))
                    }, [
                        (0, _vue.renderSlot)(_ctx.$slots, "next-arrow", {}, ()=>[
                                (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs2.V)), {
                                    stateful: ""
                                }, {
                                    default: (0, _vue.withCtx)(({ hover })=>[
                                            (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs1.V)), {
                                                color: hover ? (0, _vue.unref)(computedHoverColor) : (0, _vue.unref)(computedColor),
                                                icon: __props.vertical ? "va-arrow-down" : "va-arrow-right",
                                                "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaNextLabel)
                                            }, null, 8, [
                                                "color",
                                                "icon",
                                                "aria-label"
                                            ])
                                        ]),
                                    _: 1
                                })
                            ])
                    ], 32)) : (0, _vue.createCommentVNode)("", true)
                ], 64)) : (0, _vue.createCommentVNode)("", true),
                _ctx.$props.indicators ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_2, [
                    ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)(_ctx.$props.items, (item, index)=>{
                        return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", (0, _vue.mergeProps)({
                            class: [
                                "va-carousel__indicator",
                                {
                                    "va-carousel__indicator--active": isCurrentSlide(index)
                                }
                            ],
                            key: index
                        }, getIndicatorEvents(index)), [
                            (0, _vue.renderSlot)(_ctx.$slots, "indicator", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                item,
                                index,
                                goTo: (0, _vue.unref)(goToWithPause),
                                isActive: isCurrentSlide(index)
                            })), ()=>[
                                    (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs2.V)), {
                                        stateful: ""
                                    }, {
                                        default: (0, _vue.withCtx)(({ hover })=>[
                                                (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs1.V)), {
                                                    "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaGoToSlideLabel, {
                                                        index: index + 1
                                                    }),
                                                    round: "",
                                                    color: isCurrentSlide(index) ? (0, _vue.unref)(computedActiveColor) : hover ? (0, _vue.unref)(computedHoverColor) : (0, _vue.unref)(computedColor)
                                                }, {
                                                    default: (0, _vue.withCtx)(()=>[
                                                            (0, _vue.createTextVNode)((0, _vue.toDisplayString)(index + 1), 1)
                                                        ]),
                                                    _: 2
                                                }, 1032, [
                                                    "aria-label",
                                                    "color"
                                                ])
                                            ]),
                                        _: 2
                                    }, 1024)
                                ])
                        ], 16);
                    }), 128))
                ])) : (0, _vue.createCommentVNode)("", true),
                (0, _vue.createElementVNode)("div", _hoisted_3, [
                    (0, _vue.createElementVNode)("div", {
                        ref_key: "slidesContainer",
                        ref: slidesContainer,
                        class: "va-carousel__slides",
                        style: (0, _vue.normalizeStyle)((0, _vue.unref)(computedSlidesStyle)),
                        role: "list"
                    }, [
                        ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)((0, _vue.unref)(slides), (item, index)=>{
                            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                key: item,
                                role: "listitem",
                                class: "va-carousel__slide",
                                style: (0, _vue.normalizeStyle)(slideStyleComputed.value),
                                "aria-hidden": !isCurrentSlide(index),
                                "aria-current": isCurrentSlide(index),
                                "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaSlideOfLabel, {
                                    index: index + 1,
                                    length: (0, _vue.unref)(slides).length
                                })
                            }, [
                                (0, _vue.renderSlot)(_ctx.$slots, "default", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                    item,
                                    index,
                                    goTo: (0, _vue.unref)(goToWithPause),
                                    isActive: isCurrentSlide(index)
                                })), ()=>[
                                        (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs.V)), (0, _vue.mergeProps)((0, _vue.unref)(vaImageProps), {
                                            src: isObjectSlides.value ? item.src : item,
                                            alt: isObjectSlides.value ? item.alt : "",
                                            draggable: false
                                        }), null, 16, [
                                            "src",
                                            "alt"
                                        ])
                                    ])
                            ], 12, _hoisted_4);
                        }), 128))
                    ], 4)
                ])
            ], 14, _hoisted_1);
        };
    }
});

},{"vue":"gzxs9","./hooks/useCarousel.js":"e6f8f","./hooks/useCarouselAnimation.js":"bwYwt","./hooks/useCarouselColors.js":"7L4vR","../va-image/index.js":"a8Pl8","../va-button/index.js":"2vhcC","../va-hover/index.js":"f04ha","../../composables/useSwipe.js":"bcAbW","../../utils/component-options/extract-component-options.js":"1ODzH","../../composables/useStateful.js":"h9zUi","../../composables/useComponentPreset.js":"2HoaT","../../composables/useTranslation.js":"7S3aV","../../utils/component-options/filter-props.js":"4HycW","../../../VaCarousel.css":"giFXR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e6f8f":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useCarousel);
var _vue = require("vue");
const useCarousel = (props, currentSlide)=>{
    const goTo = (index)=>{
        currentSlide.value = index;
    };
    const prev = ()=>{
        if (props.infinite) {
            if (currentSlide.value <= 0) {
                currentSlide.value = props.items.length - 1;
                return;
            }
        }
        currentSlide.value -= 1;
    };
    const next = ()=>{
        if (props.infinite) {
            if (currentSlide.value >= props.items.length - 1) {
                currentSlide.value = 0;
                return;
            }
        }
        currentSlide.value += 1;
    };
    const doShowDirectionButtons = (0, _vue.computed)(()=>props.items.length > 1);
    const doShowPrevButton = (0, _vue.computed)(()=>currentSlide.value > 0 || props.infinite);
    const doShowNextButton = (0, _vue.computed)(()=>currentSlide.value < props.items.length - 1 || props.infinite);
    return {
        doShowPrevButton,
        doShowNextButton,
        doShowDirectionButtons,
        goTo,
        prev,
        next
    };
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bwYwt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useCarouselAnimation);
var _vue = require("vue");
const useCarouselAnimation = (props, currentSlide)=>{
    let animationInterval = -1;
    const start = ()=>{
        if (!props.autoscroll) return;
        clearInterval(animationInterval);
        animationInterval = setInterval(()=>{
            currentSlide.value += 1;
            if (currentSlide.value >= props.items.length) currentSlide.value = 0;
        }, props.autoscrollInterval);
    };
    let pauseTimeout;
    const pause = ()=>{
        if (!props.autoscroll) return;
        clearInterval(animationInterval);
        pauseTimeout = setTimeout(()=>{
            start();
            clearTimeout(pauseTimeout);
        }, props.autoscrollPauseDuration);
    };
    const stop = ()=>{
        clearInterval(animationInterval);
        clearTimeout(pauseTimeout);
    };
    (0, _vue.onMounted)(()=>start());
    (0, _vue.onBeforeUnmount)(()=>stop());
    const withPause = (fn)=>{
        return (...args)=>{
            pause();
            fn(...args);
        };
    };
    const slidesContainerStyle = (0, _vue.ref)({
        transition: void 0
    });
    const sliderToBeShown = (0, _vue.ref)(0);
    const computedSlidesStyle = (0, _vue.computed)(()=>{
        if (props.effect === "fade") return {
            ...slidesContainerStyle.value,
            transition: "none"
        };
        if (props.vertical) return {
            ...slidesContainerStyle.value,
            transform: `translateY(${sliderToBeShown.value * -100}%)`
        };
        return {
            ...slidesContainerStyle.value,
            transform: `translateX(${sliderToBeShown.value * -100}%)`
        };
    });
    const animator = {
        isAnimating: false,
        speed: 0.3,
        order: [],
        move (from, to) {
            const last = props.items.length - 1;
            const firstAfterLast = props.items.length;
            if (to === 0 && from === last) {
                this.order.push({
                    to: firstAfterLast
                });
                this.order.push({
                    to: 0,
                    animate: false
                });
            } else if (to === last && from === 0) {
                this.order.push({
                    to: firstAfterLast,
                    animate: false
                });
                this.order.push({
                    to
                });
            } else this.order.push({
                to
            });
            if (!this.isAnimating) this.runAnimation();
        },
        runAnimation () {
            this.isAnimating = true;
            const animation = this.order.shift();
            if (!animation) {
                this.isAnimating = false;
                return;
            }
            sliderToBeShown.value = animation == null ? void 0 : animation.to;
            if (animation.animate || animation.animate === void 0) {
                slidesContainerStyle.value.transition = `all ${this.speed}s linear`;
                setTimeout(()=>{
                    this.runAnimation();
                }, this.speed * 1e3);
            } else {
                slidesContainerStyle.value.transition = "none";
                setTimeout(()=>{
                    this.runAnimation();
                }, 16);
            }
        }
    };
    (0, _vue.watch)(currentSlide, (newValue, oldValue)=>{
        animator.move(oldValue, newValue);
    });
    const slides = (0, _vue.computed)(()=>{
        if (props.effect === "fade") return [
            props.items[currentSlide.value]
        ];
        if (props.infinite || props.autoscroll) return [
            ...props.items,
            props.items[0]
        ];
        return props.items;
    });
    return {
        start,
        pause,
        stop,
        withPause,
        computedSlidesStyle,
        slides
    };
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7L4vR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useCarouselColor);
var _vue = require("vue");
var _useColorsJs = require("../../../composables/useColors.js");
const useCarouselColor = ()=>{
    const { setHSLAColor, getColor } = (0, _useColorsJs.u)();
    return {
        computedColor: (0, _vue.computed)(()=>setHSLAColor(getColor("background-element"), {
                a: 0.7
            })),
        computedHoverColor: (0, _vue.computed)(()=>setHSLAColor(getColor("primary"), {
                a: 0.7
            })),
        computedActiveColor: (0, _vue.computed)(()=>getColor("primary"))
    };
};

},{"vue":"gzxs9","../../../composables/useColors.js":"a4Qgv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a8Pl8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaImage);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaImageVueVueTypeScriptSetupTrueLangJs = require("./VaImage.vue_vue_type_script_setup_true_lang.js");
const VaImage = (0, _withConfigTransportJs.w)((0, _vaImageVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaImage.vue_vue_type_script_setup_true_lang.js":"bIuzS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bIuzS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../vendor.js");
var _indexJs = require("../va-aspect-ratio/index.js");
var _indexJs1 = require("../va-fallback/index.js");
var _useNativeImgAttributesJs = require("./hooks/useNativeImgAttributes.js");
var _useIntersectionObserverJs = require("../../composables/useIntersectionObserver.js");
var _extractComponentOptionsJs = require("../../utils/component-options/extract-component-options.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useIsMountedJs = require("../../composables/useIsMounted.js");
var _filterPropsJs = require("../../utils/component-options/filter-props.js");
var _useGlobalConfigJs = require("../../composables/useGlobalConfig.js");
var _vaImageCss = require("../../../VaImage.css");
const _hoisted_1 = [
    "aria-busy"
];
const _hoisted_2 = {
    key: 0,
    class: "va-image__overlay"
};
const _hoisted_3 = {
    key: 1,
    class: "va-image__error"
};
const _hoisted_4 = {
    key: 2,
    class: "va-image__loader"
};
const _hoisted_5 = {
    key: 3,
    class: "va-image__placeholder"
};
const _hoisted_6 = [
    "src"
];
const VaFallbackProps = (0, _extractComponentOptionsJs.e)((0, _indexJs1.V));
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaImage",
    __name: "VaImage",
    props: {
        ...(0, _useComponentPresetJs.u),
        ...(0, _useNativeImgAttributesJs.u),
        ...VaFallbackProps,
        ratio: {
            type: [
                Number,
                String
            ],
            default: "auto",
            validator: (v)=>{
                if (typeof v === "number") return v > 0;
                return v === "auto";
            }
        },
        fit: {
            type: String,
            default: "cover"
        },
        maxWidth: {
            type: Number,
            default: 0,
            validator: (v)=>v >= 0
        },
        lazy: {
            type: Boolean,
            default: false
        },
        placeholderSrc: {
            type: String,
            default: ""
        }
    },
    emits: [
        "loaded",
        "error",
        "fallback"
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const root = (0, _vue.ref)();
        const image = (0, _vue.ref)();
        const renderedImage = (0, _vue.ref)();
        const currentImage = (0, _vue.computed)(()=>renderedImage.value || props.src);
        const imgWidth = (0, _vue.ref)(1);
        const imgHeight = (0, _vue.ref)(1);
        const isLoading = (0, _vue.ref)(false);
        const isError = (0, _vue.ref)(false);
        const handleLoad = ()=>{
            var _a;
            isLoading.value = true;
            if (!isReadyForLoad.value) return;
            isLoading.value = false;
            renderedImage.value = (_a = image.value) == null ? void 0 : _a.currentSrc;
            getImgSizes();
            emit("loaded", currentImage.value);
        };
        const handleError = (err)=>{
            isError.value = true;
            isLoading.value = false;
            emit("error", err || currentImage.value);
        };
        const isIntersecting = (0, _vue.ref)(false);
        const handleIntersection = (entries, observer)=>{
            entries.forEach((entry)=>{
                if (!entry.isIntersecting) return;
                isIntersecting.value = true;
                init();
                observer.disconnect();
            });
        };
        const { isIntersectionDisabled } = (0, _useIntersectionObserverJs.u)(handleIntersection, void 0, root, props.lazy);
        const isReadyForLoad = (0, _vue.computed)(()=>isIntersectionDisabled.value || isIntersecting.value);
        const isMounted = (0, _useIsMountedJs.u)();
        const isReadyForRender = (0, _vue.computed)(()=>!props.lazy || props.lazy && isMounted.value && isReadyForLoad.value);
        const init = ()=>{
            if (!props.src || isLoading.value && isIntersectionDisabled.value || !isReadyForLoad.value) return;
            isLoading.value = true;
            isError.value = false;
            (0, _vue.nextTick)(()=>{
                var _a;
                if (!((_a = image.value) == null ? void 0 : _a.complete)) return;
                if (!image.value.naturalWidth) {
                    handleError();
                    return;
                }
                handleLoad();
            });
        };
        let timer;
        const getImgSizes = ()=>{
            clearTimeout(timer);
            if (isLoading.value) timer = window.setTimeout(getImgSizes, 100);
            const { naturalHeight, naturalWidth } = image.value || {};
            if (naturalHeight && naturalWidth) {
                imgWidth.value = naturalHeight;
                imgHeight.value = naturalWidth;
            }
        };
        (0, _vue.onBeforeMount)(init);
        (0, _vue.onBeforeUnmount)(()=>clearTimeout(timer));
        (0, _vue.watch)(()=>props.src, init);
        const slots = (0, _vue.useSlots)();
        const isPlaceholderPassed = (0, _vue.computed)(()=>{
            var _a;
            return ((_a = slots == null ? void 0 : slots.placeholder) == null ? void 0 : _a.call(slots)) || props.placeholderSrc;
        });
        const isLoaderShown = (0, _vue.computed)(()=>{
            var _a;
            return isLoading.value && !((_a = slots == null ? void 0 : slots.loader) == null ? void 0 : _a.call(slots));
        });
        const isErrorShown = (0, _vue.computed)(()=>{
            var _a;
            return isError.value && !((_a = slots == null ? void 0 : slots.error) == null ? void 0 : _a.call(slots)) && !isAnyFallbackPassed.value;
        });
        const isPlaceholderShown = (0, _vue.computed)(()=>(isLoaderShown.value || isErrorShown.value) && isPlaceholderPassed.value);
        const isSuccessfullyLoaded = (0, _vue.computed)(()=>!(isLoading.value || isError.value));
        const imgAttributesComputed = (0, _useNativeImgAttributesJs.a)(props);
        const aspectRationAttributesComputed = (0, _vue.computed)(()=>({
                ...(0, _vendorJs.p)(props, [
                    "ratio",
                    "maxWidth"
                ]),
                contentWidth: imgWidth.value,
                contentHeight: imgHeight.value
            }));
        const fallbackProps = (0, _filterPropsJs.f)(VaFallbackProps);
        const checkObjectNonEmptyValues = (obj)=>!!Object.values(obj || {}).filter((prop)=>prop).length;
        const hasFallbackGlobalConfig = (0, _vue.computed)(()=>{
            var _a, _b, _c, _d;
            return checkObjectNonEmptyValues((_d = (_c = (_b = (_a = (0, _useGlobalConfigJs.u)()) == null ? void 0 : _a.globalConfig) == null ? void 0 : _b.value) == null ? void 0 : _c.components) == null ? void 0 : _d.VaFallback);
        });
        const isAnyFallbackPassed = (0, _vue.computed)(()=>checkObjectNonEmptyValues(fallbackProps.value) || hasFallbackGlobalConfig.value);
        const fitComputed = (0, _vue.computed)(()=>props.fit);
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), (0, _vue.mergeProps)({
                ref_key: "root",
                ref: root,
                class: "va-image"
            }, aspectRationAttributesComputed.value, {
                style: `--va-fit-computed: ${String(fitComputed.value)}`
            }), {
                default: (0, _vue.withCtx)(()=>[
                        (0, _vue.withDirectives)((0, _vue.createElementVNode)("picture", {
                            class: "va-image__content",
                            "aria-busy": isLoading.value
                        }, [
                            _ctx.$slots.sources ? (0, _vue.renderSlot)(_ctx.$slots, "sources", {
                                key: 0
                            }) : (0, _vue.createCommentVNode)("", true),
                            isReadyForRender.value ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("img", (0, _vue.mergeProps)({
                                key: 1,
                                ref_key: "image",
                                ref: image
                            }, (0, _vue.unref)(imgAttributesComputed), {
                                onError: handleError,
                                onLoad: handleLoad
                            }), null, 16)) : (0, _vue.createCommentVNode)("", true)
                        ], 8, _hoisted_1), [
                            [
                                (0, _vue.vShow),
                                isSuccessfullyLoaded.value
                            ]
                        ]),
                        _ctx.$slots.default && isSuccessfullyLoaded.value ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_2, [
                            (0, _vue.renderSlot)(_ctx.$slots, "default")
                        ])) : (0, _vue.createCommentVNode)("", true),
                        isError.value && (_ctx.$slots.error || isAnyFallbackPassed.value) ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_3, [
                            (0, _vue.renderSlot)(_ctx.$slots, "error", {}, ()=>[
                                    (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs1.V)), (0, _vue.mergeProps)((0, _vue.unref)(fallbackProps), {
                                        onFallback: _cache[0] || (_cache[0] = ($event)=>_ctx.$emit("fallback"))
                                    }), null, 16)
                                ])
                        ])) : (0, _vue.createCommentVNode)("", true),
                        isLoading.value && _ctx.$slots.loader ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_4, [
                            (0, _vue.renderSlot)(_ctx.$slots, "loader")
                        ])) : (0, _vue.createCommentVNode)("", true),
                        isPlaceholderShown.value ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_5, [
                            (0, _vue.renderSlot)(_ctx.$slots, "placeholder", {}, ()=>[
                                    _ctx.$props.placeholderSrc ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("img", {
                                        key: 0,
                                        src: _ctx.$props.placeholderSrc,
                                        alt: ""
                                    }, null, 8, _hoisted_6)) : (0, _vue.createCommentVNode)("", true)
                                ])
                        ])) : (0, _vue.createCommentVNode)("", true)
                    ]),
                _: 3
            }, 16, [
                "style"
            ]);
        };
    }
});

},{"vue":"gzxs9","../../../vendor.js":"l6TAc","../va-aspect-ratio/index.js":"k7XDA","../va-fallback/index.js":"3inAD","./hooks/useNativeImgAttributes.js":"3oXsi","../../composables/useIntersectionObserver.js":"eneIu","../../utils/component-options/extract-component-options.js":"1ODzH","../../composables/useComponentPreset.js":"2HoaT","../../composables/useIsMounted.js":"dEE9p","../../utils/component-options/filter-props.js":"4HycW","../../composables/useGlobalConfig.js":"8pVeR","../../../VaImage.css":"lAAXW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3oXsi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useNativeImgAttributes);
parcelHelpers.export(exports, "u", ()=>useNativeImgAttributesProps);
var _vue = require("vue");
var _vendorJs = require("../../../../vendor.js");
const useNativeImgAttributesProps = {
    src: {
        type: String,
        required: true
    },
    alt: {
        type: String,
        default: ""
    },
    title: {
        type: String,
        default: ""
    },
    sizes: {
        type: String,
        default: ""
    },
    srcset: {
        type: String,
        default: ""
    },
    draggable: {
        type: Boolean,
        default: true
    },
    loading: {
        type: String
    },
    crossorigin: {
        type: String
    },
    decoding: {
        type: String
    },
    fetchpriority: {
        type: String,
        default: "auto"
    },
    referrerpolicy: {
        type: String
    }
};
const useNativeImgAttributes = (props)=>{
    return (0, _vue.computed)(()=>(0, _vendorJs.p)(props, [
            "src",
            "alt",
            "title",
            "sizes",
            "srcset",
            "loading",
            "referrerpolicy",
            "fetchpriority",
            "decoding",
            "crossorigin",
            "draggable"
        ]));
};

},{"vue":"gzxs9","../../../../vendor.js":"l6TAc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eneIu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useIntersectionObserver);
var _vue = require("vue");
var _unwrapElJs = require("../utils/unwrapEl.js");
const useIntersectionObserver = (cb, options = (0, _vue.ref)({}), target = (0, _vue.ref)([]), enabled = true)=>{
    const observer = (0, _vue.ref)();
    const disconnectObserver = ()=>{
        var _a;
        (_a = observer.value) == null || _a.disconnect();
    };
    const observeTarget = (target2)=>{
        var _a;
        const disclosedTarget = (0, _unwrapElJs.u)((0, _vue.unref)(target2));
        disclosedTarget && ((_a = observer.value) == null || _a.observe(disclosedTarget));
    };
    const observeAll = (targets)=>{
        targets.forEach(observeTarget);
    };
    const initObserver = ()=>{
        observer.value = new IntersectionObserver(cb, options.value);
    };
    const isIntersectionDisabled = (0, _vue.computed)(()=>!enabled || !(typeof window !== "undefined" && "IntersectionObserver" in window));
    (0, _vue.watch)([
        target,
        options
    ], ([newTarget])=>{
        if (isIntersectionDisabled.value) return;
        disconnectObserver();
        if (!newTarget) return;
        initObserver();
        Array.isArray(newTarget) ? observeAll(newTarget) : observeTarget(newTarget);
    }, {
        immediate: true
    });
    (0, _vue.onBeforeUnmount)(disconnectObserver);
    return {
        isIntersectionDisabled
    };
};

},{"vue":"gzxs9","../utils/unwrapEl.js":"bYHKv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lAAXW":[function() {},{}],"f04ha":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaHover);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaHoverVueVueTypeScriptSetupTrueLangJs = require("./VaHover.vue_vue_type_script_setup_true_lang.js");
const VaHover = (0, _withConfigTransportJs.w)((0, _vaHoverVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaHover.vue_vue_type_script_setup_true_lang.js":"fCf8S","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fCf8S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useStatefulJs = require("../../composables/useStateful.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaHover",
    __name: "VaHover",
    props: {
        ...(0, _useStatefulJs.c)(true),
        ...(0, _useComponentPresetJs.u),
        disabled: {
            type: Boolean,
            default: false
        },
        modelValue: {
            type: Boolean,
            default: false
        }
    },
    emits: [
        ...(0, _useStatefulJs.a)
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const { valueComputed } = (0, _useStatefulJs.b)(props, emit);
        const onMouseEnter = ()=>{
            if (!props.disabled) valueComputed.value = true;
        };
        const onMouseLeave = ()=>{
            if (!props.disabled) valueComputed.value = false;
        };
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: "va-hover",
                onMouseenter: onMouseEnter,
                onMouseleave: onMouseLeave
            }, [
                (0, _vue.renderSlot)(_ctx.$slots, "default", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                    hover: (0, _vue.unref)(valueComputed)
                })))
            ], 32);
        };
    }
});

},{"vue":"gzxs9","../../composables/useStateful.js":"h9zUi","../../composables/useComponentPreset.js":"2HoaT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bcAbW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useSwipe);
parcelHelpers.export(exports, "u", ()=>useSwipeProps);
var _vue = require("vue");
var _useEventJs = require("./useEvent.js");
const mouseEvents = [
    "mousedown",
    "mousemove"
];
const touchEvents = [
    "touchstart",
    "touchmove"
];
const commonAllowedDirections = {
    vertical: [
        "",
        "all",
        "vertical"
    ],
    horizontal: [
        "",
        "all",
        "horizontal"
    ]
};
const verticalSpecificAllowedDirections = [
    ...commonAllowedDirections.vertical,
    "up",
    "down"
];
const horizontalSpecificAllowedDirections = [
    ...commonAllowedDirections.horizontal,
    "left",
    "right"
];
const useSwipeProps = {
    swipable: {
        type: Boolean,
        default: false
    },
    swipeDistance: {
        type: Number,
        default: 75
    },
    swipeDirection: {
        type: String,
        default: "all"
    }
};
const useSwipe = (props, container, cb)=>{
    const swipeStarted = (0, _vue.ref)(false);
    const swipePath = (0, _vue.reactive)({
        start: {
            x: 0,
            y: 0
        },
        end: {
            x: 0,
            y: 0
        }
    });
    const swipeDuration = (0, _vue.reactive)({
        start: 0,
        end: 0
    });
    const setState = (e, type)=>{
        let event;
        if (mouseEvents.includes(e.type)) event = e;
        if (touchEvents.includes(e.type)) {
            const touchEvent = e;
            event = touchEvent.changedTouches[touchEvent.changedTouches.length - 1];
        }
        if (!event) return;
        swipePath[type].x = event.pageX;
        swipePath[type].y = event.pageY;
        swipeDuration[type] = /* @__PURE__ */ new Date().getTime();
    };
    const onSwipeStart = (e)=>{
        if (!props.swipable || swipeStarted.value) return;
        swipeStarted.value = true;
        setState(e, "start");
    };
    const onSwipeMove = (e)=>{
        if (!swipeStarted.value) return;
        setState(e, "end");
    };
    const resetSwipe = ()=>{
        [
            "start",
            "end"
        ].forEach((type)=>{
            swipePath[type].x = 0;
            swipePath[type].y = 0;
            swipeDuration[type] = 0;
        });
        swipeStarted.value = false;
    };
    const isSwipeAllowed = (0, _vue.reactive)({
        vertical: false,
        horizontal: false
    });
    (0, _vue.watchEffect)(()=>{
        isSwipeAllowed.horizontal = horizontalSpecificAllowedDirections.includes(props.swipeDirection);
        isSwipeAllowed.vertical = verticalSpecificAllowedDirections.includes(props.swipeDirection);
    });
    const calcDistance = (axis)=>{
        return isSwipeAllowed[axis === "x" ? "horizontal" : "vertical"] && swipePath.start[axis] && swipePath.end[axis] ? Math.trunc(swipePath.start[axis] - swipePath.end[axis]) : 0;
    };
    const getAcceptableValue = (direction, result)=>{
        return result === props.swipeDirection || commonAllowedDirections[direction].includes(props.swipeDirection) ? result : "";
    };
    const swipeState = (0, _vue.reactive)({
        direction: "",
        duration: 0
    });
    (0, _vue.watch)(swipePath, ()=>{
        const xDistance = calcDistance("x");
        const yDistance = calcDistance("y");
        if ((xDistance || yDistance) && [
            xDistance,
            yDistance
        ].some((el)=>Math.abs(el) >= props.swipeDistance)) {
            if (Math.abs(xDistance) >= Math.abs(yDistance) && isSwipeAllowed.horizontal) {
                const result = xDistance > 0 ? "left" : "right";
                swipeState.direction = getAcceptableValue("horizontal", result);
            } else if (Math.abs(xDistance) < Math.abs(yDistance) && isSwipeAllowed.vertical) {
                const result = yDistance > 0 ? "down" : "up";
                swipeState.direction = getAcceptableValue("vertical", result);
            }
            swipeState.duration = swipeDuration.end - swipeDuration.start;
            resetSwipe();
        }
    }, {
        deep: true
    });
    (0, _vue.watch)(swipeState, ()=>cb(swipeState), {
        deep: true
    });
    if (props.swipable) {
        (0, _useEventJs.u)([
            "touchstart",
            "mousedown"
        ], onSwipeStart, container);
        (0, _useEventJs.u)([
            "touchmove",
            "mousemove"
        ], onSwipeMove, container);
        (0, _useEventJs.u)([
            "touchcancel",
            "mouseup",
            "touchend",
            "mouseleave"
        ], resetSwipe, container);
    }
    return {
        swipeState
    };
};

},{"vue":"gzxs9","./useEvent.js":"9kzUn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"giFXR":[function() {},{}],"w8J04":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaCheckbox);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaCheckboxVueVueTypeScriptSetupTrueLangJs = require("./VaCheckbox.vue_vue_type_script_setup_true_lang.js");
const VaCheckbox = (0, _withConfigTransportJs.w)((0, _vaCheckboxVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaCheckbox.vue_vue_type_script_setup_true_lang.js":"frgIl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"frgIl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useComponentUuidJs = require("../../composables/useComponentUuid.js");
var _indexJs = require("../va-icon/index.js");
var _useSelectableJs = require("../../composables/useSelectable.js");
var _useKeyboardOnlyFocusJs = require("../../composables/useKeyboardOnlyFocus.js");
var _vaMessageListWrapperVueVueTypeScriptSetupTrueLangJs = require("../va-message-list/VaMessageListWrapper.vue_vue_type_script_setup_true_lang.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useColorsJs = require("../../composables/useColors.js");
var _useTextColorJs = require("../../composables/useTextColor.js");
var _vaCheckboxCss = require("../../../VaCheckbox.css");
const _hoisted_1 = [
    "id",
    "indeterminate",
    "value",
    "checked"
];
const _hoisted_2 = [
    "for"
];
const VaCheckboxValueType = [
    Boolean,
    Array,
    String,
    Object
];
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaCheckbox",
    __name: "VaCheckbox",
    props: {
        ...(0, _useSelectableJs.u),
        ...(0, _useComponentPresetJs.u),
        modelValue: {
            type: VaCheckboxValueType,
            default: false
        },
        color: {
            type: String,
            default: "primary"
        },
        checkedIcon: {
            type: String,
            default: "va-check"
        },
        indeterminate: {
            type: Boolean,
            default: false
        },
        indeterminateValue: {
            type: VaCheckboxValueType,
            default: null
        },
        indeterminateIcon: {
            type: String,
            default: "remove"
        },
        id: {
            type: String,
            default: ""
        },
        name: {
            type: String,
            default: ""
        },
        ariaLabel: {
            type: String,
            default: void 0
        },
        vertical: {
            type: Boolean,
            default: false
        }
    },
    emits: (0, _useSelectableJs.a),
    setup (__props, { expose: __expose, emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const elements = {
            container: (0, _vue.shallowRef)(),
            input: (0, _vue.shallowRef)(),
            label: (0, _vue.shallowRef)()
        };
        const { isChecked, computedError, isIndeterminate, computedErrorMessages, validationAriaAttributes, toggleSelection, onBlur, onFocus } = (0, _useSelectableJs.b)(props, emit, elements);
        const { getColor } = (0, _useColorsJs.u)();
        const { hasKeyboardFocus, keyboardFocusListeners } = (0, _useKeyboardOnlyFocusJs.u)();
        const { textColorComputed } = (0, _useTextColorJs.u)((0, _vue.computed)(()=>getColor(props.color)));
        const isActive = (0, _vue.computed)(()=>isChecked.value || isIndeterminate.value);
        const computedClass = (0, _vue.computed)(()=>({
                "va-checkbox--selected": isChecked.value,
                "va-checkbox--readonly": props.readonly,
                "va-checkbox--disabled": props.disabled,
                "va-checkbox--indeterminate": props.indeterminate,
                "va-checkbox--error": computedError.value,
                "va-checkbox--left-label": props.leftLabel,
                "va-checkbox--on-keyboard-focus": hasKeyboardFocus.value
            }));
        const getPaddingStyle = ()=>{
            switch(true){
                case !props.label:
                    return "";
                case props.vertical:
                    return "var(--va-checkbox-vertical-padding)";
                case Boolean(props.arrayValue):
                    return "var(--va-checkbox-horizontal-padding)";
                case props.leftLabel:
                    return "var(--va-checkbox-right-padding)";
                default:
                    return "var(--va-checkbox-left-padding)";
            }
        };
        const labelStyle = (0, _vue.computed)(()=>{
            return {
                color: computedError.value ? getColor("danger") : props.success ? getColor("success") : "",
                padding: getPaddingStyle()
            };
        });
        const inputStyle = (0, _vue.computed)(()=>{
            const style = {
                background: isActive.value ? getColor(props.color) : "",
                borderColor: isActive.value ? getColor(props.color) : ""
            };
            if (computedError.value) style.borderColor = getColor("danger");
            if (props.success) style.borderColor = getColor("success");
            return style;
        });
        const computedIconName = (0, _vue.computed)(()=>props.indeterminate && isIndeterminate.value ? props.indeterminateIcon : props.checkedIcon);
        const uniqueId = (0, _useComponentUuidJs.u)();
        const computedId = (0, _vue.computed)(()=>props.id || String(uniqueId));
        const computedName = (0, _vue.computed)(()=>props.name || String(uniqueId));
        const inputAttributesComputed = (0, _vue.computed)(()=>({
                name: computedName.value,
                disabled: props.disabled,
                readonly: props.readonly,
                tabindex: props.disabled ? -1 : 0,
                "aria-label": props.ariaLabel,
                "aria-disabled": props.disabled,
                "aria-readOnly": props.readonly,
                "aria-checked": isActive.value,
                ...validationAriaAttributes.value
            }));
        const displayVal = (0, _vue.computed)(()=>props.vertical ? "--va-checkbox-display-flex" : "var(--va-checkbox-display)");
        __expose({
            toggleSelection
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _vaMessageListWrapperVueVueTypeScriptSetupTrueLangJs._)), {
                class: (0, _vue.normalizeClass)([
                    "va-checkbox",
                    computedClass.value
                ]),
                disabled: _ctx.disabled,
                success: _ctx.success,
                messages: _ctx.messages,
                error: (0, _vue.unref)(computedError),
                "error-messages": (0, _vue.unref)(computedErrorMessages),
                "error-count": _ctx.errorCount,
                style: (0, _vue.normalizeStyle)(`--va-display-val: ${String(displayVal.value)}`)
            }, {
                default: (0, _vue.withCtx)(()=>[
                        (0, _vue.createElementVNode)("div", {
                            ref: "container",
                            class: "va-checkbox__input-container",
                            onClick: _cache[6] || (_cache[6] = (...args)=>(0, _vue.unref)(toggleSelection) && (0, _vue.unref)(toggleSelection)(...args)),
                            onBlur: _cache[7] || (_cache[7] = (...args)=>(0, _vue.unref)(onBlur) && (0, _vue.unref)(onBlur)(...args))
                        }, [
                            (0, _vue.createElementVNode)("div", {
                                class: "va-checkbox__square",
                                style: (0, _vue.normalizeStyle)(inputStyle.value),
                                onSelectstart: _cache[4] || (_cache[4] = (0, _vue.withModifiers)(()=>{}, [
                                    "prevent"
                                ]))
                            }, [
                                (0, _vue.createElementVNode)("input", (0, _vue.mergeProps)({
                                    ref: "input",
                                    type: "checkbox",
                                    class: "va-checkbox__input",
                                    id: computedId.value,
                                    indeterminate: __props.indeterminate,
                                    value: _ctx.label,
                                    checked: isActive.value
                                }, inputAttributesComputed.value, (0, _vue.toHandlers)((0, _vue.unref)(keyboardFocusListeners), true), {
                                    onFocus: _cache[0] || (_cache[0] = (...args)=>(0, _vue.unref)(onFocus) && (0, _vue.unref)(onFocus)(...args)),
                                    onBlur: _cache[1] || (_cache[1] = (...args)=>(0, _vue.unref)(onBlur) && (0, _vue.unref)(onBlur)(...args)),
                                    onClick: _cache[2] || (_cache[2] = (0, _vue.withModifiers)(()=>{}, [
                                        "stop",
                                        "prevent"
                                    ])),
                                    onKeypress: _cache[3] || (_cache[3] = (0, _vue.withModifiers)(//@ts-ignore
                                    (...args)=>(0, _vue.unref)(toggleSelection) && (0, _vue.unref)(toggleSelection)(...args), [
                                        "prevent"
                                    ]))
                                }), null, 16, _hoisted_1),
                                (0, _vue.withDirectives)((0, _vue.createVNode)((0, _vue.unref)((0, _indexJs.V)), {
                                    class: "va-checkbox__icon",
                                    name: computedIconName.value,
                                    color: (0, _vue.unref)(textColorComputed)
                                }, null, 8, [
                                    "name",
                                    "color"
                                ]), [
                                    [
                                        (0, _vue.vShow),
                                        isActive.value
                                    ]
                                ])
                            ], 36),
                            _ctx.label || _ctx.$slots.label ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("label", {
                                key: 0,
                                ref: "label",
                                class: "va-checkbox__label",
                                for: computedId.value,
                                style: (0, _vue.normalizeStyle)(labelStyle.value),
                                onBlur: _cache[5] || (_cache[5] = (...args)=>(0, _vue.unref)(onBlur) && (0, _vue.unref)(onBlur)(...args))
                            }, [
                                (0, _vue.renderSlot)(_ctx.$slots, "label", {}, ()=>[
                                        (0, _vue.createTextVNode)((0, _vue.toDisplayString)(_ctx.label), 1)
                                    ])
                            ], 44, _hoisted_2)) : (0, _vue.createCommentVNode)("", true)
                        ], 544)
                    ]),
                _: 3
            }, 8, [
                "class",
                "disabled",
                "success",
                "messages",
                "error",
                "error-messages",
                "error-count",
                "style"
            ]);
        };
    }
});

},{"vue":"gzxs9","../../composables/useComponentUuid.js":"cuNNa","../va-icon/index.js":"82tPo","../../composables/useSelectable.js":"3Z4bC","../../composables/useKeyboardOnlyFocus.js":"lKbNJ","../va-message-list/VaMessageListWrapper.vue_vue_type_script_setup_true_lang.js":"050bm","../../composables/useComponentPreset.js":"2HoaT","../../composables/useColors.js":"a4Qgv","../../composables/useTextColor.js":"5pfXb","../../../VaCheckbox.css":"lBd87","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3Z4bC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useSelectableEmits);
parcelHelpers.export(exports, "b", ()=>useSelectable);
parcelHelpers.export(exports, "u", ()=>useSelectableProps);
var _vue = require("vue");
var _useStatefulJs = require("./useStateful.js");
var _useLoadingJs = require("./useLoading.js");
var _useValidationJs = require("./useValidation.js");
var _useFocusJs = require("./useFocus.js");
var _unwrapElJs = require("../utils/unwrapEl.js");
const useSelectableProps = {
    ...(0, _useStatefulJs.u),
    ...(0, _useLoadingJs.u),
    ...(0, _useValidationJs.b),
    arrayValue: {
        type: [
            String,
            Boolean,
            Object,
            Number
        ],
        default: null
    },
    label: {
        type: String,
        default: ""
    },
    leftLabel: {
        type: Boolean,
        default: false
    },
    trueValue: {
        type: null,
        default: true
    },
    falseValue: {
        type: null,
        default: false
    },
    indeterminate: {
        type: Boolean,
        default: false
    },
    indeterminateValue: {
        type: null,
        default: null
    },
    disabled: {
        type: Boolean,
        default: false
    },
    readonly: {
        type: Boolean,
        default: false
    }
};
const useSelectableEmits = [
    ...(0, _useValidationJs.u),
    "update:modelValue",
    "focus",
    "blur"
];
const checkDuplicates = (props)=>{
    const values = [
        props.falseValue,
        props.trueValue
    ];
    if (props.indeterminate) values.push(props.indeterminateValue);
    const hasDuplicates = new Set(values).size !== values.length;
    if (hasDuplicates) throw new Error("falseValue, trueValue, indeterminateValue props should have strictly different values, which is not the case.");
};
const useSelectable = (props, emit, { input, label, container })=>{
    checkDuplicates(props);
    const reset = ()=>withoutValidation(()=>{
            emit("update:modelValue", false);
            resetValidation();
        });
    const focus = ()=>{
        var _a;
        (_a = (0, _unwrapElJs.u)(input.value)) == null || _a.focus();
    };
    const { valueComputed } = (0, _useStatefulJs.b)(props, emit);
    const { computedError, computedErrorMessages, validate, validationAriaAttributes, withoutValidation, resetValidation } = (0, _useValidationJs.a)(props, emit, {
        reset,
        focus,
        value: valueComputed
    });
    const { isFocused } = (0, _useFocusJs.u)();
    const isElementRelated = (element)=>{
        return !!element && [
            (0, _unwrapElJs.u)(label.value),
            (0, _unwrapElJs.u)(container.value)
        ].includes(element);
    };
    const onBlur = (event)=>{
        if (input.value === event.target && !isElementRelated(event.relatedTarget)) {
            isFocused.value = false;
            validate();
            emit("blur", event);
        }
    };
    const onFocus = (event)=>{
        isFocused.value = true;
        emit("focus", event);
    };
    const isIndeterminate = (0, _vue.computed)(()=>props.indeterminate && valueComputed.value === props.indeterminateValue);
    const modelIsArray = (0, _vue.computed)(()=>props.arrayValue !== void 0 && props.arrayValue !== null);
    const isChecked = (0, _vue.computed)(()=>{
        var _a;
        if (modelIsArray.value) return (_a = props.modelValue) == null ? void 0 : _a.includes(props.arrayValue);
        return valueComputed.value === props.trueValue;
    });
    const toggleSelection = ()=>{
        if (props.readonly || props.disabled || props.loading) return;
        if (modelIsArray.value) {
            if (!props.modelValue) emit("update:modelValue", [
                props.arrayValue
            ]);
            else if (!Array.isArray(props.modelValue)) emit("update:modelValue", props.modelValue === props.arrayValue ? [] : [
                props.modelValue,
                props.arrayValue
            ]);
            else if (props.modelValue.includes(props.arrayValue)) emit("update:modelValue", props.modelValue.filter((option)=>option !== props.arrayValue));
            else emit("update:modelValue", props.modelValue.concat(props.arrayValue));
            return;
        }
        if (props.indeterminate) {
            if (isIndeterminate.value) valueComputed.value = props.trueValue;
            else if (isChecked.value) valueComputed.value = props.falseValue;
            else valueComputed.value = props.indeterminateValue;
            return;
        }
        if (isChecked.value) valueComputed.value = props.falseValue;
        else valueComputed.value = props.trueValue;
    };
    return {
        isChecked,
        isIndeterminate,
        onBlur,
        onFocus,
        toggleSelection,
        reset,
        focus,
        computedError,
        computedErrorMessages,
        validationAriaAttributes
    };
};

},{"vue":"gzxs9","./useStateful.js":"h9zUi","./useLoading.js":"jYmWj","./useValidation.js":"iFHh2","./useFocus.js":"8TBqW","../utils/unwrapEl.js":"bYHKv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lKbNJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useKeyboardOnlyFocusGlobal);
parcelHelpers.export(exports, "u", ()=>useKeyboardOnlyFocus);
var _vue = require("vue");
var _ssrJs = require("../utils/ssr.js");
var _a;
function useKeyboardOnlyFocus() {
    const hasKeyboardFocus = (0, _vue.ref)(false);
    let previouslyClicked2 = false;
    const keyboardFocusListeners = {
        mousedown: ()=>{
            previouslyClicked2 = true;
        },
        focus: ()=>{
            if (!previouslyClicked2) hasKeyboardFocus.value = true;
            previouslyClicked2 = false;
        },
        blur: ()=>{
            hasKeyboardFocus.value = false;
            previouslyClicked2 = false;
        }
    };
    return {
        hasKeyboardFocus,
        keyboardFocusListeners
    };
}
let previouslyClicked = false;
(_a = (0, _ssrJs.g)()) == null || _a.addEventListener("mousedown", ()=>{
    previouslyClicked = true;
    setTimeout(()=>{
        previouslyClicked = false;
    }, 300);
});
function useKeyboardOnlyFocusGlobal() {
    const hasKeyboardFocus = (0, _vue.ref)(false);
    const keyboardFocusListeners = {
        focus: ()=>{
            if (!previouslyClicked) hasKeyboardFocus.value = true;
        },
        blur: ()=>{
            hasKeyboardFocus.value = false;
        }
    };
    return {
        hasKeyboardFocus,
        keyboardFocusListeners
    };
}

},{"vue":"gzxs9","../utils/ssr.js":"cVJXV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lBd87":[function() {},{}],"9Dcs3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaChip);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaChipVueVueTypeScriptSetupTrueLangJs = require("./VaChip.vue_vue_type_script_setup_true_lang.js");
const VaChip = (0, _withConfigTransportJs.w)((0, _vaChipVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaChip.vue_vue_type_script_setup_true_lang.js":"iWKyi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iWKyi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../vendor.js");
var _indexJs = require("../va-icon/index.js");
var _useColorsJs = require("../../composables/useColors.js");
var _utilsJs = require("../../services/color/utils.js");
var _useRouterLinkJs = require("../../composables/useRouterLink.js");
var _useStatefulJs = require("../../composables/useStateful.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useTextColorJs = require("../../composables/useTextColor.js");
var _useKeyboardOnlyFocusJs = require("../../composables/useKeyboardOnlyFocus.js");
var _useHoverJs = require("../../composables/useHover.js");
var _useBemJs = require("../../composables/useBem.js");
var _useTranslationJs = require("../../composables/useTranslation.js");
var _vaChipCss = require("../../../VaChip.css");
const _hoisted_1 = {
    class: "va-chip__content"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaChip",
    __name: "VaChip",
    props: {
        ...(0, _useRouterLinkJs.u),
        ...(0, _useColorsJs.a),
        ...(0, _useStatefulJs.u),
        ...(0, _useComponentPresetJs.u),
        modelValue: {
            type: Boolean,
            default: true
        },
        closeable: {
            type: Boolean,
            default: false
        },
        outline: {
            type: Boolean,
            default: false
        },
        disabled: {
            type: Boolean,
            default: false
        },
        readonly: {
            type: Boolean,
            default: false
        },
        square: {
            type: Boolean,
            default: false
        },
        shadow: {
            type: Boolean,
            default: false
        },
        flat: {
            type: Boolean,
            default: false
        },
        icon: {
            type: String,
            default: ""
        },
        tag: {
            type: String,
            default: "span"
        },
        size: {
            type: String,
            default: "medium",
            validator: (value)=>[
                    "small",
                    "medium",
                    "large"
                ].includes(value)
        },
        ariaCloseLabel: {
            type: String,
            default: "$t:close"
        }
    },
    emits: [
        ...(0, _useStatefulJs.a),
        "focus"
    ],
    setup (__props, { expose: __expose, emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const { getColor } = (0, _useColorsJs.u)();
        const colorComputed = (0, _vue.computed)(()=>getColor(props.color));
        const borderColor = (0, _vue.computed)(()=>props.outline ? colorComputed.value : "");
        const isTransparentBackground = (0, _vue.computed)(()=>Boolean(props.outline || props.flat));
        const { textColorComputed } = (0, _useTextColorJs.u)(colorComputed, isTransparentBackground);
        const { hasKeyboardFocus, keyboardFocusListeners } = (0, _useKeyboardOnlyFocusJs.u)();
        const shadowStyle = (0, _vue.computed)(()=>{
            if (!props.shadow || props.flat || props.outline || props.disabled || hasKeyboardFocus.value) return;
            return `0 0.125rem 0.19rem 0 ${(0, _utilsJs.a)(colorComputed.value)}`;
        });
        const { valueComputed } = (0, _useStatefulJs.b)(props, emit);
        const { tagComputed, hrefComputed } = (0, _useRouterLinkJs.a)(props);
        const { isHovered, onMouseEnter, onMouseLeave } = (0, _useHoverJs.u)();
        const close = ()=>{
            if (!props.disabled) valueComputed.value = false;
        };
        const iconSize = (0, _vue.computed)(()=>props.size);
        const tabIndexComputed = (0, _vue.computed)(()=>props.disabled ? -1 : 0);
        const computedClass = (0, _useBemJs.u)("va-chip", ()=>({
                ...(0, _vendorJs.p)(props, [
                    "disabled",
                    "readonly",
                    "square"
                ]),
                small: props.size === "small",
                large: props.size === "large"
            }));
        const computedStyle = (0, _vue.computed)(()=>{
            const result = {
                color: textColorComputed.value,
                borderColor: borderColor.value,
                background: "",
                boxShadow: shadowStyle.value
            };
            if (props.outline || props.flat) {
                if (hasKeyboardFocus.value) result.background = (0, _utilsJs.b)(colorComputed.value);
                else if (!props.readonly && isHovered.value) result.background = (0, _utilsJs.c)(colorComputed.value);
            } else result.background = colorComputed.value;
            return result;
        });
        const { tp } = (0, _useTranslationJs.u)();
        __expose({
            close
        });
        return (_ctx, _cache)=>{
            return (0, _vue.unref)(valueComputed) ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.resolveDynamicComponent)((0, _vue.unref)(tagComputed)), {
                key: 0,
                class: (0, _vue.normalizeClass)([
                    "va-chip",
                    (0, _vue.unref)(computedClass)
                ]),
                href: (0, _vue.unref)(hrefComputed),
                target: _ctx.target,
                to: _ctx.to,
                replace: _ctx.replace,
                exact: _ctx.exact,
                "active-class": _ctx.activeClass,
                "exact-active-class": _ctx.exactActiveClass,
                style: (0, _vue.normalizeStyle)(computedStyle.value)
            }, {
                default: (0, _vue.withCtx)(()=>[
                        (0, _vue.createElementVNode)("span", (0, _vue.mergeProps)({
                            class: "va-chip__inner",
                            onFocus: _cache[0] || (_cache[0] = ($event)=>_ctx.$emit("focus")),
                            onMouseenter: _cache[1] || (_cache[1] = (...args)=>(0, _vue.unref)(onMouseEnter) && (0, _vue.unref)(onMouseEnter)(...args)),
                            onMouseleave: _cache[2] || (_cache[2] = (...args)=>(0, _vue.unref)(onMouseLeave) && (0, _vue.unref)(onMouseLeave)(...args))
                        }, (0, _vue.toHandlers)((0, _vue.unref)(keyboardFocusListeners), true)), [
                            __props.icon ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), {
                                key: 0,
                                class: "va-chip__icon",
                                name: __props.icon,
                                size: iconSize.value
                            }, null, 8, [
                                "name",
                                "size"
                            ])) : (0, _vue.createCommentVNode)("", true),
                            (0, _vue.createElementVNode)("span", _hoisted_1, [
                                (0, _vue.renderSlot)(_ctx.$slots, "default")
                            ]),
                            __props.closeable ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), {
                                key: 1,
                                role: "button",
                                name: "va-close",
                                class: "va-chip__close-icon",
                                "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaCloseLabel),
                                tabindex: tabIndexComputed.value,
                                size: iconSize.value,
                                onClick: (0, _vue.withModifiers)(close, [
                                    "stop"
                                ]),
                                onKeydown: [
                                    (0, _vue.withKeys)((0, _vue.withModifiers)(close, [
                                        "stop"
                                    ]), [
                                        "enter"
                                    ]),
                                    (0, _vue.withKeys)((0, _vue.withModifiers)(close, [
                                        "stop"
                                    ]), [
                                        "space"
                                    ])
                                ]
                            }, null, 8, [
                                "aria-label",
                                "tabindex",
                                "size",
                                "onKeydown"
                            ])) : (0, _vue.createCommentVNode)("", true)
                        ], 16)
                    ]),
                _: 3
            }, 8, [
                "href",
                "target",
                "to",
                "replace",
                "exact",
                "active-class",
                "exact-active-class",
                "class",
                "style"
            ])) : (0, _vue.createCommentVNode)("", true);
        };
    }
});

},{"vue":"gzxs9","../../../vendor.js":"l6TAc","../va-icon/index.js":"82tPo","../../composables/useColors.js":"a4Qgv","../../services/color/utils.js":"4SMXK","../../composables/useRouterLink.js":"bep51","../../composables/useStateful.js":"h9zUi","../../composables/useComponentPreset.js":"2HoaT","../../composables/useTextColor.js":"5pfXb","../../composables/useKeyboardOnlyFocus.js":"lKbNJ","../../composables/useHover.js":"6F99t","../../composables/useBem.js":"igmjV","../../composables/useTranslation.js":"7S3aV","../../../VaChip.css":"9As7A","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9As7A":[function() {},{}],"2GF8q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaCollapse);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaCollapseVueVueTypeScriptSetupTrueLangJs = require("./VaCollapse.vue_vue_type_script_setup_true_lang.js");
const VaCollapse = (0, _withConfigTransportJs.w)((0, _vaCollapseVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaCollapse.vue_vue_type_script_setup_true_lang.js":"2ksU3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2ksU3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../vendor.js");
var _useAccordionJs = require("../va-accordion/hooks/useAccordion.js");
var _useComponentUuidJs = require("../../composables/useComponentUuid.js");
var _indexJs = require("../va-icon/index.js");
var _useSelectableJs = require("../../composables/useSelectable.js");
var _useResizeObserverJs = require("../../composables/useResizeObserver.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useStatefulJs = require("../../composables/useStateful.js");
var _useColorsJs = require("../../composables/useColors.js");
var _useBemJs = require("../../composables/useBem.js");
var _useTextColorJs = require("../../composables/useTextColor.js");
var _vaCollapseCss = require("../../../VaCollapse.css");
const _hoisted_1 = {
    class: "va-collapse__header__text"
};
const _hoisted_2 = [
    "id",
    "aria-labelledby"
];
const _hoisted_3 = {
    class: "va-collapse__content"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaCollapse",
    __name: "VaCollapse",
    props: {
        ...(0, _useComponentPresetJs.u),
        ...(0, _useStatefulJs.u),
        modelValue: {
            type: Boolean,
            default: false
        },
        disabled: {
            type: Boolean,
            default: false
        },
        header: {
            type: String,
            default: ""
        },
        icon: {
            type: String,
            default: ""
        },
        color: {
            type: String,
            default: void 0
        },
        bodyColor: {
            type: String,
            default: void 0
        },
        textColor: {
            type: String,
            default: ""
        },
        bodyTextColor: {
            type: String,
            default: ""
        },
        iconColor: {
            type: String,
            default: "secondary"
        },
        colorAll: {
            type: Boolean,
            default: false
        },
        stateful: {
            type: Boolean,
            default: true
        }
    },
    emits: [
        "update:modelValue",
        ...(0, _useSelectableJs.a)
    ],
    setup (__props, { expose: __expose, emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const body = (0, _vue.shallowRef)();
        const { valueComputed } = (0, _useStatefulJs.b)(props, emit, "modelValue");
        const { getColor, getTextColor, setHSLAColor } = (0, _useColorsJs.u)();
        const { accordionProps, accordionItemValue } = (0, _useAccordionJs.a)();
        const computedModelValue = (0, _vue.computed)({
            get () {
                if (valueComputed.userProvided) return valueComputed.value;
                if (!(0, _vendorJs.i)(accordionItemValue)) return accordionItemValue.value;
                return valueComputed.value;
            },
            set (v) {
                if (!(0, _vendorJs.i)(accordionItemValue)) accordionItemValue.value = v;
                valueComputed.value = v;
            }
        });
        if (valueComputed.userProvided && !(0, _vendorJs.i)(accordionItemValue)) accordionItemValue.value = valueComputed.value;
        const bodyHeight = (0, _vue.ref)();
        (0, _useResizeObserverJs.u)([
            body
        ], ([body2])=>{
            bodyHeight.value = body2.contentRect.height ?? 0;
        });
        const height = (0, _vue.computed)(()=>computedModelValue.value ? bodyHeight.value : 0);
        const getTransition = ()=>{
            const duration = height.value / 1e3 * 0.2;
            return `${duration > 0.2 ? duration : 0.2}s`;
        };
        const contentBackground = (0, _vue.computed)(()=>{
            if (props.bodyColor) return getColor(props.bodyColor);
            return props.color && props.colorAll ? setHSLAColor(getColor(props.color), {
                a: 0.07
            }) : void 0;
        });
        const headerBackground = (0, _vue.computed)(()=>{
            return props.color ? getColor(props.color) : void 0;
        });
        const uniqueId = (0, _useComponentUuidJs.u)();
        const headerIdComputed = (0, _vue.computed)(()=>`header-${uniqueId}`);
        const panelIdComputed = (0, _vue.computed)(()=>`panel-${uniqueId}`);
        const tabIndexComputed = (0, _vue.computed)(()=>props.disabled ? -1 : 0);
        const headerAttributes = (0, _vue.computed)(()=>({
                id: headerIdComputed.value,
                tabindex: tabIndexComputed.value,
                "aria-controls": panelIdComputed.value,
                "aria-expanded": computedModelValue.value,
                "aria-disabled": props.disabled,
                role: "button"
            }));
        const isHeightChanging = (0, _vue.ref)(false);
        (0, _vue.watch)(height, (newValue, oldValue)=>{
            if (oldValue === void 0) return;
            if (isHeightChanging.value === true) return;
            isHeightChanging.value = true;
        });
        const onTransitionEnd = (e)=>{
            if (e.propertyName === "height" && e.target === e.currentTarget) isHeightChanging.value = false;
        };
        const computedClasses = (0, _useBemJs.u)("va-collapse", ()=>({
                ...(0, _vendorJs.p)(props, [
                    "disabled"
                ]),
                expanded: computedModelValue.value,
                active: computedModelValue.value,
                popout: !!(accordionProps.value.popout && computedModelValue.value),
                inset: !!(accordionProps.value.inset && computedModelValue.value),
                "height-changing": isHeightChanging.value,
                "colored-body": Boolean(contentBackground.value),
                "colored-header": Boolean(headerBackground.value)
            }));
        const toggle = ()=>{
            if (props.disabled) return;
            computedModelValue.value = !computedModelValue.value;
        };
        const { textColorComputed } = (0, _useTextColorJs.u)(headerBackground);
        const headerStyle = (0, _vue.computed)(()=>({
                color: textColorComputed.value,
                backgroundColor: headerBackground.value
            }));
        const doRenderBody = (0, _vue.computed)(()=>{
            if (computedModelValue.value) return true;
            if (isHeightChanging.value) return true;
            return false;
        });
        const contentStyle = (0, _vue.computed)(()=>{
            return {
                height: `${height.value}px`,
                transitionDuration: getTransition(),
                background: computedModelValue.value ? contentBackground.value : "",
                color: props.bodyTextColor ? getColor(props.bodyTextColor) : contentBackground.value ? getColor(getTextColor(contentBackground.value)) : "currentColor"
            };
        });
        __expose({
            toggle
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: (0, _vue.normalizeClass)([
                    "va-collapse",
                    (0, _vue.unref)(computedClasses)
                ])
            }, [
                (0, _vue.createElementVNode)("div", {
                    class: "va-collapse__header-wrapper",
                    onClick: toggle,
                    onKeydown: [
                        (0, _vue.withKeys)(toggle, [
                            "enter"
                        ]),
                        (0, _vue.withKeys)(toggle, [
                            "space"
                        ])
                    ]
                }, [
                    (0, _vue.renderSlot)(_ctx.$slots, "header", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                        value: computedModelValue.value,
                        bind: headerAttributes.value,
                        attributes: headerAttributes.value,
                        attrs: headerAttributes.value,
                        iconAttrs: {
                            class: [
                                "va-collapse__expand-icon",
                                computedModelValue.value ? "a-collapse__expand-icon--expanded" : "a-collapse__expand-icon--collapsed"
                            ]
                        },
                        text: __props.header
                    })), ()=>[
                            (0, _vue.createElementVNode)("div", (0, _vue.mergeProps)(headerAttributes.value, {
                                class: "va-collapse__header",
                                style: headerStyle.value
                            }), [
                                __props.icon ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), {
                                    key: 0,
                                    class: "va-collapse__header__icon",
                                    name: __props.icon
                                }, null, 8, [
                                    "name"
                                ])) : (0, _vue.createCommentVNode)("", true),
                                (0, _vue.renderSlot)(_ctx.$slots, "header-content", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                    header: __props.header
                                })), ()=>[
                                        (0, _vue.createElementVNode)("div", _hoisted_1, (0, _vue.toDisplayString)(__props.header), 1)
                                    ]),
                                (0, _vue.renderSlot)(_ctx.$slots, "expand-icon", {}, ()=>[
                                        (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs.V)), {
                                            class: (0, _vue.normalizeClass)([
                                                "va-collapse__expand-icon",
                                                computedModelValue.value ? "va-collapse__expand-icon--expanded" : "va-collapse__expand-icon--collapsed"
                                            ]),
                                            name: "va-arrow-down"
                                        }, null, 8, [
                                            "class"
                                        ])
                                    ])
                            ], 16)
                        ])
                ], 32),
                (0, _vue.createElementVNode)("div", {
                    class: (0, _vue.normalizeClass)([
                        "va-collapse__body-wrapper",
                        {
                            "va-collapse__body-wrapper--bordered": !_ctx.$slots.body && !_ctx.$slots.header
                        }
                    ]),
                    style: (0, _vue.normalizeStyle)(contentStyle.value),
                    onTransitionend: onTransitionEnd
                }, [
                    doRenderBody.value ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                        key: 0,
                        class: "va-collapse__body",
                        ref_key: "body",
                        ref: body,
                        role: "region",
                        id: panelIdComputed.value,
                        "aria-labelledby": headerIdComputed.value
                    }, [
                        (0, _vue.renderSlot)(_ctx.$slots, "body", {}, ()=>[
                                (0, _vue.createElementVNode)("div", _hoisted_3, [
                                    (0, _vue.renderSlot)(_ctx.$slots, "default", {}, ()=>[
                                            (0, _vue.renderSlot)(_ctx.$slots, "content")
                                        ])
                                ])
                            ])
                    ], 8, _hoisted_2)) : (0, _vue.createCommentVNode)("", true)
                ], 38)
            ], 2);
        };
    }
});

},{"vue":"gzxs9","../../../vendor.js":"l6TAc","../va-accordion/hooks/useAccordion.js":"9PX6J","../../composables/useComponentUuid.js":"cuNNa","../va-icon/index.js":"82tPo","../../composables/useSelectable.js":"3Z4bC","../../composables/useResizeObserver.js":"4ylh3","../../composables/useComponentPreset.js":"2HoaT","../../composables/useStateful.js":"h9zUi","../../composables/useColors.js":"a4Qgv","../../composables/useBem.js":"igmjV","../../composables/useTextColor.js":"5pfXb","../../../VaCollapse.css":"iDZ4c","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4ylh3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useResizeObserver);
var _vue = require("vue");
const useResizeObserver = (elementsList, cb)=>{
    let resizeObserver;
    const observeAll = (elementsList2)=>{
        elementsList2.forEach((element)=>{
            const unrefedElement = (0, _vue.unref)(element);
            unrefedElement && (resizeObserver == null || resizeObserver.observe(unrefedElement));
        });
    };
    (0, _vue.watch)(elementsList, (newValue)=>{
        resizeObserver == null || resizeObserver.disconnect();
        observeAll(Array.isArray(newValue) ? newValue : [
            newValue
        ]);
    });
    (0, _vue.onMounted)(()=>{
        resizeObserver = new ResizeObserver(cb);
        observeAll(Array.isArray(elementsList) ? elementsList : [
            elementsList
        ]);
    });
    (0, _vue.onBeforeUnmount)(()=>resizeObserver == null ? void 0 : resizeObserver.disconnect());
    return resizeObserver;
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iDZ4c":[function() {},{}],"euOOk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaColorIndicator);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaColorIndicatorVueVueTypeScriptSetupTrueLangJs = require("./VaColorIndicator.vue_vue_type_script_setup_true_lang.js");
const VaColorIndicator = (0, _withConfigTransportJs.w)((0, _vaColorIndicatorVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaColorIndicator.vue_vue_type_script_setup_true_lang.js":"1vn2O","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1vn2O":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useStatefulJs = require("../../composables/useStateful.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useColorsJs = require("../../composables/useColors.js");
var _useKeyboardOnlyFocusJs = require("../../composables/useKeyboardOnlyFocus.js");
var _vaColorIndicatorCss = require("../../../VaColorIndicator.css");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaColorIndicator",
    __name: "VaColorIndicator",
    props: {
        ...(0, _useStatefulJs.u),
        ...(0, _useComponentPresetJs.u),
        modelValue: {
            type: Boolean,
            default: null
        },
        color: {
            type: String,
            default: ""
        },
        square: {
            type: Boolean,
            default: false
        },
        size: {
            type: String,
            default: "1rem"
        }
    },
    emits: [
        ...(0, _useStatefulJs.a)
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const { valueComputed } = (0, _useStatefulJs.b)(props, emit);
        const { getColor } = (0, _useColorsJs.u)();
        const { hasKeyboardFocus, keyboardFocusListeners } = (0, _useKeyboardOnlyFocusJs.u)();
        const colorComputed = (0, _vue.computed)(()=>getColor(props.color));
        const borderRadiusComputed = (0, _vue.computed)(()=>props.square ? "0px" : "50%");
        const computedStyle = (0, _vue.computed)(()=>({
                backgroundColor: colorComputed.value,
                height: props.size,
                width: props.size
            }));
        const computedClass = (0, _vue.computed)(()=>({
                "va-color-indicator--selected": valueComputed.value,
                "va-color-indicator--on-keyboard-focus": hasKeyboardFocus.value
            }));
        const toggleModelValue = ()=>{
            valueComputed.value = !valueComputed.value;
        };
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", (0, _vue.mergeProps)({
                class: [
                    "va-color-indicator",
                    computedClass.value
                ],
                style: [
                    computedStyle.value,
                    `--va-border-radius-computed: ${String(borderRadiusComputed.value)}`
                ],
                onClick: toggleModelValue,
                onKeydown: [
                    (0, _vue.withKeys)(toggleModelValue, [
                        "enter"
                    ]),
                    (0, _vue.withKeys)(toggleModelValue, [
                        "space"
                    ])
                ]
            }, (0, _vue.toHandlers)((0, _vue.unref)(keyboardFocusListeners), true)), [
                (0, _vue.createElementVNode)("div", {
                    class: "va-color-indicator__core",
                    style: (0, _vue.normalizeStyle)(computedStyle.value)
                }, null, 4)
            ], 16);
        };
    }
});

},{"vue":"gzxs9","../../composables/useStateful.js":"h9zUi","../../composables/useComponentPreset.js":"2HoaT","../../composables/useColors.js":"a4Qgv","../../composables/useKeyboardOnlyFocus.js":"lKbNJ","../../../VaColorIndicator.css":"iOvJN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iOvJN":[function() {},{}],"fbL1A":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaColorInput);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaColorInputVueVueTypeScriptSetupTrueLangJs = require("./VaColorInput.vue_vue_type_script_setup_true_lang.js");
const VaColorInput = (0, _withConfigTransportJs.w)((0, _vaColorInputVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaColorInput.vue_vue_type_script_setup_true_lang.js":"kQmaM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kQmaM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _indexJs = require("../va-color-indicator/index.js");
var _indexJs1 = require("../va-input/index.js");
var _vendorJs = require("../../../vendor.js");
var _extractComponentOptionsJs = require("../../utils/component-options/extract-component-options.js");
var _useStatefulJs = require("../../composables/useStateful.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _filterPropsJs = require("../../utils/component-options/filter-props.js");
var _useTranslationJs = require("../../composables/useTranslation.js");
var _vaColorInputCss = require("../../../VaColorInput.css");
const _hoisted_1 = {
    class: "va-color-input"
};
const VaInputProps = (0, _extractComponentOptionsJs.e)((0, _indexJs1.V));
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaColorInput",
    __name: "VaColorInput",
    props: {
        ...VaInputProps,
        ...(0, _useStatefulJs.u),
        ...(0, _useComponentPresetJs.u),
        modelValue: {
            type: String,
            default: null
        },
        disabled: {
            type: Boolean,
            default: false
        },
        indicator: {
            type: String,
            default: "dot",
            validator: (value)=>[
                    "dot",
                    "square"
                ].includes(value)
        },
        ariaOpenColorPickerLabel: {
            type: String,
            default: "$t:openColorPicker"
        }
    },
    emits: [
        ...(0, _useStatefulJs.a)
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const colorPicker = (0, _vue.shallowRef)();
        const { valueComputed } = (0, _useStatefulJs.b)(props, emit);
        const callPickerDialog = ()=>{
            var _a;
            return !props.disabled && ((_a = colorPicker.value) == null ? void 0 : _a.click());
        };
        const tabIndexComputed = (0, _vue.computed)(()=>props.disabled ? -1 : 0);
        const inputValue = (0, _vue.computed)({
            get: ()=>props.modelValue,
            set: (0, _vendorJs.t)((value)=>emit("update:modelValue", value), 500)
        });
        const vaInputProps = (0, _filterPropsJs.f)(VaInputProps);
        const { tp } = (0, _useTranslationJs.u)();
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_1, [
                (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs1.V)), (0, _vue.mergeProps)((0, _vue.unref)(vaInputProps), {
                    modelValue: (0, _vue.unref)(valueComputed),
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event)=>(0, _vue.isRef)(valueComputed) ? valueComputed.value = $event : null),
                    class: "va-color-input__input",
                    tabindex: tabIndexComputed.value
                }), {
                    appendInner: (0, _vue.withCtx)(()=>[
                            (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs.V)), {
                                class: "va-color-input__dot",
                                role: "button",
                                "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaOpenColorPickerLabel),
                                "aria-disabled": _ctx.$props.disabled,
                                tabindex: tabIndexComputed.value,
                                color: (0, _vue.unref)(valueComputed),
                                indicator: _ctx.$props.indicator,
                                size: "16px",
                                onClick: callPickerDialog,
                                onKeydown: [
                                    (0, _vue.withKeys)(callPickerDialog, [
                                        "space"
                                    ]),
                                    (0, _vue.withKeys)(callPickerDialog, [
                                        "enter"
                                    ])
                                ]
                            }, null, 8, [
                                "aria-label",
                                "aria-disabled",
                                "tabindex",
                                "color",
                                "indicator"
                            ])
                        ]),
                    _: 1
                }, 16, [
                    "modelValue",
                    "tabindex"
                ]),
                (0, _vue.withDirectives)((0, _vue.createElementVNode)("input", {
                    ref_key: "colorPicker",
                    ref: colorPicker,
                    type: "color",
                    class: "va-color-input__hidden-input",
                    "aria-hidden": "true",
                    tabindex: "-1",
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event)=>inputValue.value = $event)
                }, null, 512), [
                    [
                        (0, _vue.vModelText),
                        inputValue.value
                    ]
                ])
            ]);
        };
    }
});

},{"vue":"gzxs9","../va-color-indicator/index.js":"euOOk","../va-input/index.js":"qwNV2","../../../vendor.js":"l6TAc","../../utils/component-options/extract-component-options.js":"1ODzH","../../composables/useStateful.js":"h9zUi","../../composables/useComponentPreset.js":"2HoaT","../../utils/component-options/filter-props.js":"4HycW","../../composables/useTranslation.js":"7S3aV","../../../VaColorInput.css":"7P1CA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"qwNV2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaInput);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaInputVueVueTypeScriptSetupTrueLangJs = require("./VaInput.vue_vue_type_script_setup_true_lang.js");
const VaInput = (0, _withConfigTransportJs.w)((0, _vaInputVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaInput.vue_vue_type_script_setup_true_lang.js":"kMXJU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kMXJU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../vendor.js");
var _useCleaveJs = require("./hooks/useCleave.js");
var _indexJs = require("../va-input-wrapper/index.js");
var _indexJs1 = require("../va-icon/index.js");
var _combineFunctionsJs = require("../../utils/combine-functions.js");
var _useFocusableJs = require("../../composables/useFocusable.js");
var _useClearableJs = require("../../composables/useClearable.js");
var _useValidationJs = require("../../composables/useValidation.js");
var _useDeprecatedConditionJs = require("../../composables/useDeprecatedCondition.js");
var _useEmitProxyJs = require("../../composables/useEmitProxy.js");
var _extractComponentOptionsJs = require("../../utils/component-options/extract-component-options.js");
var _useFormFieldJs = require("../../composables/useFormField.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useStatefulJs = require("../../composables/useStateful.js");
var _useTranslationJs = require("../../composables/useTranslation.js");
var _useEventJs = require("../../composables/useEvent.js");
var _filterPropsJs = require("../../utils/component-options/filter-props.js");
const _hoisted_1 = [
    "value"
];
const VaInputWrapperProps = (0, _extractComponentOptionsJs.e)((0, _indexJs.V));
const { createEmits: createInputEmits, createListeners: createInputListeners } = (0, _useEmitProxyJs.u)([
    "change",
    "keyup",
    "keypress",
    "keydown",
    "focus",
    "blur",
    "input"
]);
const { createEmits: createFieldEmits, createListeners: createFieldListeners } = (0, _useEmitProxyJs.u)([
    "click",
    "click-prepend",
    "click-append",
    "click-prepend-inner",
    "click-append-inner"
]);
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaInput",
    inheritAttrs: false,
    __name: "VaInput",
    props: {
        ...VaInputWrapperProps,
        ...(0, _useFormFieldJs.u),
        ...(0, _useFocusableJs.u),
        ...(0, _useValidationJs.b),
        ...(0, _useClearableJs.u),
        ...(0, _useCleaveJs.u),
        ...(0, _useComponentPresetJs.u),
        ...(0, _useStatefulJs.u),
        // input
        placeholder: {
            type: String,
            default: ""
        },
        tabindex: {
            type: [
                String,
                Number
            ],
            default: 0
        },
        modelValue: {
            type: [
                Number,
                String
            ],
            default: ""
        },
        type: {
            type: String,
            default: "text"
        },
        inputClass: {
            type: String,
            default: ""
        },
        pattern: {
            type: String
        },
        inputmode: {
            type: String,
            default: "text"
        },
        counter: {
            type: Boolean,
            default: false
        },
        // style
        ariaResetLabel: {
            type: String,
            default: "$t:reset"
        },
        /** Set value to input when model value is updated */ strictBindInputValue: {
            type: Boolean,
            default: false
        }
    },
    emits: [
        "update:modelValue",
        ...(0, _useValidationJs.u),
        ...(0, _useClearableJs.a),
        ...createInputEmits(),
        ...createFieldEmits(),
        ...(0, _useStatefulJs.a)
    ],
    setup (__props, { expose: __expose, emit: __emit }) {
        const props = __props;
        const emit = __emit;
        (0, _useDeprecatedConditionJs.u)([
            ()=>props.type !== "textarea" || 'Use VaTextarea component instead of VaInput with type="textarea"'
        ]);
        const input = (0, _vue.shallowRef)();
        const { valueComputed } = (0, _useStatefulJs.b)(props, emit, "modelValue");
        const reset = ()=>withoutValidation(()=>{
                valueComputed.value = props.clearValue;
                emit("clear");
                resetValidation();
            });
        const { focus, blur } = (0, _useFocusableJs.a)(input, props);
        const slots = (0, _vue.useSlots)();
        const filterSlots = (0, _vue.computed)(()=>{
            const iconSlot = [
                "icon"
            ];
            return Object.keys(slots).filter((slot)=>!iconSlot.includes(slot));
        });
        const { tp } = (0, _useTranslationJs.u)();
        const { isValid, isTouched, isDirty, computedError, computedErrorMessages, listeners: { onBlur }, validationAriaAttributes, isLoading, withoutValidation, resetValidation } = (0, _useValidationJs.a)(props, emit, {
            reset,
            focus,
            value: valueComputed
        });
        const { modelValue } = (0, _vue.toRefs)(props);
        const { canBeCleared, clearIconProps } = (0, _useClearableJs.b)(props, modelValue, input, computedError);
        const { computedValue, onInput } = (0, _useCleaveJs.a)(input, props, valueComputed);
        const inputListeners = createInputListeners(emit);
        const inputEvents = {
            ...inputListeners,
            onBlur: (0, _combineFunctionsJs.c)(onBlur, inputListeners.onBlur),
            onInput: (0, _combineFunctionsJs.c)(onInput, inputListeners.onInput)
        };
        const setInputValue = (newValue)=>{
            if (!props.strictBindInputValue) return;
            const target = input.value;
            if (!target) return;
            const selectionStart = target.selectionStart || 0;
            const selectionEnd = target.selectionEnd || 0;
            if (target.value !== newValue) target.value = String(newValue);
            target.setSelectionRange(selectionStart, selectionEnd);
        };
        (0, _vue.watch)(computedValue, (newValue)=>{
            setInputValue(String(newValue));
        }, {
            immediate: true
        });
        (0, _useEventJs.u)("input", ()=>{
            setInputValue(String(valueComputed.value));
        }, input);
        const tabIndexComputed = (0, _vue.computed)(()=>props.disabled ? -1 : props.tabindex);
        const attrs = (0, _vue.useAttrs)();
        const computedChildAttributes = (0, _vue.computed)(()=>({
                "aria-label": props.inputAriaLabel || props.label,
                "aria-labelledby": props.inputAriaLabelledby,
                "aria-required": props.requiredMark,
                tabindex: tabIndexComputed.value,
                class: props.inputClass,
                "aria-disabled": props.disabled,
                "aria-readonly": props.readonly,
                ...validationAriaAttributes.value,
                ...(0, _vendorJs.o)(attrs, [
                    "class",
                    "style"
                ])
            }));
        const computedInputAttributes = (0, _vue.computed)(()=>({
                ...computedChildAttributes.value,
                ...(0, _vendorJs.p)(props, [
                    "type",
                    "disabled",
                    "readonly",
                    "placeholder",
                    "pattern",
                    "inputmode",
                    "minlength",
                    "maxlength"
                ])
            }));
        const valueLengthComputed = (0, _vue.computed)(()=>props.counter && typeof computedValue.value === "string" ? computedValue.value.length : void 0);
        const onFieldClick = (e)=>{
            if (!e.target || !("tagName" in e.target)) return;
            if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") return;
            focus();
        };
        const wrapperProps = (0, _filterPropsJs.f)(VaInputWrapperProps);
        const fieldListeners = createFieldListeners(emit);
        __expose({
            isValid,
            isDirty,
            isTouched,
            isLoading,
            computedError,
            computedErrorMessages,
            reset,
            focus,
            blur,
            value: valueComputed,
            withoutValidation,
            resetValidation
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), (0, _vue.mergeProps)({
                ...(0, _vue.unref)(fieldListeners),
                ...(0, _vue.unref)(wrapperProps)
            }, {
                class: [
                    "va-input",
                    _ctx.$attrs.class
                ],
                style: _ctx.$attrs.style,
                loading: _ctx.$props.loading || (0, _vue.unref)(isLoading),
                error: (0, _vue.unref)(computedError),
                "error-messages": (0, _vue.unref)(computedErrorMessages),
                "error-count": _ctx.errorCount,
                "counter-value": valueLengthComputed.value,
                onClick: onFieldClick
            }), (0, _vue.createSlots)({
                icon: (0, _vue.withCtx)((slotScope)=>[
                        (0, _vue.unref)(canBeCleared) ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs1.V)), (0, _vue.mergeProps)({
                            key: 0,
                            role: "button",
                            "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaResetLabel)
                        }, (0, _vue.unref)(clearIconProps), {
                            onClick: (0, _vue.withModifiers)(reset, [
                                "stop"
                            ]),
                            onKeydown: [
                                (0, _vue.withKeys)((0, _vue.withModifiers)(reset, [
                                    "stop"
                                ]), [
                                    "enter"
                                ]),
                                (0, _vue.withKeys)((0, _vue.withModifiers)(reset, [
                                    "stop"
                                ]), [
                                    "space"
                                ])
                            ]
                        }), null, 16, [
                            "aria-label",
                            "onKeydown"
                        ])) : (0, _vue.createCommentVNode)("", true),
                        (0, _vue.renderSlot)(_ctx.$slots, "icon", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(slotScope)))
                    ]),
                default: (0, _vue.withCtx)(()=>[
                        !_ctx.$slots.content ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("input", (0, _vue.mergeProps)({
                            key: 0,
                            ref_key: "input",
                            ref: input,
                            class: "va-input__content__input"
                        }, {
                            ...computedInputAttributes.value,
                            ...inputEvents
                        }, {
                            value: (0, _vue.unref)(computedValue)
                        }), null, 16, _hoisted_1)) : (0, _vue.createCommentVNode)("", true)
                    ]),
                _: 2
            }, [
                (0, _vue.renderList)(filterSlots.value, (name)=>{
                    return {
                        name,
                        fn: (0, _vue.withCtx)((slotScope)=>[
                                (0, _vue.renderSlot)(_ctx.$slots, name, (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(slotScope)))
                            ])
                    };
                })
            ]), 1040, [
                "class",
                "style",
                "loading",
                "error",
                "error-messages",
                "error-count",
                "counter-value"
            ]);
        };
    }
});

},{"vue":"gzxs9","../../../vendor.js":"l6TAc","./hooks/useCleave.js":"Z7ZYR","../va-input-wrapper/index.js":"7MuId","../va-icon/index.js":"82tPo","../../utils/combine-functions.js":"rRUgY","../../composables/useFocusable.js":"4lsQT","../../composables/useClearable.js":"h8vES","../../composables/useValidation.js":"iFHh2","../../composables/useDeprecatedCondition.js":"flRjm","../../composables/useEmitProxy.js":"koywY","../../utils/component-options/extract-component-options.js":"1ODzH","../../composables/useFormField.js":"676Eq","../../composables/useComponentPreset.js":"2HoaT","../../composables/useStateful.js":"h9zUi","../../composables/useTranslation.js":"7S3aV","../../composables/useEvent.js":"9kzUn","../../utils/component-options/filter-props.js":"4HycW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"Z7ZYR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useCleave);
parcelHelpers.export(exports, "u", ()=>useCleaveProps);
var _vue = require("vue");
var _cleaveJs = require("cleave.js");
var _cleaveJsDefault = parcelHelpers.interopDefault(_cleaveJs);
const DEFAULT_MASK_TOKENS = {
    creditCard: {
        creditCard: true
    },
    date: {
        date: true,
        datePattern: [
            "d",
            "m",
            "Y"
        ]
    },
    time: {
        time: true,
        timePattern: [
            "h",
            "m"
        ],
        timeFormat: "24"
    },
    numeral: {
        numeral: true,
        numeralThousandsGroupStyle: "thousand"
    }
};
const useCleaveProps = {
    mask: {
        type: [
            String,
            Object
        ],
        default: ""
    },
    returnRaw: {
        type: Boolean,
        default: true
    }
};
const useCleave = (element, props, syncValue)=>{
    const cleave = (0, _vue.ref)();
    const getMask = (mask2)=>{
        if (typeof mask2 === "string") return DEFAULT_MASK_TOKENS[mask2] ? {
            ...DEFAULT_MASK_TOKENS[mask2]
        } : null;
        return {
            ...mask2
        };
    };
    const destroyCleave = ()=>{
        if (cleave.value) cleave.value.destroy();
    };
    const mask = (0, _vue.computed)(()=>getMask(props.mask));
    const cleaveEnabled = (0, _vue.computed)(()=>{
        return mask.value && Object.keys(mask.value).length;
    });
    (0, _vue.watchEffect)(()=>{
        destroyCleave();
        if (!element.value) return;
        if (!cleaveEnabled.value || !mask.value) return;
        cleave.value = new (0, _cleaveJsDefault.default)(element.value, mask.value);
        cleave.value.properties.onValueChanged = ({ target: { rawValue, value } })=>{
            if (props.returnRaw) syncValue.value = rawValue;
            else syncValue.value = value;
        };
    });
    (0, _vue.onBeforeUnmount)(()=>{
        destroyCleave();
    });
    const computedValue = (0, _vue.computed)(()=>{
        if (cleave.value) {
            if (props.returnRaw && syncValue.value === cleave.value.getRawValue()) return cleave.value.getFormattedValue();
        }
        return syncValue.value;
    });
    const onInput = (event)=>{
        const value = event.target.value;
        if (!cleaveEnabled.value) syncValue.value = value;
    };
    return {
        cleave,
        cleaveEnabled,
        computedValue,
        onInput
    };
};

},{"vue":"gzxs9","cleave.js":"dYrzx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dYrzx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var global = arguments[3];
var commonjsGlobal = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var NumeralFormatter = function(numeralDecimalMark, numeralIntegerScale, numeralDecimalScale, numeralThousandsGroupStyle, numeralPositiveOnly, stripLeadingZeroes, prefix, signBeforePrefix, tailPrefix, delimiter) {
    var owner = this;
    owner.numeralDecimalMark = numeralDecimalMark || ".";
    owner.numeralIntegerScale = numeralIntegerScale > 0 ? numeralIntegerScale : 0;
    owner.numeralDecimalScale = numeralDecimalScale >= 0 ? numeralDecimalScale : 2;
    owner.numeralThousandsGroupStyle = numeralThousandsGroupStyle || NumeralFormatter.groupStyle.thousand;
    owner.numeralPositiveOnly = !!numeralPositiveOnly;
    owner.stripLeadingZeroes = stripLeadingZeroes !== false;
    owner.prefix = prefix || prefix === "" ? prefix : "";
    owner.signBeforePrefix = !!signBeforePrefix;
    owner.tailPrefix = !!tailPrefix;
    owner.delimiter = delimiter || delimiter === "" ? delimiter : ",";
    owner.delimiterRE = delimiter ? new RegExp("\\" + delimiter, "g") : "";
};
NumeralFormatter.groupStyle = {
    thousand: "thousand",
    lakh: "lakh",
    wan: "wan",
    none: "none"
};
NumeralFormatter.prototype = {
    getRawValue: function(value) {
        return value.replace(this.delimiterRE, "").replace(this.numeralDecimalMark, ".");
    },
    format: function(value) {
        var owner = this, parts, partSign, partSignAndPrefix, partInteger, partDecimal = "";
        // strip alphabet letters
        value = value.replace(/[A-Za-z]/g, "")// replace the first decimal mark with reserved placeholder
        .replace(owner.numeralDecimalMark, "M")// strip non numeric letters except minus and "M"
        // this is to ensure prefix has been stripped
        .replace(/[^\dM-]/g, "")// replace the leading minus with reserved placeholder
        .replace(/^\-/, "N")// strip the other minus sign (if present)
        .replace(/\-/g, "")// replace the minus sign (if present)
        .replace("N", owner.numeralPositiveOnly ? "" : "-")// replace decimal mark
        .replace("M", owner.numeralDecimalMark);
        // strip any leading zeros
        if (owner.stripLeadingZeroes) value = value.replace(/^(-)?0+(?=\d)/, "$1");
        partSign = value.slice(0, 1) === "-" ? "-" : "";
        if (typeof owner.prefix != "undefined") {
            if (owner.signBeforePrefix) partSignAndPrefix = partSign + owner.prefix;
            else partSignAndPrefix = owner.prefix + partSign;
        } else partSignAndPrefix = partSign;
        partInteger = value;
        if (value.indexOf(owner.numeralDecimalMark) >= 0) {
            parts = value.split(owner.numeralDecimalMark);
            partInteger = parts[0];
            partDecimal = owner.numeralDecimalMark + parts[1].slice(0, owner.numeralDecimalScale);
        }
        if (partSign === "-") partInteger = partInteger.slice(1);
        if (owner.numeralIntegerScale > 0) partInteger = partInteger.slice(0, owner.numeralIntegerScale);
        switch(owner.numeralThousandsGroupStyle){
            case NumeralFormatter.groupStyle.lakh:
                partInteger = partInteger.replace(/(\d)(?=(\d\d)+\d$)/g, "$1" + owner.delimiter);
                break;
            case NumeralFormatter.groupStyle.wan:
                partInteger = partInteger.replace(/(\d)(?=(\d{4})+$)/g, "$1" + owner.delimiter);
                break;
            case NumeralFormatter.groupStyle.thousand:
                partInteger = partInteger.replace(/(\d)(?=(\d{3})+$)/g, "$1" + owner.delimiter);
                break;
        }
        if (owner.tailPrefix) return partSign + partInteger.toString() + (owner.numeralDecimalScale > 0 ? partDecimal.toString() : "") + owner.prefix;
        return partSignAndPrefix + partInteger.toString() + (owner.numeralDecimalScale > 0 ? partDecimal.toString() : "");
    }
};
var NumeralFormatter_1 = NumeralFormatter;
var DateFormatter = function(datePattern, dateMin, dateMax) {
    var owner = this;
    owner.date = [];
    owner.blocks = [];
    owner.datePattern = datePattern;
    owner.dateMin = dateMin.split("-").reverse().map(function(x) {
        return parseInt(x, 10);
    });
    if (owner.dateMin.length === 2) owner.dateMin.unshift(0);
    owner.dateMax = dateMax.split("-").reverse().map(function(x) {
        return parseInt(x, 10);
    });
    if (owner.dateMax.length === 2) owner.dateMax.unshift(0);
    owner.initBlocks();
};
DateFormatter.prototype = {
    initBlocks: function() {
        var owner = this;
        owner.datePattern.forEach(function(value) {
            if (value === "Y") owner.blocks.push(4);
            else owner.blocks.push(2);
        });
    },
    getISOFormatDate: function() {
        var owner = this, date = owner.date;
        return date[2] ? date[2] + "-" + owner.addLeadingZero(date[1]) + "-" + owner.addLeadingZero(date[0]) : "";
    },
    getBlocks: function() {
        return this.blocks;
    },
    getValidatedDate: function(value) {
        var owner = this, result = "";
        value = value.replace(/[^\d]/g, "");
        owner.blocks.forEach(function(length, index) {
            if (value.length > 0) {
                var sub = value.slice(0, length), sub0 = sub.slice(0, 1), rest = value.slice(length);
                switch(owner.datePattern[index]){
                    case "d":
                        if (sub === "00") sub = "01";
                        else if (parseInt(sub0, 10) > 3) sub = "0" + sub0;
                        else if (parseInt(sub, 10) > 31) sub = "31";
                        break;
                    case "m":
                        if (sub === "00") sub = "01";
                        else if (parseInt(sub0, 10) > 1) sub = "0" + sub0;
                        else if (parseInt(sub, 10) > 12) sub = "12";
                        break;
                }
                result += sub;
                // update remaining string
                value = rest;
            }
        });
        return this.getFixedDateString(result);
    },
    getFixedDateString: function(value) {
        var owner = this, datePattern = owner.datePattern, date = [], dayIndex = 0, monthIndex = 0, yearIndex = 0, dayStartIndex = 0, monthStartIndex = 0, yearStartIndex = 0, day, month, year, fullYearDone = false;
        // mm-dd || dd-mm
        if (value.length === 4 && datePattern[0].toLowerCase() !== "y" && datePattern[1].toLowerCase() !== "y") {
            dayStartIndex = datePattern[0] === "d" ? 0 : 2;
            monthStartIndex = 2 - dayStartIndex;
            day = parseInt(value.slice(dayStartIndex, dayStartIndex + 2), 10);
            month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);
            date = this.getFixedDate(day, month, 0);
        }
        // yyyy-mm-dd || yyyy-dd-mm || mm-dd-yyyy || dd-mm-yyyy || dd-yyyy-mm || mm-yyyy-dd
        if (value.length === 8) {
            datePattern.forEach(function(type, index) {
                switch(type){
                    case "d":
                        dayIndex = index;
                        break;
                    case "m":
                        monthIndex = index;
                        break;
                    default:
                        yearIndex = index;
                        break;
                }
            });
            yearStartIndex = yearIndex * 2;
            dayStartIndex = dayIndex <= yearIndex ? dayIndex * 2 : dayIndex * 2 + 2;
            monthStartIndex = monthIndex <= yearIndex ? monthIndex * 2 : monthIndex * 2 + 2;
            day = parseInt(value.slice(dayStartIndex, dayStartIndex + 2), 10);
            month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);
            year = parseInt(value.slice(yearStartIndex, yearStartIndex + 4), 10);
            fullYearDone = value.slice(yearStartIndex, yearStartIndex + 4).length === 4;
            date = this.getFixedDate(day, month, year);
        }
        // mm-yy || yy-mm
        if (value.length === 4 && (datePattern[0] === "y" || datePattern[1] === "y")) {
            monthStartIndex = datePattern[0] === "m" ? 0 : 2;
            yearStartIndex = 2 - monthStartIndex;
            month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);
            year = parseInt(value.slice(yearStartIndex, yearStartIndex + 2), 10);
            fullYearDone = value.slice(yearStartIndex, yearStartIndex + 2).length === 2;
            date = [
                0,
                month,
                year
            ];
        }
        // mm-yyyy || yyyy-mm
        if (value.length === 6 && (datePattern[0] === "Y" || datePattern[1] === "Y")) {
            monthStartIndex = datePattern[0] === "m" ? 0 : 4;
            yearStartIndex = 2 - 0.5 * monthStartIndex;
            month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);
            year = parseInt(value.slice(yearStartIndex, yearStartIndex + 4), 10);
            fullYearDone = value.slice(yearStartIndex, yearStartIndex + 4).length === 4;
            date = [
                0,
                month,
                year
            ];
        }
        date = owner.getRangeFixedDate(date);
        owner.date = date;
        var result = date.length === 0 ? value : datePattern.reduce(function(previous, current) {
            switch(current){
                case "d":
                    return previous + (date[0] === 0 ? "" : owner.addLeadingZero(date[0]));
                case "m":
                    return previous + (date[1] === 0 ? "" : owner.addLeadingZero(date[1]));
                case "y":
                    return previous + (fullYearDone ? owner.addLeadingZeroForYear(date[2], false) : "");
                case "Y":
                    return previous + (fullYearDone ? owner.addLeadingZeroForYear(date[2], true) : "");
            }
        }, "");
        return result;
    },
    getRangeFixedDate: function(date) {
        var owner = this, datePattern = owner.datePattern, dateMin = owner.dateMin || [], dateMax = owner.dateMax || [];
        if (!date.length || dateMin.length < 3 && dateMax.length < 3) return date;
        if (datePattern.find(function(x) {
            return x.toLowerCase() === "y";
        }) && date[2] === 0) return date;
        if (dateMax.length && (dateMax[2] < date[2] || dateMax[2] === date[2] && (dateMax[1] < date[1] || dateMax[1] === date[1] && dateMax[0] < date[0]))) return dateMax;
        if (dateMin.length && (dateMin[2] > date[2] || dateMin[2] === date[2] && (dateMin[1] > date[1] || dateMin[1] === date[1] && dateMin[0] > date[0]))) return dateMin;
        return date;
    },
    getFixedDate: function(day, month, year) {
        day = Math.min(day, 31);
        month = Math.min(month, 12);
        year = parseInt(year || 0, 10);
        if (month < 7 && month % 2 === 0 || month > 8 && month % 2 === 1) day = Math.min(day, month === 2 ? this.isLeapYear(year) ? 29 : 28 : 30);
        return [
            day,
            month,
            year
        ];
    },
    isLeapYear: function(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    },
    addLeadingZero: function(number) {
        return (number < 10 ? "0" : "") + number;
    },
    addLeadingZeroForYear: function(number, fullYearMode) {
        if (fullYearMode) return (number < 10 ? "000" : number < 100 ? "00" : number < 1000 ? "0" : "") + number;
        return (number < 10 ? "0" : "") + number;
    }
};
var DateFormatter_1 = DateFormatter;
var TimeFormatter = function(timePattern, timeFormat) {
    var owner = this;
    owner.time = [];
    owner.blocks = [];
    owner.timePattern = timePattern;
    owner.timeFormat = timeFormat;
    owner.initBlocks();
};
TimeFormatter.prototype = {
    initBlocks: function() {
        var owner = this;
        owner.timePattern.forEach(function() {
            owner.blocks.push(2);
        });
    },
    getISOFormatTime: function() {
        var owner = this, time = owner.time;
        return time[2] ? owner.addLeadingZero(time[0]) + ":" + owner.addLeadingZero(time[1]) + ":" + owner.addLeadingZero(time[2]) : "";
    },
    getBlocks: function() {
        return this.blocks;
    },
    getTimeFormatOptions: function() {
        var owner = this;
        if (String(owner.timeFormat) === "12") return {
            maxHourFirstDigit: 1,
            maxHours: 12,
            maxMinutesFirstDigit: 5,
            maxMinutes: 60
        };
        return {
            maxHourFirstDigit: 2,
            maxHours: 23,
            maxMinutesFirstDigit: 5,
            maxMinutes: 60
        };
    },
    getValidatedTime: function(value) {
        var owner = this, result = "";
        value = value.replace(/[^\d]/g, "");
        var timeFormatOptions = owner.getTimeFormatOptions();
        owner.blocks.forEach(function(length, index) {
            if (value.length > 0) {
                var sub = value.slice(0, length), sub0 = sub.slice(0, 1), rest = value.slice(length);
                switch(owner.timePattern[index]){
                    case "h":
                        if (parseInt(sub0, 10) > timeFormatOptions.maxHourFirstDigit) sub = "0" + sub0;
                        else if (parseInt(sub, 10) > timeFormatOptions.maxHours) sub = timeFormatOptions.maxHours + "";
                        break;
                    case "m":
                    case "s":
                        if (parseInt(sub0, 10) > timeFormatOptions.maxMinutesFirstDigit) sub = "0" + sub0;
                        else if (parseInt(sub, 10) > timeFormatOptions.maxMinutes) sub = timeFormatOptions.maxMinutes + "";
                        break;
                }
                result += sub;
                // update remaining string
                value = rest;
            }
        });
        return this.getFixedTimeString(result);
    },
    getFixedTimeString: function(value) {
        var owner = this, timePattern = owner.timePattern, time = [], secondIndex = 0, minuteIndex = 0, hourIndex = 0, secondStartIndex = 0, minuteStartIndex = 0, hourStartIndex = 0, second, minute, hour;
        if (value.length === 6) {
            timePattern.forEach(function(type, index) {
                switch(type){
                    case "s":
                        secondIndex = index * 2;
                        break;
                    case "m":
                        minuteIndex = index * 2;
                        break;
                    case "h":
                        hourIndex = index * 2;
                        break;
                }
            });
            hourStartIndex = hourIndex;
            minuteStartIndex = minuteIndex;
            secondStartIndex = secondIndex;
            second = parseInt(value.slice(secondStartIndex, secondStartIndex + 2), 10);
            minute = parseInt(value.slice(minuteStartIndex, minuteStartIndex + 2), 10);
            hour = parseInt(value.slice(hourStartIndex, hourStartIndex + 2), 10);
            time = this.getFixedTime(hour, minute, second);
        }
        if (value.length === 4 && owner.timePattern.indexOf("s") < 0) {
            timePattern.forEach(function(type, index) {
                switch(type){
                    case "m":
                        minuteIndex = index * 2;
                        break;
                    case "h":
                        hourIndex = index * 2;
                        break;
                }
            });
            hourStartIndex = hourIndex;
            minuteStartIndex = minuteIndex;
            second = 0;
            minute = parseInt(value.slice(minuteStartIndex, minuteStartIndex + 2), 10);
            hour = parseInt(value.slice(hourStartIndex, hourStartIndex + 2), 10);
            time = this.getFixedTime(hour, minute, second);
        }
        owner.time = time;
        return time.length === 0 ? value : timePattern.reduce(function(previous, current) {
            switch(current){
                case "s":
                    return previous + owner.addLeadingZero(time[2]);
                case "m":
                    return previous + owner.addLeadingZero(time[1]);
                case "h":
                    return previous + owner.addLeadingZero(time[0]);
            }
        }, "");
    },
    getFixedTime: function(hour, minute, second) {
        second = Math.min(parseInt(second || 0, 10), 60);
        minute = Math.min(minute, 60);
        hour = Math.min(hour, 60);
        return [
            hour,
            minute,
            second
        ];
    },
    addLeadingZero: function(number) {
        return (number < 10 ? "0" : "") + number;
    }
};
var TimeFormatter_1 = TimeFormatter;
var PhoneFormatter = function(formatter, delimiter) {
    var owner = this;
    owner.delimiter = delimiter || delimiter === "" ? delimiter : " ";
    owner.delimiterRE = delimiter ? new RegExp("\\" + delimiter, "g") : "";
    owner.formatter = formatter;
};
PhoneFormatter.prototype = {
    setFormatter: function(formatter) {
        this.formatter = formatter;
    },
    format: function(phoneNumber) {
        var owner = this;
        owner.formatter.clear();
        // only keep number and +
        phoneNumber = phoneNumber.replace(/[^\d+]/g, "");
        // strip non-leading +
        phoneNumber = phoneNumber.replace(/^\+/, "B").replace(/\+/g, "").replace("B", "+");
        // strip delimiter
        phoneNumber = phoneNumber.replace(owner.delimiterRE, "");
        var result = "", current, validated = false;
        for(var i = 0, iMax = phoneNumber.length; i < iMax; i++){
            current = owner.formatter.inputDigit(phoneNumber.charAt(i));
            // has ()- or space inside
            if (/[\s()-]/g.test(current)) {
                result = current;
                validated = true;
            } else if (!validated) result = current;
        }
        // strip ()
        // e.g. US: 7161234567 returns (716) 123-4567
        result = result.replace(/[()]/g, "");
        // replace library delimiter with user customized delimiter
        result = result.replace(/[\s-]/g, owner.delimiter);
        return result;
    }
};
var PhoneFormatter_1 = PhoneFormatter;
var CreditCardDetector = {
    blocks: {
        uatp: [
            4,
            5,
            6
        ],
        amex: [
            4,
            6,
            5
        ],
        diners: [
            4,
            6,
            4
        ],
        discover: [
            4,
            4,
            4,
            4
        ],
        mastercard: [
            4,
            4,
            4,
            4
        ],
        dankort: [
            4,
            4,
            4,
            4
        ],
        instapayment: [
            4,
            4,
            4,
            4
        ],
        jcb15: [
            4,
            6,
            5
        ],
        jcb: [
            4,
            4,
            4,
            4
        ],
        maestro: [
            4,
            4,
            4,
            4
        ],
        visa: [
            4,
            4,
            4,
            4
        ],
        mir: [
            4,
            4,
            4,
            4
        ],
        unionPay: [
            4,
            4,
            4,
            4
        ],
        general: [
            4,
            4,
            4,
            4
        ]
    },
    re: {
        // starts with 1; 15 digits, not starts with 1800 (jcb card)
        uatp: /^(?!1800)1\d{0,14}/,
        // starts with 34/37; 15 digits
        amex: /^3[47]\d{0,13}/,
        // starts with 6011/65/644-649; 16 digits
        discover: /^(?:6011|65\d{0,2}|64[4-9]\d?)\d{0,12}/,
        // starts with 300-305/309 or 36/38/39; 14 digits
        diners: /^3(?:0([0-5]|9)|[689]\d?)\d{0,11}/,
        // starts with 51-55/22212720; 16 digits
        mastercard: /^(5[1-5]\d{0,2}|22[2-9]\d{0,1}|2[3-7]\d{0,2})\d{0,12}/,
        // starts with 5019/4175/4571; 16 digits
        dankort: /^(5019|4175|4571)\d{0,12}/,
        // starts with 637-639; 16 digits
        instapayment: /^63[7-9]\d{0,13}/,
        // starts with 2131/1800; 15 digits
        jcb15: /^(?:2131|1800)\d{0,11}/,
        // starts with 2131/1800/35; 16 digits
        jcb: /^(?:35\d{0,2})\d{0,12}/,
        // starts with 50/56-58/6304/67; 16 digits
        maestro: /^(?:5[0678]\d{0,2}|6304|67\d{0,2})\d{0,12}/,
        // starts with 22; 16 digits
        mir: /^220[0-4]\d{0,12}/,
        // starts with 4; 16 digits
        visa: /^4\d{0,15}/,
        // starts with 62/81; 16 digits
        unionPay: /^(62|81)\d{0,14}/
    },
    getStrictBlocks: function(block) {
        var total = block.reduce(function(prev, current) {
            return prev + current;
        }, 0);
        return block.concat(19 - total);
    },
    getInfo: function(value, strictMode) {
        var blocks = CreditCardDetector.blocks, re = CreditCardDetector.re;
        // Some credit card can have up to 19 digits number.
        // Set strictMode to true will remove the 16 max-length restrain,
        // however, I never found any website validate card number like
        // this, hence probably you don't want to enable this option.
        strictMode = !!strictMode;
        for(var key in re)if (re[key].test(value)) {
            var matchedBlocks = blocks[key];
            return {
                type: key,
                blocks: strictMode ? this.getStrictBlocks(matchedBlocks) : matchedBlocks
            };
        }
        return {
            type: "unknown",
            blocks: strictMode ? this.getStrictBlocks(blocks.general) : blocks.general
        };
    }
};
var CreditCardDetector_1 = CreditCardDetector;
var Util = {
    noop: function() {},
    strip: function(value, re) {
        return value.replace(re, "");
    },
    getPostDelimiter: function(value, delimiter, delimiters) {
        // single delimiter
        if (delimiters.length === 0) return value.slice(-delimiter.length) === delimiter ? delimiter : "";
        // multiple delimiters
        var matchedDelimiter = "";
        delimiters.forEach(function(current) {
            if (value.slice(-current.length) === current) matchedDelimiter = current;
        });
        return matchedDelimiter;
    },
    getDelimiterREByDelimiter: function(delimiter) {
        return new RegExp(delimiter.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1"), "g");
    },
    getNextCursorPosition: function(prevPos, oldValue, newValue, delimiter, delimiters) {
        // If cursor was at the end of value, just place it back.
        // Because new value could contain additional chars.
        if (oldValue.length === prevPos) return newValue.length;
        return prevPos + this.getPositionOffset(prevPos, oldValue, newValue, delimiter, delimiters);
    },
    getPositionOffset: function(prevPos, oldValue, newValue, delimiter, delimiters) {
        var oldRawValue, newRawValue, lengthOffset;
        oldRawValue = this.stripDelimiters(oldValue.slice(0, prevPos), delimiter, delimiters);
        newRawValue = this.stripDelimiters(newValue.slice(0, prevPos), delimiter, delimiters);
        lengthOffset = oldRawValue.length - newRawValue.length;
        return lengthOffset !== 0 ? lengthOffset / Math.abs(lengthOffset) : 0;
    },
    stripDelimiters: function(value, delimiter, delimiters) {
        var owner = this;
        // single delimiter
        if (delimiters.length === 0) {
            var delimiterRE = delimiter ? owner.getDelimiterREByDelimiter(delimiter) : "";
            return value.replace(delimiterRE, "");
        }
        // multiple delimiters
        delimiters.forEach(function(current) {
            current.split("").forEach(function(letter) {
                value = value.replace(owner.getDelimiterREByDelimiter(letter), "");
            });
        });
        return value;
    },
    headStr: function(str, length) {
        return str.slice(0, length);
    },
    getMaxLength: function(blocks) {
        return blocks.reduce(function(previous, current) {
            return previous + current;
        }, 0);
    },
    // strip prefix
    // Before type  |   After type    |     Return value
    // PEFIX-...    |   PEFIX-...     |     ''
    // PREFIX-123   |   PEFIX-123     |     123
    // PREFIX-123   |   PREFIX-23     |     23
    // PREFIX-123   |   PREFIX-1234   |     1234
    getPrefixStrippedValue: function(value, prefix, prefixLength, prevResult, delimiter, delimiters, noImmediatePrefix, tailPrefix, signBeforePrefix) {
        // No prefix
        if (prefixLength === 0) return value;
        // Value is prefix
        if (value === prefix && value !== "") return "";
        if (signBeforePrefix && value.slice(0, 1) == "-") {
            var prev = prevResult.slice(0, 1) == "-" ? prevResult.slice(1) : prevResult;
            return "-" + this.getPrefixStrippedValue(value.slice(1), prefix, prefixLength, prev, delimiter, delimiters, noImmediatePrefix, tailPrefix, signBeforePrefix);
        }
        // Pre result prefix string does not match pre-defined prefix
        if (prevResult.slice(0, prefixLength) !== prefix && !tailPrefix) {
            // Check if the first time user entered something
            if (noImmediatePrefix && !prevResult && value) return value;
            return "";
        } else if (prevResult.slice(-prefixLength) !== prefix && tailPrefix) {
            // Check if the first time user entered something
            if (noImmediatePrefix && !prevResult && value) return value;
            return "";
        }
        var prevValue = this.stripDelimiters(prevResult, delimiter, delimiters);
        // New value has issue, someone typed in between prefix letters
        // Revert to pre value
        if (value.slice(0, prefixLength) !== prefix && !tailPrefix) return prevValue.slice(prefixLength);
        else if (value.slice(-prefixLength) !== prefix && tailPrefix) return prevValue.slice(0, -prefixLength - 1);
        // No issue, strip prefix for new value
        return tailPrefix ? value.slice(0, -prefixLength) : value.slice(prefixLength);
    },
    getFirstDiffIndex: function(prev, current) {
        var index = 0;
        while(prev.charAt(index) === current.charAt(index)){
            if (prev.charAt(index++) === "") return -1;
        }
        return index;
    },
    getFormattedValue: function(value, blocks, blocksLength, delimiter, delimiters, delimiterLazyShow) {
        var result = "", multipleDelimiters = delimiters.length > 0, currentDelimiter = "";
        // no options, normal input
        if (blocksLength === 0) return value;
        blocks.forEach(function(length, index) {
            if (value.length > 0) {
                var sub = value.slice(0, length), rest = value.slice(length);
                if (multipleDelimiters) currentDelimiter = delimiters[delimiterLazyShow ? index - 1 : index] || currentDelimiter;
                else currentDelimiter = delimiter;
                if (delimiterLazyShow) {
                    if (index > 0) result += currentDelimiter;
                    result += sub;
                } else {
                    result += sub;
                    if (sub.length === length && index < blocksLength - 1) result += currentDelimiter;
                }
                // update remaining string
                value = rest;
            }
        });
        return result;
    },
    // move cursor to the end
    // the first time user focuses on an input with prefix
    fixPrefixCursor: function(el, prefix, delimiter, delimiters) {
        if (!el) return;
        var val = el.value, appendix = delimiter || delimiters[0] || " ";
        if (!el.setSelectionRange || !prefix || prefix.length + appendix.length <= val.length) return;
        var len = val.length * 2;
        // set timeout to avoid blink
        setTimeout(function() {
            el.setSelectionRange(len, len);
        }, 1);
    },
    // Check if input field is fully selected
    checkFullSelection: function(value) {
        try {
            var selection = window.getSelection() || document.getSelection() || {};
            return selection.toString().length === value.length;
        } catch (ex) {
        // Ignore
        }
        return false;
    },
    setSelection: function(element, position, doc) {
        if (element !== this.getActiveElement(doc)) return;
        // cursor is already in the end
        if (element && element.value.length <= position) return;
        if (element.createTextRange) {
            var range = element.createTextRange();
            range.move("character", position);
            range.select();
        } else try {
            element.setSelectionRange(position, position);
        } catch (e) {
            // eslint-disable-next-line
            console.warn("The input element type does not support selection");
        }
    },
    getActiveElement: function(parent) {
        var activeElement = parent.activeElement;
        if (activeElement && activeElement.shadowRoot) return this.getActiveElement(activeElement.shadowRoot);
        return activeElement;
    },
    isAndroid: function() {
        return navigator && /android/i.test(navigator.userAgent);
    },
    // On Android chrome, the keyup and keydown events
    // always return key code 229 as a composition that
    // buffers the users keystrokes
    // see https://github.com/nosir/cleave.js/issues/147
    isAndroidBackspaceKeydown: function(lastInputValue, currentInputValue) {
        if (!this.isAndroid() || !lastInputValue || !currentInputValue) return false;
        return currentInputValue === lastInputValue.slice(0, -1);
    }
};
var Util_1 = Util;
/**
 * Props Assignment
 *
 * Separate this, so react module can share the usage
 */ var DefaultProperties = {
    // Maybe change to object-assign
    // for now just keep it as simple
    assign: function(target, opts) {
        target = target || {};
        opts = opts || {};
        // credit card
        target.creditCard = !!opts.creditCard;
        target.creditCardStrictMode = !!opts.creditCardStrictMode;
        target.creditCardType = "";
        target.onCreditCardTypeChanged = opts.onCreditCardTypeChanged || function() {};
        // phone
        target.phone = !!opts.phone;
        target.phoneRegionCode = opts.phoneRegionCode || "AU";
        target.phoneFormatter = {};
        // time
        target.time = !!opts.time;
        target.timePattern = opts.timePattern || [
            "h",
            "m",
            "s"
        ];
        target.timeFormat = opts.timeFormat || "24";
        target.timeFormatter = {};
        // date
        target.date = !!opts.date;
        target.datePattern = opts.datePattern || [
            "d",
            "m",
            "Y"
        ];
        target.dateMin = opts.dateMin || "";
        target.dateMax = opts.dateMax || "";
        target.dateFormatter = {};
        // numeral
        target.numeral = !!opts.numeral;
        target.numeralIntegerScale = opts.numeralIntegerScale > 0 ? opts.numeralIntegerScale : 0;
        target.numeralDecimalScale = opts.numeralDecimalScale >= 0 ? opts.numeralDecimalScale : 2;
        target.numeralDecimalMark = opts.numeralDecimalMark || ".";
        target.numeralThousandsGroupStyle = opts.numeralThousandsGroupStyle || "thousand";
        target.numeralPositiveOnly = !!opts.numeralPositiveOnly;
        target.stripLeadingZeroes = opts.stripLeadingZeroes !== false;
        target.signBeforePrefix = !!opts.signBeforePrefix;
        target.tailPrefix = !!opts.tailPrefix;
        // others
        target.swapHiddenInput = !!opts.swapHiddenInput;
        target.numericOnly = target.creditCard || target.date || !!opts.numericOnly;
        target.uppercase = !!opts.uppercase;
        target.lowercase = !!opts.lowercase;
        target.prefix = target.creditCard || target.date ? "" : opts.prefix || "";
        target.noImmediatePrefix = !!opts.noImmediatePrefix;
        target.prefixLength = target.prefix.length;
        target.rawValueTrimPrefix = !!opts.rawValueTrimPrefix;
        target.copyDelimiter = !!opts.copyDelimiter;
        target.initValue = opts.initValue !== undefined && opts.initValue !== null ? opts.initValue.toString() : "";
        target.delimiter = opts.delimiter || opts.delimiter === "" ? opts.delimiter : opts.date ? "/" : opts.time ? ":" : opts.numeral ? "," : opts.phone ? " " : " ";
        target.delimiterLength = target.delimiter.length;
        target.delimiterLazyShow = !!opts.delimiterLazyShow;
        target.delimiters = opts.delimiters || [];
        target.blocks = opts.blocks || [];
        target.blocksLength = target.blocks.length;
        target.root = typeof commonjsGlobal === "object" && commonjsGlobal ? commonjsGlobal : window;
        target.document = opts.document || target.root.document;
        target.maxLength = 0;
        target.backspace = false;
        target.result = "";
        target.onValueChanged = opts.onValueChanged || function() {};
        return target;
    }
};
var DefaultProperties_1 = DefaultProperties;
/**
 * Construct a new Cleave instance by passing the configuration object
 *
 * @param {String | HTMLElement} element
 * @param {Object} opts
 */ var Cleave = function(element, opts) {
    var owner = this;
    var hasMultipleElements = false;
    if (typeof element === "string") {
        owner.element = document.querySelector(element);
        hasMultipleElements = document.querySelectorAll(element).length > 1;
    } else if (typeof element.length !== "undefined" && element.length > 0) {
        owner.element = element[0];
        hasMultipleElements = element.length > 1;
    } else owner.element = element;
    if (!owner.element) throw new Error("[cleave.js] Please check the element");
    if (hasMultipleElements) try {
        // eslint-disable-next-line
        console.warn("[cleave.js] Multiple input fields matched, cleave.js will only take the first one.");
    } catch (e) {
    // Old IE
    }
    opts.initValue = owner.element.value;
    owner.properties = Cleave.DefaultProperties.assign({}, opts);
    owner.init();
};
Cleave.prototype = {
    init: function() {
        var owner = this, pps = owner.properties;
        // no need to use this lib
        if (!pps.numeral && !pps.phone && !pps.creditCard && !pps.time && !pps.date && pps.blocksLength === 0 && !pps.prefix) {
            owner.onInput(pps.initValue);
            return;
        }
        pps.maxLength = Cleave.Util.getMaxLength(pps.blocks);
        owner.isAndroid = Cleave.Util.isAndroid();
        owner.lastInputValue = "";
        owner.isBackward = "";
        owner.onChangeListener = owner.onChange.bind(owner);
        owner.onKeyDownListener = owner.onKeyDown.bind(owner);
        owner.onFocusListener = owner.onFocus.bind(owner);
        owner.onCutListener = owner.onCut.bind(owner);
        owner.onCopyListener = owner.onCopy.bind(owner);
        owner.initSwapHiddenInput();
        owner.element.addEventListener("input", owner.onChangeListener);
        owner.element.addEventListener("keydown", owner.onKeyDownListener);
        owner.element.addEventListener("focus", owner.onFocusListener);
        owner.element.addEventListener("cut", owner.onCutListener);
        owner.element.addEventListener("copy", owner.onCopyListener);
        owner.initPhoneFormatter();
        owner.initDateFormatter();
        owner.initTimeFormatter();
        owner.initNumeralFormatter();
        // avoid touch input field if value is null
        // otherwise Firefox will add red box-shadow for <input required />
        if (pps.initValue || pps.prefix && !pps.noImmediatePrefix) owner.onInput(pps.initValue);
    },
    initSwapHiddenInput: function() {
        var owner = this, pps = owner.properties;
        if (!pps.swapHiddenInput) return;
        var inputFormatter = owner.element.cloneNode(true);
        owner.element.parentNode.insertBefore(inputFormatter, owner.element);
        owner.elementSwapHidden = owner.element;
        owner.elementSwapHidden.type = "hidden";
        owner.element = inputFormatter;
        owner.element.id = "";
    },
    initNumeralFormatter: function() {
        var owner = this, pps = owner.properties;
        if (!pps.numeral) return;
        pps.numeralFormatter = new Cleave.NumeralFormatter(pps.numeralDecimalMark, pps.numeralIntegerScale, pps.numeralDecimalScale, pps.numeralThousandsGroupStyle, pps.numeralPositiveOnly, pps.stripLeadingZeroes, pps.prefix, pps.signBeforePrefix, pps.tailPrefix, pps.delimiter);
    },
    initTimeFormatter: function() {
        var owner = this, pps = owner.properties;
        if (!pps.time) return;
        pps.timeFormatter = new Cleave.TimeFormatter(pps.timePattern, pps.timeFormat);
        pps.blocks = pps.timeFormatter.getBlocks();
        pps.blocksLength = pps.blocks.length;
        pps.maxLength = Cleave.Util.getMaxLength(pps.blocks);
    },
    initDateFormatter: function() {
        var owner = this, pps = owner.properties;
        if (!pps.date) return;
        pps.dateFormatter = new Cleave.DateFormatter(pps.datePattern, pps.dateMin, pps.dateMax);
        pps.blocks = pps.dateFormatter.getBlocks();
        pps.blocksLength = pps.blocks.length;
        pps.maxLength = Cleave.Util.getMaxLength(pps.blocks);
    },
    initPhoneFormatter: function() {
        var owner = this, pps = owner.properties;
        if (!pps.phone) return;
        // Cleave.AsYouTypeFormatter should be provided by
        // external google closure lib
        try {
            pps.phoneFormatter = new Cleave.PhoneFormatter(new pps.root.Cleave.AsYouTypeFormatter(pps.phoneRegionCode), pps.delimiter);
        } catch (ex) {
            throw new Error("[cleave.js] Please include phone-type-formatter.{country}.js lib");
        }
    },
    onKeyDown: function(event) {
        var owner = this, charCode = event.which || event.keyCode;
        owner.lastInputValue = owner.element.value;
        owner.isBackward = charCode === 8;
    },
    onChange: function(event) {
        var owner = this, pps = owner.properties, Util = Cleave.Util;
        owner.isBackward = owner.isBackward || event.inputType === "deleteContentBackward";
        var postDelimiter = Util.getPostDelimiter(owner.lastInputValue, pps.delimiter, pps.delimiters);
        if (owner.isBackward && postDelimiter) pps.postDelimiterBackspace = postDelimiter;
        else pps.postDelimiterBackspace = false;
        this.onInput(this.element.value);
    },
    onFocus: function() {
        var owner = this, pps = owner.properties;
        owner.lastInputValue = owner.element.value;
        if (pps.prefix && pps.noImmediatePrefix && !owner.element.value) this.onInput(pps.prefix);
        Cleave.Util.fixPrefixCursor(owner.element, pps.prefix, pps.delimiter, pps.delimiters);
    },
    onCut: function(e) {
        if (!Cleave.Util.checkFullSelection(this.element.value)) return;
        this.copyClipboardData(e);
        this.onInput("");
    },
    onCopy: function(e) {
        if (!Cleave.Util.checkFullSelection(this.element.value)) return;
        this.copyClipboardData(e);
    },
    copyClipboardData: function(e) {
        var owner = this, pps = owner.properties, Util = Cleave.Util, inputValue = owner.element.value, textToCopy = "";
        if (!pps.copyDelimiter) textToCopy = Util.stripDelimiters(inputValue, pps.delimiter, pps.delimiters);
        else textToCopy = inputValue;
        try {
            if (e.clipboardData) e.clipboardData.setData("Text", textToCopy);
            else window.clipboardData.setData("Text", textToCopy);
            e.preventDefault();
        } catch (ex) {
        //  empty
        }
    },
    onInput: function(value) {
        var owner = this, pps = owner.properties, Util = Cleave.Util;
        // case 1: delete one more character "4"
        // 1234*| -> hit backspace -> 123|
        // case 2: last character is not delimiter which is:
        // 12|34* -> hit backspace -> 1|34*
        // note: no need to apply this for numeral mode
        var postDelimiterAfter = Util.getPostDelimiter(value, pps.delimiter, pps.delimiters);
        if (!pps.numeral && pps.postDelimiterBackspace && !postDelimiterAfter) value = Util.headStr(value, value.length - pps.postDelimiterBackspace.length);
        // phone formatter
        if (pps.phone) {
            if (pps.prefix && (!pps.noImmediatePrefix || value.length)) pps.result = pps.prefix + pps.phoneFormatter.format(value).slice(pps.prefix.length);
            else pps.result = pps.phoneFormatter.format(value);
            owner.updateValueState();
            return;
        }
        // numeral formatter
        if (pps.numeral) {
            // Do not show prefix when noImmediatePrefix is specified
            // This mostly because we need to show user the native input placeholder
            if (pps.prefix && pps.noImmediatePrefix && value.length === 0) pps.result = "";
            else pps.result = pps.numeralFormatter.format(value);
            owner.updateValueState();
            return;
        }
        // date
        if (pps.date) value = pps.dateFormatter.getValidatedDate(value);
        // time
        if (pps.time) value = pps.timeFormatter.getValidatedTime(value);
        // strip delimiters
        value = Util.stripDelimiters(value, pps.delimiter, pps.delimiters);
        // strip prefix
        value = Util.getPrefixStrippedValue(value, pps.prefix, pps.prefixLength, pps.result, pps.delimiter, pps.delimiters, pps.noImmediatePrefix, pps.tailPrefix, pps.signBeforePrefix);
        // strip non-numeric characters
        value = pps.numericOnly ? Util.strip(value, /[^\d]/g) : value;
        // convert case
        value = pps.uppercase ? value.toUpperCase() : value;
        value = pps.lowercase ? value.toLowerCase() : value;
        // prevent from showing prefix when no immediate option enabled with empty input value
        if (pps.prefix) {
            if (pps.tailPrefix) value = value + pps.prefix;
            else value = pps.prefix + value;
            // no blocks specified, no need to do formatting
            if (pps.blocksLength === 0) {
                pps.result = value;
                owner.updateValueState();
                return;
            }
        }
        // update credit card props
        if (pps.creditCard) owner.updateCreditCardPropsByValue(value);
        // strip over length characters
        value = Util.headStr(value, pps.maxLength);
        // apply blocks
        pps.result = Util.getFormattedValue(value, pps.blocks, pps.blocksLength, pps.delimiter, pps.delimiters, pps.delimiterLazyShow);
        owner.updateValueState();
    },
    updateCreditCardPropsByValue: function(value) {
        var owner = this, pps = owner.properties, Util = Cleave.Util, creditCardInfo;
        // At least one of the first 4 characters has changed
        if (Util.headStr(pps.result, 4) === Util.headStr(value, 4)) return;
        creditCardInfo = Cleave.CreditCardDetector.getInfo(value, pps.creditCardStrictMode);
        pps.blocks = creditCardInfo.blocks;
        pps.blocksLength = pps.blocks.length;
        pps.maxLength = Util.getMaxLength(pps.blocks);
        // credit card type changed
        if (pps.creditCardType !== creditCardInfo.type) {
            pps.creditCardType = creditCardInfo.type;
            pps.onCreditCardTypeChanged.call(owner, pps.creditCardType);
        }
    },
    updateValueState: function() {
        var owner = this, Util = Cleave.Util, pps = owner.properties;
        if (!owner.element) return;
        var endPos = owner.element.selectionEnd;
        var oldValue = owner.element.value;
        var newValue = pps.result;
        endPos = Util.getNextCursorPosition(endPos, oldValue, newValue, pps.delimiter, pps.delimiters);
        // fix Android browser type="text" input field
        // cursor not jumping issue
        if (owner.isAndroid) {
            window.setTimeout(function() {
                owner.element.value = newValue;
                Util.setSelection(owner.element, endPos, pps.document, false);
                owner.callOnValueChanged();
            }, 1);
            return;
        }
        owner.element.value = newValue;
        if (pps.swapHiddenInput) owner.elementSwapHidden.value = owner.getRawValue();
        Util.setSelection(owner.element, endPos, pps.document, false);
        owner.callOnValueChanged();
    },
    callOnValueChanged: function() {
        var owner = this, pps = owner.properties;
        pps.onValueChanged.call(owner, {
            target: {
                name: owner.element.name,
                value: pps.result,
                rawValue: owner.getRawValue()
            }
        });
    },
    setPhoneRegionCode: function(phoneRegionCode) {
        var owner = this, pps = owner.properties;
        pps.phoneRegionCode = phoneRegionCode;
        owner.initPhoneFormatter();
        owner.onChange();
    },
    setRawValue: function(value) {
        var owner = this, pps = owner.properties;
        value = value !== undefined && value !== null ? value.toString() : "";
        if (pps.numeral) value = value.replace(".", pps.numeralDecimalMark);
        pps.postDelimiterBackspace = false;
        owner.element.value = value;
        owner.onInput(value);
    },
    getRawValue: function() {
        var owner = this, pps = owner.properties, Util = Cleave.Util, rawValue = owner.element.value;
        if (pps.rawValueTrimPrefix) rawValue = Util.getPrefixStrippedValue(rawValue, pps.prefix, pps.prefixLength, pps.result, pps.delimiter, pps.delimiters, pps.noImmediatePrefix, pps.tailPrefix, pps.signBeforePrefix);
        if (pps.numeral) rawValue = pps.numeralFormatter.getRawValue(rawValue);
        else rawValue = Util.stripDelimiters(rawValue, pps.delimiter, pps.delimiters);
        return rawValue;
    },
    getISOFormatDate: function() {
        var owner = this, pps = owner.properties;
        return pps.date ? pps.dateFormatter.getISOFormatDate() : "";
    },
    getISOFormatTime: function() {
        var owner = this, pps = owner.properties;
        return pps.time ? pps.timeFormatter.getISOFormatTime() : "";
    },
    getFormattedValue: function() {
        return this.element.value;
    },
    destroy: function() {
        var owner = this;
        owner.element.removeEventListener("input", owner.onChangeListener);
        owner.element.removeEventListener("keydown", owner.onKeyDownListener);
        owner.element.removeEventListener("focus", owner.onFocusListener);
        owner.element.removeEventListener("cut", owner.onCutListener);
        owner.element.removeEventListener("copy", owner.onCopyListener);
    },
    toString: function() {
        return "[Cleave Object]";
    }
};
Cleave.NumeralFormatter = NumeralFormatter_1;
Cleave.DateFormatter = DateFormatter_1;
Cleave.TimeFormatter = TimeFormatter_1;
Cleave.PhoneFormatter = PhoneFormatter_1;
Cleave.CreditCardDetector = CreditCardDetector_1;
Cleave.Util = Util_1;
Cleave.DefaultProperties = DefaultProperties_1;
// for angular directive
(typeof commonjsGlobal === "object" && commonjsGlobal ? commonjsGlobal : window)["Cleave"] = Cleave;
// CommonJS
var Cleave_1 = Cleave;
exports.default = Cleave_1;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7MuId":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaInputWrapper);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaInputWrapperJs = require("./VaInputWrapper.js");
const VaInputWrapper = (0, _withConfigTransportJs.w)((0, _vaInputWrapperJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaInputWrapper.js":"7Gzu1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7Gzu1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_VaInputWrapper);
var _vaInputWrapperVueVueTypeScriptLangJs = require("./VaInputWrapper.vue_vue_type_script_lang.js");
var _vue = require("vue");
var _pluginVueExportHelperJs = require("../../../plugin-vue_export-helper.js");
var _vaInputWrapperCss = require("../../../VaInputWrapper.css");
const VaInputWrapper_vue_vue_type_style_index_0_lang = "";
const _hoisted_1 = {
    class: "va-input-wrapper__fieldset va-input-wrapper__size-keeper"
};
const _hoisted_2 = {
    class: "va-input-wrapper__container"
};
const _hoisted_3 = {
    class: "va-input-wrapper__text"
};
const _hoisted_4 = [
    "placeholder",
    "readonly",
    "disabled"
];
const _hoisted_5 = [
    "id"
];
const _hoisted_6 = {
    class: "va-input-wrapper__counter"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_VaInputLabel = (0, _vue.resolveComponent)("VaInputLabel");
    const _component_va_icon = (0, _vue.resolveComponent)("va-icon");
    const _component_va_message_list = (0, _vue.resolveComponent)("va-message-list");
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
        class: (0, _vue.normalizeClass)([
            "va-input-wrapper",
            _ctx.wrapperClass
        ]),
        onClick: _cache[6] || (_cache[6] = ($event)=>_ctx.$emit("click", $event)),
        style: (0, _vue.normalizeStyle)(`--va-background-computed: ${String(_ctx.backgroundComputed)};--va-color-computed: ${String(_ctx.colorComputed)};--va-text-color-computed: ${String(_ctx.textColorComputed)}`)
    }, [
        (0, _vue.createElementVNode)("fieldset", _hoisted_1, [
            (0, _vue.createVNode)(_component_va_message_list, {
                color: _ctx.messagesColor,
                "model-value": _ctx.messagesComputed,
                limit: _ctx.errorLimit,
                "inherit-slots": [
                    "message",
                    "messages"
                ]
            }, {
                default: (0, _vue.withCtx)(({ ariaAttributes: messagesChildAriaAttributes })=>[
                        (_ctx.$props.label || _ctx.$slots.label) && !_ctx.$props.innerLabel ? ((0, _vue.openBlock)(), (0, _vue.createBlock)(_component_VaInputLabel, (0, _vue.mergeProps)({
                            key: 0,
                            class: "va-input-wrapper__label va-input-wrapper__label--outer"
                        }, _ctx.vaInputLabelProps, {
                            id: _ctx.labelId
                        }), {
                            default: (0, _vue.withCtx)((bind)=>[
                                    (0, _vue.renderSlot)(_ctx.$slots, "label", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(bind)))
                                ]),
                            _: 3
                        }, 16, [
                            "id"
                        ])) : (0, _vue.createCommentVNode)("", true),
                        (0, _vue.createElementVNode)("div", _hoisted_2, [
                            _ctx.$slots.prepend ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                key: 0,
                                class: "va-input-wrapper__prepend-inner",
                                onClick: _cache[0] || (_cache[0] = ($event)=>_ctx.$emit("click-prepend"))
                            }, [
                                (0, _vue.renderSlot)(_ctx.$slots, "prepend")
                            ])) : (0, _vue.createCommentVNode)("", true),
                            (0, _vue.createElementVNode)("div", {
                                onClick: _cache[4] || (_cache[4] = ($event)=>_ctx.$emit("click-field", $event)),
                                class: "va-input-wrapper__field"
                            }, [
                                _ctx.$slots.prependInner ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                    key: 0,
                                    class: "va-input-wrapper__prepend-inner",
                                    ref: "container",
                                    onClick: _cache[1] || (_cache[1] = ($event)=>_ctx.$emit("click-prepend-inner", $event))
                                }, [
                                    (0, _vue.renderSlot)(_ctx.$slots, "prependInner")
                                ], 512)) : (0, _vue.createCommentVNode)("", true),
                                (0, _vue.createElementVNode)("div", _hoisted_3, [
                                    (_ctx.$props.label || _ctx.$slots.label) && _ctx.$props.innerLabel ? ((0, _vue.openBlock)(), (0, _vue.createBlock)(_component_VaInputLabel, (0, _vue.mergeProps)({
                                        key: 0,
                                        class: "va-input-wrapper__label va-input-wrapper__label--inner"
                                    }, _ctx.vaInputLabelProps, {
                                        id: _ctx.labelId
                                    }), {
                                        default: (0, _vue.withCtx)((bind)=>[
                                                (0, _vue.renderSlot)(_ctx.$slots, "label", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(bind)))
                                            ]),
                                        _: 3
                                    }, 16, [
                                        "id"
                                    ])) : (0, _vue.createCommentVNode)("", true),
                                    (0, _vue.renderSlot)(_ctx.$slots, "default", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                        ariaAttributes: {
                                            ...messagesChildAriaAttributes,
                                            ..._ctx.ariaAttributes
                                        },
                                        value: _ctx.vModel
                                    })), ()=>[
                                            (0, _vue.withDirectives)((0, _vue.createElementVNode)("input", (0, _vue.mergeProps)({
                                                ...messagesChildAriaAttributes,
                                                ..._ctx.ariaAttributes
                                            }, {
                                                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event)=>_ctx.vModel = $event),
                                                ref: "inputRef",
                                                placeholder: _ctx.$props.placeholder,
                                                readonly: _ctx.$props.readonly,
                                                disabled: _ctx.$props.disabled
                                            }), null, 16, _hoisted_4), [
                                                [
                                                    (0, _vue.vModelDynamic),
                                                    _ctx.vModel
                                                ]
                                            ])
                                        ])
                                ]),
                                _ctx.success ? ((0, _vue.openBlock)(), (0, _vue.createBlock)(_component_va_icon, {
                                    key: 1,
                                    color: "success",
                                    name: "va-check-circle",
                                    class: "va-input-wrapper__icon va-input-wrapper__icon--success"
                                })) : (0, _vue.createCommentVNode)("", true),
                                _ctx.error ? ((0, _vue.openBlock)(), (0, _vue.createBlock)(_component_va_icon, {
                                    key: 2,
                                    color: "danger",
                                    name: "va-warning",
                                    class: "va-input-wrapper__icon va-input-wrapper__icon--error"
                                })) : (0, _vue.createCommentVNode)("", true),
                                _ctx.$props.loading ? ((0, _vue.openBlock)(), (0, _vue.createBlock)(_component_va_icon, {
                                    key: 3,
                                    color: _ctx.$props.color,
                                    name: "va-loading",
                                    spin: "counter-clockwise",
                                    class: "va-input-wrapper__icon va-input-wrapper__icon--loading"
                                }, null, 8, [
                                    "color"
                                ])) : (0, _vue.createCommentVNode)("", true),
                                (0, _vue.renderSlot)(_ctx.$slots, "icon"),
                                _ctx.$slots.appendInner ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                    key: 4,
                                    class: "va-input-wrapper__append-inner",
                                    onClick: _cache[3] || (_cache[3] = ($event)=>_ctx.$emit("click-append-inner", $event))
                                }, [
                                    (0, _vue.renderSlot)(_ctx.$slots, "appendInner")
                                ])) : (0, _vue.createCommentVNode)("", true)
                            ]),
                            _ctx.$slots.append ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                key: 1,
                                class: "va-input-wrapper__append-inner",
                                onClick: _cache[5] || (_cache[5] = ($event)=>_ctx.$emit("click-append"))
                            }, [
                                (0, _vue.renderSlot)(_ctx.$slots, "append")
                            ])) : (0, _vue.createCommentVNode)("", true)
                        ]),
                        _ctx.isCounterVisible ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                            key: 1,
                            class: "va-input-wrapper__counter-wrapper",
                            id: _ctx.characterCountId
                        }, [
                            (0, _vue.renderSlot)(_ctx.$slots, "counter", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                valueLength: _ctx.counterValue,
                                maxLength: _ctx.$props.maxLength
                            })), ()=>[
                                    (0, _vue.createElementVNode)("div", _hoisted_6, (0, _vue.toDisplayString)(_ctx.counterComputed), 1)
                                ])
                        ], 8, _hoisted_5)) : (0, _vue.createCommentVNode)("", true)
                    ]),
                _: 3
            }, 8, [
                "color",
                "model-value",
                "limit"
            ])
        ])
    ], 6);
}
const _VaInputWrapper = /* @__PURE__ */ (0, _pluginVueExportHelperJs._)((0, _vaInputWrapperVueVueTypeScriptLangJs._), [
    [
        "render",
        _sfc_render
    ]
]);

},{"./VaInputWrapper.vue_vue_type_script_lang.js":"ch3JG","vue":"gzxs9","../../../plugin-vue_export-helper.js":"broGc","../../../VaInputWrapper.css":"1c74a","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ch3JG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../vendor.js");
var _vaInputLabelVueVueTypeScriptSetupTrueLangJs = require("./components/VaInputLabel.vue_vue_type_script_setup_true_lang.js");
var _indexJs = require("../va-icon/index.js");
var _useInputFieldAriaJs = require("./hooks/useInputFieldAria.js");
var _withSlotInheritanceJs = require("../../utils/with-slot-inheritance/with-slot-inheritance.js");
var _useFormFieldJs = require("../../composables/useFormField.js");
var _useSyncPropJs = require("../../composables/useSyncProp.js");
var _useFocusDeepJs = require("../../composables/useFocusDeep.js");
var _vaMessageListJs = require("../va-message-list/VaMessageList.js");
var _extractComponentOptionsJs = require("../../utils/component-options/extract-component-options.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useValidationJs = require("../../composables/useValidation.js");
var _useColorsJs = require("../../composables/useColors.js");
var _useBemJs = require("../../composables/useBem.js");
var _useTextColorJs = require("../../composables/useTextColor.js");
var _filterPropsJs = require("../../utils/component-options/filter-props.js");
var _vaInputWrapperCss = require("../../../VaInputWrapper.css");
const VaInputLabelProps = (0, _extractComponentOptionsJs.e)((0, _vaInputLabelVueVueTypeScriptSetupTrueLangJs._));
const _sfc_main = (0, _vue.defineComponent)({
    name: "VaInputWrapper",
    components: {
        VaMessageList: (0, _withSlotInheritanceJs.W)((0, _vaMessageListJs.V)),
        VaIcon: (0, _indexJs.V),
        VaInputLabel: (0, _vaInputLabelVueVueTypeScriptSetupTrueLangJs._)
    },
    props: {
        ...(0, _useComponentPresetJs.u),
        ...(0, _useInputFieldAriaJs.u),
        ...(0, _useFormFieldJs.u),
        ...(0, _useValidationJs.b),
        ...VaInputLabelProps,
        modelValue: {
            type: null,
            default: ""
        },
        counter: {
            type: Boolean
        },
        maxLength: {
            type: Number,
            default: void 0
        },
        label: {
            type: String,
            default: ""
        },
        placeholder: {
            type: String,
            default: ""
        },
        color: {
            type: String,
            default: "primary"
        },
        background: {
            type: String
        },
        success: {
            type: Boolean,
            default: false
        },
        loading: {
            type: Boolean,
            default: false
        },
        requiredMark: {
            type: Boolean,
            default: false
        },
        innerLabel: {
            type: Boolean,
            default: false
        }
    },
    emits: [
        "click",
        "click-prepend",
        "click-append",
        "click-prepend-inner",
        "click-append-inner",
        "click-field",
        "update:modelValue"
    ],
    setup (props, { emit, slots }) {
        const { getColor } = (0, _useColorsJs.u)();
        const [vModel] = (0, _useSyncPropJs.u)("modelValue", props, emit, "");
        const inputRef = (0, _vue.ref)();
        const isFocused = (0, _useFocusDeepJs.u)();
        const counterValue = (0, _vue.computed)(()=>props.counter && typeof vModel.value === "string" ? vModel.value.length : void 0);
        const wrapperClass = (0, _useBemJs.u)("va-input-wrapper", ()=>({
                ...(0, _vendorJs.p)(props, [
                    "success",
                    "error",
                    "disabled",
                    "readonly"
                ]),
                focused: Boolean(isFocused.value),
                labeled: Boolean(props.label || slots.label),
                labeledInner: Boolean(props.label || slots.label) && props.innerLabel
            }));
        const colorComputed = (0, _vue.computed)(()=>getColor(props.color));
        const backgroundComputed = (0, _vue.computed)(()=>props.background ? getColor(props.background) : "#ffffff00");
        const messagesComputed = (0, _vue.computed)(()=>props.error ? props.errorMessages : props.messages);
        const { textColorComputed } = (0, _useTextColorJs.u)(backgroundComputed);
        const messagesColor = (0, _vue.computed)(()=>{
            if (props.error) return "danger";
            if (props.success) return "success";
            return "";
        });
        const errorLimit = (0, _vue.computed)(()=>props.error ? Number(props.errorCount) : 99);
        const isCounterVisible = (0, _vue.computed)(()=>counterValue.value !== void 0);
        const counterComputed = (0, _vue.computed)(()=>props.maxLength !== void 0 ? `${counterValue.value}/${props.maxLength}` : counterValue.value);
        const { labelId, characterCountId, ariaAttributes } = (0, _useInputFieldAriaJs.a)(props);
        const vaInputLabelProps = (0, _filterPropsJs.f)(VaInputLabelProps);
        const focus = ()=>{
            isFocused.value = true;
        };
        const blur = ()=>{
            isFocused.value = false;
        };
        return {
            inputRef,
            focus,
            blur,
            labelId,
            characterCountId,
            ariaAttributes,
            vModel,
            counterValue,
            vaInputLabelProps,
            wrapperClass,
            textColorComputed,
            isCounterVisible,
            counterComputed,
            colorComputed,
            backgroundComputed,
            messagesColor,
            messagesComputed,
            errorLimit
        };
    }
});

},{"vue":"gzxs9","../../../vendor.js":"l6TAc","./components/VaInputLabel.vue_vue_type_script_setup_true_lang.js":"8jmjT","../va-icon/index.js":"82tPo","./hooks/useInputFieldAria.js":"8EH06","../../utils/with-slot-inheritance/with-slot-inheritance.js":"cpS7y","../../composables/useFormField.js":"676Eq","../../composables/useSyncProp.js":"3q1sU","../../composables/useFocusDeep.js":"ay8Fe","../va-message-list/VaMessageList.js":"kMkwf","../../utils/component-options/extract-component-options.js":"1ODzH","../../composables/useComponentPreset.js":"2HoaT","../../composables/useValidation.js":"iFHh2","../../composables/useColors.js":"a4Qgv","../../composables/useBem.js":"igmjV","../../composables/useTextColor.js":"5pfXb","../../utils/component-options/filter-props.js":"4HycW","../../../VaInputWrapper.css":"1c74a","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8jmjT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useColorsJs = require("../../../composables/useColors.js");
var _vaInputLabelCss = require("../../../../VaInputLabel.css");
const _hoisted_1 = {
    key: 0,
    class: "va-input-label__required-mark"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaInputLabel",
    __name: "VaInputLabel",
    props: {
        label: {
            type: String,
            default: ""
        },
        requiredMark: {
            type: Boolean,
            default: false
        },
        color: {
            type: String,
            default: "primary"
        }
    },
    setup (__props) {
        const { getColor } = (0, _useColorsJs.u)();
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("label", {
                "aria-hidden": "true",
                class: "va-input-label",
                style: (0, _vue.normalizeStyle)({
                    color: (0, _vue.unref)(getColor)(_ctx.$props.color, void 0, true)
                })
            }, [
                (0, _vue.renderSlot)(_ctx.$slots, "default", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                    label: __props.label,
                    requiredMark: __props.requiredMark,
                    color: (0, _vue.unref)(getColor)(_ctx.$props.color)
                })), ()=>[
                        (0, _vue.createTextVNode)((0, _vue.toDisplayString)(__props.label) + " ", 1),
                        __props.requiredMark ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("span", _hoisted_1, " * ")) : (0, _vue.createCommentVNode)("", true)
                    ])
            ], 4);
        };
    }
});

},{"vue":"gzxs9","../../../composables/useColors.js":"a4Qgv","../../../../VaInputLabel.css":"dibhP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dibhP":[function() {},{}],"8EH06":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useInputFieldAria);
parcelHelpers.export(exports, "u", ()=>useInputFieldAriaProps);
var _vue = require("vue");
var _useComponentUuidJs = require("../../../composables/useComponentUuid.js");
const useInputFieldAriaProps = {
    label: {
        type: String,
        default: ""
    },
    inputAriaLabel: {
        type: String,
        default: "$t:inputField"
    },
    inputAriaLabelledby: {
        type: String
    },
    inputAriaDescribedby: {
        type: String
    }
};
const useInputFieldAria = (props)=>{
    const id = (0, _useComponentUuidJs.u)();
    const labelId = `input-label-${id}`;
    const characterCountId = `input-character-count-${id}`;
    const ariaAttributes = (0, _vue.computed)(()=>({
            "aria-label": props.label !== "" ? props.label : props.inputAriaLabel,
            "aria-labelledby": props.inputAriaLabelledby ? props.inputAriaLabelledby : labelId,
            "aria-describedby": props.inputAriaDescribedby ? props.inputAriaDescribedby : characterCountId
        }));
    return {
        labelId,
        characterCountId,
        ariaAttributes
    };
};

},{"vue":"gzxs9","../../../composables/useComponentUuid.js":"cuNNa","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cpS7y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "W", ()=>WithSlotInheritance);
var _vue = require("vue");
const WithSlotInheritance = (component)=>{
    return (0, _vue.defineComponent)({
        name: "ProxySlots",
        props: {
            inheritSlots: {
                type: Array,
                required: true
            }
        },
        render () {
            var _a;
            const parentSlots = ((_a = this.$parent) == null ? void 0 : _a.$slots) || {};
            const slotsToProxy = this.$props.inheritSlots || Object.keys(parentSlots);
            const slots = slotsToProxy.reduce((slots2, name)=>{
                if (parentSlots[name]) slots2[name] = parentSlots[name];
                return slots2;
            }, {});
            return (0, _vue.h)(component, this.$attrs, {
                ...slots,
                ...this.$slots
            });
        }
    });
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"676Eq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useFormField);
parcelHelpers.export(exports, "u", ()=>useFormFieldProps);
var _vue = require("vue");
var _vendorJs = require("../../vendor.js");
var _useBemJs = require("./useBem.js");
const useFormFieldProps = {
    disabled: {
        type: Boolean,
        default: false
    },
    readonly: {
        type: Boolean,
        default: false
    }
};
const useFormField = (prefix, props)=>{
    const computedClasses = (0, _useBemJs.u)(prefix, (0, _vue.computed)(()=>(0, _vendorJs.p)(props, [
            "disabled",
            "readonly"
        ])));
    return {
        computedClasses
    };
};

},{"vue":"gzxs9","../../vendor.js":"l6TAc","./useBem.js":"igmjV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ay8Fe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useFocusDeep);
var _vue = require("vue");
var _useHTMLElementJs = require("./useHTMLElement.js");
var _useCurrentElementJs = require("./useCurrentElement.js");
var _useActiveElementJs = require("./useActiveElement.js");
const useFocusDeep = (el)=>{
    const focused = (0, _useActiveElementJs.u)();
    const current = (0, _useCurrentElementJs.u)(el ? (0, _useHTMLElementJs.u)(el) : void 0);
    let previouslyFocusedElement = null;
    const isFocused = (0, _vue.computed)({
        get () {
            var _a;
            if (!focused.value) return false;
            if (focused.value === current.value) return true;
            const isFocused2 = (_a = current.value) == null ? void 0 : _a.contains(focused.value);
            if (isFocused2) previouslyFocusedElement = focused.value;
            return isFocused2;
        },
        set (value) {
            var _a;
            let target = previouslyFocusedElement ?? current.value;
            if (!((_a = current.value) == null ? void 0 : _a.contains(target))) target = current.value;
            if (value) target == null || target.focus();
            else target == null || target.blur();
        }
    });
    return Object.assign(isFocused, {
        /** Focus `el` if focus is not set to any other element */ focusIfNothingIfFocused: ()=>{
            if (focused.value === document.body) isFocused.value = true;
        },
        focusPreviousElement: ()=>{
            if (previouslyFocusedElement) previouslyFocusedElement.focus();
            else document.body.focus();
        }
    });
};

},{"vue":"gzxs9","./useHTMLElement.js":"1Yk4Z","./useCurrentElement.js":"iOsak","./useActiveElement.js":"3ucTg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1c74a":[function() {},{}],"1c74a":[function() {},{}],"rRUgY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "c", ()=>combineFunctions);
const combineFunctions = (...list)=>{
    return (...args)=>list.forEach((fn)=>fn(...args));
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4lsQT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useFocusable);
parcelHelpers.export(exports, "u", ()=>useFocusableProps);
var _vue = require("vue");
var _focusJs = require("../utils/focus.js");
var _unwrapElJs = require("../utils/unwrapEl.js");
const useFocusableProps = {
    /** Focus element when mounted */ autofocus: {
        type: Boolean,
        default: false
    }
};
const useFocusable = (el, props)=>{
    const focus = ()=>{
        (0, _focusJs.a)((0, _unwrapElJs.u)(el.value));
    };
    const blur = ()=>{
        (0, _focusJs.b)((0, _unwrapElJs.u)(el.value));
    };
    (0, _vue.onMounted)(()=>{
        if (props.autofocus) focus();
    });
    return {
        focus,
        blur
    };
};

},{"vue":"gzxs9","../utils/focus.js":"e1Xlj","../utils/unwrapEl.js":"bYHKv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h8vES":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useClearableEmits);
parcelHelpers.export(exports, "b", ()=>useClearable);
parcelHelpers.export(exports, "u", ()=>useClearableProps);
var _vue = require("vue");
var _useFocusJs = require("./useFocus.js");
const useClearableProps = {
    clearable: {
        type: Boolean,
        default: false
    },
    clearableIcon: {
        type: String,
        default: "va-clear"
    },
    clearValue: {
        type: String,
        default: ""
    }
};
const useClearableEmits = [
    "clear"
];
const useClearable = (props, inputValue, el, hasError)=>{
    const { isFocused, onFocus, onBlur } = (0, _useFocusJs.u)(el);
    const clearedValues = [
        null,
        void 0,
        props.clearValue
    ];
    const canBeCleared = (0, _vue.computed)(()=>props.clearable && !props.disabled && !props.readonly && !clearedValues.includes(inputValue.value));
    const clearIconColor = (0, _vue.computed)(()=>{
        if (isFocused == null ? void 0 : isFocused.value) return props.color || "primary";
        if (hasError == null ? void 0 : hasError.value) return "danger";
        if (props.success) return "success";
        return "secondary";
    });
    const clearIconProps = (0, _vue.computed)(()=>({
            name: props.clearableIcon,
            color: clearIconColor.value,
            size: "medium",
            tabindex: canBeCleared.value ? 0 : -1
        }));
    return {
        canBeCleared,
        clearIconColor,
        clearIconProps,
        onFocus,
        onBlur
    };
};

},{"vue":"gzxs9","./useFocus.js":"8TBqW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"flRjm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useDeprecatedCondition);
var _vue = require("vue");
var _envJs = require("../utils/env.js");
var _consoleJs = require("../utils/console.js");
const useDeprecatedCondition = (validators)=>{
    if (!(0, _envJs.i)) return void 0;
    const instance = (0, _vue.getCurrentInstance)();
    if (!instance) throw new Error("`useDeprecated` hook must be used only inside of setup function!");
    validators.forEach((validator)=>{
        const message = validator();
        if (typeof message === "string") (0, _consoleJs.w)(`(${instance.type.name} component) ${message}`);
    });
};

},{"vue":"gzxs9","../utils/env.js":"Fmkmq","../utils/console.js":"58L6z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7P1CA":[function() {},{}],"72GfW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaColorPalette);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaColorPaletteVueVueTypeScriptSetupTrueLangJs = require("./VaColorPalette.vue_vue_type_script_setup_true_lang.js");
const VaColorPalette = (0, _withConfigTransportJs.w)((0, _vaColorPaletteVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaColorPalette.vue_vue_type_script_setup_true_lang.js":"hZuRa","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hZuRa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _indexJs = require("../va-color-indicator/index.js");
var _useStatefulJs = require("../../composables/useStateful.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useTranslationJs = require("../../composables/useTranslation.js");
var _vaColorPaletteCss = require("../../../VaColorPalette.css");
const _hoisted_1 = [
    "aria-label"
];
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaColorPalette",
    __name: "VaColorPalette",
    props: {
        ...(0, _useStatefulJs.u),
        ...(0, _useComponentPresetJs.u),
        modelValue: {
            type: String,
            default: null
        },
        palette: {
            type: Array,
            default: ()=>[]
        },
        indicator: {
            type: String,
            default: "dot",
            validator: (value)=>[
                    "dot",
                    "square"
                ].includes(value)
        },
        ariaLabel: {
            type: String,
            default: "$t:colorSelection"
        },
        ariaIndicatorLabel: {
            type: String,
            default: "$t:color"
        }
    },
    emits: [
        ...(0, _useStatefulJs.a)
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const { valueComputed } = (0, _useStatefulJs.b)(props, emit);
        const isSelected = (color)=>valueComputed.value === color;
        const { tp } = (0, _useTranslationJs.u)();
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("ul", {
                class: "va-color-palette",
                role: "listbox",
                "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaLabel)
            }, [
                ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)(__props.palette, (color, index)=>{
                    return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), {
                        key: index,
                        role: "option",
                        "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaIndicatorLabel, {
                            color
                        }),
                        "aria-selected": isSelected(color),
                        tabindex: "0",
                        modelValue: isSelected(color),
                        color,
                        square: __props.indicator === "square",
                        "onUpdate:modelValue": ($event)=>valueComputed.value = color
                    }, null, 8, [
                        "aria-label",
                        "aria-selected",
                        "modelValue",
                        "color",
                        "square",
                        "onUpdate:modelValue"
                    ]);
                }), 128))
            ], 8, _hoisted_1);
        };
    }
});

},{"vue":"gzxs9","../va-color-indicator/index.js":"euOOk","../../composables/useStateful.js":"h9zUi","../../composables/useComponentPreset.js":"2HoaT","../../composables/useTranslation.js":"7S3aV","../../../VaColorPalette.css":"hzfzy","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hzfzy":[function() {},{}],"lYcyd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaContent);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaContentJs = require("./VaContent.js");
const VaContent = (0, _withConfigTransportJs.w)((0, _vaContentJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaContent.js":"apwrs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"apwrs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_VaContent);
var _vue = require("vue");
var _pluginVueExportHelperJs = require("../../../plugin-vue_export-helper.js");
const _sfc_main = {
    name: "VaContent"
};
const _hoisted_1 = {
    class: "va-typography-block"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_1, [
        (0, _vue.renderSlot)(_ctx.$slots, "default")
    ]);
}
const _VaContent = /* @__PURE__ */ (0, _pluginVueExportHelperJs._)(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../plugin-vue_export-helper.js":"broGc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4iuxZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaCounter);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaCounterVueVueTypeScriptSetupTrueLangJs = require("./VaCounter.vue_vue_type_script_setup_true_lang.js");
const VaCounter = (0, _withConfigTransportJs.w)((0, _vaCounterVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaCounter.vue_vue_type_script_setup_true_lang.js":"lAn8W","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lAn8W":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../vendor.js");
var _cssJs = require("../../utils/css.js");
var _useCounterPropsValidationJs = require("./hooks/useCounterPropsValidation.js");
var _indexJs = require("../va-input-wrapper/index.js");
var _indexJs1 = require("../va-button/index.js");
var _useFocusJs = require("../../composables/useFocus.js");
var _useLongPressJs = require("../../composables/useLongPress.js");
var _extractComponentOptionsJs = require("../../utils/component-options/extract-component-options.js");
var _useFormFieldJs = require("../../composables/useFormField.js");
var _useStatefulJs = require("../../composables/useStateful.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useClearableJs = require("../../composables/useClearable.js");
var _useValidationJs = require("../../composables/useValidation.js");
var _useTemplateRefJs = require("../../composables/useTemplateRef.js");
var _useColorsJs = require("../../composables/useColors.js");
var _useTranslationJs = require("../../composables/useTranslation.js");
var _filterPropsJs = require("../../utils/component-options/filter-props.js");
var _useEmitProxyJs = require("../../composables/useEmitProxy.js");
var _vaCounterCss = require("../../../VaCounter.css");
const _hoisted_1 = [
    "value",
    "aria-live"
];
const { createEmits: createInputEmits, createListeners: createInputListeners } = (0, _useEmitProxyJs.u)([
    "change"
]);
const { createEmits: createFieldEmits, createListeners: createFieldListeners } = (0, _useEmitProxyJs.u)([
    {
        listen: "click-prepend",
        emit: "click:decrease-button"
    },
    {
        listen: "click-append",
        emit: "click:increase-button"
    },
    {
        listen: "click-prepend-inner",
        emit: "click:decrease-icon"
    },
    {
        listen: "click-append-inner",
        emit: "click:increase-icon"
    }
]);
const VaInputWrapperProps = (0, _extractComponentOptionsJs.e)((0, _indexJs.V));
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaCounter",
    inheritAttrs: false,
    __name: "VaCounter",
    props: {
        ...(0, _useFormFieldJs.u),
        ...(0, _useStatefulJs.u),
        ...(0, _useComponentPresetJs.u),
        ...(0, _useClearableJs.u),
        ...VaInputWrapperProps,
        // input
        modelValue: {
            type: [
                String,
                Number
            ],
            default: 0
        },
        manualInput: {
            type: Boolean,
            default: false
        },
        min: {
            type: [
                Number,
                String
            ]
        },
        max: {
            type: [
                Number,
                String
            ]
        },
        step: {
            type: [
                Number,
                String
            ],
            default: 1
        },
        color: {
            type: String,
            default: "primary"
        },
        // icons & buttons
        increaseIcon: {
            type: String,
            default: "va-plus"
        },
        decreaseIcon: {
            type: String,
            default: "va-minus"
        },
        buttons: {
            type: Boolean,
            default: false
        },
        flat: {
            type: Boolean,
            default: true
        },
        rounded: {
            type: Boolean,
            default: false
        },
        margins: {
            type: [
                String,
                Number
            ],
            default: "4px"
        },
        longPressDelay: {
            type: Number,
            default: 500
        },
        ariaLabel: {
            type: String,
            default: "$t:counterValue"
        },
        ariaDecreaseLabel: {
            type: String,
            default: "$t:decreaseCounter"
        },
        ariaIncreaseLabel: {
            type: String,
            default: "$t:increaseCounter"
        }
    },
    emits: [
        "update:modelValue",
        ...(0, _useValidationJs.u),
        ...createInputEmits(),
        ...createFieldEmits(),
        ...(0, _useFocusJs.a)
    ],
    setup (__props, { expose: __expose, emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const input = (0, _vue.shallowRef)();
        const { min = (0, _vue.ref)(void 0), max = (0, _vue.ref)(void 0), step } = (0, _vue.toRefs)(props);
        const { isFocused, focus, blur } = (0, _useFocusJs.u)(input, emit);
        const { valueComputed: statefulValue } = (0, _useStatefulJs.b)(props, emit);
        function floatify(num) {
            return parseFloat(Number(num).toFixed(10));
        }
        const valueComputed = (0, _vue.computed)({
            get () {
                return statefulValue.value;
            },
            set (v) {
                statefulValue.value = floatify(v);
            }
        });
        const reset = ()=>withoutValidation(()=>{
                emit("update:modelValue", props.clearValue);
                emit("clear");
                resetValidation();
            });
        const { computedError, computedErrorMessages, withoutValidation, resetValidation } = (0, _useValidationJs.a)(props, emit, {
            reset,
            focus,
            value: valueComputed
        });
        const setCountInput = ({ target })=>{
            valueComputed.value = Number(target == null ? void 0 : target.value);
        };
        const setCountChange = ({ target })=>{
            calculateCounterValue(Number(target == null ? void 0 : target.value));
        };
        const getRoundDownWithStep = (value)=>{
            if (typeof min.value === "undefined" || !Number(step.value)) return value;
            return Number(min.value) + Number(step.value) * Math.floor((value - Number(min.value)) / Number(step.value));
        };
        const calculateCounterValue = (counterValue)=>{
            if (typeof min.value !== "undefined" && counterValue < Number(min.value)) {
                valueComputed.value = Number(min.value);
                return;
            }
            if (Number(max.value) && counterValue > Number(max.value)) {
                valueComputed.value = getRoundDownWithStep(Number(max.value));
                return;
            }
            valueComputed.value = getRoundDownWithStep(counterValue);
        };
        const isMinReached = (0, _vue.computed)(()=>{
            if ((0, _vendorJs.i)(min.value)) return false;
            return Number(valueComputed.value) <= Number(min.value);
        });
        const isMaxReached = (0, _vue.computed)(()=>{
            if ((0, _vendorJs.i)(max.value)) return false;
            return step.value ? Number(valueComputed.value) > Number(max.value) - Number(step.value) : Number(valueComputed.value) >= Number(max.value);
        });
        const tabIndexComputed = (0, _vue.computed)(()=>props.disabled ? -1 : 0);
        const isDecreaseActionDisabled = (0, _vue.computed)(()=>isMinReached.value || props.disabled);
        const isIncreaseActionDisabled = (0, _vue.computed)(()=>isMaxReached.value || props.disabled);
        const decreaseCount = ()=>{
            if (isDecreaseActionDisabled.value) return;
            calculateCounterValue(Number(valueComputed.value) - Number(step.value));
        };
        const increaseCount = ()=>{
            if (isIncreaseActionDisabled.value) return;
            calculateCounterValue(Number(valueComputed.value) + Number(step.value));
        };
        (0, _useLongPressJs.u)((0, _useTemplateRefJs.u)("decreaseButtonRef"), {
            onUpdate: decreaseCount,
            delay: (0, _vue.toRef)(props, "longPressDelay")
        });
        (0, _useLongPressJs.u)((0, _useTemplateRefJs.u)("increaseButtonRef"), {
            onUpdate: increaseCount,
            delay: (0, _vue.toRef)(props, "longPressDelay")
        });
        const { getColor } = (0, _useColorsJs.u)();
        const colorComputed = (0, _vue.computed)(()=>getColor(props.color));
        const decreaseIconProps = (0, _vue.computed)(()=>({
                class: {
                    "va-counter__icon--inactive": isDecreaseActionDisabled.value
                },
                color: colorComputed.value,
                icon: props.decreaseIcon,
                plain: true,
                disabled: isDecreaseActionDisabled.value,
                readonly: props.readonly,
                tabindex: -1,
                "aria-label": tp(props.ariaDecreaseLabel),
                ...!isDecreaseActionDisabled.value && {
                    onClick: decreaseCount
                }
            }));
        const increaseIconProps = (0, _vue.computed)(()=>({
                class: {
                    "va-counter__icon--inactive": isIncreaseActionDisabled.value
                },
                color: colorComputed.value,
                icon: props.increaseIcon,
                plain: true,
                disabled: isIncreaseActionDisabled.value,
                readonly: props.readonly,
                tabindex: -1,
                "aria-label": tp(props.ariaIncreaseLabel),
                ...!isIncreaseActionDisabled.value && {
                    onClick: increaseCount
                }
            }));
        const isSquareCorners = (0, _vue.computed)(()=>(typeof props.margins === "string" ? parseFloat(props.margins) : props.margins) === 0);
        const buttonsColor = ()=>{
            if (isFocused.value) return props.color;
            return "background-border";
        };
        const buttonProps = (0, _vue.computed)(()=>({
                ...(0, _vendorJs.p)(props, [
                    "color",
                    "textColor"
                ]),
                round: props.rounded,
                preset: props.flat ? "secondary" : "",
                borderColor: props.flat ? buttonsColor() : ""
            }));
        const decreaseButtonProps = (0, _vue.computed)(()=>({
                ...buttonProps.value,
                icon: props.decreaseIcon,
                disabled: isDecreaseActionDisabled.value,
                "aria-label": tp(props.ariaDecreaseLabel),
                ...!isDecreaseActionDisabled.value && {
                    onClick: decreaseCount
                }
            }));
        const increaseButtonProps = (0, _vue.computed)(()=>({
                ...buttonProps.value,
                icon: props.increaseIcon,
                disabled: isIncreaseActionDisabled.value,
                "aria-label": tp(props.ariaIncreaseLabel),
                ...!isIncreaseActionDisabled.value && {
                    onClick: increaseCount
                }
            }));
        const { tp } = (0, _useTranslationJs.u)();
        const attrs = (0, _vue.useAttrs)();
        const slots = (0, _vue.useSlots)();
        const inputAttributesComputed = (0, _vue.computed)(()=>({
                tabindex: tabIndexComputed.value,
                "aria-label": tp(props.ariaLabel),
                "aria-valuemin": Number(min.value),
                "aria-valuemax": Number(max.value),
                ...(0, _vendorJs.o)(attrs, [
                    "class",
                    "style"
                ]),
                ...(0, _vendorJs.p)(props, [
                    "disabled",
                    "min",
                    "max",
                    "step"
                ]),
                readonly: props.readonly || !props.manualInput
            }));
        const classComputed = (0, _vue.computed)(()=>[
                attrs.class,
                {
                    "va-counter--input-square": isSquareCorners.value
                },
                {
                    "va-counter--content-slot": slots.content && props.buttons
                }
            ].filter(Boolean));
        const styleComputed = (0, _vue.computed)(()=>({
                ...attrs.style || {}
            }));
        const marginComputed = (0, _vue.computed)(()=>(0, _cssJs.s)(props.margins));
        (0, _useCounterPropsValidationJs.u)(props);
        const fieldListeners = createFieldListeners(emit);
        const inputListeners = createInputListeners(emit);
        const inputWrapperPropsComputed = (0, _filterPropsJs.f)(VaInputWrapperProps);
        __expose({
            focus,
            blur,
            decreaseCount,
            increaseCount,
            reset
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), (0, _vue.mergeProps)({
                class: "va-counter"
            }, {
                ...(0, _vue.unref)(fieldListeners),
                ...(0, _vue.unref)(inputWrapperPropsComputed)
            }, {
                class: classComputed.value,
                style: styleComputed.value,
                focused: (0, _vue.unref)(isFocused),
                error: (0, _vue.unref)(computedError),
                "error-messages": (0, _vue.unref)(computedErrorMessages),
                onKeydown: [
                    (0, _vue.withKeys)((0, _vue.withModifiers)(increaseCount, [
                        "prevent"
                    ]), [
                        "up"
                    ]),
                    (0, _vue.withKeys)((0, _vue.withModifiers)(increaseCount, [
                        "prevent"
                    ]), [
                        "right"
                    ]),
                    (0, _vue.withKeys)((0, _vue.withModifiers)(decreaseCount, [
                        "prevent"
                    ]), [
                        "down"
                    ]),
                    (0, _vue.withKeys)((0, _vue.withModifiers)(decreaseCount, [
                        "prevent"
                    ]), [
                        "left"
                    ])
                ]
            }), (0, _vue.createSlots)({
                default: (0, _vue.withCtx)(()=>[
                        !_ctx.$slots.content ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("input", (0, _vue.mergeProps)({
                            key: 0,
                            ref_key: "input",
                            ref: input,
                            class: "va-input__content__input",
                            type: "number",
                            inputmode: "decimal"
                        }, {
                            ...inputAttributesComputed.value,
                            ...(0, _vue.unref)(inputListeners)
                        }, {
                            value: valueComputed.value,
                            "aria-live": _ctx.$props.disabled ? "off" : "polite",
                            onInput: setCountInput,
                            onChange: setCountChange
                        }), null, 16, _hoisted_1)) : (0, _vue.createCommentVNode)("", true)
                    ]),
                _: 2
            }, [
                _ctx.$props.buttons ? {
                    name: "prepend",
                    fn: (0, _vue.withCtx)((slotScope)=>[
                            (0, _vue.createElementVNode)("div", {
                                class: "va-counter__prepend-wrapper",
                                style: (0, _vue.normalizeStyle)({
                                    marginRight: marginComputed.value
                                }),
                                onMousedown: _cache[0] || (_cache[0] = (0, _vue.withModifiers)(//@ts-ignore
                                (...args)=>(0, _vue.unref)(focus) && (0, _vue.unref)(focus)(...args), [
                                    "prevent"
                                ]))
                            }, [
                                (0, _vue.renderSlot)(_ctx.$slots, "decreaseAction", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                    ...slotScope,
                                    decreaseCount
                                })), ()=>[
                                        (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs1.V)), (0, _vue.mergeProps)({
                                            class: "va-counter__button-decrease"
                                        }, decreaseButtonProps.value, {
                                            ref: "decreaseButtonRef"
                                        }), null, 16)
                                    ])
                            ], 36)
                        ]),
                    key: "0"
                } : {
                    name: "prependInner",
                    fn: (0, _vue.withCtx)((slotScope)=>[
                            (0, _vue.createElementVNode)("div", {
                                class: "va-counter__prepend-inner",
                                onMousedown: _cache[1] || (_cache[1] = (0, _vue.withModifiers)(//@ts-ignore
                                (...args)=>(0, _vue.unref)(focus) && (0, _vue.unref)(focus)(...args), [
                                    "prevent"
                                ]))
                            }, [
                                (0, _vue.renderSlot)(_ctx.$slots, "decreaseAction", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                    ...slotScope,
                                    decreaseCount
                                })), ()=>[
                                        (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs1.V)), (0, _vue.mergeProps)(decreaseIconProps.value, {
                                            ref: "decreaseButtonRef"
                                        }), null, 16)
                                    ])
                            ], 32)
                        ]),
                    key: "1"
                },
                _ctx.$props.buttons ? {
                    name: "append",
                    fn: (0, _vue.withCtx)((slotScope)=>[
                            (0, _vue.createElementVNode)("div", {
                                class: "va-counter__append-wrapper",
                                style: (0, _vue.normalizeStyle)({
                                    marginLeft: marginComputed.value
                                }),
                                onMousedown: _cache[2] || (_cache[2] = (0, _vue.withModifiers)(//@ts-ignore
                                (...args)=>(0, _vue.unref)(focus) && (0, _vue.unref)(focus)(...args), [
                                    "prevent"
                                ]))
                            }, [
                                (0, _vue.renderSlot)(_ctx.$slots, "increaseAction", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                    ...slotScope,
                                    increaseCount
                                })), ()=>[
                                        (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs1.V)), (0, _vue.mergeProps)({
                                            class: "va-counter__button-increase"
                                        }, increaseButtonProps.value, {
                                            ref: "increaseButtonRef"
                                        }), null, 16)
                                    ])
                            ], 36)
                        ]),
                    key: "2"
                } : {
                    name: "appendInner",
                    fn: (0, _vue.withCtx)((slotScope)=>[
                            (0, _vue.createElementVNode)("div", {
                                class: "va-counter__append-inner",
                                onMousedown: _cache[3] || (_cache[3] = (0, _vue.withModifiers)(//@ts-ignore
                                (...args)=>(0, _vue.unref)(focus) && (0, _vue.unref)(focus)(...args), [
                                    "prevent"
                                ]))
                            }, [
                                (0, _vue.renderSlot)(_ctx.$slots, "increaseAction", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                    ...slotScope,
                                    increaseCount
                                })), ()=>[
                                        (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs1.V)), (0, _vue.mergeProps)(increaseIconProps.value, {
                                            ref: "increaseButtonRef"
                                        }), null, 16)
                                    ])
                            ], 32)
                        ]),
                    key: "3"
                },
                _ctx.$slots.content ? {
                    name: "default",
                    fn: (0, _vue.withCtx)((slotScope)=>[
                            (0, _vue.createElementVNode)("div", {
                                ref_key: "input",
                                ref: input,
                                tabindex: "0",
                                class: "va-counter__content-wrapper"
                            }, [
                                (0, _vue.renderSlot)(_ctx.$slots, "content", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                    ...slotScope,
                                    value: Number(valueComputed.value)
                                })))
                            ], 512)
                        ]),
                    key: "4"
                } : void 0
            ]), 1040, [
                "class",
                "style",
                "focused",
                "error",
                "error-messages",
                "onKeydown"
            ]);
        };
    }
});

},{"vue":"gzxs9","../../../vendor.js":"l6TAc","../../utils/css.js":"gIe0Y","./hooks/useCounterPropsValidation.js":"8sbTq","../va-input-wrapper/index.js":"7MuId","../va-button/index.js":"2vhcC","../../composables/useFocus.js":"8TBqW","../../composables/useLongPress.js":"hIlWk","../../utils/component-options/extract-component-options.js":"1ODzH","../../composables/useFormField.js":"676Eq","../../composables/useStateful.js":"h9zUi","../../composables/useComponentPreset.js":"2HoaT","../../composables/useClearable.js":"h8vES","../../composables/useValidation.js":"iFHh2","../../composables/useTemplateRef.js":"7NOsO","../../composables/useColors.js":"a4Qgv","../../composables/useTranslation.js":"7S3aV","../../utils/component-options/filter-props.js":"4HycW","../../composables/useEmitProxy.js":"koywY","../../../VaCounter.css":"eUg4E","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gIe0Y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "s", ()=>safeCSSLength);
const safeCSSLength = (length)=>typeof length === "number" ? `${length}px` : length;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8sbTq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useCounterPropsValidation);
var _vue = require("vue");
var _consoleJs = require("../../../utils/console.js");
function useCounterPropsValidation(props) {
    const validateCounterProps = ()=>{
        const val = Number(props.modelValue);
        const max = Number(props.max);
        const min = Number(props.min);
        const step = Number(props.step);
        if (Number.isNaN(val)) {
            (0, _consoleJs.w)("The value is not a number or cannot be reduced to a number.");
            return;
        }
        if (min && max && min > max) (0, _consoleJs.w)(`The maximum value (${max}) can not be less than the minimum value (${min}).`);
        if (min && val < min) (0, _consoleJs.w)(`The value of the counter (${val}) can not be less than the minimum value (${min}).`);
        if (max && val > max) (0, _consoleJs.w)(`The value of the counter (${val}) can not be greater than the maximum value (${max}).`);
        if (min && max && step > max - min) (0, _consoleJs.w)(`The value of the step (${step}) can not be greater than the difference (${max - min}) between maximum value (${max}) and minimum value (${min}).`);
    };
    (0, _vue.watch)([
        ()=>props.step,
        ()=>props.min,
        ()=>props.max
    ], validateCounterProps, {
        immediate: true
    });
}

},{"vue":"gzxs9","../../../utils/console.js":"58L6z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hIlWk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useLongPress);
var _vue = require("vue");
var _useEventJs = require("./useEvent.js");
var _useHTMLElementJs = require("./useHTMLElement.js");
function useLongPress(el, options) {
    let timeoutId = -1;
    let intervalId = -1;
    const handleMouseDown = ()=>{
        var _a;
        (_a = options.onStart) == null || _a.call(options);
        clearTimeout(timeoutId);
        timeoutId = setTimeout(()=>{
            intervalId = setInterval(()=>{
                var _a2;
                return (_a2 = options.onUpdate) == null ? void 0 : _a2.call(options);
            }, options.interval || 100);
        }, (0, _vue.unref)(options.delay) || 500);
    };
    const handleMouseUp = ()=>{
        var _a;
        clearTimeout(timeoutId);
        clearInterval(intervalId);
        (_a = options.onEnd) == null || _a.call(options);
    };
    const htmlElement = (0, _useHTMLElementJs.u)(el);
    (0, _useEventJs.u)([
        "mousedown",
        "touchstart",
        "dragstart"
    ], handleMouseDown, htmlElement);
    (0, _useEventJs.u)([
        "mouseup",
        "mouseleave",
        "touchend",
        "touchcancel",
        "drop",
        "dragend",
        "blur"
    ], handleMouseUp, true);
}

},{"vue":"gzxs9","./useEvent.js":"9kzUn","./useHTMLElement.js":"1Yk4Z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eUg4E":[function() {},{}],"3rH5r":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaDataTable);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaDataTableVueVueTypeScriptSetupTrueLangJs = require("./VaDataTable.vue_vue_type_script_setup_true_lang.js");
const VaDataTable = (0, _withConfigTransportJs.w)((0, _vaDataTableVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaDataTable.vue_vue_type_script_setup_true_lang.js":"6Fyg1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Fyg1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../vendor.js");
var _useColumnsJs = require("./hooks/useColumns.js");
var _usePaginatedRowsJs = require("./hooks/usePaginatedRows.js");
var _useSelectableRowJs = require("./hooks/useSelectableRow.js");
var _useStylableJs = require("./hooks/useStylable.js");
var _useBindingJs = require("./hooks/useBinding.js");
var _useAnimationNameJs = require("./hooks/useAnimationName.js");
var _useRowsJs = require("./hooks/useRows.js");
var _useFilterableJs = require("./hooks/useFilterable.js");
var _useSortableJs = require("./hooks/useSortable.js");
var _useTableScrollJs = require("./hooks/useTableScroll.js");
var _indexJs = require("./components/index.js");
var _indexJs1 = require("../va-virtual-scroller/index.js");
var _indexJs2 = require("../va-inner-loading/index.js");
var _indexJs3 = require("../va-checkbox/index.js");
var _extractComponentOptionsJs = require("../../utils/component-options/extract-component-options.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useThrottleJs = require("../../composables/useThrottle.js");
var _useTranslationJs = require("../../composables/useTranslation.js");
var _filterPropsJs = require("../../utils/component-options/filter-props.js");
var _vaDataTableCss = require("../../../VaDataTable.css");
const _hoisted_1 = {
    key: 0
};
const _hoisted_2 = {
    ref: "list",
    class: "va-data-table__table-tbody"
};
const _hoisted_3 = {
    key: "showNoDataHtml",
    class: "va-data-table__table-tr"
};
const _hoisted_4 = [
    "innerHTML"
];
const _hoisted_5 = {
    key: "showNoDataFilteredHtml",
    class: "va-data-table__table-tr"
};
const _hoisted_6 = [
    "innerHTML"
];
const _hoisted_7 = [
    "onClick",
    "onDblclick",
    "onContextmenu"
];
const _hoisted_8 = {
    key: 0,
    class: "va-data-table__grid-column-header"
};
const VaVirtualScrollerProps = (0, _extractComponentOptionsJs.e)((0, _indexJs1.V), [
    "items",
    "trackBy",
    "horizontal",
    "disabled",
    "table"
]);
const VaDataTableThRowProps = (0, _extractComponentOptionsJs.e)((0, _indexJs.V));
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaDataTable",
    inheritAttrs: false,
    __name: "VaDataTable",
    props: {
        ...(0, _useComponentPresetJs.u),
        ...VaVirtualScrollerProps,
        ...(0, _useAnimationNameJs.u),
        ...(0, _useBindingJs.u),
        ...(0, _useTableScrollJs.u),
        ...(0, _useSortableJs.u),
        ...(0, _useStylableJs.u),
        ...(0, _useColumnsJs.u),
        ...(0, _useFilterableJs.u),
        ...(0, _usePaginatedRowsJs.u),
        ...(0, _useRowsJs.c)(),
        ...(0, _useSelectableRowJs.u),
        ...(0, _useThrottleJs.u),
        ...(0, _vendorJs.p)(VaDataTableThRowProps, [
            "ariaSelectAllRowsLabel",
            "ariaSortColumnByLabel"
        ]),
        hoverable: {
            type: Boolean,
            default: false
        },
        clickable: {
            type: Boolean,
            default: false
        },
        loading: {
            type: Boolean,
            default: false
        },
        loadingColor: {
            type: String,
            default: "primary"
        },
        noDataHtml: {
            type: String,
            default: "No items"
        },
        noDataFilteredHtml: {
            type: String,
            default: "No items match the provided filtering condition"
        },
        hideDefaultHeader: {
            type: Boolean,
            default: false
        },
        footerClone: {
            type: Boolean,
            default: false
        },
        striped: {
            type: Boolean,
            default: false
        },
        virtualScroller: {
            type: Boolean,
            default: false
        },
        virtualTrackBy: {
            type: [
                String,
                Number
            ],
            default: "initialIndex"
        },
        grid: {
            type: Boolean,
            default: false
        },
        gridColumns: {
            type: [
                Number,
                String
            ],
            default: 0
        },
        wrapperSize: {
            type: [
                Number,
                String
            ],
            default: "auto"
        },
        ariaSelectRowLabel: {
            type: String,
            default: "$t:selectRowByIndex"
        }
    },
    emits: [
        "update:modelValue",
        // `modelValue` is selectedItems
        "update:sortBy",
        "update:sortingOrder",
        "filtered",
        "sorted",
        "selectionChange",
        "row:click",
        "row:dblclick",
        "row:contextmenu",
        "columnSorted",
        ...(0, _useTableScrollJs.a)
    ],
    setup (__props, { emit: __emit }) {
        const { tp } = (0, _useTranslationJs.u)();
        const props = __props;
        const emit = __emit;
        const { columnsComputed } = (0, _useColumnsJs.a)(props);
        const { rowsComputed } = (0, _useRowsJs.u)(columnsComputed, props);
        const { filteredRows } = (0, _useFilterableJs.a)(rowsComputed, props, emit);
        const { sortBySync, sortingOrderSync, toggleSorting, sortedRows, sortingOrderIconName } = (0, _useSortableJs.a)(columnsComputed, filteredRows, props, emit);
        const { paginatedRows } = (0, _usePaginatedRowsJs.a)(sortedRows, props);
        const { ctrlSelectRow, shiftSelectRows, toggleBulkSelection, isRowSelected, severalRowsSelected, allRowsSelected, toggleRowSelection } = (0, _useSelectableRowJs.a)(paginatedRows, props, emit);
        const { CSSVariables, getCellCSSVariables, getClass, getStyle } = (0, _useStylableJs.a)(props);
        const { getRowBind, getCellBind } = (0, _useBindingJs.a)(props);
        const animationName = (0, _useAnimationNameJs.a)(props, paginatedRows);
        const showNoDataHtml = (0, _vue.computed)(()=>props.items.length === 0);
        const showNoDataFilteredHtml = (0, _vue.computed)(()=>paginatedRows.value.length === 0);
        const onRowClickHandler = (name, event, row)=>{
            emit(name, {
                event,
                item: row.source,
                itemIndex: row.initialIndex,
                row
            });
            if (props.selectable && props.grid) toggleRowSelection(row);
        };
        const computedTableAttributes = (0, _vue.computed)(()=>({
                ...(0, _vendorJs.o)(attrs, [
                    "class",
                    "style"
                ]),
                class: (0, _vendorJs.p)(props, [
                    "striped",
                    "selectable",
                    "hoverable",
                    "clickable"
                ])
            }));
        const filteredVirtualScrollerProps = (0, _filterPropsJs.f)(VaVirtualScrollerProps);
        const virtualScrollerPropsComputed = (0, _vue.computed)(()=>({
                ...filteredVirtualScrollerProps.value,
                items: paginatedRows.value,
                trackBy: props.virtualTrackBy,
                disabled: !props.virtualScroller,
                table: true
            }));
        const attrs = (0, _vue.useAttrs)();
        const computedAttributes = (0, _vue.computed)(()=>({
                class: [
                    {
                        "va-data-table--sticky": props.stickyHeader || props.stickyFooter
                    },
                    {
                        "va-data-table--scroll": !!props.height
                    },
                    {
                        "va-data-table--virtual-scroller": isVirtualScroll.value
                    },
                    {
                        "va-data-table--grid": props.grid
                    },
                    attrs.class
                ],
                style: [
                    attrs.style
                ],
                ...virtualScrollerPropsComputed.value
            }));
        const filteredThProps = (0, _filterPropsJs.f)(VaDataTableThRowProps);
        const thAttributesComputed = (0, _vue.computed)(()=>({
                ...filteredThProps.value,
                columns: columnsComputed.value,
                sortingOrderIconName: sortingOrderIconName.value,
                severalRowsSelected: severalRowsSelected.value,
                sortingOrderSync: sortingOrderSync.value,
                allRowsSelected: allRowsSelected.value,
                sortBySync: sortBySync.value
            }));
        const { scrollContainer, topTrigger, bottomTrigger, doRenderTopTrigger, doRenderBottomTrigger } = (0, _useTableScrollJs.b)(props, emit);
        const isVirtualScroll = (0, _vue.computed)(()=>props.virtualScroller && !props.grid);
        const gridColumnsCount = (0, _vue.computed)(()=>props.gridColumns || "var(--va-data-table-grid-tbody-columns)");
        const cellData = (cellData2, internalColumnData)=>internalColumnData.displayFormatFn ? internalColumnData.displayFormatFn(cellData2.value) : cellData2.value;
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs1.V)), (0, _vue.mergeProps)({
                class: "va-data-table"
            }, computedAttributes.value, {
                ref_key: "scrollContainer",
                ref: scrollContainer,
                style: `--va-css-variables-selected-color: ${String((0, _vue.unref)(CSSVariables).selectedColor)};--va-css-variables-hover-color: ${String((0, _vue.unref)(CSSVariables).hoverColor)};--va-css-variables-table-height: ${String((0, _vue.unref)(CSSVariables).tableHeight)};--va-css-variables-thead-bg: ${String((0, _vue.unref)(CSSVariables).theadBg)};--va-css-variables-tfoot-bg: ${String((0, _vue.unref)(CSSVariables).tfootBg)};--va-grid-columns-count: ${String(gridColumnsCount.value)}`
            }), {
                content: (0, _vue.withCtx)(({ uniqueKey, renderBuffer, currentListOffset, listStyleComputed, containerStyleComputed })=>[
                        (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs2.V)), {
                            "aria-live": "polite",
                            style: (0, _vue.normalizeStyle)(containerStyleComputed),
                            loading: __props.loading,
                            color: __props.loadingColor
                        }, {
                            default: (0, _vue.withCtx)(()=>[
                                    (0, _vue.unref)(doRenderTopTrigger) ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                        key: 0,
                                        ref_key: "topTrigger",
                                        ref: topTrigger,
                                        class: "va-data-table__scroll-trigger"
                                    }, null, 512)) : (0, _vue.createCommentVNode)("", true),
                                    (0, _vue.createElementVNode)("table", (0, _vue.mergeProps)({
                                        class: "va-data-table__table",
                                        style: listStyleComputed
                                    }, computedTableAttributes.value), [
                                        "colgroup" in _ctx.$slots ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("colgroup", _hoisted_1, [
                                            (0, _vue.renderSlot)(_ctx.$slots, "colgroup", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)((0, _vue.unref)(columnsComputed))))
                                        ])) : (0, _vue.createCommentVNode)("", true),
                                        (0, _vue.createElementVNode)("thead", {
                                            class: (0, _vue.normalizeClass)([
                                                "va-data-table__table-thead",
                                                {
                                                    "va-data-table__table-thead--sticky": _ctx.$props.stickyHeader
                                                }
                                            ]),
                                            style: (0, _vue.normalizeStyle)({
                                                top: isVirtualScroll.value && _ctx.$props.stickyHeader ? `-${currentListOffset}px` : void 0
                                            })
                                        }, [
                                            (0, _vue.renderSlot)(_ctx.$slots, "headerPrepend"),
                                            (0, _vue.renderSlot)(_ctx.$slots, "header", {}, ()=>[
                                                    !__props.hideDefaultHeader ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), (0, _vue.mergeProps)({
                                                        key: 0
                                                    }, thAttributesComputed.value, {
                                                        onToggleBulkSelection: (0, _vue.unref)(toggleBulkSelection),
                                                        onToggleSorting: (0, _vue.unref)(toggleSorting)
                                                    }), (0, _vue.createSlots)({
                                                        _: 2
                                                    }, [
                                                        (0, _vue.renderList)(_ctx.$slots, (_, slot)=>{
                                                            return {
                                                                name: slot,
                                                                fn: (0, _vue.withCtx)((scope)=>[
                                                                        (0, _vue.renderSlot)(_ctx.$slots, slot, (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(scope)))
                                                                    ])
                                                            };
                                                        })
                                                    ]), 1040, [
                                                        "onToggleBulkSelection",
                                                        "onToggleSorting"
                                                    ])) : (0, _vue.createCommentVNode)("", true)
                                                ]),
                                            (0, _vue.renderSlot)(_ctx.$slots, "headerAppend")
                                        ], 6),
                                        (0, _vue.createElementVNode)("tbody", _hoisted_2, [
                                            (0, _vue.renderSlot)(_ctx.$slots, "bodyPrepend"),
                                            (0, _vue.createVNode)((0, _vue.TransitionGroup), {
                                                name: isVirtualScroll.value ? "" : (0, _vue.unref)(animationName),
                                                css: !_ctx.$props.virtualScroller,
                                                appear: !_ctx.$props.virtualScroller
                                            }, {
                                                default: (0, _vue.withCtx)(()=>[
                                                        showNoDataHtml.value ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("tr", _hoisted_3, [
                                                            (0, _vue.createElementVNode)("td", {
                                                                class: "va-data-table__table-td no-data",
                                                                colspan: "99999",
                                                                innerHTML: __props.noDataHtml
                                                            }, null, 8, _hoisted_4)
                                                        ])) : showNoDataFilteredHtml.value ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("tr", _hoisted_5, [
                                                            (0, _vue.createElementVNode)("td", {
                                                                class: "va-data-table__table-td no-data",
                                                                colspan: "99999",
                                                                innerHTML: __props.noDataFilteredHtml
                                                            }, null, 8, _hoisted_6)
                                                        ])) : (0, _vue.createCommentVNode)("", true),
                                                        ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)(renderBuffer, (row, index)=>{
                                                            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                                                                key: `table-row_${uniqueKey(row, index)}`
                                                            }, [
                                                                (0, _vue.createElementVNode)("tr", (0, _vue.mergeProps)({
                                                                    class: [
                                                                        "va-data-table__table-tr",
                                                                        [
                                                                            {
                                                                                selected: (0, _vue.unref)(isRowSelected)(row),
                                                                                "va-data-table__table-tr--expanded": row.isExpandableRowVisible
                                                                            }
                                                                        ]
                                                                    ]
                                                                }, (0, _vue.unref)(getRowBind)(row), {
                                                                    onClick: ($event)=>onRowClickHandler("row:click", $event, row),
                                                                    onDblclick: ($event)=>onRowClickHandler("row:dblclick", $event, row),
                                                                    onContextmenu: ($event)=>onRowClickHandler("row:contextmenu", $event, row)
                                                                }), [
                                                                    _ctx.selectable && !_ctx.$props.grid ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("td", {
                                                                        class: "va-data-table__table-td va-data-table__table-cell-select",
                                                                        key: `selectable_${uniqueKey(row, index)}`,
                                                                        onSelectstart: _cache[0] || (_cache[0] = (0, _vue.withModifiers)(()=>{}, [
                                                                            "prevent"
                                                                        ]))
                                                                    }, [
                                                                        (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs3.V)), {
                                                                            class: "va-data-table__table-cell-checkbox",
                                                                            "model-value": (0, _vue.unref)(isRowSelected)(row),
                                                                            color: _ctx.selectedColor,
                                                                            "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaSelectRowLabel, {
                                                                                index: row.initialIndex
                                                                            }),
                                                                            onClick: [
                                                                                (0, _vue.withModifiers)(($event)=>(0, _vue.unref)(shiftSelectRows)(row), [
                                                                                    "shift",
                                                                                    "exact",
                                                                                    "stop"
                                                                                ]),
                                                                                (0, _vue.withModifiers)(($event)=>(0, _vue.unref)(ctrlSelectRow)(row), [
                                                                                    "ctrl",
                                                                                    "exact",
                                                                                    "stop"
                                                                                ]),
                                                                                (0, _vue.withModifiers)(($event)=>(0, _vue.unref)(ctrlSelectRow)(row), [
                                                                                    "exact",
                                                                                    "stop"
                                                                                ])
                                                                            ]
                                                                        }, null, 8, [
                                                                            "model-value",
                                                                            "color",
                                                                            "aria-label",
                                                                            "onClick"
                                                                        ])
                                                                    ], 32)) : (0, _vue.createCommentVNode)("", true),
                                                                    ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)(row.cells, (cell, cellIndex)=>{
                                                                        return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("td", (0, _vue.mergeProps)({
                                                                            key: `table-cell_${cell.column.name + cell.rowIndex}`,
                                                                            class: [
                                                                                "va-data-table__table-td",
                                                                                (0, _vue.unref)(getClass)(cell.column.tdClass)
                                                                            ],
                                                                            style: [
                                                                                cell.column.width ? {
                                                                                    minWidth: cell.column.width,
                                                                                    maxWidth: cell.column.width
                                                                                } : {},
                                                                                (0, _vue.unref)(getCellCSSVariables)(cell),
                                                                                (0, _vue.unref)(getStyle)(cell.column.tdStyle)
                                                                            ]
                                                                        }, (0, _vue.unref)(getCellBind)(cell, row)), [
                                                                            `cell(${cell.column.name})` in _ctx.$slots ? (0, _vue.renderSlot)(_ctx.$slots, `cell(${cell.column.name})`, (0, _vue.normalizeProps)((0, _vue.mergeProps)({
                                                                                key: 0
                                                                            }, {
                                                                                ...cell,
                                                                                row,
                                                                                isExpanded: row.isExpandableRowVisible
                                                                            }))) : (0, _vue.renderSlot)(_ctx.$slots, "cell", (0, _vue.normalizeProps)((0, _vue.mergeProps)({
                                                                                key: 1
                                                                            }, {
                                                                                cell,
                                                                                row
                                                                            })), ()=>[
                                                                                    _ctx.$props.grid ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("span", _hoisted_8, (0, _vue.toDisplayString)((0, _vue.unref)(columnsComputed)[cellIndex].label), 1)) : (0, _vue.createCommentVNode)("", true),
                                                                                    (0, _vue.createTextVNode)(" " + (0, _vue.toDisplayString)(cellData(cell, (0, _vue.unref)(columnsComputed)[cellIndex])), 1)
                                                                                ])
                                                                        ], 16);
                                                                    }), 128))
                                                                ], 16, _hoisted_7),
                                                                row.isExpandableRowVisible ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("td", {
                                                                    class: "va-data-table__table-expanded-content",
                                                                    colspan: "99999",
                                                                    key: uniqueKey(row, index)
                                                                }, [
                                                                    (0, _vue.renderSlot)(_ctx.$slots, "expandableRow", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(row)))
                                                                ])) : (0, _vue.createCommentVNode)("", true)
                                                            ], 64);
                                                        }), 128))
                                                    ]),
                                                _: 2
                                            }, 1032, [
                                                "name",
                                                "css",
                                                "appear"
                                            ]),
                                            (0, _vue.renderSlot)(_ctx.$slots, "bodyAppend")
                                        ], 512),
                                        _ctx.$slots.footer || __props.footerClone && !_ctx.$props.grid ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("tfoot", {
                                            key: 1,
                                            class: (0, _vue.normalizeClass)([
                                                "va-data-table__table-tfoot",
                                                {
                                                    "va-data-table__table-tfoot--sticky": _ctx.$props.stickyFooter
                                                }
                                            ]),
                                            style: (0, _vue.normalizeStyle)({
                                                bottom: isVirtualScroll.value && _ctx.$props.stickyFooter ? `${currentListOffset}px` : void 0
                                            })
                                        }, [
                                            (0, _vue.renderSlot)(_ctx.$slots, "footerPrepend"),
                                            (0, _vue.renderSlot)(_ctx.$slots, "footer", {}, ()=>[
                                                    !__props.hideDefaultHeader ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), (0, _vue.mergeProps)({
                                                        key: 0
                                                    }, thAttributesComputed.value, {
                                                        "is-footer": "",
                                                        onToggleBulkSelection: (0, _vue.unref)(toggleBulkSelection),
                                                        onToggleSorting: (0, _vue.unref)(toggleSorting)
                                                    }), (0, _vue.createSlots)({
                                                        _: 2
                                                    }, [
                                                        (0, _vue.renderList)(_ctx.$slots, (_, slot)=>{
                                                            return {
                                                                name: slot,
                                                                fn: (0, _vue.withCtx)((scope)=>[
                                                                        (0, _vue.renderSlot)(_ctx.$slots, slot, (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(scope)))
                                                                    ])
                                                            };
                                                        })
                                                    ]), 1040, [
                                                        "onToggleBulkSelection",
                                                        "onToggleSorting"
                                                    ])) : (0, _vue.createCommentVNode)("", true)
                                                ]),
                                            (0, _vue.renderSlot)(_ctx.$slots, "footerAppend")
                                        ], 6)) : (0, _vue.createCommentVNode)("", true)
                                    ], 16),
                                    (0, _vue.unref)(doRenderBottomTrigger) ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                        key: 1,
                                        ref_key: "bottomTrigger",
                                        ref: bottomTrigger,
                                        class: "va-data-table__scroll-trigger"
                                    }, null, 512)) : (0, _vue.createCommentVNode)("", true)
                                ]),
                            _: 2
                        }, 1032, [
                            "style",
                            "loading",
                            "color"
                        ])
                    ]),
                _: 3
            }, 16, [
                "style"
            ]);
        };
    }
});

},{"vue":"gzxs9","../../../vendor.js":"l6TAc","./hooks/useColumns.js":"97pKl","./hooks/usePaginatedRows.js":"ZKPnp","./hooks/useSelectableRow.js":"dqz9a","./hooks/useStylable.js":"1JTRD","./hooks/useBinding.js":"M6BWY","./hooks/useAnimationName.js":"ewHlj","./hooks/useRows.js":"8biUf","./hooks/useFilterable.js":"bJ6gP","./hooks/useSortable.js":"5cage","./hooks/useTableScroll.js":"bRMII","./components/index.js":"8cUCu","../va-virtual-scroller/index.js":"cvrbR","../va-inner-loading/index.js":"9vecB","../va-checkbox/index.js":"w8J04","../../utils/component-options/extract-component-options.js":"1ODzH","../../composables/useComponentPreset.js":"2HoaT","../../composables/useThrottle.js":"8b3Ic","../../composables/useTranslation.js":"7S3aV","../../utils/component-options/filter-props.js":"4HycW","../../../VaDataTable.css":"fYZus","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"97pKl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useColumns);
parcelHelpers.export(exports, "u", ()=>useColumnsProps);
var _vue = require("vue");
var _vendorJs = require("../../../../vendor.js");
var _useCommonPropsJs = require("./useCommonProps.js");
var _consoleJs = require("../../../utils/console.js");
const sortingOptionsValidator = (options)=>{
    const isAllowedOptionsLength = options.length === 2 || options.length === 3;
    const isAvailableOptions = options.every((option)=>[
            "asc",
            "desc",
            null
        ].includes(option));
    const isUniqueOptions = options.length === new Set(options).size;
    return isAllowedOptionsLength && isAvailableOptions && isUniqueOptions;
};
const useColumnsProps = {
    ...(0, _useCommonPropsJs.c)(),
    columns: {
        type: Array,
        default: ()=>[]
    },
    sortingOptions: {
        type: Array,
        default: ()=>[
                "asc",
                "desc",
                null
            ],
        validator: sortingOptionsValidator
    }
};
const buildTableColumn = (source, initialIndex, props)=>{
    const input = typeof source === "string" ? {
        key: source
    } : source;
    const isValidOptions = input.sortingOptions ? sortingOptionsValidator(input.sortingOptions) : true;
    if (!isValidOptions) (0, _consoleJs.w)(`The "sortingOptions" array in the column with "${input.key}" key is invalid. For this column, the "sortingOptions" value is taken as for the table: ${JSON.stringify(props.sortingOptions)}.`);
    return {
        source,
        initialIndex,
        key: input.key,
        name: input.name || input.key,
        label: input.label || (0, _vendorJs.s)(input.key),
        thTitle: input.thTitle || input.headerTitle || input.label || (0, _vendorJs.s)(input.key),
        sortable: input.sortable || false,
        sortingFn: input.sortingFn,
        displayFormatFn: input.displayFormatFn,
        sortingOptions: isValidOptions && input.sortingOptions || props.sortingOptions,
        thAlign: input.thAlign || input.alignHead || "left",
        thVerticalAlign: input.thVerticalAlign || input.verticalAlignHead || "middle",
        tdAlign: input.tdAlign || input.align || "left",
        tdVerticalAlign: input.tdVerticalAlign || input.verticalAlign || "middle",
        width: input.width,
        tdClass: input.tdClass || input.classes,
        thClass: input.thClass || input.headerClasses,
        tdStyle: input.tdStyle || input.style,
        thStyle: input.thStyle || input.headerStyle
    };
};
const buildColumnsFromItems = (props)=>{
    return Object.keys((0, _vendorJs.m)({}, ...props.items)).map((item, index)=>buildTableColumn(item, index, props));
};
const buildNormalizedColumns = (props)=>{
    return props.columns.map((item, index)=>buildTableColumn(item, index, props));
};
const useColumns = (props)=>{
    const columnsComputed = (0, _vue.computed)(()=>{
        if (props.columns.length === 0) return buildColumnsFromItems(props);
        else return buildNormalizedColumns(props);
    });
    return {
        columnsComputed
    };
};

},{"vue":"gzxs9","../../../../vendor.js":"l6TAc","./useCommonProps.js":"f3wHu","../../../utils/console.js":"58L6z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f3wHu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useItemsTrackByProp);
parcelHelpers.export(exports, "b", ()=>useSelectableProp);
parcelHelpers.export(exports, "c", ()=>createItemsProp);
parcelHelpers.export(exports, "u", ()=>useCurrentPageProp);
const useCurrentPageProp = {
    currentPage: {
        type: Number
    }
};
const createItemsProp = ()=>({
        items: {
            type: Array,
            default: ()=>[]
        }
    });
const useSelectableProp = {
    selectable: {
        type: Boolean,
        default: false
    }
};
const useItemsTrackByProp = {
    itemsTrackBy: {
        type: [
            String,
            Function
        ],
        default: ""
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ZKPnp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>usePaginatedRows);
parcelHelpers.export(exports, "u", ()=>usePaginatedRowsProps);
var _vue = require("vue");
var _useCommonPropsJs = require("./useCommonProps.js");
var _useThrottleJs = require("../../../composables/useThrottle.js");
const usePaginatedRowsProps = {
    ...(0, _useThrottleJs.u),
    ...(0, _useCommonPropsJs.u),
    perPage: {
        type: Number
    }
};
const usePaginatedRows = (sortedRows, props)=>{
    const paginatedRows = (0, _vue.computed)(()=>{
        if (!props.perPage || props.perPage < 0) return sortedRows.value;
        if (!props.currentPage || props.currentPage < 0) return sortedRows.value.slice(0, props.perPage);
        const pageStartIndex = props.perPage * (props.currentPage - 1);
        return sortedRows.value.slice(pageStartIndex, pageStartIndex + props.perPage);
    });
    const paginatedRowsThrottled = (0, _useThrottleJs.a)(paginatedRows, props);
    return {
        paginatedRows: paginatedRowsThrottled
    };
};

},{"vue":"gzxs9","./useCommonProps.js":"f3wHu","../../../composables/useThrottle.js":"8b3Ic","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8b3Ic":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useThrottleValue);
parcelHelpers.export(exports, "b", ()=>useThrottleFunction);
parcelHelpers.export(exports, "u", ()=>useThrottleProps);
var _vue = require("vue");
const useThrottleProps = {
    delay: {
        type: Number,
        default: 0,
        validator: (value)=>value >= 0
    }
};
function useThrottleFunction(fn, props) {
    const delay = (0, _vue.toRef)(props, "delay") ?? 0;
    const isThrottled = (0, _vue.ref)(true);
    let lastCallResult = void 0;
    return function(...args) {
        const invoke = ()=>fn.apply(this, args);
        if (!(0, _vue.unref)(delay)) return invoke();
        if (isThrottled.value) {
            isThrottled.value = false;
            setTimeout(()=>isThrottled.value = true, (0, _vue.unref)(delay));
            lastCallResult = invoke();
        }
        return lastCallResult;
    };
}
function useThrottleValue(value, props) {
    const delay = (0, _vue.toRef)(props, "delay") ?? 0;
    if (!(0, _vue.unref)(delay)) return value;
    const isThrottled = (0, _vue.ref)(true);
    const previousCallValue = (0, _vue.ref)();
    const previousReturnedValue = (0, _vue.ref)();
    const currentCallValue = (0, _vue.ref)();
    (0, _vue.watch)(value, ()=>{
        previousCallValue.value = value.value;
        const lastCallValue = setTimeout(()=>{
            currentCallValue.value = previousCallValue.value;
        }, (0, _vue.unref)(delay));
        if (isThrottled.value) {
            isThrottled.value = false;
            currentCallValue.value = value.value;
            previousReturnedValue.value = value.value;
            clearTimeout(lastCallValue);
            setTimeout(()=>isThrottled.value = true, (0, _vue.unref)(delay));
        } else currentCallValue.value = previousReturnedValue.value;
    }, {
        immediate: true
    });
    return currentCallValue;
}

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dqz9a":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useSelectableRow);
parcelHelpers.export(exports, "u", ()=>useSelectableProps);
var _vue = require("vue");
var _useRowsJs = require("./useRows.js");
var _useCommonPropsJs = require("./useCommonProps.js");
const useSelectableProps = {
    ...(0, _useCommonPropsJs.b),
    ...(0, _useCommonPropsJs.a),
    modelValue: {
        type: Array
    },
    selectMode: {
        type: String,
        default: "multiple"
    }
};
const useSelectableRow = (paginatedRows, props, emit)=>{
    const selectedItemsFallback = (0, _vue.ref)([]);
    const selectedItemsSync = (0, _vue.computed)({
        get () {
            if (props.modelValue === void 0) return selectedItemsFallback.value;
            else return props.modelValue;
        },
        set (modelValue) {
            if (props.modelValue === void 0) selectedItemsFallback.value = modelValue;
            emit("update:modelValue", modelValue);
        }
    });
    const prevSelectedRowIndex = (0, _vue.ref)(-1);
    (0, _vue.watch)(()=>props.selectMode, (newSelectMode, oldSelectMode)=>{
        if (newSelectMode === "single" && oldSelectMode === "multiple") {
            selectedItemsSync.value = [];
            setPrevSelectedRowIndex(-1);
        }
    });
    (0, _vue.watch)(paginatedRows, ()=>{
        setPrevSelectedRowIndex(-1);
    });
    (0, _vue.watch)(selectedItemsSync, (currentSelectedItems, previousSelectedItems = [])=>{
        emit("selectionChange", {
            currentSelectedItems,
            previousSelectedItems
        });
    }, {
        immediate: true
    });
    const getKey = (source)=>(0, _useRowsJs.g)(source, props.itemsTrackBy);
    const noRowsSelected = (0, _vue.computed)(()=>!paginatedRows.value.some(({ source })=>selectedItemsSync.value.includes(getKey(source))));
    const allRowsSelected = (0, _vue.computed)(()=>{
        if (paginatedRows.value.length === 0) return false;
        return paginatedRows.value.every(({ source })=>selectedItemsSync.value.includes(getKey(source)));
    });
    const severalRowsSelected = (0, _vue.computed)(()=>!noRowsSelected.value && !allRowsSelected.value);
    function isRowSelected(row) {
        return selectedItemsSync.value.includes(getKey(row.source));
    }
    function selectAllRows() {
        selectedItemsSync.value = [
            .../* @__PURE__ */ new Set([
                ...selectedItemsSync.value,
                ...paginatedRows.value.map((row)=>getKey(row.source))
            ])
        ];
    }
    function unselectAllRows() {
        const paginatedRowsKeys = paginatedRows.value.map((row)=>getKey(row.source));
        selectedItemsSync.value = selectedItemsSync.value.filter((item)=>!paginatedRowsKeys.includes(item));
    }
    function selectRow(row) {
        selectedItemsSync.value = [
            ...selectedItemsSync.value,
            getKey(row.source)
        ];
    }
    function selectOnlyRow(row) {
        selectedItemsSync.value = [
            getKey(row.source)
        ];
    }
    function unselectRow(row) {
        const index = selectedItemsSync.value.findIndex((item)=>item === getKey(row.source));
        selectedItemsSync.value = [
            ...selectedItemsSync.value.slice(0, index),
            ...selectedItemsSync.value.slice(index + 1)
        ];
    }
    function setPrevSelectedRowIndex(rowInitialIndex) {
        if (rowInitialIndex === -1) prevSelectedRowIndex.value = -1;
        else {
            const prevSelectedRow = paginatedRows.value.find((row)=>row.initialIndex === rowInitialIndex);
            prevSelectedRow ? prevSelectedRowIndex.value = paginatedRows.value.indexOf(prevSelectedRow) : prevSelectedRowIndex.value = -1;
        }
    }
    function getRowsToSelect(targetIndex) {
        let start;
        let end;
        if (isRowSelected(paginatedRows.value[prevSelectedRowIndex.value])) {
            start = Math.min(prevSelectedRowIndex.value, targetIndex);
            end = Math.max(prevSelectedRowIndex.value, targetIndex);
        } else {
            start = Math.min(prevSelectedRowIndex.value + 1, targetIndex);
            end = Math.max(prevSelectedRowIndex.value - 1, targetIndex);
        }
        return paginatedRows.value.slice(start, end + 1);
    }
    function mergeSelection(rowsToSelect) {
        const rowsToSelectedItems = rowsToSelect.map((row)=>getKey(row.source));
        if (noRowsSelected.value) {
            selectedItemsSync.value = rowsToSelectedItems;
            return;
        }
        const isInternalSelection = rowsToSelectedItems.every((item)=>selectedItemsSync.value.includes(item));
        if (isInternalSelection) {
            selectedItemsSync.value = selectedItemsSync.value.filter((item)=>!rowsToSelectedItems.includes(item));
            return;
        }
        selectedItemsSync.value = [
            .../* @__PURE__ */ new Set([
                ...selectedItemsSync.value,
                ...rowsToSelectedItems
            ])
        ];
    }
    function toggleRowSelection(row) {
        if (!props.selectable) return;
        if (isRowSelected(row)) {
            unselectRow(row);
            props.selectMode === "single" ? setPrevSelectedRowIndex(-1) : setPrevSelectedRowIndex(row.initialIndex);
        } else {
            props.selectMode === "single" ? selectOnlyRow(row) : selectRow(row);
            setPrevSelectedRowIndex(row.initialIndex);
        }
    }
    function ctrlSelectRow(row) {
        if (!props.selectable) return;
        toggleRowSelection(row);
    }
    function shiftSelectRows(row) {
        if (!props.selectable) return;
        if (props.selectMode === "single" || prevSelectedRowIndex.value === -1) return toggleRowSelection(row);
        const targetIndex = paginatedRows.value.indexOf(row);
        mergeSelection(getRowsToSelect(targetIndex));
        setPrevSelectedRowIndex(-1);
    }
    function toggleBulkSelection() {
        if (allRowsSelected.value) unselectAllRows();
        else selectAllRows();
        setPrevSelectedRowIndex(-1);
    }
    return {
        ctrlSelectRow,
        shiftSelectRows,
        toggleRowSelection,
        toggleBulkSelection,
        isRowSelected,
        noRowsSelected,
        severalRowsSelected,
        allRowsSelected
    };
};

},{"vue":"gzxs9","./useRows.js":"8biUf","./useCommonProps.js":"f3wHu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8biUf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "c", ()=>createRowsProps);
parcelHelpers.export(exports, "g", ()=>getItemKey);
parcelHelpers.export(exports, "u", ()=>useRows);
var _vue = require("vue");
var _useCommonPropsJs = require("./useCommonProps.js");
var _valueByKeyJs = require("../../../utils/value-by-key.js");
const getItemKey = (source, itemsTrackBy)=>typeof itemsTrackBy === "function" ? itemsTrackBy(source) : (0, _valueByKeyJs.g)(source, itemsTrackBy) || source;
const createRowsProps = ()=>({
        ...(0, _useCommonPropsJs.c)(),
        ...(0, _useCommonPropsJs.a)
    });
const buildTableCell = (rowIndex, rowKey, rowData, column)=>{
    var _a;
    const source = (0, _valueByKeyJs.g)(rowData, column.key);
    return {
        rowIndex,
        rowKey,
        rowData,
        column,
        source,
        value: ((_a = source == null ? void 0 : source.toString) == null ? void 0 : _a.call(source)) || ""
    };
};
const buildTableRow = (source, initialIndex, itemsTrackBy, columns)=>{
    const itemKey = getItemKey(source, itemsTrackBy);
    return {
        initialIndex,
        itemKey,
        source,
        cells: columns.map((column)=>buildTableCell(initialIndex, itemKey, source, column)),
        rowData: source
    };
};
const useRows = (columns, props)=>{
    const expandableRows = (0, _vue.ref)({});
    const rowsComputed = (0, _vue.computed)(()=>props.items.map((rawItem, index)=>({
                ...buildTableRow(rawItem, index, props.itemsTrackBy, columns.value),
                toggleRowDetails: (show)=>{
                    if (typeof show === "boolean") expandableRows.value[index] = show;
                    else expandableRows.value[index] = !expandableRows.value[index];
                },
                isExpandableRowVisible: !!expandableRows.value[index]
            })));
    return {
        rowsComputed
    };
};

},{"vue":"gzxs9","./useCommonProps.js":"f3wHu","../../../utils/value-by-key.js":"aZDG9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1JTRD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useStylable);
parcelHelpers.export(exports, "u", ()=>useStylableProps);
var _vue = require("vue");
var _cssJs = require("../../../utils/css.js");
var _useCommonPropsJs = require("./useCommonProps.js");
var _useColorsJs = require("../../../composables/useColors.js");
const prefix = "--va-data-table";
const isFunction = (val)=>typeof val === "function";
const useStylableProps = {
    ...(0, _useCommonPropsJs.b),
    selectedColor: {
        type: String,
        default: "primary"
    },
    allowFooterSorting: {
        type: Boolean,
        default: false
    },
    stickyHeader: {
        type: Boolean,
        default: false
    },
    stickyFooter: {
        type: Boolean,
        default: false
    },
    height: {
        type: [
            String,
            Number
        ]
    }
};
const getClass = (classes)=>isFunction(classes) ? classes() : classes;
const getStyle = (styles)=>isFunction(styles) ? styles() : styles;
const useStylable = (props)=>{
    const { getColor, getFocusColor, getHoverColor } = (0, _useColorsJs.u)();
    const color = (0, _vue.computed)(()=>getColor(props.selectedColor));
    const CSSVariables = (0, _vue.computed)(()=>({
            hoverColor: getHoverColor(color.value),
            selectedColor: props.selectable ? getFocusColor(color.value) : void 0,
            tableHeight: props.height ? (0, _cssJs.s)(props.height) : "var(--va-data-table-height)",
            theadBg: props.stickyHeader ? "var(--va-data-table-thead-background, var(--va-data-table-header-background))" : "var(--va-data-table-thead-background)",
            tfootBg: props.stickyFooter ? "var(--va-data-table-tfoot-background, var(--va-data-table-header-background))" : "var(--va-data-table-tfoot-background)"
        }));
    const getHeaderCSSVariables = (column)=>({
            [`${prefix}-width`]: column.width && (0, _cssJs.s)(column.width),
            [`${prefix}-align`]: column.thAlign,
            [`${prefix}-vertical-align`]: column.thVerticalAlign,
            [`${prefix}-cursor`]: column.sortable ? "pointer" : "default"
        });
    const getCellCSSVariables = (cell)=>({
            [`${prefix}-align`]: cell.column.tdAlign,
            [`${prefix}-vertical-align`]: cell.column.tdVerticalAlign
        });
    const getFooterCSSVariables = (column)=>({
            [`${prefix}-align`]: column.thAlign,
            [`${prefix}-vertical-align`]: column.thVerticalAlign,
            [`${prefix}-cursor`]: props.allowFooterSorting && column.sortable ? "pointer" : "default"
        });
    return {
        CSSVariables,
        getHeaderCSSVariables,
        getCellCSSVariables,
        getFooterCSSVariables,
        getClass,
        getStyle
    };
};

},{"vue":"gzxs9","../../../utils/css.js":"gIe0Y","./useCommonProps.js":"f3wHu","../../../composables/useColors.js":"a4Qgv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"M6BWY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useBinding);
parcelHelpers.export(exports, "u", ()=>useBindingProps);
const isFunction = (val)=>typeof val === "function";
const isObject = (val)=>val !== null && typeof val === "object";
const useBindingProps = {
    rowBind: {
        type: null
    },
    cellBind: {
        type: null
    }
};
const useBinding = (props)=>{
    const getRowBind = (row)=>isFunction(props.rowBind) ? props.rowBind(row.source, row.initialIndex) : isObject(props.rowBind) ? props.rowBind : {};
    const getCellBind = (cell, row)=>isFunction(props.cellBind) ? props.cellBind(cell.source, row.source, cell.column, row.initialIndex) : isObject(props.cellBind) ? props.cellBind : {};
    return {
        getRowBind,
        getCellBind
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ewHlj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useAnimationName);
parcelHelpers.export(exports, "u", ()=>useAnimationNameProps);
var _vue = require("vue");
var _useCommonPropsJs = require("./useCommonProps.js");
const useAnimationNameProps = {
    ...(0, _useCommonPropsJs.u),
    animated: {
        type: Boolean,
        default: true
    }
};
const useAnimationName = (props, rows)=>{
    const animationType = (0, _vue.ref)("shuffle");
    const animationName = (0, _vue.computed)(()=>props.animated ? `table-transition-${animationType.value}` : "");
    const oldRowsLength = (0, _vue.ref)(rows.value.length);
    const isDifferentRowLength = (0, _vue.computed)(()=>rows.value.length !== oldRowsLength.value);
    (0, _vue.watch)(rows, (newRows, oldRows)=>{
        const hasRows = !!(newRows.length && oldRows.length);
        animationType.value = newRows.length > 50 || isDifferentRowLength.value && hasRows ? "fade" : "shuffle";
        oldRowsLength.value = newRows.length;
    });
    (0, _vue.watch)(()=>props.currentPage, ()=>{
        if (!isDifferentRowLength.value) animationType.value = "shuffle";
    });
    return animationName;
};

},{"vue":"gzxs9","./useCommonProps.js":"f3wHu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bJ6gP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useFilterable);
parcelHelpers.export(exports, "u", ()=>useFilterableProps);
var _vue = require("vue");
var _useThrottleJs = require("../../../composables/useThrottle.js");
const useFilterableProps = {
    ...(0, _useThrottleJs.u),
    filter: {
        type: String,
        default: ""
    },
    filterMethod: {
        type: Function
    }
};
const useFilterable = (rawRows, props, emit)=>{
    const filteredRows = (0, _vue.computed)(()=>{
        if (!rawRows.value.length) return rawRows.value;
        if (props.filter === "" && !props.filterMethod) return rawRows.value;
        return rawRows.value.filter((row)=>row.cells.some((cell)=>{
                if (typeof props.filterMethod === "function") return props.filterMethod(cell.source, cell);
                const cellRegex = new RegExp(props.filter, "i");
                return cellRegex.test(cell.value);
            }));
    });
    const filteredRowsThrottled = (0, _useThrottleJs.a)(filteredRows, props);
    (0, _vue.watch)(filteredRowsThrottled, ()=>{
        emit("filtered", {
            items: filteredRowsThrottled.value.map((row)=>row.source),
            itemsIndexes: filteredRowsThrottled.value.map((row)=>row.initialIndex)
        });
    });
    if (filteredRows.value.length !== rawRows.value.length) emit("filtered", {
        items: filteredRows.value.map((row)=>row.source),
        itemsIndexes: filteredRows.value.map((row)=>row.initialIndex)
    });
    return {
        filteredRows: filteredRowsThrottled
    };
};

},{"vue":"gzxs9","../../../composables/useThrottle.js":"8b3Ic","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5cage":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useSortable);
parcelHelpers.export(exports, "u", ()=>useSortableProps);
var _vue = require("vue");
var _useThrottleJs = require("../../../composables/useThrottle.js");
const useSortableProps = {
    ...(0, _useThrottleJs.u),
    sortBy: {
        type: String
    },
    columnSorted: {
        type: Object
    },
    sortingOrder: {
        type: [
            String,
            null
        ]
    },
    disableClientSideSorting: {
        type: Boolean,
        default: false
    }
};
const useSortable = (columns, filteredRows, props, emit)=>{
    const sortByFallback = (0, _vue.ref)("");
    const sortBySync = (0, _vue.computed)({
        get () {
            if (props.sortBy === void 0) return sortByFallback.value;
            else return props.sortBy;
        },
        set (value) {
            if (props.sortBy === void 0) sortByFallback.value = value;
            emit("update:sortBy", value);
        }
    });
    const sortingOrderFallback = (0, _vue.ref)(null);
    const sortingOrderSync = (0, _vue.computed)({
        get () {
            if (props.sortingOrder === void 0) return sortingOrderFallback.value;
            else return props.sortingOrder;
        },
        set (value) {
            if (props.sortingOrder === void 0) sortingOrderFallback.value = value;
            emit("update:sortingOrder", value);
        }
    });
    const defaultSortingFn = (a, b)=>{
        if (typeof a === "string" && typeof b === "string") return a.localeCompare(b);
        if (typeof a === "number" && typeof b === "number") return a - b;
        const aParsed = parseFloat(a);
        const bParsed = parseFloat(b);
        if (!isNaN(aParsed) && !isNaN(bParsed)) return aParsed - bParsed;
        if (!isNaN(aParsed)) return -1;
        if (!isNaN(bParsed)) return 1;
        return 0;
    };
    const sortedRows = (0, _vue.computed)(()=>{
        if (props.disableClientSideSorting) return filteredRows.value;
        if (filteredRows.value.length <= 1) return filteredRows.value;
        const columnIndex = columns.value.findIndex(({ name, sortable })=>sortBySync.value === name && sortable);
        const column = columns.value[columnIndex];
        if (!column) return filteredRows.value;
        const sortingOrderRatio = sortingOrderSync.value === "desc" ? -1 : 1;
        return [
            ...filteredRows.value
        ].sort((a, b)=>{
            if (sortingOrderSync.value === null) return a.initialIndex - b.initialIndex;
            else {
                const firstSource = a.cells[columnIndex].source;
                const secondSource = b.cells[columnIndex].source;
                return sortingOrderRatio * (typeof column.sortingFn === "function" ? column.sortingFn(firstSource, secondSource) : defaultSortingFn(firstSource, secondSource));
            }
        });
    });
    (0, _vue.watch)(sortedRows, ()=>{
        emit("sorted", {
            sortBy: sortBySync.value,
            sortingOrder: sortingOrderSync.value,
            items: sortedRows.value.map((row)=>row.source),
            itemsIndexes: sortedRows.value.map((row)=>row.initialIndex)
        });
    });
    const getNextSortingOptionsValue = (value, options)=>{
        const index = options.findIndex((sortingValue)=>sortingValue === value);
        return index !== -1 ? options[(index + 1) % options.length] : options[0];
    };
    function toggleSorting(column) {
        let value;
        if (column.name === sortBySync.value) value = getNextSortingOptionsValue(sortingOrderSync.value, column.sortingOptions);
        else {
            sortBySync.value = column.name;
            value = column.sortingOptions[0];
        }
        sortingOrderSync.value = value;
        emit("columnSorted", {
            columnName: column.name,
            value,
            column
        });
    }
    const toggleSortingThrottled = (0, _useThrottleJs.b)(toggleSorting, props);
    const sortingOrderIconName = (0, _vue.computed)(()=>{
        return sortingOrderSync.value === "asc" ? "va-arrow-up" : sortingOrderSync.value === "desc" ? "va-arrow-down" : "unfold_more";
    });
    return {
        sortBySync,
        sortingOrderSync,
        toggleSorting: toggleSortingThrottled,
        sortedRows,
        sortingOrderIconName
    };
};

},{"vue":"gzxs9","../../../composables/useThrottle.js":"8b3Ic","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bRMII":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useTableScrollEmits);
parcelHelpers.export(exports, "b", ()=>useTableScroll);
parcelHelpers.export(exports, "u", ()=>useTableScrollProps);
var _vue = require("vue");
var _useElementRefJs = require("../../../composables/useElementRef.js");
var _useIntersectionObserverJs = require("../../../composables/useIntersectionObserver.js");
const useTableScrollProps = {
    scrollTopMargin: {
        type: Number,
        default: 0
    },
    scrollBottomMargin: {
        type: Number,
        default: 0
    }
};
const useTableScrollEmits = [
    "scroll:top",
    "scroll:bottom"
];
const useTableScroll = (props, emit)=>{
    var _a;
    const vNodeProps = (_a = (0, _vue.getCurrentInstance)()) == null ? void 0 : _a.vnode.props;
    const doRenderTopTrigger = (vNodeProps == null ? void 0 : vNodeProps["onScroll:top"]) !== void 0;
    const doRenderBottomTrigger = (vNodeProps == null ? void 0 : vNodeProps["onScroll:bottom"]) !== void 0;
    const scrollContainer = (0, _useElementRefJs.u)();
    const topTrigger = (0, _useElementRefJs.u)();
    const bottomTrigger = (0, _useElementRefJs.u)();
    const isObservable = (0, _vue.computed)(()=>!!scrollContainer.value);
    const intersectionHandler = (entries)=>{
        entries.forEach((entry)=>{
            if (entry.isIntersecting) entry.target === topTrigger.value ? emit("scroll:top") : emit("scroll:bottom");
        });
    };
    const targets = (0, _vue.computed)(()=>{
        const list = [];
        if (isObservable.value) {
            topTrigger.value && list.push(topTrigger.value);
            bottomTrigger.value && list.push(bottomTrigger.value);
        }
        return list;
    });
    const options = (0, _vue.computed)(()=>({
            root: scrollContainer.value,
            rootMargin: `${props.scrollTopMargin ?? 0}px 0px ${props.scrollBottomMargin ?? 0}px 0px`
        }));
    (0, _useIntersectionObserverJs.u)(intersectionHandler, options, targets);
    return {
        scrollContainer,
        topTrigger,
        bottomTrigger,
        doRenderTopTrigger,
        doRenderBottomTrigger
    };
};

},{"vue":"gzxs9","../../../composables/useElementRef.js":"3HFKq","../../../composables/useIntersectionObserver.js":"eneIu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3HFKq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useElementRef);
var _vue = require("vue");
var _unwrapElJs = require("../utils/unwrapEl.js");
const unrefElement = (el)=>{
    const e = (0, _vue.unref)(el);
    return (0, _unwrapElJs.u)(e);
};
const useElementRef = ()=>{
    const el = (0, _vue.shallowRef)();
    return (0, _vue.computed)({
        get () {
            return unrefElement(el);
        },
        set (node) {
            el.value = node;
        }
    });
};

},{"vue":"gzxs9","../utils/unwrapEl.js":"bYHKv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8cUCu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaDataTableThRow);
var _withConfigTransportJs = require("../../../services/config-transport/withConfigTransport.js");
var _vaDataTableThRowVueVueTypeScriptSetupTrueLangJs = require("./VaDataTableThRow.vue_vue_type_script_setup_true_lang.js");
const VaDataTableThRow = (0, _withConfigTransportJs.w)((0, _vaDataTableThRowVueVueTypeScriptSetupTrueLangJs._));

},{"../../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaDataTableThRow.vue_vue_type_script_setup_true_lang.js":"f2R7J","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f2R7J":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _indexJs = require("../../va-icon/index.js");
var _indexJs1 = require("../../va-checkbox/index.js");
var _useStylableJs = require("../hooks/useStylable.js");
var _useTranslationJs = require("../../../composables/useTranslation.js");
var _vaDataTableThRowCss = require("../../../../VaDataTableThRow.css");
const _hoisted_1 = {
    class: "va-data-table__table-tr"
};
const _hoisted_2 = {
    key: 0,
    scope: "col",
    class: "va-data-table__table-th va-data-table__table-cell-select"
};
const _hoisted_3 = [
    "title",
    "onClick",
    "onKeydown"
];
const _hoisted_4 = {
    class: "va-data-table__table-th-wrapper"
};
const _hoisted_5 = {
    key: 0
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaDataTableThRow",
    __name: "VaDataTableThRow",
    props: {
        ...(0, _useStylableJs.u),
        selectMode: {
            type: String,
            default: "multiple"
        },
        allRowsSelected: {
            type: Boolean,
            default: false
        },
        severalRowsSelected: {
            type: Boolean,
            default: false
        },
        columns: {
            type: Array,
            required: true
        },
        isFooter: {
            type: Boolean,
            default: false
        },
        sortBySync: {
            type: String,
            required: true
        },
        sortingOrderIconName: {
            type: String,
            required: true
        },
        sortingOrderSync: {
            type: String,
            default: null
        },
        ariaSelectAllRowsLabel: {
            type: String,
            default: "$t:selectAllRows"
        },
        ariaSortColumnByLabel: {
            type: String,
            default: "$t:sortColumnBy"
        }
    },
    emits: [
        "toggleBulkSelection",
        "toggleSorting"
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const { t, tp } = (0, _useTranslationJs.u)();
        const { getFooterCSSVariables, getHeaderCSSVariables, getClass, getStyle } = (0, _useStylableJs.a)(props);
        const getAriaAttributes = (column)=>{
            const ariaSort = props.sortingOrderSync && props.sortBySync === column.name ? props.sortingOrderSync === "asc" ? "ascending" : "descending" : "none";
            const ariaLabel = column.sortable ? tp(props.ariaSortColumnByLabel, {
                name: column.label
            }) : void 0;
            return {
                "aria-sort": ariaSort,
                "aria-label": ariaLabel
            };
        };
        const sortByColumn = (column)=>{
            if (props.isFooter && !props.allowFooterSorting || !column.sortable) return;
            emit("toggleSorting", column);
        };
        const toggleBulkSelection = ()=>emit("toggleBulkSelection");
        const getColumnStyles = (column)=>{
            return [
                column.width ? {
                    minWidth: column.width,
                    maxWidth: column.width
                } : {},
                props.isFooter ? getFooterCSSVariables(column) : getHeaderCSSVariables(column),
                getStyle(column.thStyle)
            ];
        };
        const slotNameComputed = (0, _vue.computed)(()=>props.isFooter ? "footer" : "header");
        const multiplySelectAvailable = (0, _vue.computed)(()=>props.selectMode === "multiple");
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("tr", _hoisted_1, [
                _ctx.$props.selectable ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("th", _hoisted_2, [
                    multiplySelectAvailable.value ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs1.V)), {
                        key: 0,
                        class: "va-data-table__table-cell-checkbox",
                        "model-value": _ctx.$props.severalRowsSelected ? "idl" : _ctx.$props.allRowsSelected,
                        "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaSelectAllRowsLabel),
                        "true-value": true,
                        "false-value": false,
                        color: _ctx.$props.selectedColor,
                        "indeterminate-value": "idl",
                        indeterminate: "",
                        "onUpdate:modelValue": toggleBulkSelection
                    }, null, 8, [
                        "model-value",
                        "aria-label",
                        "color"
                    ])) : (0, _vue.createCommentVNode)("", true)
                ])) : (0, _vue.createCommentVNode)("", true),
                ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)(__props.columns, (column)=>{
                    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("th", (0, _vue.mergeProps)({
                        key: column.name,
                        scope: "col",
                        class: [
                            "va-data-table__table-th",
                            (0, _vue.unref)(getClass)(column.thClass)
                        ],
                        title: column.thTitle,
                        style: getColumnStyles(column)
                    }, getAriaAttributes(column), {
                        onClick: (0, _vue.withModifiers)(($event)=>sortByColumn(column), [
                            "exact"
                        ]),
                        onKeydown: (0, _vue.withKeys)((0, _vue.withModifiers)(($event)=>sortByColumn(column), [
                            "stop"
                        ]), [
                            "enter"
                        ])
                    }), [
                        (0, _vue.createElementVNode)("div", _hoisted_4, [
                            `${slotNameComputed.value}(${column.name})` in _ctx.$slots ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("span", _hoisted_5, [
                                (0, _vue.renderSlot)(_ctx.$slots, `${slotNameComputed.value}(${column.name})`, (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                    label: column.label,
                                    key: column.key
                                })))
                            ])) : (0, _vue.renderSlot)(_ctx.$slots, slotNameComputed.value, (0, _vue.normalizeProps)((0, _vue.mergeProps)({
                                key: 1
                            }, {
                                label: column.label,
                                key: column.key
                            })), ()=>[
                                    (0, _vue.createElementVNode)("span", null, (0, _vue.toDisplayString)(column.label), 1)
                                ]),
                            column.sortable ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), {
                                key: 2,
                                class: (0, _vue.normalizeClass)([
                                    "va-data-table__table-th-sorting-icon",
                                    {
                                        active: __props.sortBySync === column.name && __props.sortingOrderSync !== null
                                    }
                                ]),
                                size: "small",
                                role: column.sortable ? "button" : void 0,
                                tabindex: column.sortable ? 0 : -1,
                                name: __props.sortingOrderIconName,
                                onSelectstart: (0, _vue.withModifiers)(()=>{}, [
                                    "prevent"
                                ])
                            }, null, 8, [
                                "class",
                                "role",
                                "tabindex",
                                "name"
                            ])) : (0, _vue.createCommentVNode)("", true)
                        ])
                    ], 16, _hoisted_3);
                }), 128))
            ]);
        };
    }
});

},{"vue":"gzxs9","../../va-icon/index.js":"82tPo","../../va-checkbox/index.js":"w8J04","../hooks/useStylable.js":"1JTRD","../../../composables/useTranslation.js":"7S3aV","../../../../VaDataTableThRow.css":"9Uyul","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9Uyul":[function() {},{}],"cvrbR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaVirtualScroller);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaVirtualScrollerVueVueTypeScriptSetupTrueLangJs = require("./VaVirtualScroller.vue_vue_type_script_setup_true_lang.js");
const VaVirtualScroller = (0, _withConfigTransportJs.w)((0, _vaVirtualScrollerVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaVirtualScroller.vue_vue_type_script_setup_true_lang.js":"7KgLY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7KgLY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../vendor.js");
var _useVirtualScrollerSizesJs = require("./useVirtualScrollerSizes.js");
var _useTrackByJs = require("../../composables/useTrackBy.js");
var _useEventJs = require("../../composables/useEvent.js");
var _useBemJs = require("../../composables/useBem.js");
var _vaVirtualScrollerCss = require("../../../VaVirtualScroller.css");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaVirtualScroller",
    __name: "VaVirtualScroller",
    props: {
        ...(0, _useTrackByJs.u),
        ...(0, _useVirtualScrollerSizesJs.u),
        items: {
            type: Array,
            default: ()=>[]
        },
        bench: {
            type: Number,
            default: 10,
            validator: (v)=>v >= 0
        },
        disabled: {
            type: Boolean,
            default: false
        },
        table: {
            type: Boolean,
            default: false
        }
    },
    emits: [
        "scroll:bottom"
    ],
    setup (__props, { expose: __expose, emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const listScrollPosition = (0, _vue.ref)(0);
        const scrollDirection = (0, _vue.computed)(()=>props.horizontal ? "scrollLeft" : "scrollTop");
        const handleScroll = ()=>{
            if (!wrapper.value) return;
            listScrollPosition.value = wrapper.value[scrollDirection.value];
        };
        if (!props.disabled) (0, _useEventJs.u)("scroll", handleScroll, true);
        const { list, wrapper, itemSize, wrapperSize } = (0, _useVirtualScrollerSizesJs.a)(props, listScrollPosition);
        const { getKey } = (0, _useTrackByJs.a)(props);
        const uniqueKey = (item, index, defaultValue)=>getKey(item, index, defaultValue);
        (0, _vue.watch)(listScrollPosition, (newValue)=>{
            if (newValue + wrapperSize.value === containerSize.value) emit("scroll:bottom");
        });
        const renderStartIndex = (0, _vue.computed)(()=>{
            return Math.max(0, Math.floor(listScrollPosition.value / itemSize.value) - props.bench);
        });
        const renderItemsAmount = (0, _vue.computed)(()=>{
            var _a;
            if (!((_a = props.items) == null ? void 0 : _a.length)) return 0;
            return props.disabled ? props.items.length : Math.min(props.items.length - renderStartIndex.value, Math.ceil(wrapperSize.value / itemSize.value) + props.bench * 2);
        });
        const renderEndIndex = (0, _vue.computed)(()=>renderStartIndex.value + renderItemsAmount.value);
        const renderBuffer = (0, _vue.computed)(()=>{
            var _a;
            if (!((_a = props.items) == null ? void 0 : _a.length)) return [];
            return props.items.slice(renderStartIndex.value, renderEndIndex.value);
        });
        const sizeAttribute = (0, _vue.computed)(()=>props.horizontal ? "width" : "height");
        const isDisabledVirtualTable = (0, _vue.computed)(()=>props.table && props.disabled);
        const wrapperStyleComputed = (0, _vue.computed)(()=>({
                [sizeAttribute.value]: isDisabledVirtualTable.value || !wrapperSize.value ? void 0 : `${wrapperSize.value}px`
            }));
        const wrapperClassComputed = (0, _useBemJs.u)("va-virtual-scroller", ()=>({
                ...(0, _vendorJs.p)(props, [
                    "horizontal"
                ])
            }));
        const containerSize = (0, _vue.computed)(()=>{
            var _a;
            return (((_a = props.items) == null ? void 0 : _a.length) ?? 0) * itemSize.value;
        });
        const containerStyleComputed = (0, _vue.computed)(()=>({
                [sizeAttribute.value]: isDisabledVirtualTable.value ? void 0 : `${containerSize.value}px`
            }));
        const currentListOffset = (0, _vue.computed)(()=>renderStartIndex.value * itemSize.value);
        const listStyleComputed = (0, _vue.computed)(()=>({
                transform: `translate${props.horizontal ? "X" : "Y"}(${currentListOffset.value}px)`
            }));
        const scrollToAttribute = (0, _vue.computed)(()=>props.horizontal ? "left" : "top");
        const virtualScrollTo = (index)=>{
            var _a;
            if (!index && index !== 0) return;
            (_a = wrapper.value) == null || _a.scrollTo({
                [scrollToAttribute.value]: index * itemSize.value
            });
        };
        __expose({
            scrollToAttribute,
            virtualScrollTo
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                ref_key: "wrapper",
                ref: wrapper,
                class: (0, _vue.normalizeClass)([
                    "va-virtual-scroller",
                    (0, _vue.unref)(wrapperClassComputed)
                ]),
                style: (0, _vue.normalizeStyle)(wrapperStyleComputed.value)
            }, [
                (0, _vue.renderSlot)(_ctx.$slots, "content", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                    containerStyleComputed: containerStyleComputed.value,
                    listStyleComputed: listStyleComputed.value,
                    renderBuffer: renderBuffer.value,
                    uniqueKey,
                    currentListOffset: currentListOffset.value
                })), ()=>[
                        (0, _vue.createElementVNode)("div", {
                            class: "va-virtual-scroller__container",
                            style: (0, _vue.normalizeStyle)(containerStyleComputed.value)
                        }, [
                            (0, _vue.createElementVNode)("div", {
                                ref_key: "list",
                                ref: list,
                                role: "list",
                                class: "va-virtual-scroller__list",
                                style: (0, _vue.normalizeStyle)(listStyleComputed.value)
                            }, [
                                ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)(renderBuffer.value, (item, index)=>{
                                    return (0, _vue.renderSlot)(_ctx.$slots, "default", (0, _vue.normalizeProps)((0, _vue.mergeProps)({
                                        key: uniqueKey(item, index)
                                    }, {
                                        item,
                                        index: renderStartIndex.value + index
                                    })));
                                }), 128))
                            ], 4)
                        ], 4)
                    ])
            ], 6);
        };
    }
});

},{"vue":"gzxs9","../../../vendor.js":"l6TAc","./useVirtualScrollerSizes.js":"kOrLC","../../composables/useTrackBy.js":"hYJj9","../../composables/useEvent.js":"9kzUn","../../composables/useBem.js":"igmjV","../../../VaVirtualScroller.css":"1vcNx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kOrLC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useVirtualScrollerSizes);
parcelHelpers.export(exports, "u", ()=>useVirtualScrollerSizesProps);
var _vue = require("vue");
var _consoleJs = require("../../utils/console.js");
var _useEventJs = require("../../composables/useEvent.js");
var _useParsableMeasureJs = require("../../composables/useParsableMeasure.js");
const { isParsablePositiveMeasure, parseSizeValue } = (0, _useParsableMeasureJs.u)();
const validateSizeProp = (v, propName)=>{
    const isProperValue = isParsablePositiveMeasure(v);
    !isProperValue && (0, _consoleJs.w)(`[va-virtual-scroller] ${propName} should be number or parsable int greater or equal to 0. Provided: ${v}.`);
    return isProperValue;
};
const useVirtualScrollerSizesProps = {
    horizontal: {
        type: Boolean,
        default: false
    },
    itemSize: {
        type: [
            Number,
            String
        ],
        default: 0,
        validator: (v)=>{
            return validateSizeProp(v, "itemSize");
        }
    },
    wrapperSize: {
        type: [
            Number,
            String
        ],
        default: 100,
        validator: (v)=>{
            return v === "auto" || validateSizeProp(v, "wrapperSize");
        }
    }
};
const useVirtualScrollerSizes = (props, scrollPosition)=>{
    const list = (0, _vue.shallowRef)();
    const wrapper = (0, _vue.shallowRef)();
    const clientSizeMeasure = (0, _vue.computed)(()=>props.horizontal ? "clientWidth" : "clientHeight");
    const wrapperSize = (0, _vue.computed)(()=>{
        var _a;
        if (props.wrapperSize === "auto") return ((_a = wrapper.value) == null ? void 0 : _a[clientSizeMeasure.value]) || 0;
        return parseSizeValue(props.wrapperSize, pageFontSize);
    });
    const pageFontSize = (0, _vue.ref)(16);
    const handleWindowResize = ()=>{
        pageFontSize.value = parseFloat(getComputedStyle(document.documentElement).fontSize);
        calcAverageItemsSize();
    };
    (0, _useEventJs.u)("resize", handleWindowResize, true);
    const itemSizeCalculated = (0, _vue.ref)(0);
    const calcAverageItemsSize = ()=>{
        if (!list.value) return;
        const sizes = [];
        const itemsList = list.value.children;
        const itemsAmount = itemsList.length;
        for(let i = 0; i < itemsAmount; i++){
            const currentChild = list.value.children.item(i);
            currentChild && sizes.push(currentChild[clientSizeMeasure.value]);
        }
        itemSizeCalculated.value = itemsAmount ? Math.trunc(sizes.reduce((acc, el)=>acc + el, 0) / (itemsAmount - 1)) : 0;
    };
    const instance = (0, _vue.getCurrentInstance)();
    (0, _vue.onMounted)(()=>{
        var _a, _b;
        if (!list.value) list.value = (_b = (_a = instance == null ? void 0 : instance.parent) == null ? void 0 : _a.refs) == null ? void 0 : _b.list;
        calcAverageItemsSize();
    });
    (0, _vue.watch)(scrollPosition, calcAverageItemsSize);
    (0, _vue.watch)(wrapperSize, calcAverageItemsSize);
    let oldItemSize = 0;
    const itemSize = (0, _vue.computed)(()=>{
        const sizeParsed = parseSizeValue(props.itemSize, pageFontSize);
        const result = Math.max(sizeParsed, itemSizeCalculated.value, 1);
        const diff = Math.abs(oldItemSize / result * 100 - 100);
        if (diff > 5 || oldItemSize === 0) {
            oldItemSize = result;
            return result;
        }
        return oldItemSize;
    });
    return {
        list,
        wrapper,
        itemSize,
        wrapperSize
    };
};

},{"vue":"gzxs9","../../utils/console.js":"58L6z","../../composables/useEvent.js":"9kzUn","../../composables/useParsableMeasure.js":"3bLfO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hYJj9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useTrackBy);
parcelHelpers.export(exports, "u", ()=>useTrackByProps);
var _vendorJs = require("../../vendor.js");
var _consoleJs = require("../utils/console.js");
const useTrackByProps = {
    trackBy: {
        type: [
            String,
            Number,
            Function
        ],
        default: ""
    }
};
const useTrackBy = (props)=>{
    const getKey = (item, index, defaultValue)=>{
        if (props.trackBy && item && typeof item === "object" && !(0, _vendorJs.g)(props.trackBy)) {
            const isArrayItem = Array.isArray(item);
            let key;
            if (isArrayItem && !isNaN(+props.trackBy)) key = item[+props.trackBy];
            if (!isArrayItem) key = item[props.trackBy];
            if (key || key === 0) return key;
            (0, _consoleJs.w)(`${isArrayItem ? "Index" : "Key"} '${props.trackBy}' wasn't found in provided ${isArrayItem ? "array" : "object"}: `, item);
        }
        if ((0, _vendorJs.g)(props.trackBy)) return props.trackBy(item);
        return defaultValue;
    };
    return {
        getKey
    };
};

},{"../../vendor.js":"l6TAc","../utils/console.js":"58L6z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1vcNx":[function() {},{}],"9vecB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaInnerLoading);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaInnerLoadingVueVueTypeScriptSetupTrueLangJs = require("./VaInnerLoading.vue_vue_type_script_setup_true_lang.js");
const VaInnerLoading = (0, _withConfigTransportJs.w)((0, _vaInnerLoadingVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaInnerLoading.vue_vue_type_script_setup_true_lang.js":"awMAp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"awMAp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _indexJs = require("../va-icon/index.js");
var _useLoadingJs = require("../../composables/useLoading.js");
var _useColorsJs = require("../../composables/useColors.js");
var _vaInnerLoadingCss = require("../../../VaInnerLoading.css");
const _hoisted_1 = {
    key: 0,
    class: "va-inner-loading__overlay",
    "aria-hidden": "true"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaInnerLoading",
    __name: "VaInnerLoading",
    props: {
        ...(0, _useLoadingJs.u),
        ...(0, _useComponentPresetJs.u),
        color: {
            type: String
        },
        icon: {
            type: String,
            default: "va-loading"
        },
        size: {
            type: Number,
            default: 30
        }
    },
    setup (__props) {
        const props = __props;
        const { getColor } = (0, _useColorsJs.u)();
        const colorComputed = (0, _vue.computed)(()=>getColor(props.color));
        const computedClass = (0, _vue.computed)(()=>({
                "va-inner-loading--active": props.loading
            }));
        const ariaAttributesComputed = (0, _vue.computed)(()=>({
                "aria-busy": props.loading
            }));
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", (0, _vue.mergeProps)({
                class: [
                    "va-inner-loading",
                    computedClass.value
                ],
                "aria-live": "polite"
            }, ariaAttributesComputed.value), [
                (0, _vue.renderSlot)(_ctx.$slots, "default"),
                _ctx.$props.loading ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_1, [
                    (0, _vue.renderSlot)(_ctx.$slots, "loading", {}, ()=>[
                            (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs.V)), {
                                class: "va-inner-loading__spinner",
                                spin: "counter-clockwise",
                                color: colorComputed.value,
                                size: _ctx.$props.size,
                                name: _ctx.$props.icon
                            }, null, 8, [
                                "color",
                                "size",
                                "name"
                            ])
                        ])
                ])) : (0, _vue.createCommentVNode)("", true)
            ], 16);
        };
    }
});

},{"vue":"gzxs9","../../composables/useComponentPreset.js":"2HoaT","../va-icon/index.js":"82tPo","../../composables/useLoading.js":"jYmWj","../../composables/useColors.js":"a4Qgv","../../../VaInnerLoading.css":"5BiOz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5BiOz":[function() {},{}],"fYZus":[function() {},{}],"bfPrQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaDateInput);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaDateInputVueVueTypeScriptSetupTrueLangJs = require("./VaDateInput.vue_vue_type_script_setup_true_lang.js");
const VaDateInput = (0, _withConfigTransportJs.w)((0, _vaDateInputVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaDateInput.vue_vue_type_script_setup_true_lang.js":"fv6iO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fv6iO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../vendor.js");
var _rangeModelValueGuardJs = require("./hooks/range-model-value-guard.js");
var _inputTextParserJs = require("./hooks/input-text-parser.js");
var _modelValueJs = require("./hooks/model-value.js");
var _dateUtilsJs = require("../va-date-picker/utils/date-utils.js");
var _indexJs = require("../va-dropdown/index.js");
var _vaDatePickerVueVueTypeScriptSetupTrueLangJs = require("../va-date-picker/VaDatePicker.vue_vue_type_script_setup_true_lang.js");
var _indexJs1 = require("../va-input-wrapper/index.js");
var _indexJs2 = require("../va-icon/index.js");
var _unwrapElJs = require("../../utils/unwrapEl.js");
var _useDropdownableJs = require("../../composables/useDropdownable.js");
var _indexJs3 = require("../va-dropdown/components/VaDropdownContent/index.js");
var _extractComponentOptionsJs = require("../../utils/component-options/extract-component-options.js");
var _useClearableJs = require("../../composables/useClearable.js");
var _useValidationJs = require("../../composables/useValidation.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useFocusJs = require("../../composables/useFocus.js");
var _useStatefulJs = require("../../composables/useStateful.js");
var _useTrapFocusJs = require("../../composables/useTrapFocus.js");
var _useFocusDeepJs = require("../../composables/useFocusDeep.js");
var _filterPropsJs = require("../../utils/component-options/filter-props.js");
var _useTranslationJs = require("../../composables/useTranslation.js");
var _vaDateInputCss = require("../../../VaDateInput.css");
const VaInputWrapperPropsDeclaration = (0, _extractComponentOptionsJs.e)((0, _indexJs1.V), [
    "focused",
    "maxLength",
    "counterValue"
]);
const VaDatePickerPropsDeclaration = (0, _extractComponentOptionsJs.e)((0, _vaDatePickerVueVueTypeScriptSetupTrueLangJs._));
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaDateInput",
    inheritAttrs: false,
    __name: "VaDateInput",
    props: {
        ...(0, _useDropdownableJs.u),
        ...(0, _useClearableJs.u),
        ...VaInputWrapperPropsDeclaration,
        ...VaDatePickerPropsDeclaration,
        ...(0, _useValidationJs.b),
        ...(0, _useComponentPresetJs.u),
        clearValue: {
            type: Date,
            default: void 0
        },
        modelValue: {
            type: [
                Date,
                Array,
                Object,
                String,
                Number
            ]
        },
        resetOnClose: {
            type: Boolean,
            default: true
        },
        closeOnContentClick: {
            type: Boolean,
            default: false
        },
        offset: {
            ...(0, _useDropdownableJs.u).offset,
            default: ()=>[
                    2,
                    0
                ]
        },
        format: {
            type: Function
        },
        formatDate: {
            type: Function,
            default: (d)=>d.toLocaleDateString()
        },
        /** Force model value to string instead of date */ formatValue: {
            type: Function
        },
        parse: {
            type: Function
        },
        parseDate: {
            type: Function
        },
        delimiter: {
            type: String,
            default: ", "
        },
        rangeDelimiter: {
            type: String,
            default: " ~ "
        },
        manualInput: {
            type: Boolean,
            default: false
        },
        color: {
            type: String,
            default: "primary"
        },
        leftIcon: {
            type: Boolean,
            default: false
        },
        icon: {
            type: String,
            default: "va-calendar"
        },
        ariaToggleDropdownLabel: {
            type: String,
            default: "$t:toggleDropdown"
        },
        ariaResetLabel: {
            type: String,
            default: "$t:resetDate"
        },
        ariaSelectedDateLabel: {
            type: String,
            default: "$t:selectedDate"
        }
    },
    emits: [
        ...(0, _useFocusJs.a),
        ...(0, _extractComponentOptionsJs.a)((0, _vaDatePickerVueVueTypeScriptSetupTrueLangJs._)),
        ...(0, _useClearableJs.a),
        ...(0, _useValidationJs.u),
        ...(0, _useStatefulJs.a),
        ...(0, _useDropdownableJs.a),
        "update:text"
    ],
    setup (__props, { expose: __expose, emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const input = (0, _vue.shallowRef)();
        const datePicker = (0, _vue.ref)();
        const { resetOnClose } = (0, _vue.toRefs)(props);
        const { trapFocusIn, freeFocus } = (0, _useTrapFocusJs.u)();
        const trapFocus = ()=>{
            const el = (0, _unwrapElJs.u)(datePicker.value);
            if (!el) {
                freeFocus();
                return;
            }
            trapFocusIn(el);
        };
        (0, _vue.watch)([
            datePicker
        ], ()=>{
            trapFocus();
        });
        const { valueComputed: statefulValue } = (0, _useStatefulJs.b)(props, emit);
        const { isOpenSync, dropdownProps } = (0, _useDropdownableJs.b)(props, emit, {
            defaultCloseOnValueUpdate: (0, _vue.computed)(()=>{
                if (Array.isArray(valueComputed.value)) return false;
                if ((0, _dateUtilsJs.i)(valueComputed.value) && valueComputed.value.end === null) return false;
                return true;
            })
        });
        const isRangeModelValueGuardDisabled = (0, _vue.computed)(()=>!resetOnClose.value);
        const { valueComputed, reset: resetInvalidRange } = (0, _rangeModelValueGuardJs.u)(statefulValue, isRangeModelValueGuardDisabled);
        (0, _vue.watch)(isOpenSync, (isOpened)=>{
            if (!isOpened && !isRangeModelValueGuardDisabled.value) resetInvalidRange();
        });
        const { isFocused: isInputFocused, focus, blur, onFocus: focusListener, onBlur: blurListener } = (0, _useFocusJs.u)(input);
        const isPickerFocused = (0, _useFocusDeepJs.u)(datePicker);
        const dateOrNothing = (date)=>date ? props.formatDate(date) : "...";
        const { parseDateInputValue, isValid } = (0, _inputTextParserJs.u)(props);
        (0, _vue.watch)(valueComputed, ()=>{
            isValid.value = true;
        });
        const modelValueToString = (value)=>{
            if (props.format) return props.format(valueComputed.value);
            if ((0, _dateUtilsJs.a)(value)) return value.map((d)=>props.formatDate(d)).join(props.delimiter);
            if ((0, _dateUtilsJs.b)(value)) return props.formatDate(value);
            if ((0, _dateUtilsJs.i)(value)) return dateOrNothing(value.start) + props.rangeDelimiter + dateOrNothing(value.end);
            if (value === null || value === void 0) return "";
            throw new Error("VaDatePicker: Invalid model value. Value should be Date, Date[] or { start: Date, end: Date | null }, got " + typeof value);
        };
        const { text, normalized: valueWithoutText } = (0, _modelValueJs.u)(statefulValue, (0, _vue.toRef)(props, "mode"), parseDateInputValue, modelValueToString, props.formatValue);
        const valueText = (0, _vue.computed)(()=>{
            if (!isValid.value) return "";
            if (!valueComputed.value) {
                if (!props.clearValue) return "";
                return modelValueToString(props.clearValue);
            }
            return text.value;
        });
        const onInputTextChanged = ({ target })=>{
            if (props.disabled) return;
            const parsedValue = parseDateInputValue(target.value);
            if (isValid.value) valueComputed.value = parsedValue;
        };
        const reset = ()=>withoutValidation(()=>{
                statefulValue.value = props.clearValue;
                emit("clear");
                resetValidation();
            });
        const hideAndFocus = ()=>{
            isOpenSync.value = false;
            focus();
        };
        const focusDatePicker = ()=>{
            (0, _vue.nextTick)(()=>{
                var _a;
                return (_a = datePicker.value) == null ? void 0 : _a.focusCurrentPicker();
            });
        };
        const focusInputOrPicker = ()=>{
            isOpenSync.value ? focusDatePicker() : focus();
        };
        const checkProhibitedDropdownOpening = (e)=>{
            if (isOpenSync.value) return false;
            if (props.disabled || props.readonly) return true;
            if (e === void 0) return false;
            return props.manualInput && (e == null ? void 0 : e.code) !== "Space";
        };
        const toggleDropdown = (event)=>{
            if (checkProhibitedDropdownOpening(event instanceof KeyboardEvent ? event : void 0)) return;
            isOpenSync.value = !isOpenSync.value;
            (0, _vue.nextTick)(focusInputOrPicker);
        };
        const showDropdown = ()=>{
            if (props.disabled || props.readonly) return;
            isOpenSync.value = true;
            (0, _vue.nextTick)(focusDatePicker);
        };
        const { computedError, computedErrorMessages, listeners, validationAriaAttributes, validate, withoutValidation, resetValidation } = (0, _useValidationJs.a)(props, emit, {
            reset,
            focus,
            value: valueComputed
        });
        const hasError = (0, _vue.computed)(()=>!isValid.value && valueComputed.value !== props.clearValue || computedError.value);
        const slots = (0, _vue.useSlots)();
        const filterSlots = (0, _vue.computed)(()=>{
            const slotsWithIcons = [
                props.leftIcon && "prependInner",
                (!props.leftIcon || props.clearable) && "icon"
            ];
            return Object.keys(slots).filter((slot)=>!slotsWithIcons.includes(slot));
        });
        const { canBeCleared, clearIconProps, onFocus, onBlur } = (0, _useClearableJs.b)(props, valueComputed);
        const cursorStyleComputed = (0, _vue.computed)(()=>{
            if (props.disabled) return {};
            if (props.manualInput) return {
                cursor: "text"
            };
            return {
                cursor: "pointer"
            };
        });
        const iconTabindexComputed = (0, _vue.computed)(()=>{
            if (!props.manualInput) return -1;
            return props.disabled || props.readonly ? -1 : 0;
        });
        const iconProps = (0, _vue.computed)(()=>({
                role: iconTabindexComputed.value === 0 ? "button" : "none",
                ariaHidden: iconTabindexComputed.value === -1,
                name: props.icon,
                color: "secondary",
                tabindex: iconTabindexComputed.value
            }));
        const filteredWrapperProps = (0, _filterPropsJs.f)(VaInputWrapperPropsDeclaration);
        const computedInputWrapperProps = (0, _vue.computed)(()=>({
                ...filteredWrapperProps.value,
                focused: isInputFocused.value || isPickerFocused.value,
                error: hasError.value,
                errorMessages: computedErrorMessages.value,
                readonly: props.readonly || !props.manualInput
            }));
        const computedInputListeners = (0, _vue.computed)(()=>({
                focus: ()=>{
                    if (props.disabled) return;
                    focusListener();
                    if (props.readonly) return;
                    onFocus();
                },
                blur: ()=>{
                    if (props.disabled) return;
                    blurListener();
                    if (props.readonly) return;
                    onBlur();
                    listeners.onBlur();
                }
            }));
        const { tp } = (0, _useTranslationJs.u)();
        const attrs = (0, _vue.useAttrs)();
        const inputAttributesComputed = (0, _vue.computed)(()=>({
                readonly: props.readonly || !props.manualInput,
                disabled: props.disabled,
                tabindex: props.disabled ? -1 : 0,
                placeholder: props.placeholder,
                value: valueText.value,
                ariaLabel: props.label || tp(props.ariaSelectedDateLabel),
                ariaRequired: props.requiredMark,
                ariaDisabled: props.disabled,
                ariaReadOnly: props.readonly,
                ...validationAriaAttributes.value,
                ...(0, _vendorJs.o)(attrs, [
                    "class",
                    "style"
                ])
            }));
        const dropdownPropsComputed = (0, _vue.computed)(()=>({
                ...dropdownProps.value,
                stateful: false,
                innerAnchorSelector: ".va-input-wrapper__field",
                trigger: [
                    "click",
                    "right-click",
                    "enter",
                    "space"
                ]
            }));
        const inputWrapperProps = computedInputWrapperProps;
        const inputListeners = computedInputListeners;
        const datePickerProps = (0, _filterPropsJs.f)(VaDatePickerPropsDeclaration);
        __expose({
            valueText,
            valueWithoutText,
            valueDate: valueWithoutText,
            focus,
            blur,
            reset,
            validate,
            showDropdown,
            hideAndFocus,
            toggleDropdown,
            focusDatePicker
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), (0, _vue.mergeProps)({
                modelValue: (0, _vue.unref)(isOpenSync),
                "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event)=>(0, _vue.isRef)(isOpenSync) ? isOpenSync.value = $event : null),
                class: [
                    "va-date-input",
                    _ctx.$attrs.class
                ],
                style: _ctx.$attrs.style
            }, dropdownPropsComputed.value, {
                onOpen: focusDatePicker,
                role: "none"
            }), {
                anchor: (0, _vue.withCtx)(()=>[
                        (0, _vue.renderSlot)(_ctx.$slots, "input", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                            valueText: valueText.value,
                            inputAttributes: inputAttributesComputed.value,
                            inputWrapperProps: (0, _vue.unref)(inputWrapperProps),
                            inputListeners: (0, _vue.unref)(inputListeners)
                        })), ()=>[
                                (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs1.V)), (0, _vue.mergeProps)({
                                    class: "va-date-input__anchor",
                                    style: cursorStyleComputed.value
                                }, (0, _vue.unref)(inputWrapperProps), (0, _vue.toHandlers)((0, _vue.unref)(inputListeners)), {
                                    "model-value": valueText.value,
                                    onChange: onInputTextChanged
                                }), (0, _vue.createSlots)({
                                    icon: (0, _vue.withCtx)(()=>[
                                            (0, _vue.unref)(canBeCleared) ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs2.V)), (0, _vue.mergeProps)({
                                                key: 0,
                                                "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaResetLabel)
                                            }, {
                                                ...iconProps.value,
                                                ...(0, _vue.unref)(clearIconProps)
                                            }, {
                                                onClick: (0, _vue.withModifiers)(reset, [
                                                    "stop"
                                                ]),
                                                onKeydown: [
                                                    (0, _vue.withKeys)((0, _vue.withModifiers)(reset, [
                                                        "stop"
                                                    ]), [
                                                        "enter"
                                                    ]),
                                                    (0, _vue.withKeys)((0, _vue.withModifiers)(reset, [
                                                        "stop"
                                                    ]), [
                                                        "space"
                                                    ])
                                                ]
                                            }), null, 16, [
                                                "aria-label",
                                                "onKeydown"
                                            ])) : (0, _vue.createCommentVNode)("", true),
                                            !_ctx.$props.leftIcon && _ctx.$props.icon ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs2.V)), (0, _vue.mergeProps)({
                                                key: 1,
                                                "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaToggleDropdownLabel)
                                            }, iconProps.value), null, 16, [
                                                "aria-label"
                                            ])) : (0, _vue.createCommentVNode)("", true)
                                        ]),
                                    _: 2
                                }, [
                                    (0, _vue.renderList)(filterSlots.value, (name)=>{
                                        return {
                                            name,
                                            fn: (0, _vue.withCtx)((slotScope)=>[
                                                    (0, _vue.renderSlot)(_ctx.$slots, name, (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(slotScope)))
                                                ])
                                        };
                                    }),
                                    _ctx.$slots.prependInner || _ctx.$props.leftIcon ? {
                                        name: "prependInner",
                                        fn: (0, _vue.withCtx)((slotScope)=>[
                                                (0, _vue.renderSlot)(_ctx.$slots, "prependInner", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(slotScope))),
                                                _ctx.$props.leftIcon ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs2.V)), (0, _vue.mergeProps)({
                                                    key: 0,
                                                    "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaToggleDropdownLabel)
                                                }, iconProps.value), null, 16, [
                                                    "aria-label"
                                                ])) : (0, _vue.createCommentVNode)("", true)
                                            ]),
                                        key: "0"
                                    } : void 0
                                ]), 1040, [
                                    "style",
                                    "model-value"
                                ])
                            ])
                    ]),
                default: (0, _vue.withCtx)(()=>[
                        (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs3.V)), {
                            class: "va-date-input__dropdown-content",
                            onKeydown: _cache[8] || (_cache[8] = (0, _vue.withKeys)(($event)=>(0, _vue.unref)(focus)(), [
                                "esc"
                            ])),
                            role: "dialog"
                        }, {
                            default: (0, _vue.withCtx)(()=>[
                                    (0, _vue.createVNode)((0, _vaDatePickerVueVueTypeScriptSetupTrueLangJs._), (0, _vue.mergeProps)({
                                        ref_key: "datePicker",
                                        ref: datePicker
                                    }, (0, _vue.unref)(datePickerProps), {
                                        modelValue: (0, _vue.unref)(valueWithoutText),
                                        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event)=>(0, _vue.isRef)(valueWithoutText) ? valueWithoutText.value = $event : null),
                                        "onClick:day": _cache[1] || (_cache[1] = ($event)=>_ctx.$emit("click:day", $event)),
                                        "onClick:month": _cache[2] || (_cache[2] = ($event)=>_ctx.$emit("click:month", $event)),
                                        "onClick:year": _cache[3] || (_cache[3] = ($event)=>_ctx.$emit("click:year", $event)),
                                        "onHover:day": _cache[4] || (_cache[4] = ($event)=>_ctx.$emit("hover:day", $event)),
                                        "onHover:month": _cache[5] || (_cache[5] = ($event)=>_ctx.$emit("hover:month", $event)),
                                        "onHover:year": _cache[6] || (_cache[6] = ($event)=>_ctx.$emit("hover:year", $event)),
                                        "onUpdate:view": _cache[7] || (_cache[7] = ($event)=>{
                                            _ctx.$nextTick(()=>trapFocus());
                                            _ctx.$emit("update:view", $event);
                                        })
                                    }), (0, _vue.createSlots)({
                                        _: 2
                                    }, [
                                        (0, _vue.renderList)(_ctx.$slots, (_, name)=>{
                                            return {
                                                name,
                                                fn: (0, _vue.withCtx)((bind)=>[
                                                        (0, _vue.renderSlot)(_ctx.$slots, name, (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(bind)))
                                                    ])
                                            };
                                        })
                                    ]), 1040, [
                                        "modelValue"
                                    ])
                                ]),
                            _: 3
                        })
                    ]),
                _: 3
            }, 16, [
                "modelValue",
                "class",
                "style"
            ]);
        };
    }
});

},{"vue":"gzxs9","../../../vendor.js":"l6TAc","./hooks/range-model-value-guard.js":"evFTH","./hooks/input-text-parser.js":"2wztN","./hooks/model-value.js":"lKdSZ","../va-date-picker/utils/date-utils.js":"gX2KK","../va-dropdown/index.js":"2ag98","../va-date-picker/VaDatePicker.vue_vue_type_script_setup_true_lang.js":"hY7Wl","../va-input-wrapper/index.js":"7MuId","../va-icon/index.js":"82tPo","../../utils/unwrapEl.js":"bYHKv","../../composables/useDropdownable.js":"iz6O5","../va-dropdown/components/VaDropdownContent/index.js":"eUpbA","../../utils/component-options/extract-component-options.js":"1ODzH","../../composables/useClearable.js":"h8vES","../../composables/useValidation.js":"iFHh2","../../composables/useComponentPreset.js":"2HoaT","../../composables/useFocus.js":"8TBqW","../../composables/useStateful.js":"h9zUi","../../composables/useTrapFocus.js":"gBu8E","../../composables/useFocusDeep.js":"ay8Fe","../../utils/component-options/filter-props.js":"4HycW","../../composables/useTranslation.js":"7S3aV","../../../VaDateInput.css":"lGJau","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"evFTH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useRangeModelValueGuard);
var _vue = require("vue");
var _modelValueParserJs = require("./model-value-parser.js");
const useRangeModelValueGuard = (modelValue, disabled)=>{
    const bufferValue = (0, _vue.ref)(modelValue.value);
    const valueComputed = (0, _vue.computed)({
        get: ()=>bufferValue.value,
        set: (value)=>{
            if (disabled.value) modelValue.value = value;
            if (!value) {
                modelValue.value = value;
                return;
            }
            if ((0, _modelValueParserJs.i)(value)) {
                if (value.end !== null) modelValue.value = value;
            } else modelValue.value = value;
            bufferValue.value = value;
        }
    });
    (0, _vue.watch)(modelValue, (newValue)=>{
        bufferValue.value = newValue;
    });
    const reset = ()=>{
        if (bufferValue.value && (0, _modelValueParserJs.i)(bufferValue.value)) bufferValue.value = modelValue.value;
    };
    return {
        valueComputed,
        reset
    };
};

},{"vue":"gzxs9","./model-value-parser.js":"lwCg2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lwCg2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "i", ()=>isRange);
const isRange = (date)=>{
    if (date === null) return false;
    return typeof date === "object" && ("start" in date || "end" in date);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2wztN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useDateParser);
var _vue = require("vue");
var _vendorJs = require("../../../../vendor.js");
const defaultParseDateFunction = (text)=>new Date(Date.parse(text));
const isValidDate = (d)=>(0, _vendorJs.a)(d) && !isNaN(d.getTime());
const useDateParser = (props)=>{
    const isMultipleDates = (text)=>{
        const dates = text.split(props.delimiter);
        if (dates.length < 2) return false;
        return dates.every((date)=>{
            const parsedDate = (props.parseDate || defaultParseDateFunction)(date);
            return isValidDate(parsedDate);
        });
    };
    const isRange = (text)=>text.includes(props.rangeDelimiter);
    const isValid = (0, _vue.ref)(true);
    const parseDate = (text)=>{
        const splitDate = text.split(".");
        const valueToParse = (splitDate == null ? void 0 : splitDate.length) === 3 ? splitDate.reverse().join("-") : text;
        const date = (props.parseDate || defaultParseDateFunction)(valueToParse);
        isValid.value = isValidDate(date);
        return date;
    };
    const parseDateInputValue = (text)=>{
        isValid.value = true;
        if (props.parse) return props.parse(text, isValid);
        if (isMultipleDates(text)) return text.split(props.delimiter).map(parseDate);
        if (isRange(text)) {
            const [start, end] = text.split(props.rangeDelimiter).map(parseDate);
            return {
                start,
                end
            };
        }
        return parseDate(text);
    };
    return {
        parseDateInputValue,
        isValid
    };
};

},{"vue":"gzxs9","../../../../vendor.js":"l6TAc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lKdSZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useDateInputModelValue);
var _vendorJs = require("../../../../vendor.js");
var _vue = require("vue");
var _parseDateJs = require("../utils/parse-date.js");
const isRange = (date)=>{
    if (date === null) return false;
    return typeof date === "object" && ("start" in date || "end" in date);
};
const isMultiple = (date)=>{
    if (date === null) return false;
    return Array.isArray(date);
};
const isSingleDate = (date)=>{
    if (date === null) return false;
    return typeof date === "string" || typeof date === "number" || date instanceof Date;
};
const useDateInputModelValue = (modelValue, mode, parseModelValue, formatModelValue, formatModelValueSingleDate)=>{
    const syncFormat = (original, target)=>{
        if (formatModelValueSingleDate) return formatModelValueSingleDate(target);
        if (typeof original === "string") {
            const standardFormat = (0, _parseDateJs.f)(target, original);
            if (standardFormat) return standardFormat;
            return formatModelValue(target);
        }
        if (typeof original === "number") return target.getTime();
        return target;
    };
    const normalizeSingleDate = (value)=>{
        if (value instanceof Date) return value;
        return new Date(value);
    };
    const dateValue = (0, _vue.computed)(()=>{
        if (modelValue.value === null || modelValue.value === void 0) return null;
        if (typeof modelValue.value === "string") return parseModelValue(modelValue.value);
        if (typeof modelValue.value === "number") return new Date(modelValue.value);
        return modelValue.value;
    });
    const normalized = (0, _vue.computed)({
        get: ()=>{
            if (dateValue.value === null || dateValue.value === void 0) return null;
            if (isMultiple(dateValue.value)) return dateValue.value.map(normalizeSingleDate);
            if (isRange(dateValue.value)) {
                const { start, end } = dateValue.value;
                return {
                    start: start ? normalizeSingleDate(start) : null,
                    end: end ? normalizeSingleDate(end) : null
                };
            }
            return normalizeSingleDate(dateValue.value);
        },
        set (newValue) {
            var _a, _b;
            if (newValue === null || newValue === void 0) {
                modelValue.value = newValue;
                return;
            }
            if (isMultiple(newValue) && (isMultiple(modelValue.value) || (0, _vendorJs.i)(modelValue.value))) {
                const originalValue = modelValue.value;
                modelValue.value = newValue.map((v, index)=>syncFormat((originalValue == null ? void 0 : originalValue[index]) || (originalValue == null ? void 0 : originalValue[0]), v));
                return;
            }
            if (isRange(newValue) && (isRange(modelValue.value) || (0, _vendorJs.i)(modelValue.value))) {
                const { start, end } = newValue;
                modelValue.value = {
                    start: start ? syncFormat((_a = modelValue.value) == null ? void 0 : _a.start, start) : null,
                    // Sync end date only if start date is specified
                    end: end ? syncFormat((_b = modelValue.value) == null ? void 0 : _b.start, end) : null
                };
                return;
            }
            if (isSingleDate(newValue) && (isSingleDate(modelValue.value) || (0, _vendorJs.i)(modelValue.value))) {
                modelValue.value = syncFormat(modelValue.value, newValue);
                return;
            }
            console.log({
                inputDate: newValue,
                modelValue: modelValue.value
            });
            throw new Error("Input date is not the same as date from props");
        }
    });
    const text = (0, _vue.computed)({
        get: ()=>{
            if (normalized.value === null || normalized.value === void 0) return "";
            return formatModelValue(normalized.value);
        },
        set: (value)=>{
            modelValue.value = parseModelValue(value);
        }
    });
    return {
        text,
        normalized
    };
};

},{"../../../../vendor.js":"l6TAc","vue":"gzxs9","../utils/parse-date.js":"33XCq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"33XCq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "f", ()=>formatDateToTheSameStandardFormat);
const isISO8601 = (date)=>{
    const isoDate = Date.parse(date);
    return !isNaN(isoDate) && !date.includes(" ");
};
const isRFC1123GTM = (date)=>{
    return date.endsWith("GMT");
};
const isRFC1123 = (date)=>{
    const rfcDate = new Date(date);
    return !isNaN(rfcDate.getTime());
};
const formatDateToTheSameStandardFormat = (date, formattedString)=>{
    if (isRFC1123GTM(formattedString)) return date.toUTCString();
    if (isISO8601(formattedString)) return date.toISOString();
    if (isRFC1123(formattedString)) return date.toString();
    return null;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gX2KK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>isDates);
parcelHelpers.export(exports, "b", ()=>isSingleDate);
parcelHelpers.export(exports, "c", ()=>createYearDate);
parcelHelpers.export(exports, "d", ()=>isDatesMonthEqual);
parcelHelpers.export(exports, "e", ()=>isDatesDayEqual);
parcelHelpers.export(exports, "f", ()=>isDatesYearEqual);
parcelHelpers.export(exports, "i", ()=>isRange);
var _vendorJs = require("../../../../vendor.js");
const isDatesDayEqual = (date1, date2)=>(date1 == null ? void 0 : date1.toDateString()) === (date2 == null ? void 0 : date2.toDateString());
const isDatesYearEqual = (date1, date2)=>{
    return (date1 == null ? void 0 : date1.getFullYear()) === (date2 == null ? void 0 : date2.getFullYear());
};
const isDatesMonthEqual = (date1, date2)=>{
    return isDatesYearEqual(date1, date2) && (date1 == null ? void 0 : date1.getMonth()) === (date2 == null ? void 0 : date2.getMonth());
};
const createYearDate = (year)=>{
    const date = /* @__PURE__ */ new Date();
    date.setFullYear(year);
    return date;
};
const isRange = (value)=>{
    if (value === null) return false;
    return typeof value === "object" && ("start" in value || "end" in value);
};
const isSingleDate = (value)=>(0, _vendorJs.a)(value);
const isDates = (value)=>Array.isArray(value);

},{"../../../../vendor.js":"l6TAc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hY7Wl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _viewJs = require("./hooks/view.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _vaDayPickerVueVueTypeScriptSetupTrueLangJs = require("./components/VaDayPicker/VaDayPicker.vue_vue_type_script_setup_true_lang.js");
var _vaDatePickerHeaderVueVueTypeScriptSetupTrueLangJs = require("./components/VaDatePickerHeader/VaDatePickerHeader.vue_vue_type_script_setup_true_lang.js");
var _vaMonthPickerVueVueTypeScriptSetupTrueLangJs = require("./components/VaMonthPicker/VaMonthPicker.vue_vue_type_script_setup_true_lang.js");
var _vaYearPickerVueVueTypeScriptSetupTrueLangJs = require("./components/VaYearPicker/VaYearPicker.vue_vue_type_script_setup_true_lang.js");
var _useChildComponentsJs = require("../../composables/useChildComponents.js");
var _extractComponentOptionsJs = require("../../utils/component-options/extract-component-options.js");
var _indexJs = require("../va-button/index.js");
var _useStatefulJs = require("../../composables/useStateful.js");
var _useColorsJs = require("../../composables/useColors.js");
var _filterPropsJs = require("../../utils/component-options/filter-props.js");
var _vaDatePickerCss = require("../../../VaDatePicker.css");
const _hoisted_1 = {
    class: "va-date-picker__picker-wrapper"
};
const DEFAULT_MONTH_NAMES = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
];
const DEFAULT_WEEKDAY_NAMES = [
    "SU",
    "MO",
    "TU",
    "WE",
    "TH",
    "FR",
    "SA"
];
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaDatePicker",
    __name: "VaDatePicker",
    props: {
        ...(0, _useChildComponentsJs.d)({
            prevButton: (0, _indexJs.V),
            nextButton: (0, _indexJs.V),
            middleButton: (0, _indexJs.V)
        }),
        ...(0, _useStatefulJs.u),
        ...(0, _useComponentPresetJs.u),
        ...(0, _extractComponentOptionsJs.e)((0, _vaDatePickerHeaderVueVueTypeScriptSetupTrueLangJs._)),
        ...(0, _extractComponentOptionsJs.e)((0, _vaDayPickerVueVueTypeScriptSetupTrueLangJs._)),
        ...(0, _extractComponentOptionsJs.e)((0, _vaMonthPickerVueVueTypeScriptSetupTrueLangJs._)),
        ...(0, _extractComponentOptionsJs.e)((0, _vaYearPickerVueVueTypeScriptSetupTrueLangJs._)),
        modelValue: {
            type: [
                Date,
                Array,
                Object
            ]
        },
        monthNames: {
            type: Array,
            default: DEFAULT_MONTH_NAMES
        },
        weekdayNames: {
            type: Array,
            default: DEFAULT_WEEKDAY_NAMES
        },
        view: {
            type: Object
        },
        type: {
            type: String,
            default: "day"
        },
        readonly: {
            type: Boolean,
            default: false
        },
        disabled: {
            type: Boolean,
            default: false
        },
        // Colors
        color: {
            type: String,
            default: void 0
        },
        weekendsColor: {
            type: String,
            default: void 0
        }
    },
    emits: [
        ...(0, _useStatefulJs.a),
        ...(0, _extractComponentOptionsJs.a)((0, _vaDatePickerHeaderVueVueTypeScriptSetupTrueLangJs._)),
        ...(0, _extractComponentOptionsJs.a)((0, _vaYearPickerVueVueTypeScriptSetupTrueLangJs._)),
        ...(0, _extractComponentOptionsJs.a)((0, _vaDayPickerVueVueTypeScriptSetupTrueLangJs._)),
        ...(0, _extractComponentOptionsJs.a)((0, _vaMonthPickerVueVueTypeScriptSetupTrueLangJs._))
    ],
    setup (__props, { expose: __expose, emit: __emit }) {
        const props = __props;
        (0, _useChildComponentsJs.u)(props);
        const emit = __emit;
        const currentPicker = (0, _vue.ref)();
        const { valueComputed } = (0, _useStatefulJs.b)(props, emit);
        const { syncView } = (0, _viewJs.u)(props, emit, {
            type: props.type
        });
        const classComputed = (0, _vue.computed)(()=>({
                "va-date-picker_without-week-days": props.hideWeekDays,
                "va-date-picker_disabled": props.disabled
            }));
        const onDayModelValueUpdate = (modelValue)=>{
            if (props.readonly) return;
            if (props.type === "day") valueComputed.value = modelValue;
        };
        const onMonthClick = (date)=>{
            emit("click:month", date);
            const year = date.getFullYear();
            const month = date.getMonth();
            if (props.type !== "month") syncView.value = {
                type: "day",
                year,
                month
            };
        };
        const onMonthModelValueUpdate = (modelValue)=>{
            if (props.type === "month") valueComputed.value = modelValue;
        };
        const onYearClick = (date)=>{
            emit("click:year", date);
            const year = date.getFullYear();
            if (props.type !== "year") syncView.value = {
                type: "month",
                year,
                month: syncView.value.month
            };
        };
        const onYearModelValueUpdate = (modelValue)=>{
            if (props.type === "year") valueComputed.value = modelValue;
        };
        const { colorsToCSSVariable } = (0, _useColorsJs.u)();
        const styleComputed = (0, _vue.computed)(()=>({
                ...colorsToCSSVariable({
                    color: props.color,
                    "weekends-color": props.weekendsColor
                }, "va-date-picker")
            }));
        const focusCurrentPicker = ()=>{
            var _a;
            return (_a = currentPicker.value) == null ? void 0 : _a.$el.focus();
        };
        (0, _vue.watch)(syncView, (newValue, prevValue)=>{
            if (newValue.type === prevValue.type) return;
            (0, _vue.nextTick)(focusCurrentPicker);
        });
        const isPickerReadonly = (pickerName)=>{
            return props.readonly && props.type === pickerName;
        };
        const dayPickerProps = (0, _filterPropsJs.f)((0, _extractComponentOptionsJs.e)((0, _vaDayPickerVueVueTypeScriptSetupTrueLangJs._)));
        const headerProps = (0, _filterPropsJs.f)((0, _extractComponentOptionsJs.e)((0, _vaDatePickerHeaderVueVueTypeScriptSetupTrueLangJs._)));
        const monthPickerProps = (0, _filterPropsJs.f)((0, _extractComponentOptionsJs.e)((0, _vaMonthPickerVueVueTypeScriptSetupTrueLangJs._)));
        const yearPickerProps = (0, _filterPropsJs.f)((0, _extractComponentOptionsJs.e)((0, _vaYearPickerVueVueTypeScriptSetupTrueLangJs._)));
        __expose({
            focus: focusCurrentPicker,
            focusCurrentPicker
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: (0, _vue.normalizeClass)([
                    "va-date-picker",
                    classComputed.value
                ]),
                style: (0, _vue.normalizeStyle)(styleComputed.value)
            }, [
                (0, _vue.createVNode)((0, _vaDatePickerHeaderVueVueTypeScriptSetupTrueLangJs._), (0, _vue.mergeProps)((0, _vue.unref)(headerProps), {
                    view: (0, _vue.unref)(syncView),
                    "onUpdate:view": _cache[0] || (_cache[0] = ($event)=>(0, _vue.isRef)(syncView) ? syncView.value = $event : null)
                }), (0, _vue.createSlots)({
                    _: 2
                }, [
                    (0, _vue.renderList)(_ctx.$slots, (_, name)=>{
                        return {
                            name,
                            fn: (0, _vue.withCtx)((bind)=>[
                                    (0, _vue.renderSlot)(_ctx.$slots, name, (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(bind)))
                                ])
                        };
                    })
                ]), 1040, [
                    "view"
                ]),
                (0, _vue.createElementVNode)("div", _hoisted_1, [
                    (0, _vue.unref)(syncView).type === "day" ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vaDayPickerVueVueTypeScriptSetupTrueLangJs._), (0, _vue.mergeProps)({
                        key: 0,
                        ref_key: "currentPicker",
                        ref: currentPicker
                    }, (0, _vue.unref)(dayPickerProps), {
                        "model-value": (0, _vue.unref)(valueComputed),
                        view: (0, _vue.unref)(syncView),
                        readonly: _ctx.$props.disabled || isPickerReadonly("day"),
                        "onUpdate:modelValue": onDayModelValueUpdate,
                        "onHover:day": _cache[1] || (_cache[1] = (value)=>_ctx.$emit("hover:day", value)),
                        "onClick:day": _cache[2] || (_cache[2] = (value)=>_ctx.$emit("click:day", value))
                    }), (0, _vue.createSlots)({
                        _: 2
                    }, [
                        (0, _vue.renderList)(_ctx.$slots, (_, name)=>{
                            return {
                                name,
                                fn: (0, _vue.withCtx)((bind)=>[
                                        (0, _vue.renderSlot)(_ctx.$slots, name, (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(bind)))
                                    ])
                            };
                        })
                    ]), 1040, [
                        "model-value",
                        "view",
                        "readonly"
                    ])) : (0, _vue.createCommentVNode)("", true),
                    (0, _vue.unref)(syncView).type === "month" ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vaMonthPickerVueVueTypeScriptSetupTrueLangJs._), (0, _vue.mergeProps)({
                        key: 1,
                        ref_key: "currentPicker",
                        ref: currentPicker
                    }, (0, _vue.unref)(monthPickerProps), {
                        view: (0, _vue.unref)(syncView),
                        "model-value": (0, _vue.unref)(valueComputed),
                        readonly: _ctx.$props.disabled || isPickerReadonly("month"),
                        "onUpdate:modelValue": onMonthModelValueUpdate,
                        "onHover:month": _cache[3] || (_cache[3] = (value)=>_ctx.$emit("hover:month", value)),
                        "onClick:month": onMonthClick
                    }), (0, _vue.createSlots)({
                        _: 2
                    }, [
                        (0, _vue.renderList)(_ctx.$slots, (_, name)=>{
                            return {
                                name,
                                fn: (0, _vue.withCtx)((bind)=>[
                                        (0, _vue.renderSlot)(_ctx.$slots, name, (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(bind)))
                                    ])
                            };
                        })
                    ]), 1040, [
                        "view",
                        "model-value",
                        "readonly"
                    ])) : (0, _vue.createCommentVNode)("", true),
                    (0, _vue.unref)(syncView).type === "year" ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vaYearPickerVueVueTypeScriptSetupTrueLangJs._), (0, _vue.mergeProps)({
                        key: 2,
                        ref_key: "currentPicker",
                        ref: currentPicker
                    }, (0, _vue.unref)(yearPickerProps), {
                        view: (0, _vue.unref)(syncView),
                        "model-value": (0, _vue.unref)(valueComputed),
                        readonly: _ctx.$props.disabled || isPickerReadonly("year"),
                        "onHover:year": _cache[4] || (_cache[4] = (value)=>_ctx.$emit("hover:year", value)),
                        "onUpdate:modelValue": onYearModelValueUpdate,
                        "onClick:year": onYearClick
                    }), (0, _vue.createSlots)({
                        _: 2
                    }, [
                        (0, _vue.renderList)(_ctx.$slots, (_, name)=>{
                            return {
                                name,
                                fn: (0, _vue.withCtx)((bind)=>[
                                        (0, _vue.renderSlot)(_ctx.$slots, name, (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(bind)))
                                    ])
                            };
                        })
                    ]), 1040, [
                        "view",
                        "model-value",
                        "readonly"
                    ])) : (0, _vue.createCommentVNode)("", true)
                ])
            ], 6);
        };
    }
});

},{"vue":"gzxs9","./hooks/view.js":"90krE","../../composables/useComponentPreset.js":"2HoaT","./components/VaDayPicker/VaDayPicker.vue_vue_type_script_setup_true_lang.js":"1jNib","./components/VaDatePickerHeader/VaDatePickerHeader.vue_vue_type_script_setup_true_lang.js":"jXPho","./components/VaMonthPicker/VaMonthPicker.vue_vue_type_script_setup_true_lang.js":"3w1Lh","./components/VaYearPicker/VaYearPicker.vue_vue_type_script_setup_true_lang.js":"gtPzR","../../composables/useChildComponents.js":"gy3gn","../../utils/component-options/extract-component-options.js":"1ODzH","../va-button/index.js":"2vhcC","../../composables/useStateful.js":"h9zUi","../../composables/useColors.js":"a4Qgv","../../utils/component-options/filter-props.js":"4HycW","../../../VaDatePicker.css":"4C1Eb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"90krE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useView);
var _vue = require("vue");
var _vendorJs = require("../../../../vendor.js");
const JANUARY_MONTH_INDEX = 0;
const DECEMBER_MONTH_INDEX = 11;
const addMonth = (view)=>{
    if (view.month === DECEMBER_MONTH_INDEX) return {
        ...view,
        year: view.year + 1,
        month: JANUARY_MONTH_INDEX
    };
    else return {
        ...view,
        month: view.month + 1
    };
};
const subMonth = (view)=>{
    if (view.month === JANUARY_MONTH_INDEX) return {
        ...view,
        year: view.year - 1,
        month: DECEMBER_MONTH_INDEX
    };
    else return {
        ...view,
        month: view.month - 1
    };
};
const getDefaultDate = (modelValue)=>{
    if ((0, _vendorJs.a)(modelValue)) return modelValue;
    if ((0, _vendorJs.a)(modelValue == null ? void 0 : modelValue.start)) return modelValue.start;
    if (Array.isArray(modelValue) && (0, _vendorJs.a)(modelValue[0])) return modelValue[0];
    return /* @__PURE__ */ new Date();
};
const useView = (props, emit, defaultOverride)=>{
    const defaultDate = getDefaultDate(props.modelValue);
    const defaultView = {
        type: "day",
        year: defaultDate.getFullYear(),
        month: defaultDate.getMonth(),
        ...defaultOverride
    };
    const statefulView = (0, _vue.ref)(defaultView);
    const syncView = (0, _vue.computed)({
        get () {
            return {
                ...statefulView.value,
                ...props.view
            };
        },
        set (view) {
            statefulView.value = view;
            emit("update:view", view);
        }
    });
    const next = ()=>{
        if (syncView.value.type === "day") syncView.value = addMonth(syncView.value);
        else if (syncView.value.type === "month") syncView.value = {
            ...syncView.value,
            year: syncView.value.year + 1
        };
    };
    const prev = ()=>{
        if (syncView.value.type === "day") syncView.value = subMonth(syncView.value);
        else if (syncView.value.type === "month") syncView.value = {
            ...syncView.value,
            year: syncView.value.year - 1
        };
    };
    return {
        syncView,
        next,
        prev
    };
};

},{"vue":"gzxs9","../../../../vendor.js":"l6TAc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1jNib":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vaDatePickerCellVueVueTypeScriptSetupTrueLangJs = require("../VaDatePickerCell.vue_vue_type_script_setup_true_lang.js");
var _gridKeyboardNavigationJs = require("../../hooks/grid-keyboard-navigation.js");
var _usePickerJs = require("../../hooks/use-picker.js");
var _vaDatePickerCalendarHookJs = require("./va-date-picker-calendar-hook.js");
var _vaDayPickerCss = require("../../../../../VaDayPicker.css");
const _hoisted_1 = [
    "onMouseenter"
];
const _hoisted_2 = {
    class: "va-date-picker-cell__day"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaDayPicker",
    __name: "VaDayPicker",
    props: {
        monthNames: {
            type: Array,
            required: true
        },
        weekdayNames: {
            type: Array,
            required: true
        },
        firstWeekday: {
            type: String,
            default: "Sunday"
        },
        hideWeekDays: {
            type: Boolean,
            default: false
        },
        view: {
            type: Object,
            default: ()=>({
                    type: "day"
                })
        },
        modelValue: {
            type: [
                Date,
                Array,
                Object
            ]
        },
        mode: {
            type: String,
            default: "auto"
        },
        showOtherMonths: {
            type: Boolean,
            default: false
        },
        allowedDays: {
            type: Function
        },
        weekends: {
            type: Function
        },
        highlightWeekend: {
            type: Boolean,
            default: false
        },
        highlightToday: {
            type: Boolean,
            default: false
        },
        readonly: {
            type: Boolean,
            default: false
        },
        color: {
            type: String,
            default: "primary"
        }
    },
    emits: [
        "update:modelValue",
        "hover:day",
        "click:day"
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const { firstWeekday, weekdayNames, view } = (0, _vue.toRefs)(props);
        const { calendarDates, currentMonthStartIndex, currentMonthEndIndex } = (0, _vaDatePickerCalendarHookJs.u)(view, {
            firstWeekday
        });
        const weekdayNamesComputed = (0, _vue.computed)(()=>{
            return firstWeekday.value.toLowerCase() === "sunday" ? weekdayNames.value : [
                ...weekdayNames.value.slice(1),
                weekdayNames.value[0]
            ];
        });
        const { hoveredIndex, onClick, isToday, isSelected, isInRange } = (0, _usePickerJs.u)("day", calendarDates, props, emit);
        const gridStartIndex = (0, _vue.computed)(()=>props.showOtherMonths ? 0 : currentMonthStartIndex.value);
        const gridEndIndex = (0, _vue.computed)(()=>props.showOtherMonths ? calendarDates.value.length : currentMonthEndIndex.value);
        const { focusedCellIndex, containerAttributes } = (0, _gridKeyboardNavigationJs.u)({
            rowSize: 7,
            start: gridStartIndex,
            end: gridEndIndex,
            onSelected: (selectedValue)=>onClick(calendarDates.value[selectedValue])
        });
        (0, _vue.watch)(focusedCellIndex, (index)=>{
            hoveredIndex.value = index;
        });
        (0, _vue.watch)(hoveredIndex, (index)=>{
            focusedCellIndex.value = index;
        });
        const isOtherMonth = (date)=>props.view.month !== date.getMonth();
        const isDateDisabled = (date)=>props.allowedDays === void 0 ? false : !props.allowedDays(date);
        const isDateWeekend = (date)=>{
            if (props.weekends === void 0) return date.getDay() === 6 || date.getDay() === 0;
            return props.weekends(date);
        };
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", (0, _vue.mergeProps)({
                class: "va-day-picker"
            }, (0, _vue.unref)(containerAttributes)), [
                !__props.hideWeekDays ? ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                    key: 0
                }, (0, _vue.renderList)(weekdayNamesComputed.value, (weekday)=>{
                    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                        key: weekday,
                        class: "va-day-picker__weekday"
                    }, [
                        (0, _vue.renderSlot)(_ctx.$slots, "weekday", {}, ()=>[
                                (0, _vue.createTextVNode)((0, _vue.toDisplayString)(weekday), 1)
                            ])
                    ]);
                }), 128)) : (0, _vue.createCommentVNode)("", true),
                ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)((0, _vue.unref)(calendarDates), (date, index)=>{
                    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                        class: "va-day-picker__calendar__day-wrapper",
                        key: index,
                        onMouseenter: ($event)=>hoveredIndex.value = index,
                        onMouseleave: _cache[0] || (_cache[0] = ($event)=>hoveredIndex.value = -1)
                    }, [
                        (0, _vue.createVNode)((0, _vaDatePickerCellVueVueTypeScriptSetupTrueLangJs._), {
                            hidden: isOtherMonth(date) && !__props.showOtherMonths,
                            today: (0, _vue.unref)(isToday)(date),
                            selected: (0, _vue.unref)(isSelected)(date),
                            "in-range": (0, _vue.unref)(isInRange)(date),
                            "other-month": isOtherMonth(date),
                            weekend: isDateWeekend(date),
                            disabled: isDateDisabled(date),
                            focused: (0, _vue.unref)(hoveredIndex) === index,
                            "highlight-today": __props.highlightToday,
                            "highlight-weekend": __props.highlightWeekend,
                            readonly: _ctx.$props.readonly,
                            color: __props.color,
                            onClick: ($event)=>{
                                (0, _vue.unref)(onClick)(date);
                                focusedCellIndex.value = index;
                            }
                        }, {
                            default: (0, _vue.withCtx)(()=>[
                                    (0, _vue.createElementVNode)("span", _hoisted_2, [
                                        (0, _vue.renderSlot)(_ctx.$slots, "day", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                            date
                                        })), ()=>[
                                                (0, _vue.createTextVNode)((0, _vue.toDisplayString)(date.getDate()), 1)
                                            ])
                                    ])
                                ]),
                            _: 2
                        }, 1032, [
                            "hidden",
                            "today",
                            "selected",
                            "in-range",
                            "other-month",
                            "weekend",
                            "disabled",
                            "focused",
                            "highlight-today",
                            "highlight-weekend",
                            "readonly",
                            "color",
                            "onClick"
                        ])
                    ], 40, _hoisted_1);
                }), 128))
            ], 16);
        };
    }
});

},{"vue":"gzxs9","../VaDatePickerCell.vue_vue_type_script_setup_true_lang.js":"cpA3e","../../hooks/grid-keyboard-navigation.js":"fKQcp","../../hooks/use-picker.js":"8jT2Q","./va-date-picker-calendar-hook.js":"5xscX","../../../../../VaDayPicker.css":"6jivn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cpA3e":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useColorsJs = require("../../../composables/useColors.js");
var _useTextColorJs = require("../../../composables/useTextColor.js");
var _vaDatePickerCellCss = require("../../../../VaDatePickerCell.css");
const _hoisted_1 = [
    "onKeypress"
];
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaDatePickerCell",
    __name: "VaDatePickerCell",
    props: {
        otherMonth: {
            type: Boolean,
            default: false
        },
        today: {
            type: Boolean,
            default: false
        },
        inRange: {
            type: Boolean,
            default: false
        },
        disabled: {
            type: Boolean,
            default: false
        },
        selected: {
            type: Boolean,
            default: false
        },
        weekend: {
            type: Boolean,
            default: false
        },
        hidden: {
            type: Boolean,
            default: false
        },
        focused: {
            type: Boolean,
            default: false
        },
        highlightWeekend: {
            type: Boolean,
            default: false
        },
        highlightToday: {
            type: Boolean,
            default: false
        },
        readonly: {
            type: Boolean,
            default: false
        },
        color: {
            type: String,
            default: "primary"
        }
    },
    emits: [
        "click"
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const onClick = ()=>{
            if (!props.disabled) emit("click");
        };
        const { getColor } = (0, _useColorsJs.u)();
        const bg = (0, _vue.computed)(()=>getColor(props.color));
        const { textColorComputed } = (0, _useTextColorJs.u)(bg);
        return (_ctx, _cache)=>{
            return __props.hidden ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                key: 0,
                class: "va-date-picker-cell va-date-picker-cell_clear",
                style: (0, _vue.normalizeStyle)(`--va-bg: ${String(bg.value)};--va-text-color-computed: ${String((0, _vue.unref)(textColorComputed))}`)
            }, null, 4)) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                key: 1,
                class: (0, _vue.normalizeClass)([
                    "va-date-picker-cell",
                    {
                        "va-date-picker-cell_other-month": __props.otherMonth,
                        "va-date-picker-cell_today": __props.highlightToday && __props.today,
                        "va-date-picker-cell_in-range": __props.inRange,
                        "va-date-picker-cell_disabled": __props.disabled,
                        "va-date-picker-cell_highlighted-weekend": __props.highlightWeekend && __props.weekend,
                        "va-date-picker-cell_selected": __props.selected,
                        "va-date-picker-cell_focused": __props.focused,
                        "va-date-picker-cell_readonly": __props.readonly
                    }
                ]),
                onClick,
                onKeypress: (0, _vue.withKeys)((0, _vue.withModifiers)(onClick, [
                    "prevent",
                    "stop"
                ]), [
                    "space",
                    "enter"
                ]),
                style: (0, _vue.normalizeStyle)(`--va-bg: ${String(bg.value)};--va-text-color-computed: ${String((0, _vue.unref)(textColorComputed))}`)
            }, [
                (0, _vue.renderSlot)(_ctx.$slots, "default")
            ], 46, _hoisted_1));
        };
    }
});

},{"vue":"gzxs9","../../../composables/useColors.js":"a4Qgv","../../../composables/useTextColor.js":"5pfXb","../../../../VaDatePickerCell.css":"gtpix","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gtpix":[function() {},{}],"fKQcp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useGridKeyboardNavigation);
var _vue = require("vue");
function isUndefined(t) {
    return t === void 0;
}
const useGridKeyboardNavigation = ({ rowSize, start, end, onSelected, onFocusIndex })=>{
    const focusedCellIndex = (0, _vue.ref)(-1);
    let previouslyClicked = false;
    const onMousedown = ()=>{
        previouslyClicked = true;
    };
    const onFocus = ()=>{
        if (previouslyClicked) return;
        previouslyClicked = false;
        const index = onFocusIndex === void 0 ? (0, _vue.unref)(start) || 0 : (0, _vue.unref)(onFocusIndex);
        focusedCellIndex.value = index;
    };
    const onBlur = ()=>{
        previouslyClicked = false;
        focusedCellIndex.value = -1;
    };
    const onKeydown = (e)=>{
        if ([
            "ArrowRight",
            "ArrowLeft",
            "ArrowDown",
            "ArrowUp",
            "Enter",
            "Space"
        ].includes(e.key)) {
            e.preventDefault();
            e.stopPropagation();
        }
        if (e.key === "Enter" || e.key === "Space") {
            if (onSelected === void 0) return;
            onSelected(focusedCellIndex.value);
            return;
        }
        if (e.key === "ArrowRight") focusedCellIndex.value += 1;
        if (e.key === "ArrowLeft") focusedCellIndex.value -= 1;
        if (e.key === "ArrowDown") focusedCellIndex.value += rowSize;
        if (e.key === "ArrowUp") focusedCellIndex.value -= rowSize;
        if (!isUndefined(start) && focusedCellIndex.value < (0, _vue.unref)(start)) focusedCellIndex.value = (0, _vue.unref)(start);
        if (!isUndefined(end) && focusedCellIndex.value > (0, _vue.unref)(end) - 1) focusedCellIndex.value = (0, _vue.unref)(end) - 1;
    };
    const containerAttributes = {
        onFocus,
        onKeydown,
        onBlur,
        onMousedown,
        tabindex: 0
    };
    return {
        focusedCellIndex,
        containerAttributes
    };
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8jT2Q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useDatePicker);
var _vue = require("vue");
var _dateUtilsJs = require("../utils/date-utils.js");
var _modelValueHelperJs = require("./model-value-helper.js");
const getDateEqualFunction = (type)=>{
    return ({
        month: (0, _dateUtilsJs.d),
        day: (0, _dateUtilsJs.e),
        year: (0, _dateUtilsJs.f)
    })[type];
};
const useDatePicker = (type, dates, props, emit)=>{
    const datesEqual = getDateEqualFunction(type);
    const isAllowedDate = props.allowedDays || props.allowedMonths || props.allowedYears;
    const isDateDisabled = (date)=>isAllowedDate === void 0 ? false : !isAllowedDate(date);
    const hoveredIndex = (0, _vue.ref)(-1);
    const hoveredValue = (0, _vue.computed)(()=>dates.value[hoveredIndex.value]);
    const { updateModelValue } = (0, _modelValueHelperJs.u)(props, emit, datesEqual);
    const onClick = (date)=>{
        if (props.readonly || isDateDisabled(date)) return;
        updateModelValue(date);
        emit(`click:${type}`, date);
    };
    const isToday = (date)=>{
        const today = /* @__PURE__ */ new Date();
        return datesEqual(today, date);
    };
    const isSelected = (date)=>{
        if (!props.modelValue) return false;
        if ((0, _dateUtilsJs.b)(props.modelValue)) return datesEqual(props.modelValue, date);
        else if ((0, _dateUtilsJs.a)(props.modelValue)) return !!props.modelValue.find((d)=>datesEqual(d, date));
        else if ((0, _dateUtilsJs.i)(props.modelValue)) return datesEqual(props.modelValue.start, date) || datesEqual(props.modelValue.end, date);
        return false;
    };
    const isInRange = (date)=>{
        if (!props.modelValue) return false;
        if (!(0, _dateUtilsJs.i)(props.modelValue)) return false;
        if (props.modelValue.start && props.modelValue.end) return props.modelValue.start < date && props.modelValue.end > date;
        const selectedDate = props.modelValue.start || props.modelValue.end;
        if (selectedDate) {
            if (!hoveredValue.value) return false;
            return selectedDate < date ? hoveredValue.value >= date : hoveredValue.value <= date;
        }
        return false;
    };
    (0, _vue.watch)(hoveredValue, (date)=>{
        emit(`hover:${type}`, date);
    });
    return {
        hoveredIndex,
        hoveredValue,
        onClick,
        isToday,
        isSelected,
        isInRange
    };
};

},{"vue":"gzxs9","../utils/date-utils.js":"gX2KK","./model-value-helper.js":"7FMom","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7FMom":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useDatePickerModelValue);
var _dateUtilsJs = require("../utils/date-utils.js");
const modeInitialValue = (date, mode)=>{
    if (mode === "single") return date;
    else if (mode === "range") return {
        start: date,
        end: null
    };
    else if (mode === "multiple") return [
        date
    ];
    else if (mode === "auto") return date;
    throw new Error("Unknown mode");
};
const throwIncorrectModelValueError = (modelValue, mode)=>{
    throw Error(`Incorrect modelValue for mode ${mode}. Got ${JSON.stringify(modelValue)}`);
};
const modeFromModelValue = (modelValue)=>{
    if ((0, _dateUtilsJs.b)(modelValue)) return "single";
    else if ((0, _dateUtilsJs.i)(modelValue)) return "range";
    else if ((0, _dateUtilsJs.a)(modelValue)) return "multiple";
    return throwIncorrectModelValueError(modelValue, "auto");
};
const sortRange = (modelValue)=>{
    if (modelValue.start && modelValue.end) {
        if (modelValue.start > modelValue.end) return {
            start: modelValue.end,
            end: modelValue.start
        };
    }
    return modelValue;
};
const useDatePickerModelValue = (props, emit, dateEqual)=>{
    const updateModelValue = (date)=>{
        if (!props.modelValue) {
            emit("update:modelValue", modeInitialValue(date, props.mode));
            return;
        }
        const mode = props.mode === "auto" ? modeFromModelValue(props.modelValue) : props.mode;
        if (mode === "single") {
            if (!(0, _dateUtilsJs.b)(props.modelValue)) return throwIncorrectModelValueError(props.modelValue, mode);
            emit("update:modelValue", date);
        } else if (mode === "range") {
            if (!(0, _dateUtilsJs.i)(props.modelValue)) return throwIncorrectModelValueError(props.modelValue, mode);
            if (props.modelValue.end && dateEqual(props.modelValue.end, date)) return emit("update:modelValue", {
                start: props.modelValue.start,
                end: null
            });
            if (props.modelValue.start && dateEqual(props.modelValue.start, date)) return emit("update:modelValue", {
                start: null,
                end: props.modelValue.end
            });
            if (props.modelValue.end === null) return emit("update:modelValue", sortRange({
                start: props.modelValue.start,
                end: date
            }));
            if (props.modelValue.start === null) return emit("update:modelValue", sortRange({
                end: props.modelValue.end,
                start: date
            }));
            emit("update:modelValue", {
                start: date,
                end: null
            });
        } else if (mode === "multiple") {
            if (!(0, _dateUtilsJs.a)(props.modelValue)) return throwIncorrectModelValueError(props.modelValue, mode);
            const isDatesIncludesDate = !!props.modelValue.find((d)=>dateEqual(d, date));
            if (isDatesIncludesDate) emit("update:modelValue", props.modelValue.filter((d)=>!dateEqual(d, date)));
            else emit("update:modelValue", [
                ...props.modelValue,
                date
            ].sort((a, b)=>a.getTime() - b.getTime()));
        }
    };
    return {
        updateModelValue
    };
};

},{"../utils/date-utils.js":"gX2KK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5xscX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useVaDatePickerCalendar);
var _vue = require("vue");
const getMonthDaysCount = (year, month)=>new Date(year, month + 1, 0).getDate();
const getMonthStartWeekday = (year, month)=>new Date(year, month, 1).getDay();
const getNumbersArray = (length)=>Array.from(Array(length).keys()).map((k)=>k + 1);
const useVaDatePickerCalendar = (view, options)=>{
    const CALENDAR_ROWS_COUNT = 6;
    const localizeWeekday = (weekdayNumber)=>{
        var _a;
        if (!options || !((_a = options.firstWeekday) == null ? void 0 : _a.value)) return weekdayNumber;
        if (options.firstWeekday.value.toLowerCase() === "monday") return weekdayNumber === 0 ? 6 : weekdayNumber - 1;
        return weekdayNumber;
    };
    const currentMonthStartWeekday = (0, _vue.computed)(()=>localizeWeekday(getMonthStartWeekday(view.value.year, view.value.month)));
    const getPreviousDates = ()=>{
        if (currentMonthStartWeekday.value === 0) return [];
        const prevMonthDaysCount = getMonthDaysCount(view.value.year, view.value.month - 1);
        const prevMonthDays = getNumbersArray(prevMonthDaysCount);
        return prevMonthDays.slice(-currentMonthStartWeekday.value).map((d)=>new Date(view.value.year, view.value.month - 1, d));
    };
    const getCurrentDates = ()=>{
        const currentMonthDays = getNumbersArray(getMonthDaysCount(view.value.year, view.value.month));
        return currentMonthDays.map((d)=>new Date(view.value.year, view.value.month, d));
    };
    const prevAndCurrentDays = (0, _vue.computed)(()=>[
            ...getPreviousDates(),
            ...getCurrentDates()
        ]);
    const currentMonthEndIndex = (0, _vue.computed)(()=>prevAndCurrentDays.value.length);
    const calendarDates = (0, _vue.computed)(()=>{
        const days = prevAndCurrentDays.value;
        const daysRemaining = 7 * CALENDAR_ROWS_COUNT - days.length;
        const nextMonthDaysCount = getMonthDaysCount(view.value.year, view.value.month + 1);
        const nextMonthDays = getNumbersArray(nextMonthDaysCount);
        return [
            ...days,
            ...nextMonthDays.slice(0, daysRemaining).map((d)=>new Date(view.value.year, view.value.month + 1, d))
        ];
    });
    return {
        calendarDates,
        currentMonthStartIndex: currentMonthStartWeekday,
        currentMonthEndIndex
    };
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6jivn":[function() {},{}],"jXPho":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _viewJs = require("../../hooks/view.js");
var _indexJs = require("../../../va-button/index.js");
var _useElementTextColorJs = require("../../../../composables/useElementTextColor.js");
var _useElementBackgroundJs = require("../../../../composables/useElementBackground.js");
var _useCurrentElementJs = require("../../../../composables/useCurrentElement.js");
var _useTranslationJs = require("../../../../composables/useTranslation.js");
var _vaDatePickerHeaderCss = require("../../../../../VaDatePickerHeader.css");
const _hoisted_1 = {
    key: 0,
    class: "va-date-picker-header va-date-picker__header"
};
const _hoisted_2 = {
    class: "va-date-picker__header__text"
};
const _hoisted_3 = {
    class: "va-date-picker__header__month"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaDatePickerHeader",
    __name: "VaDatePickerHeader",
    props: {
        monthNames: {
            type: Array,
            required: true
        },
        view: {
            type: Object
        },
        color: {
            type: String
        },
        disabled: {
            type: Boolean,
            default: false
        },
        ariaNextPeriodLabel: {
            type: String,
            default: "$t:nextPeriod"
        },
        ariaPreviousPeriodLabel: {
            type: String,
            default: "$t:previousPeriod"
        },
        ariaSwitchViewLabel: {
            type: String,
            default: "$t:switchView"
        }
    },
    emits: [
        "update:view"
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const { syncView, prev, next } = (0, _viewJs.u)(props, emit);
        const switchView = ()=>{
            if (syncView.value.type === "day") syncView.value = {
                ...syncView.value,
                type: "month"
            };
            else if (syncView.value.type === "month") syncView.value = {
                ...syncView.value,
                type: "year"
            };
        };
        const changeView = (view)=>{
            syncView.value = view;
        };
        const currentColor = (0, _useElementTextColorJs.u)((0, _useElementBackgroundJs.u)((0, _useCurrentElementJs.u)()));
        const { tp } = (0, _useTranslationJs.u)();
        return (_ctx, _cache)=>{
            return (0, _vue.unref)(syncView).type !== "year" ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_1, [
                (0, _vue.renderSlot)(_ctx.$slots, "buttonPrev", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                    onClick: (0, _vue.unref)(prev)
                })), ()=>[
                        (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs.V)), {
                            "va-child": "prevButton",
                            disabled: _ctx.$props.disabled,
                            icon: "va-arrow-left",
                            preset: "plain",
                            size: "small",
                            color: __props.color,
                            textColor: (0, _vue.unref)(currentColor),
                            "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaPreviousPeriodLabel),
                            round: "",
                            onClick: (0, _vue.unref)(prev)
                        }, null, 8, [
                            "disabled",
                            "color",
                            "textColor",
                            "aria-label",
                            "onClick"
                        ])
                    ]),
                (0, _vue.createElementVNode)("div", _hoisted_2, [
                    (0, _vue.renderSlot)(_ctx.$slots, "header", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                        year: (0, _vue.unref)(syncView).year,
                        month: (0, _vue.unref)(syncView).month,
                        monthNames: __props.monthNames,
                        view: (0, _vue.unref)(syncView),
                        changeView,
                        switchView
                    })), ()=>[
                            (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs.V)), {
                                "va-child": "middleButton",
                                disabled: _ctx.$props.disabled,
                                preset: "plain",
                                size: "small",
                                color: __props.color,
                                textColor: (0, _vue.unref)(currentColor),
                                "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaSwitchViewLabel),
                                onClick: switchView
                            }, {
                                default: (0, _vue.withCtx)(()=>[
                                        (0, _vue.renderSlot)(_ctx.$slots, "year", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                            year: (0, _vue.unref)(syncView).year
                                        })), ()=>[
                                                (0, _vue.createTextVNode)((0, _vue.toDisplayString)((0, _vue.unref)(syncView).year), 1)
                                            ]),
                                        (0, _vue.unref)(syncView).type === "day" ? (0, _vue.renderSlot)(_ctx.$slots, "month", (0, _vue.normalizeProps)((0, _vue.mergeProps)({
                                            key: 0
                                        }, {
                                            month: (0, _vue.unref)(syncView).month
                                        })), ()=>[
                                                (0, _vue.createElementVNode)("span", _hoisted_3, (0, _vue.toDisplayString)(__props.monthNames[(0, _vue.unref)(syncView).month]), 1)
                                            ]) : (0, _vue.createCommentVNode)("", true)
                                    ]),
                                _: 3
                            }, 8, [
                                "disabled",
                                "color",
                                "textColor",
                                "aria-label"
                            ])
                        ])
                ]),
                (0, _vue.renderSlot)(_ctx.$slots, "buttonNext", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                    onClick: (0, _vue.unref)(next)
                })), ()=>[
                        (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs.V)), {
                            "va-child": "nextButton",
                            disabled: _ctx.$props.disabled,
                            icon: "va-arrow-right",
                            preset: "plain",
                            size: "small",
                            color: __props.color,
                            textColor: (0, _vue.unref)(currentColor),
                            "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaNextPeriodLabel),
                            onClick: (0, _vue.unref)(next),
                            round: ""
                        }, null, 8, [
                            "disabled",
                            "color",
                            "textColor",
                            "aria-label",
                            "onClick"
                        ])
                    ])
            ])) : (0, _vue.createCommentVNode)("", true);
        };
    }
});

},{"vue":"gzxs9","../../hooks/view.js":"90krE","../../../va-button/index.js":"2vhcC","../../../../composables/useElementTextColor.js":"kLVMS","../../../../composables/useElementBackground.js":"8MRId","../../../../composables/useCurrentElement.js":"iOsak","../../../../composables/useTranslation.js":"7S3aV","../../../../../VaDatePickerHeader.css":"3DaRk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3DaRk":[function() {},{}],"3w1Lh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vaDatePickerCellVueVueTypeScriptSetupTrueLangJs = require("../VaDatePickerCell.vue_vue_type_script_setup_true_lang.js");
var _gridKeyboardNavigationJs = require("../../hooks/grid-keyboard-navigation.js");
var _usePickerJs = require("../../hooks/use-picker.js");
var _vaMonthPickerCss = require("../../../../../VaMonthPicker.css");
const _hoisted_1 = [
    "onMouseenter"
];
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaMonthPicker",
    __name: "VaMonthPicker",
    props: {
        modelValue: {
            type: [
                Date,
                Array,
                Object
            ]
        },
        monthNames: {
            type: Array,
            required: true
        },
        view: {
            type: Object,
            default: ()=>({
                    type: "month"
                })
        },
        allowedMonths: {
            type: Function,
            default: void 0
        },
        highlightToday: {
            type: Boolean,
            default: true
        },
        mode: {
            type: String,
            default: "auto"
        },
        readonly: {
            type: Boolean,
            default: false
        },
        color: {
            type: String,
            default: "primary"
        }
    },
    emits: [
        "update:modelValue",
        "hover:month",
        "click:month"
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const { view } = (0, _vue.toRefs)(props);
        const months = (0, _vue.computed)(()=>Array.from(Array(12).keys()).map((month)=>new Date(view.value.year, month)));
        const { hoveredIndex, onClick, isToday, isSelected, isInRange } = (0, _usePickerJs.u)("month", months, props, emit);
        const isDisabled = (date)=>props.allowedMonths === void 0 ? false : !props.allowedMonths(date);
        const { focusedCellIndex, containerAttributes } = (0, _gridKeyboardNavigationJs.u)({
            rowSize: 3,
            start: 0,
            end: months.value.length,
            onSelected: (selectedIndex)=>onClick(months.value[selectedIndex])
        });
        (0, _vue.watch)(focusedCellIndex, (index)=>{
            hoveredIndex.value = index;
        });
        (0, _vue.watch)(hoveredIndex, (index)=>{
            focusedCellIndex.value = index;
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", (0, _vue.mergeProps)({
                class: "va-month-picker"
            }, (0, _vue.unref)(containerAttributes)), [
                ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)(months.value, (month, monthIndex)=>{
                    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                        key: monthIndex,
                        class: "va-month-picker__month-wrapper",
                        onMouseenter: ($event)=>hoveredIndex.value = monthIndex,
                        onMouseleave: _cache[0] || (_cache[0] = ($event)=>hoveredIndex.value = -1)
                    }, [
                        (0, _vue.createVNode)((0, _vaDatePickerCellVueVueTypeScriptSetupTrueLangJs._), {
                            "in-range": !!(0, _vue.unref)(isInRange)(month),
                            selected: !!(0, _vue.unref)(isSelected)(month),
                            disabled: !!isDisabled(month),
                            today: !!(0, _vue.unref)(isToday)(month),
                            focused: (0, _vue.unref)(hoveredIndex) === monthIndex,
                            "highlight-today": __props.highlightToday,
                            readonly: _ctx.$props.readonly,
                            color: __props.color,
                            onClick: ($event)=>{
                                (0, _vue.unref)(onClick)(month);
                                focusedCellIndex.value = monthIndex;
                            }
                        }, {
                            default: (0, _vue.withCtx)(()=>[
                                    (0, _vue.renderSlot)(_ctx.$slots, "month", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                        monthIndex,
                                        month: __props.monthNames[monthIndex]
                                    })), ()=>[
                                            (0, _vue.createTextVNode)((0, _vue.toDisplayString)(__props.monthNames[monthIndex]), 1)
                                        ])
                                ]),
                            _: 2
                        }, 1032, [
                            "in-range",
                            "selected",
                            "disabled",
                            "today",
                            "focused",
                            "highlight-today",
                            "readonly",
                            "color",
                            "onClick"
                        ])
                    ], 40, _hoisted_1);
                }), 128))
            ], 16);
        };
    }
});

},{"vue":"gzxs9","../VaDatePickerCell.vue_vue_type_script_setup_true_lang.js":"cpA3e","../../hooks/grid-keyboard-navigation.js":"fKQcp","../../hooks/use-picker.js":"8jT2Q","../../../../../VaMonthPicker.css":"bSlME","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bSlME":[function() {},{}],"gtPzR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vaDatePickerCellVueVueTypeScriptSetupTrueLangJs = require("../VaDatePickerCell.vue_vue_type_script_setup_true_lang.js");
var _dateUtilsJs = require("../../utils/date-utils.js");
var _gridKeyboardNavigationJs = require("../../hooks/grid-keyboard-navigation.js");
var _usePickerJs = require("../../hooks/use-picker.js");
var _vaYearPickerCss = require("../../../../../VaYearPicker.css");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaYearPicker",
    __name: "VaYearPicker",
    props: {
        modelValue: {
            type: [
                Date,
                Array,
                Object
            ]
        },
        allowedYears: {
            type: Function,
            default: void 0
        },
        highlightToday: {
            type: Boolean,
            default: true
        },
        startYear: {
            type: Number,
            default: 1970
        },
        mode: {
            type: String,
            default: "auto"
        },
        view: {
            type: Object,
            default: ()=>({
                    type: "year"
                })
        },
        endYear: {
            type: Number,
            default: ()=>/* @__PURE__ */ new Date().getFullYear() + 50
        },
        readonly: {
            type: Boolean,
            default: false
        },
        color: {
            type: String,
            default: "primary"
        }
    },
    emits: [
        "update:modelValue",
        "hover:year",
        "click:year"
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const rootNode = (0, _vue.shallowRef)();
        const { view } = (0, _vue.toRefs)(props);
        const generateYearsArray = (start, end)=>{
            const yearsCount = end - start + 1;
            return Array.from(Array(yearsCount).keys()).map((i)=>(0, _dateUtilsJs.c)(start + i));
        };
        const years = (0, _vue.computed)(()=>generateYearsArray(props.startYear, props.endYear));
        const scrollIntoYearIndex = (index)=>{
            if (!rootNode.value) return;
            const scrollHeight = rootNode.value.scrollHeight;
            const rootNodeHeight = rootNode.value.offsetHeight;
            const currentYearOffset = scrollHeight / years.value.length * index;
            const cellSize = scrollHeight / years.value.length;
            const relativeScrollPosition = currentYearOffset - rootNode.value.scrollTop;
            if (relativeScrollPosition < 0) rootNode.value.scrollTo({
                top: currentYearOffset
            });
            else if (relativeScrollPosition > rootNodeHeight) rootNode.value.scrollTo({
                top: currentYearOffset - rootNodeHeight + cellSize
            });
        };
        const scrollIntoYearIndexCenter = (index)=>{
            if (!rootNode.value) return;
            const scrollHeight = rootNode.value.scrollHeight;
            const rootNodeHeight = rootNode.value.offsetHeight;
            const currentYearOffset = scrollHeight / years.value.length * index;
            rootNode.value.scrollTo({
                top: currentYearOffset - rootNodeHeight / 2
            });
        };
        (0, _vue.onMounted)(()=>{
            const currentYearIndex = years.value.findIndex((date)=>date.getFullYear() === view.value.year);
            scrollIntoYearIndexCenter(currentYearIndex);
        });
        const { hoveredIndex, onClick, isToday, isSelected, isInRange } = (0, _usePickerJs.u)("year", years, props, emit);
        const isYearDisabled = (year)=>props.allowedYears === void 0 ? false : !props.allowedYears(year);
        const { focusedCellIndex, containerAttributes } = (0, _gridKeyboardNavigationJs.u)({
            rowSize: 1,
            start: 0,
            end: years.value.length,
            onFocusIndex: (0, _vue.computed)(()=>years.value.findIndex((date)=>date.getFullYear() === view.value.year)),
            onSelected: (selectedIndex)=>onClick(years.value[selectedIndex])
        });
        (0, _vue.watch)(focusedCellIndex, (index)=>index !== -1 && scrollIntoYearIndex(index));
        (0, _vue.watch)(focusedCellIndex, (index)=>{
            hoveredIndex.value = index;
        });
        (0, _vue.watch)(hoveredIndex, (index)=>{
            focusedCellIndex.value = index;
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", (0, _vue.mergeProps)({
                ref_key: "rootNode",
                ref: rootNode,
                class: "va-year-picker"
            }, (0, _vue.unref)(containerAttributes), {
                onKeydown: _cache[1] || (_cache[1] = (0, _vue.withKeys)((0, _vue.withModifiers)(()=>{}, [
                    "prevent"
                ]), [
                    "space"
                ]))
            }), [
                ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)(years.value, (year, index)=>{
                    return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vaDatePickerCellVueVueTypeScriptSetupTrueLangJs._), {
                        key: year.toString(),
                        "in-range": (0, _vue.unref)(isInRange)(year),
                        selected: (0, _vue.unref)(isSelected)(year),
                        disabled: isYearDisabled(year),
                        today: (0, _vue.unref)(isToday)(year),
                        focused: (0, _vue.unref)(focusedCellIndex) === index,
                        "highlight-today": __props.highlightToday,
                        readonly: _ctx.$props.readonly,
                        color: __props.color,
                        onClick: ($event)=>{
                            (0, _vue.unref)(onClick)(year);
                            focusedCellIndex.value = index;
                        },
                        onMouseenter: ($event)=>hoveredIndex.value = index,
                        onMouseleave: _cache[0] || (_cache[0] = ($event)=>hoveredIndex.value = -1)
                    }, {
                        default: (0, _vue.withCtx)(()=>[
                                (0, _vue.createTextVNode)((0, _vue.toDisplayString)(year.getFullYear()), 1)
                            ]),
                        _: 2
                    }, 1032, [
                        "in-range",
                        "selected",
                        "disabled",
                        "today",
                        "focused",
                        "highlight-today",
                        "readonly",
                        "color",
                        "onClick",
                        "onMouseenter"
                    ]);
                }), 128))
            ], 16);
        };
    }
});

},{"vue":"gzxs9","../VaDatePickerCell.vue_vue_type_script_setup_true_lang.js":"cpA3e","../../utils/date-utils.js":"gX2KK","../../hooks/grid-keyboard-navigation.js":"fKQcp","../../hooks/use-picker.js":"8jT2Q","../../../../../VaYearPicker.css":"3Lhqt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3Lhqt":[function() {},{}],"4C1Eb":[function() {},{}],"iz6O5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useDropdownableEmits);
parcelHelpers.export(exports, "b", ()=>useDropdownable);
parcelHelpers.export(exports, "u", ()=>useDropdownableProps);
var _vue = require("vue");
var _useSyncPropJs = require("./useSyncProp.js");
var _indexJs = require("../components/va-dropdown/index.js");
var _extractComponentOptionsJs = require("../utils/component-options/extract-component-options.js");
var _filterPropsJs = require("../utils/component-options/filter-props.js");
const VaDropdownProps = (0, _extractComponentOptionsJs.e)((0, _indexJs.V), [
    "innerAnchorSelector",
    "stateful",
    "keyboardNavigation",
    "modelValue"
]);
const useDropdownableProps = {
    ...VaDropdownProps,
    modelValue: {},
    /**
   * Close dropdown on value updated.
   * @default null - behavior controlled by component
   */ closeOnChange: {
        type: Boolean,
        default: null
    },
    isOpen: {
        type: Boolean,
        default: void 0
    }
};
const useDropdownableEmits = [
    "update:isOpen"
];
const useDropdownable = function(props, emit, options = {}) {
    const [isOpenSync] = (0, _useSyncPropJs.u)("isOpen", props, emit, false);
    const doWatch = (0, _vue.computed)(()=>props.closeOnChange !== null ? props.closeOnChange : (0, _vue.unref)(options.defaultCloseOnValueUpdate || false));
    (0, _vue.watch)(()=>props.modelValue, ()=>{
        if (doWatch.value) isOpenSync.value = false;
    });
    return {
        dropdownProps: (0, _filterPropsJs.f)(VaDropdownProps),
        isOpenSync
    };
};

},{"vue":"gzxs9","./useSyncProp.js":"3q1sU","../components/va-dropdown/index.js":"2ag98","../utils/component-options/extract-component-options.js":"1ODzH","../utils/component-options/filter-props.js":"4HycW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lGJau":[function() {},{}],"2GBIc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaDatePicker);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaDatePickerVueVueTypeScriptSetupTrueLangJs = require("./VaDatePicker.vue_vue_type_script_setup_true_lang.js");
const VaDatePicker = (0, _withConfigTransportJs.w)((0, _vaDatePickerVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaDatePicker.vue_vue_type_script_setup_true_lang.js":"hY7Wl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"wiQvd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaDivider);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaDividerVueVueTypeScriptSetupTrueLangJs = require("./VaDivider.vue_vue_type_script_setup_true_lang.js");
const VaDivider = (0, _withConfigTransportJs.w)((0, _vaDividerVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaDivider.vue_vue_type_script_setup_true_lang.js":"kkC4e","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kkC4e":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useColorsJs = require("../../composables/useColors.js");
var _vaDividerCss = require("../../../VaDivider.css");
const _hoisted_1 = [
    "aria-orientation"
];
const _hoisted_2 = {
    key: 0,
    class: "va-divider__text"
};
const prefixClass = "va-divider";
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaDivider",
    __name: "VaDivider",
    props: {
        ...(0, _useComponentPresetJs.u),
        vertical: {
            type: Boolean,
            default: false
        },
        dashed: {
            type: Boolean,
            default: false
        },
        inset: {
            type: Boolean,
            default: false
        },
        orientation: {
            type: String,
            default: "center",
            validator: (value)=>[
                    "left",
                    "right",
                    "center"
                ].includes(value)
        },
        color: {
            type: String,
            default: "backgroundBorder"
        }
    },
    setup (__props) {
        const props = __props;
        const { getColor } = (0, _useColorsJs.u)();
        const colorComputed = (0, _vue.computed)(()=>getColor(props.color));
        const slots = (0, _vue.useSlots)();
        const hasSlot = (0, _vue.computed)(()=>!!slots.default);
        const classComputed = (0, _vue.computed)(()=>({
                [`${prefixClass}--vertical`]: props.vertical,
                [`${prefixClass}--inset`]: props.inset,
                [`${prefixClass}--${props.orientation}`]: props.orientation && !props.vertical,
                [`${prefixClass}--dashed`]: props.dashed
            }));
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                role: "separator",
                class: (0, _vue.normalizeClass)([
                    "va-divider",
                    classComputed.value
                ]),
                "aria-orientation": __props.vertical ? "vertical" : "horizontal",
                "aria-hidden": true,
                style: (0, _vue.normalizeStyle)(`--va-color-computed: ${String(colorComputed.value)}`)
            }, [
                hasSlot.value && !__props.vertical ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_2, [
                    (0, _vue.renderSlot)(_ctx.$slots, "default")
                ])) : (0, _vue.createCommentVNode)("", true)
            ], 14, _hoisted_1);
        };
    }
});

},{"vue":"gzxs9","../../composables/useComponentPreset.js":"2HoaT","../../composables/useColors.js":"a4Qgv","../../../VaDivider.css":"37FCr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"37FCr":[function() {},{}],"8rtbN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaFileUpload);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaFileUploadVueVueTypeScriptSetupTrueLangJs = require("./VaFileUpload.vue_vue_type_script_setup_true_lang.js");
const VaFileUpload = (0, _withConfigTransportJs.w)((0, _vaFileUploadVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaFileUpload.vue_vue_type_script_setup_true_lang.js":"5Xczp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5Xczp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _typesJs = require("./types.js");
var _indexJs = require("./VaFileUploadList/index.js");
var _vaModalJs = require("../va-modal/VaModal.js");
var _extractComponentOptionsJs = require("../../utils/component-options/extract-component-options.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useColorsJs = require("../../composables/useColors.js");
var _useBemJs = require("../../composables/useBem.js");
var _useTranslationJs = require("../../composables/useTranslation.js");
var _filterPropsJs = require("../../utils/component-options/filter-props.js");
var _indexJs1 = require("../va-button/index.js");
var _vaFileUploadCss = require("../../../VaFileUpload.css");
const _hoisted_1 = {
    class: "va-file-upload__field"
};
const _hoisted_2 = {
    key: 0,
    class: "va-file-upload__field__text"
};
const _hoisted_3 = [
    "accept",
    "multiple",
    "disabled"
];
const VaFileUploadListProps = (0, _extractComponentOptionsJs.e)((0, _indexJs.V));
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaFileUpload",
    __name: "VaFileUpload",
    props: {
        ...(0, _useComponentPresetJs.u),
        ...VaFileUploadListProps,
        fileTypes: {
            type: String,
            default: ""
        },
        dropzone: {
            type: Boolean,
            default: false
        },
        hideFileList: {
            type: Boolean,
            default: false
        },
        color: {
            type: String,
            default: "primary"
        },
        disabled: {
            type: Boolean,
            default: false
        },
        undo: {
            type: Boolean,
            default: false
        },
        undoDuration: {
            type: Number,
            default: 3e3
        },
        undoButtonText: {
            type: String,
            default: "$t:undo"
        },
        dropZoneText: {
            type: String,
            default: "$t:dropzone"
        },
        uploadButtonText: {
            type: String,
            default: "$t:uploadFile"
        },
        deletedFileMessage: {
            type: String,
            default: "$t:fileDeleted"
        },
        modelValue: {
            type: [
                Object,
                Array
            ],
            default: ()=>[]
        },
        type: {
            type: String,
            default: "list",
            validator: (value)=>[
                    "list",
                    "gallery",
                    "single"
                ].includes(value)
        }
    },
    emits: [
        "update:modelValue",
        "file-removed",
        "file-added"
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const fileInputRef = (0, _vue.shallowRef)();
        const modal = (0, _vue.ref)(false);
        const dropzoneHighlight = (0, _vue.ref)(false);
        const { getColor, shiftHSLAColor } = (0, _useColorsJs.u)();
        const colorComputed = (0, _vue.computed)(()=>getColor(props.color));
        const computedStyle = (0, _vue.computed)(()=>({
                backgroundColor: props.dropzone ? shiftHSLAColor(colorComputed.value, {
                    a: dropzoneHighlight.value ? -0.82 : -0.92
                }) : "transparent"
            }));
        const computedClasses = (0, _useBemJs.u)("va-file-upload", ()=>({
                dropzone: props.dropzone,
                disabled: props.disabled
            }));
        const files = (0, _vue.computed)({
            get () {
                return Array.isArray(props.modelValue) ? props.modelValue : [
                    props.modelValue
                ];
            },
            set (files2) {
                if (props.type === "single") emit("update:modelValue", files2[0]);
                else emit("update:modelValue", files2);
            }
        });
        const filterInvalidFiles = (files2)=>files2.filter((file)=>{
                const fileName = file.name || file.url;
                if (!fileName) return false;
                if (file.url) return true;
                const MIMETypes = [
                    "audio/*",
                    "video/*",
                    "image/*"
                ];
                const isContainedMIMEType = MIMETypes.find((t)=>props.fileTypes.includes(t));
                if (isContainedMIMEType) return true;
                const extension = fileName.substring(fileName.lastIndexOf(".") + 1).toLowerCase();
                const isCorrectExt = props.fileTypes.includes(extension);
                if (!isCorrectExt) modal.value = true;
                return isCorrectExt;
            });
        const uploadFile = (e)=>{
            var _a, _b;
            const f = ((_a = e.target) == null ? void 0 : _a.files) || ((_b = e.dataTransfer) == null ? void 0 : _b.files);
            if (!f) return;
            const validatedFiles = props.fileTypes ? filterInvalidFiles(Array.from(f)) : f;
            files.value = props.type === "single" ? validatedFiles : [
                ...files.value,
                ...validatedFiles
            ];
            emit("file-added", validatedFiles);
        };
        const changeFieldValue = (e)=>{
            uploadFile(e);
            if (fileInputRef.value) fileInputRef.value.value = "";
        };
        const removeFile = (index)=>{
            if (index in files.value) {
                const removedFile = files.value[index];
                files.value = files.value.filter((item, idx)=>idx !== index);
                emit("file-removed", removedFile);
            }
        };
        const removeSingleFile = ()=>{
            if (files.value.length > 0) {
                const removedFile = files.value[0];
                files.value = [];
                emit("file-removed", removedFile);
            }
        };
        const callFileDialogue = ()=>{
            if (fileInputRef.value) fileInputRef.value.click();
        };
        (0, _vue.onMounted)(()=>{
            if (Array.isArray(files.value)) {
                const filteredFiles = filterInvalidFiles(files.value);
                if (filteredFiles.length !== files.value.length) files.value = filteredFiles;
            }
        });
        const { tp } = (0, _useTranslationJs.u)();
        (0, _vue.provide)((0, _typesJs.V), {
            undo: (0, _vue.toRef)(props, "undo"),
            disabled: (0, _vue.toRef)(props, "disabled"),
            undoDuration: (0, _vue.toRef)(props, "undoDuration"),
            undoButtonText: (0, _vue.computed)(()=>tp(props.undoButtonText)),
            deletedFileMessage: (0, _vue.computed)(()=>tp(props.deletedFileMessage))
        });
        const fileUploadListProps = (0, _filterPropsJs.f)(VaFileUploadListProps);
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: (0, _vue.normalizeClass)([
                    "va-file-upload",
                    (0, _vue.unref)(computedClasses)
                ]),
                style: (0, _vue.normalizeStyle)(computedStyle.value)
            }, [
                (0, _vue.renderSlot)(_ctx.$slots, "default", {}, ()=>[
                        (0, _vue.createElementVNode)("div", _hoisted_1, [
                            __props.dropzone ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_2, (0, _vue.toDisplayString)((0, _vue.unref)(tp)(__props.dropZoneText)), 1)) : (0, _vue.createCommentVNode)("", true),
                            (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs1.V)), {
                                class: "va-file-upload__field__button",
                                disabled: __props.disabled,
                                "aria-disabled": __props.disabled,
                                color: colorComputed.value,
                                style: (0, _vue.normalizeStyle)({
                                    "pointer-events": dropzoneHighlight.value ? "none" : void 0
                                }),
                                onChange: changeFieldValue,
                                onClick: callFileDialogue
                            }, {
                                default: (0, _vue.withCtx)(()=>[
                                        (0, _vue.createTextVNode)((0, _vue.toDisplayString)((0, _vue.unref)(tp)(__props.uploadButtonText)), 1)
                                    ]),
                                _: 1
                            }, 8, [
                                "disabled",
                                "aria-disabled",
                                "color",
                                "style"
                            ])
                        ])
                    ]),
                (0, _vue.createElementVNode)("input", {
                    ref_key: "fileInputRef",
                    ref: fileInputRef,
                    type: "file",
                    class: "va-file-upload__field__input",
                    tabindex: -1,
                    "aria-hidden": "true",
                    accept: __props.fileTypes,
                    multiple: __props.type !== "single",
                    disabled: __props.disabled,
                    onChange: changeFieldValue,
                    onDragenter: _cache[0] || (_cache[0] = ($event)=>dropzoneHighlight.value = true),
                    onDragleave: _cache[1] || (_cache[1] = ($event)=>dropzoneHighlight.value = false)
                }, null, 40, _hoisted_3),
                files.value.length && !_ctx.$props.hideFileList ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), (0, _vue.mergeProps)({
                    key: 0
                }, (0, _vue.unref)(fileUploadListProps), {
                    type: __props.type,
                    files: files.value,
                    color: colorComputed.value,
                    onRemove: removeFile,
                    onRemoveSingle: removeSingleFile
                }), null, 16, [
                    "type",
                    "files",
                    "color"
                ])) : (0, _vue.createCommentVNode)("", true),
                (0, _vue.createVNode)((0, _vue.unref)((0, _vaModalJs.V)), {
                    modelValue: modal.value,
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event)=>modal.value = $event),
                    "hide-default-actions": "",
                    title: "File validation",
                    message: "File type is incorrect!"
                }, null, 8, [
                    "modelValue"
                ])
            ], 6);
        };
    }
});

},{"vue":"gzxs9","./types.js":"5OjBK","./VaFileUploadList/index.js":"kw9Pp","../va-modal/VaModal.js":"g5tjq","../../utils/component-options/extract-component-options.js":"1ODzH","../../composables/useComponentPreset.js":"2HoaT","../../composables/useColors.js":"a4Qgv","../../composables/useBem.js":"igmjV","../../composables/useTranslation.js":"7S3aV","../../utils/component-options/filter-props.js":"4HycW","../va-button/index.js":"2vhcC","../../../VaFileUpload.css":"85Ljx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5OjBK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaFileUploadKey);
const VaFileUploadKey = Symbol("VaFileUpload");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kw9Pp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaFileUploadList);
var _withConfigTransportJs = require("../../../services/config-transport/withConfigTransport.js");
var _vaFileUploadListVueVueTypeScriptSetupTrueLangJs = require("./VaFileUploadList.vue_vue_type_script_setup_true_lang.js");
const VaFileUploadList = (0, _withConfigTransportJs.w)((0, _vaFileUploadListVueVueTypeScriptSetupTrueLangJs._));

},{"../../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaFileUploadList.vue_vue_type_script_setup_true_lang.js":"4VMP3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4VMP3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _indexJs = require("../VaFileUploadListItem/index.js");
var _indexJs1 = require("../VaFileUploadGalleryItem/index.js");
var _indexJs2 = require("../VaFileUploadSingleItem/index.js");
var _indexJs3 = require("../../va-list/index.js");
var _extractComponentOptionsJs = require("../../../utils/component-options/extract-component-options.js");
var _filterPropsJs = require("../../../utils/component-options/filter-props.js");
var _vaFileUploadListCss = require("../../../../VaFileUploadList.css");
const VaFileUploadGalleryItemProps = (0, _extractComponentOptionsJs.e)((0, _indexJs1.V));
const VaFileUploadListItemProps = (0, _extractComponentOptionsJs.e)((0, _indexJs.V));
const VaFileUploadSingleItemProps = (0, _extractComponentOptionsJs.e)((0, _indexJs2.V));
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaFileUploadList",
    __name: "VaFileUploadList",
    props: {
        type: {
            type: String,
            default: ""
        },
        files: {
            type: Array,
            default: null
        },
        ...VaFileUploadGalleryItemProps,
        ...VaFileUploadListItemProps,
        ...VaFileUploadSingleItemProps
    },
    emits: [
        "remove",
        "removeSingle"
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const filesList = (0, _vue.computed)(()=>props.files.map(convertFile));
        const convertFile = (file)=>({
                name: file.name || file.url || "",
                size: formatSize(file.size),
                date: formatDate(/* @__PURE__ */ new Date()),
                image: file
            });
        const formatSize = (bytes)=>{
            if (bytes === 0) return "0 Bytes";
            if (!bytes) return "";
            const k = 1024;
            const sizes = [
                "Bytes",
                "KB",
                "MB",
                "GB",
                "TB",
                "PB",
                "EB",
                "ZB",
                "YB"
            ];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
        };
        const formatDate = (date = /* @__PURE__ */ new Date())=>{
            return date.toLocaleDateString("en-US", {
                hour: "2-digit",
                minute: "2-digit",
                month: "short",
                day: "numeric",
                year: "numeric"
            });
        };
        const galleryItemProps = (0, _filterPropsJs.f)(VaFileUploadGalleryItemProps);
        const itemProps = (0, _filterPropsJs.f)(VaFileUploadListItemProps);
        const singleItemProps = (0, _filterPropsJs.f)(VaFileUploadSingleItemProps);
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs3.b)), {
                class: (0, _vue.normalizeClass)([
                    "va-file-upload-list",
                    `va-file-upload-list--${__props.type}`
                ]),
                role: __props.type !== "single" ? "list" : void 0
            }, {
                default: (0, _vue.withCtx)(()=>[
                        __props.type === "list" ? ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                            key: 0
                        }, (0, _vue.renderList)(filesList.value, (file, index)=>{
                            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), (0, _vue.mergeProps)({
                                key: file.name
                            }, (0, _vue.unref)(itemProps), {
                                file,
                                role: "listitem",
                                onRemove: ($event)=>_ctx.$emit("remove", index)
                            }), null, 16, [
                                "file",
                                "onRemove"
                            ]);
                        }), 128)) : (0, _vue.createCommentVNode)("", true),
                        __props.type === "gallery" ? ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                            key: 1
                        }, (0, _vue.renderList)(filesList.value, (file, index)=>{
                            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs1.V)), (0, _vue.mergeProps)((0, _vue.unref)(galleryItemProps), {
                                key: file.name,
                                file,
                                role: "listitem",
                                onRemove: ($event)=>_ctx.$emit("remove", index)
                            }), null, 16, [
                                "file",
                                "onRemove"
                            ]);
                        }), 128)) : (0, _vue.createCommentVNode)("", true),
                        __props.type === "single" && filesList.value.length ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs2.V)), (0, _vue.mergeProps)({
                            key: 2
                        }, (0, _vue.unref)(singleItemProps), {
                            file: filesList.value[filesList.value.length - 1],
                            onRemove: _cache[0] || (_cache[0] = ($event)=>_ctx.$emit("removeSingle"))
                        }), null, 16, [
                            "file"
                        ])) : (0, _vue.createCommentVNode)("", true)
                    ]),
                _: 1
            }, 8, [
                "role",
                "class"
            ]);
        };
    }
});

},{"vue":"gzxs9","../VaFileUploadListItem/index.js":"bzMaZ","../VaFileUploadGalleryItem/index.js":"59TQd","../VaFileUploadSingleItem/index.js":"lLoH2","../../va-list/index.js":"iaP6m","../../../utils/component-options/extract-component-options.js":"1ODzH","../../../utils/component-options/filter-props.js":"4HycW","../../../../VaFileUploadList.css":"89Lnv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bzMaZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaFileUploadListItem);
var _withConfigTransportJs = require("../../../services/config-transport/withConfigTransport.js");
var _vaFileUploadListItemVueVueTypeScriptSetupTrueLangJs = require("./VaFileUploadListItem.vue_vue_type_script_setup_true_lang.js");
const VaFileUploadListItem = (0, _withConfigTransportJs.w)((0, _vaFileUploadListItemVueVueTypeScriptSetupTrueLangJs._));

},{"../../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaFileUploadListItem.vue_vue_type_script_setup_true_lang.js":"8CF4O","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8CF4O":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _typesJs = require("../types.js");
var _indexJs = require("../../va-button/index.js");
var _indexJs1 = require("../../va-list/index.js");
var _indexJs2 = require("../VaFileUploadUndo/index.js");
var _useTranslationJs = require("../../../composables/useTranslation.js");
var _useStrictInjectJs = require("../../../composables/useStrictInject.js");
var _useFocusJs = require("../../../composables/useFocus.js");
var _useBemJs = require("../../../composables/useBem.js");
var _vaFileUploadListItemCss = require("../../../../VaFileUploadListItem.css");
const _hoisted_1 = {
    class: "va-file-upload-list-item__content"
};
const _hoisted_2 = {
    key: 0,
    class: "va-file-upload-list-item__name"
};
const _hoisted_3 = {
    class: "va-file-upload-list-item__size"
};
const INJECTION_ERROR_MESSAGE = "The VaFileUploadListItem component should be used in the context of VaFileUpload component";
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaFileUploadListItem",
    __name: "VaFileUploadListItem",
    props: {
        file: {
            type: Object,
            default: null
        },
        color: {
            type: String,
            default: "success"
        },
        ariaRemoveFileLabel: {
            type: String,
            default: "$t:removeFile"
        }
    },
    emits: [
        "remove"
    ],
    setup (__props, { emit: __emit }) {
        const { tp } = (0, _useTranslationJs.u)();
        const emit = __emit;
        const { undo, disabled, undoDuration } = (0, _useStrictInjectJs.u)((0, _typesJs.V), INJECTION_ERROR_MESSAGE);
        const { onFocus, onBlur } = (0, _useFocusJs.u)();
        const removed = (0, _vue.ref)(false);
        const removeFile = ()=>{
            if (undo.value) {
                removed.value = true;
                setTimeout(()=>{
                    if (removed.value) {
                        emit("remove");
                        removed.value = false;
                    }
                }, undoDuration.value ?? 0);
            } else {
                emit("remove");
                removed.value = false;
            }
        };
        const recoverFile = ()=>{
            removed.value = false;
        };
        const computedClasses = (0, _useBemJs.u)("va-file-upload-list-item", ()=>({
                undo: removed.value
            }));
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs1.V)), {
                class: (0, _vue.normalizeClass)([
                    "va-file-upload-list-item",
                    (0, _vue.unref)(computedClasses)
                ]),
                tabindex: "-1",
                disabled: (0, _vue.unref)(disabled),
                "aria-disabled": (0, _vue.unref)(disabled)
            }, {
                default: (0, _vue.withCtx)(()=>[
                        removed.value && (0, _vue.unref)(undo) ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs1.a)), {
                            key: 0
                        }, {
                            default: (0, _vue.withCtx)(()=>[
                                    (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs2.V)), {
                                        onRecover: recoverFile
                                    })
                                ]),
                            _: 1
                        })) : ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs1.a)), {
                            key: 1
                        }, {
                            default: (0, _vue.withCtx)(()=>[
                                    (0, _vue.createElementVNode)("div", _hoisted_1, [
                                        __props.file && __props.file.name ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_2, (0, _vue.toDisplayString)(__props.file && __props.file.name), 1)) : (0, _vue.createCommentVNode)("", true),
                                        (0, _vue.createElementVNode)("div", _hoisted_3, (0, _vue.toDisplayString)(__props.file && __props.file.size), 1),
                                        !(0, _vue.unref)(disabled) ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), {
                                            key: 1,
                                            flat: "",
                                            color: "danger",
                                            icon: "clear",
                                            class: "va-file-upload-list-item__delete",
                                            "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaRemoveFileLabel),
                                            onClick: (0, _vue.withModifiers)(removeFile, [
                                                "stop"
                                            ]),
                                            onKeydown: [
                                                (0, _vue.withKeys)((0, _vue.withModifiers)(removeFile, [
                                                    "stop"
                                                ]), [
                                                    "enter"
                                                ]),
                                                (0, _vue.withKeys)((0, _vue.withModifiers)(removeFile, [
                                                    "stop"
                                                ]), [
                                                    "space"
                                                ])
                                            ],
                                            onFocus: (0, _vue.unref)(onFocus),
                                            onBlur: (0, _vue.unref)(onBlur)
                                        }, null, 8, [
                                            "aria-label",
                                            "onKeydown",
                                            "onFocus",
                                            "onBlur"
                                        ])) : (0, _vue.createCommentVNode)("", true)
                                    ])
                                ]),
                            _: 1
                        }))
                    ]),
                _: 1
            }, 8, [
                "class",
                "disabled",
                "aria-disabled"
            ]);
        };
    }
});

},{"vue":"gzxs9","../types.js":"5OjBK","../../va-button/index.js":"2vhcC","../../va-list/index.js":"iaP6m","../VaFileUploadUndo/index.js":"inZom","../../../composables/useTranslation.js":"7S3aV","../../../composables/useStrictInject.js":"dIxtb","../../../composables/useFocus.js":"8TBqW","../../../composables/useBem.js":"igmjV","../../../../VaFileUploadListItem.css":"8Awp4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iaP6m":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaListItem);
parcelHelpers.export(exports, "a", ()=>VaListItemSection);
parcelHelpers.export(exports, "b", ()=>VaList);
parcelHelpers.export(exports, "c", ()=>VaListLabel);
parcelHelpers.export(exports, "d", ()=>VaListItemLabel);
parcelHelpers.export(exports, "e", ()=>VaListSeparator);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaListVueVueTypeScriptSetupTrueLangJs = require("./VaList.vue_vue_type_script_setup_true_lang.js");
var _vaListItemVueVueTypeScriptSetupTrueLangJs = require("./VaListItem.vue_vue_type_script_setup_true_lang.js");
var _vaListLabelVueVueTypeScriptSetupTrueLangJs = require("./VaListLabel.vue_vue_type_script_setup_true_lang.js");
var _vaListItemLabelVueVueTypeScriptSetupTrueLangJs = require("./VaListItemLabel.vue_vue_type_script_setup_true_lang.js");
var _vaListItemSectionVueVueTypeScriptSetupTrueLangJs = require("./VaListItemSection.vue_vue_type_script_setup_true_lang.js");
var _vaListSeparatorVueVueTypeScriptSetupTrueLangJs = require("./VaListSeparator.vue_vue_type_script_setup_true_lang.js");
const VaListItem = (0, _withConfigTransportJs.w)((0, _vaListItemVueVueTypeScriptSetupTrueLangJs._));
const VaListLabel = (0, _withConfigTransportJs.w)((0, _vaListLabelVueVueTypeScriptSetupTrueLangJs._));
const VaListItemLabel = (0, _withConfigTransportJs.w)((0, _vaListItemLabelVueVueTypeScriptSetupTrueLangJs._));
const VaListItemSection = (0, _withConfigTransportJs.w)((0, _vaListItemSectionVueVueTypeScriptSetupTrueLangJs._));
const VaListSeparator = (0, _withConfigTransportJs.w)((0, _vaListSeparatorVueVueTypeScriptSetupTrueLangJs._));
const VaList = (0, _withConfigTransportJs.w)((0, _vaListVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaList.vue_vue_type_script_setup_true_lang.js":"1kBOQ","./VaListItem.vue_vue_type_script_setup_true_lang.js":"dLfjK","./VaListLabel.vue_vue_type_script_setup_true_lang.js":"iq1as","./VaListItemLabel.vue_vue_type_script_setup_true_lang.js":"7oeQX","./VaListItemSection.vue_vue_type_script_setup_true_lang.js":"6ESMU","./VaListSeparator.vue_vue_type_script_setup_true_lang.js":"ifQXq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1kBOQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _vaListCss = require("../../../VaList.css");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaList",
    __name: "VaList",
    props: {
        ...(0, _useComponentPresetJs.u),
        fit: {
            type: Boolean,
            default: false
        }
    },
    setup (__props) {
        const props = __props;
        const computedClass = (0, _vue.computed)(()=>({
                "va-list--fit": props.fit
            }));
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: (0, _vue.normalizeClass)([
                    "va-list",
                    computedClass.value
                ]),
                role: "list"
            }, [
                (0, _vue.renderSlot)(_ctx.$slots, "default")
            ], 2);
        };
    }
});

},{"vue":"gzxs9","../../composables/useComponentPreset.js":"2HoaT","../../../VaList.css":"hGUlY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hGUlY":[function() {},{}],"dLfjK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../vendor.js");
var _useRouterLinkJs = require("../../composables/useRouterLink.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useBemJs = require("../../composables/useBem.js");
var _vaListItemCss = require("../../../VaListItem.css");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaListItem",
    __name: "VaListItem",
    props: {
        ...(0, _useRouterLinkJs.u),
        ...(0, _useComponentPresetJs.u),
        tag: {
            type: String,
            default: "div"
        },
        disabled: {
            type: Boolean,
            default: false
        }
    },
    emits: [
        "focus",
        "click"
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const tabIndexComputed = (0, _vue.computed)(()=>props.disabled ? -1 : 0);
        const computedClass = (0, _useBemJs.u)("va-list-item", ()=>({
                ...(0, _vendorJs.p)(props, [
                    "disabled"
                ])
            }));
        const { tagComputed, hrefComputed } = (0, _useRouterLinkJs.a)(props);
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.resolveDynamicComponent)((0, _vue.unref)(tagComputed)), {
                class: (0, _vue.normalizeClass)([
                    "va-list-item",
                    (0, _vue.unref)(computedClass)
                ]),
                role: "listitem",
                href: (0, _vue.unref)(hrefComputed),
                target: _ctx.target,
                to: _ctx.to,
                replace: _ctx.replace,
                exact: _ctx.exact,
                "active-class": _ctx.activeClass,
                "exact-active-class": _ctx.exactActiveClass,
                tabindex: tabIndexComputed.value
            }, {
                default: (0, _vue.withCtx)(()=>[
                        (0, _vue.createElementVNode)("div", {
                            class: "va-list-item__inner",
                            onClick: _cache[0] || (_cache[0] = ($event)=>_ctx.$emit("click")),
                            onFocus: _cache[1] || (_cache[1] = ($event)=>_ctx.$emit("focus"))
                        }, [
                            (0, _vue.renderSlot)(_ctx.$slots, "default")
                        ], 32)
                    ]),
                _: 3
            }, 8, [
                "href",
                "target",
                "to",
                "replace",
                "exact",
                "active-class",
                "exact-active-class",
                "class",
                "tabindex"
            ]);
        };
    }
});

},{"vue":"gzxs9","../../../vendor.js":"l6TAc","../../composables/useRouterLink.js":"bep51","../../composables/useComponentPreset.js":"2HoaT","../../composables/useBem.js":"igmjV","../../../VaListItem.css":"dr3Ev","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dr3Ev":[function() {},{}],"iq1as":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useColorsJs = require("../../composables/useColors.js");
var _vaListLabelCss = require("../../../VaListLabel.css");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaListLabel",
    __name: "VaListLabel",
    props: {
        ...(0, _useComponentPresetJs.u),
        color: {
            type: String,
            default: "primary"
        }
    },
    setup (__props) {
        const props = __props;
        const { getColor } = (0, _useColorsJs.u)();
        const computedStyle = (0, _vue.computed)(()=>({
                color: getColor(props.color)
            }));
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: "va-list-label",
                style: (0, _vue.normalizeStyle)(computedStyle.value)
            }, [
                (0, _vue.renderSlot)(_ctx.$slots, "default")
            ], 4);
        };
    }
});

},{"vue":"gzxs9","../../composables/useComponentPreset.js":"2HoaT","../../composables/useColors.js":"a4Qgv","../../../VaListLabel.css":"eCieF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eCieF":[function() {},{}],"7oeQX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _vaListItemLabelCss = require("../../../VaListItemLabel.css");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaListItemLabel",
    __name: "VaListItemLabel",
    props: {
        ...(0, _useComponentPresetJs.u),
        caption: {
            type: Boolean,
            default: false
        },
        lines: {
            type: Number,
            default: 1
        }
    },
    setup (__props) {
        const props = __props;
        const computedClass = (0, _vue.computed)(()=>({
                "va-list-item-label--caption": props.caption
            }));
        const computedStyle = (0, _vue.computed)(()=>({
                "-webkit-line-clamp": props.lines
            }));
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: (0, _vue.normalizeClass)([
                    "va-list-item-label",
                    computedClass.value
                ]),
                style: (0, _vue.normalizeStyle)(computedStyle.value)
            }, [
                (0, _vue.renderSlot)(_ctx.$slots, "default")
            ], 6);
        };
    }
});

},{"vue":"gzxs9","../../composables/useComponentPreset.js":"2HoaT","../../../VaListItemLabel.css":"iIiqi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iIiqi":[function() {},{}],"6ESMU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _vaListItemSectionCss = require("../../../VaListItemSection.css");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaListItemSection",
    __name: "VaListItemSection",
    props: {
        ...(0, _useComponentPresetJs.u),
        icon: {
            type: Boolean,
            default: false
        },
        avatar: {
            type: Boolean,
            default: false
        }
    },
    setup (__props) {
        const props = __props;
        const computedClass = (0, _vue.computed)(()=>({
                "va-list-item-section--main": !props.icon && !props.avatar,
                "va-list-item-section--icon": props.icon,
                "va-list-item-section--avatar": props.avatar
            }));
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: (0, _vue.normalizeClass)([
                    "va-list-item-section",
                    computedClass.value
                ])
            }, [
                (0, _vue.renderSlot)(_ctx.$slots, "default")
            ], 2);
        };
    }
});

},{"vue":"gzxs9","../../composables/useComponentPreset.js":"2HoaT","../../../VaListItemSection.css":"2nlk5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2nlk5":[function() {},{}],"ifQXq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _vaListSeparatorCss = require("../../../VaListSeparator.css");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaListSeparator",
    __name: "VaListSeparator",
    props: {
        ...(0, _useComponentPresetJs.u),
        fit: {
            type: Boolean,
            default: false
        },
        spaced: {
            type: Boolean,
            default: false
        }
    },
    setup (__props) {
        const props = __props;
        const computedClass = (0, _vue.computed)(()=>({
                "va-list-separator--offset": !props.fit,
                "va-list-separator--spaced": props.spaced
            }));
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                "aria-hidden": "true",
                class: (0, _vue.normalizeClass)([
                    "va-list-separator",
                    computedClass.value
                ])
            }, null, 2);
        };
    }
});

},{"vue":"gzxs9","../../composables/useComponentPreset.js":"2HoaT","../../../VaListSeparator.css":"iU4xr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iU4xr":[function() {},{}],"inZom":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaFileUploadUndo);
var _withConfigTransportJs = require("../../../services/config-transport/withConfigTransport.js");
var _vaFileUploadUndoVueVueTypeScriptSetupTrueLangJs = require("./VaFileUploadUndo.vue_vue_type_script_setup_true_lang.js");
const VaFileUploadUndo = (0, _withConfigTransportJs.w)((0, _vaFileUploadUndoVueVueTypeScriptSetupTrueLangJs._));

},{"../../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaFileUploadUndo.vue_vue_type_script_setup_true_lang.js":"3oGgt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3oGgt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _typesJs = require("../types.js");
var _indexJs = require("../../va-button/index.js");
var _indexJs1 = require("../../va-progress-bar/index.js");
var _useStrictInjectJs = require("../../../composables/useStrictInject.js");
var _useBemJs = require("../../../composables/useBem.js");
var _vaFileUploadUndoCss = require("../../../../VaFileUploadUndo.css");
const _hoisted_1 = {
    class: "va-file-upload-undo__text"
};
const INJECTION_ERROR_MESSAGE = "The VaFileUploadUndo component should be used in the context of VaFileUpload component";
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaFileUploadUndo",
    __name: "VaFileUploadUndo",
    props: {
        vertical: {
            type: Boolean,
            default: false
        }
    },
    emits: [
        "recover"
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const progress = (0, _vue.ref)(100);
        const { undoDuration, undoButtonText, deletedFileMessage } = (0, _useStrictInjectJs.u)((0, _typesJs.V), INJECTION_ERROR_MESSAGE);
        const computedClasses = (0, _useBemJs.u)("va-file-upload-undo", ()=>({
                vertical: props.vertical
            }));
        const undoDurationStyle = (0, _vue.computed)(()=>`${undoDuration.value ?? 0}ms`);
        (0, _vue.onMounted)(()=>{
            const timer = setTimeout(()=>{
                progress.value = 0;
                clearTimeout(timer);
            }, 0);
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), null, [
                (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs1.V)), {
                    "model-value": progress.value,
                    rounded: false,
                    class: "va-file-upload-undo-progress-bar",
                    style: (0, _vue.normalizeStyle)(`--va-undo-duration-style: ${String(undoDurationStyle.value)}`)
                }, null, 8, [
                    "model-value",
                    "style"
                ]),
                (0, _vue.createElementVNode)("div", {
                    class: (0, _vue.normalizeClass)([
                        "va-file-upload-undo",
                        (0, _vue.unref)(computedClasses)
                    ]),
                    style: (0, _vue.normalizeStyle)(`--va-undo-duration-style: ${String(undoDurationStyle.value)}`)
                }, [
                    (0, _vue.createElementVNode)("span", _hoisted_1, (0, _vue.toDisplayString)((0, _vue.unref)(deletedFileMessage)), 1),
                    (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs.V)), {
                        class: "va-file-upload-undo__button",
                        "aria-label": (0, _vue.unref)(undoButtonText),
                        size: "small",
                        outline: "",
                        onClick: _cache[0] || (_cache[0] = ($event)=>_ctx.$emit("recover"))
                    }, {
                        default: (0, _vue.withCtx)(()=>[
                                (0, _vue.createTextVNode)((0, _vue.toDisplayString)((0, _vue.unref)(undoButtonText)), 1)
                            ]),
                        _: 1
                    }, 8, [
                        "aria-label"
                    ])
                ], 6)
            ], 64);
        };
    }
});

},{"vue":"gzxs9","../types.js":"5OjBK","../../va-button/index.js":"2vhcC","../../va-progress-bar/index.js":"3h0vS","../../../composables/useStrictInject.js":"dIxtb","../../../composables/useBem.js":"igmjV","../../../../VaFileUploadUndo.css":"7ERLY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3h0vS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaProgressBar);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaProgressBarVueVueTypeScriptSetupTrueLangJs = require("./VaProgressBar.vue_vue_type_script_setup_true_lang.js");
const VaProgressBar = (0, _withConfigTransportJs.w)((0, _vaProgressBarVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaProgressBar.vue_vue_type_script_setup_true_lang.js":"ly6Q1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ly6Q1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _vendorJs = require("../../../vendor.js");
var _useColorsJs = require("../../composables/useColors.js");
var _useTextColorJs = require("../../composables/useTextColor.js");
var _useTranslationJs = require("../../composables/useTranslation.js");
var _vaProgressBarCss = require("../../../VaProgressBar.css");
const _hoisted_1 = {
    key: 0,
    class: "va-progress-bar__info"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaProgressBar",
    __name: "VaProgressBar",
    props: {
        ...(0, _useComponentPresetJs.u),
        modelValue: {
            type: [
                Number,
                String
            ],
            default: 0
        },
        indeterminate: {
            type: Boolean,
            default: false
        },
        color: {
            type: String,
            default: "primary"
        },
        size: {
            type: [
                Number,
                String
            ],
            default: "medium"
        },
        buffer: {
            type: [
                Number,
                String
            ],
            default: 100
        },
        rounded: {
            type: Boolean,
            default: true
        },
        reverse: {
            type: Boolean,
            default: false
        },
        contentInside: {
            type: Boolean,
            default: false
        },
        showPercent: {
            type: Boolean,
            default: false
        },
        max: {
            type: [
                Number,
                String
            ],
            default: 100
        },
        ariaLabel: {
            type: String,
            default: "$t:progressState"
        }
    },
    setup (__props) {
        const props = __props;
        const { getColor, getHoverColor } = (0, _useColorsJs.u)();
        const colorComputed = (0, _vue.computed)(()=>getColor(props.color));
        const { textColorComputed } = (0, _useTextColorJs.u)(colorComputed);
        const isTextSize = (0, _vue.computed)(()=>typeof props.size === "string" && [
                "small",
                "medium",
                "large"
            ].includes(props.size));
        const getCSSHeight = ()=>{
            if (typeof props.size === "number") return `${props.size}px`;
            if (isTextSize.value) return;
            return props.size;
        };
        const { tp } = (0, _useTranslationJs.u)();
        const progressBarValue = (0, _vue.computed)(()=>100 / Number(props.max) * Number(props.modelValue));
        const rootClass = (0, _vue.computed)(()=>({
                "va-progress-bar--square": !props.rounded,
                [`va-progress-bar--${props.size}`]: isTextSize.value
            }));
        const rooStyle = (0, _vue.computed)(()=>({
                "--va-progress-bar-color": colorComputed.value,
                "--va-progress-bar-background-color": getHoverColor(colorComputed.value)
            }));
        const wrapperStyle = (0, _vue.computed)(()=>({
                height: getCSSHeight()
            }));
        const bufferStyle = (0, _vue.computed)(()=>({
                width: `${props.indeterminate ? 100 : (0, _vendorJs.b)(Number(props.buffer), 0, 100)}%`,
                color: textColorComputed.value,
                [props.reverse ? "right" : "left"]: 0
            }));
        const progressStyle = (0, _vue.computed)(()=>({
                marginLeft: props.reverse ? "auto" : void 0,
                width: `${(0, _vendorJs.b)(progressBarValue.value, 0, 100)}%`
            }));
        const intermediateStyle = (0, _vue.computed)(()=>({
                animationDirection: props.reverse ? "reverse" : "normal"
            }));
        const ariaAttributesComputed = (0, _vue.computed)(()=>({
                role: "progressbar",
                "aria-label": tp(props.ariaLabel),
                "aria-valuenow": !props.indeterminate ? props.modelValue : void 0
            }));
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", (0, _vue.mergeProps)({
                class: [
                    "va-progress-bar",
                    rootClass.value
                ],
                style: rooStyle.value
            }, ariaAttributesComputed.value), [
                !_ctx.$props.contentInside ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_1, [
                    (0, _vue.renderSlot)(_ctx.$slots, "default", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                        value: _ctx.$props.modelValue
                    })), ()=>[
                            _ctx.$props.showPercent ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                                key: 0
                            }, [
                                (0, _vue.createTextVNode)((0, _vue.toDisplayString)(_ctx.$props.modelValue) + "% ", 1)
                            ], 64)) : (0, _vue.createCommentVNode)("", true)
                        ])
                ])) : (0, _vue.createCommentVNode)("", true),
                (0, _vue.createElementVNode)("div", {
                    class: "va-progress-bar__wrapper",
                    style: (0, _vue.normalizeStyle)(wrapperStyle.value)
                }, [
                    (0, _vue.createElementVNode)("div", {
                        class: "va-progress-bar__buffer",
                        style: (0, _vue.normalizeStyle)(bufferStyle.value)
                    }, [
                        _ctx.$props.contentInside ? (0, _vue.renderSlot)(_ctx.$slots, "default", (0, _vue.normalizeProps)((0, _vue.mergeProps)({
                            key: 0
                        }, {
                            value: _ctx.$props.modelValue
                        })), ()=>[
                                _ctx.$props.showPercent ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                                    key: 0
                                }, [
                                    (0, _vue.createTextVNode)((0, _vue.toDisplayString)(_ctx.$props.modelValue) + "% ", 1)
                                ], 64)) : (0, _vue.createCommentVNode)("", true)
                            ]) : (0, _vue.createCommentVNode)("", true)
                    ], 4),
                    __props.indeterminate ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                        key: 0
                    }, [
                        (0, _vue.createElementVNode)("div", {
                            class: "va-progress-bar__progress--indeterminate-start",
                            style: (0, _vue.normalizeStyle)(intermediateStyle.value)
                        }, null, 4),
                        (0, _vue.createElementVNode)("div", {
                            class: "va-progress-bar__progress--indeterminate-end",
                            style: (0, _vue.normalizeStyle)(intermediateStyle.value)
                        }, null, 4)
                    ], 64)) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                        key: 1,
                        class: "va-progress-bar__progress",
                        style: (0, _vue.normalizeStyle)(progressStyle.value)
                    }, null, 4))
                ], 4)
            ], 16);
        };
    }
});

},{"vue":"gzxs9","../../composables/useComponentPreset.js":"2HoaT","../../../vendor.js":"l6TAc","../../composables/useColors.js":"a4Qgv","../../composables/useTextColor.js":"5pfXb","../../composables/useTranslation.js":"7S3aV","../../../VaProgressBar.css":"ftaLM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ftaLM":[function() {},{}],"dIxtb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useStrictInject);
var _vue = require("vue");
const useStrictInject = (injectionSymbol, errorMessage)=>{
    const strictInjection = (0, _vue.inject)(injectionSymbol);
    if (!strictInjection) throw new Error(errorMessage);
    return strictInjection;
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7ERLY":[function() {},{}],"8Awp4":[function() {},{}],"59TQd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaFileUploadGalleryItem);
var _withConfigTransportJs = require("../../../services/config-transport/withConfigTransport.js");
var _vaFileUploadGalleryItemVueVueTypeScriptSetupTrueLangJs = require("./VaFileUploadGalleryItem.vue_vue_type_script_setup_true_lang.js");
const VaFileUploadGalleryItem = (0, _withConfigTransportJs.w)((0, _vaFileUploadGalleryItemVueVueTypeScriptSetupTrueLangJs._));

},{"../../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaFileUploadGalleryItem.vue_vue_type_script_setup_true_lang.js":"bC0qR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bC0qR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _typesJs = require("../types.js");
var _useTextColorJs = require("../../../composables/useTextColor.js");
var _indexJs = require("../VaFileUploadUndo/index.js");
var _utilsJs = require("../../../services/color/utils.js");
var _indexJs1 = require("../../va-list/index.js");
var _useStrictInjectJs = require("../../../composables/useStrictInject.js");
var _useFocusJs = require("../../../composables/useFocus.js");
var _useBemJs = require("../../../composables/useBem.js");
var _useTranslationJs = require("../../../composables/useTranslation.js");
var _indexJs2 = require("../../va-button/index.js");
var _vaFileUploadGalleryItemCss = require("../../../../VaFileUploadGalleryItem.css");
const _hoisted_1 = [
    "src",
    "alt"
];
const _hoisted_2 = {
    class: "va-file-upload-gallery-item__overlay"
};
const _hoisted_3 = [
    "title"
];
const INJECTION_ERROR_MESSAGE = "The VaFileUploadGalleryItem component should be used in the context of VaFileUpload component";
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaFileUploadGalleryItem",
    __name: "VaFileUploadGalleryItem",
    props: {
        file: {
            type: Object,
            default: null
        },
        color: {
            type: String,
            default: "success"
        },
        ariaRemoveFileLabel: {
            type: String,
            default: "$t:removeFile"
        }
    },
    emits: [
        "remove"
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const { undo, disabled, undoDuration } = (0, _useStrictInjectJs.u)((0, _typesJs.V), INJECTION_ERROR_MESSAGE);
        const { isFocused, onFocus, onBlur } = (0, _useFocusJs.u)();
        const previewImage = (0, _vue.ref)("");
        const removed = (0, _vue.ref)(false);
        const overlayStylesComputed = (0, _vue.computed)(()=>({
                backgroundColor: (0, _utilsJs.d)(props.color, 0.7)
            }));
        const classesComputed = (0, _useBemJs.u)("va-file-upload-gallery-item", ()=>({
                notImage: !previewImage.value,
                focused: isFocused.value,
                undo: removed.value
            }));
        const removeImage = ()=>{
            if (undo.value) {
                removed.value = true;
                setTimeout(()=>{
                    if (!removed.value) return;
                    emit("remove");
                    removed.value = false;
                }, undoDuration.value ?? 0);
            } else {
                emit("remove");
                removed.value = false;
            }
        };
        const recoverImage = ()=>{
            removed.value = false;
        };
        const convertToImg = ()=>{
            if (!props.file.name || !props.file.image) return;
            if (props.file.image.url) previewImage.value = props.file.image.url;
            else if (props.file.image instanceof File) {
                const reader = new FileReader();
                reader.readAsDataURL(props.file.image);
                reader.onload = (e)=>{
                    var _a, _b;
                    if (((_a = e.target) == null ? void 0 : _a.result).includes("image")) previewImage.value = (_b = e.target) == null ? void 0 : _b.result;
                };
            }
        };
        (0, _vue.onMounted)(convertToImg);
        (0, _vue.watch)(()=>props.file, convertToImg);
        const { t, tp } = (0, _useTranslationJs.u)();
        const { textColorComputed } = (0, _useTextColorJs.u)((0, _vue.toRef)(props, "color"));
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs1.V)), {
                class: (0, _vue.normalizeClass)([
                    "va-file-upload-gallery-item",
                    (0, _vue.unref)(classesComputed)
                ]),
                tabindex: "-1",
                disabled: (0, _vue.unref)(disabled),
                "aria-disabled": (0, _vue.unref)(disabled),
                onFocus: (0, _vue.unref)(onFocus),
                onBlur: (0, _vue.unref)(onBlur)
            }, {
                default: (0, _vue.withCtx)(()=>[
                        removed.value && (0, _vue.unref)(undo) ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs1.a)), {
                            key: 0
                        }, {
                            default: (0, _vue.withCtx)(()=>[
                                    (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs.V)), {
                                        vertical: "",
                                        onRecover: recoverImage
                                    })
                                ]),
                            _: 1
                        })) : ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs1.a)), {
                            key: 1
                        }, {
                            default: (0, _vue.withCtx)(()=>[
                                    previewImage.value ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("img", {
                                        key: 0,
                                        src: previewImage.value,
                                        alt: __props.file.name || "",
                                        class: "va-file-upload-gallery-item__image"
                                    }, null, 8, _hoisted_1)) : (0, _vue.createCommentVNode)("", true),
                                    (0, _vue.createElementVNode)("div", _hoisted_2, [
                                        (0, _vue.createElementVNode)("div", {
                                            class: "va-file-upload-gallery-item__overlay-background",
                                            style: (0, _vue.normalizeStyle)(overlayStylesComputed.value)
                                        }, null, 4),
                                        __props.file && __props.file.name ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                            key: 0,
                                            class: "va-file-upload-gallery-item__name",
                                            title: __props.file.name,
                                            style: (0, _vue.normalizeStyle)({
                                                color: (0, _vue.unref)(textColorComputed)
                                            })
                                        }, (0, _vue.toDisplayString)(__props.file.name), 13, _hoisted_3)) : (0, _vue.createCommentVNode)("", true),
                                        !(0, _vue.unref)(disabled) ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs2.V)), {
                                            key: 1,
                                            flat: "",
                                            color: "danger",
                                            icon: "va-delete",
                                            class: "va-file-upload-gallery-item__delete",
                                            "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaRemoveFileLabel),
                                            onClick: removeImage,
                                            onFocus: (0, _vue.unref)(onFocus),
                                            onBlur: (0, _vue.unref)(onBlur)
                                        }, null, 8, [
                                            "aria-label",
                                            "onFocus",
                                            "onBlur"
                                        ])) : (0, _vue.createCommentVNode)("", true)
                                    ])
                                ]),
                            _: 1
                        }))
                    ]),
                _: 1
            }, 8, [
                "class",
                "disabled",
                "aria-disabled",
                "onFocus",
                "onBlur"
            ]);
        };
    }
});

},{"vue":"gzxs9","../types.js":"5OjBK","../../../composables/useTextColor.js":"5pfXb","../VaFileUploadUndo/index.js":"inZom","../../../services/color/utils.js":"4SMXK","../../va-list/index.js":"iaP6m","../../../composables/useStrictInject.js":"dIxtb","../../../composables/useFocus.js":"8TBqW","../../../composables/useBem.js":"igmjV","../../../composables/useTranslation.js":"7S3aV","../../va-button/index.js":"2vhcC","../../../../VaFileUploadGalleryItem.css":"lSR1d","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lSR1d":[function() {},{}],"lLoH2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaFileUploadSingleItem);
var _withConfigTransportJs = require("../../../services/config-transport/withConfigTransport.js");
var _vaFileUploadSingleItemVueVueTypeScriptSetupTrueLangJs = require("./VaFileUploadSingleItem.vue_vue_type_script_setup_true_lang.js");
const VaFileUploadSingleItem = (0, _withConfigTransportJs.w)((0, _vaFileUploadSingleItemVueVueTypeScriptSetupTrueLangJs._));

},{"../../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaFileUploadSingleItem.vue_vue_type_script_setup_true_lang.js":"6N2VF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6N2VF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _typesJs = require("../types.js");
var _useTranslationJs = require("../../../composables/useTranslation.js");
var _useStrictInjectJs = require("../../../composables/useStrictInject.js");
var _indexJs = require("../../va-list/index.js");
var _indexJs1 = require("../../va-button/index.js");
var _vaFileUploadSingleItemCss = require("../../../../VaFileUploadSingleItem.css");
const _hoisted_1 = {
    class: "va-file-upload-single-item__name"
};
const INJECTION_ERROR_MESSAGE = "The VaFileUploadSingleItem component should be used in the context of VaFileUpload component";
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaFileUploadSingleItem",
    __name: "VaFileUploadSingleItem",
    props: {
        file: {
            type: Object,
            default: null
        },
        ariaRemoveFileLabel: {
            type: String,
            default: "$t:removeFile"
        }
    },
    emits: [
        "remove"
    ],
    setup (__props, { emit: __emit }) {
        const { t, tp } = (0, _useTranslationJs.u)();
        const { disabled } = (0, _useStrictInjectJs.u)((0, _typesJs.V), INJECTION_ERROR_MESSAGE);
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), {
                disabled: (0, _vue.unref)(disabled),
                "aria-disabled": (0, _vue.unref)(disabled),
                class: "va-file-upload-single-item",
                tabindex: "-1"
            }, {
                default: (0, _vue.withCtx)(()=>[
                        (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs.a)), {
                            class: "va-file-upload-single-item__content"
                        }, {
                            default: (0, _vue.withCtx)(()=>[
                                    (0, _vue.createElementVNode)("div", _hoisted_1, (0, _vue.toDisplayString)(__props.file && __props.file.name), 1),
                                    !(0, _vue.unref)(disabled) ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs1.V)), {
                                        key: 0,
                                        class: "va-file-upload-single-item__button",
                                        "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaRemoveFileLabel),
                                        size: "small",
                                        color: "danger",
                                        preset: "secondary",
                                        onClick: _cache[0] || (_cache[0] = ($event)=>_ctx.$emit("remove"))
                                    }, {
                                        default: (0, _vue.withCtx)(()=>[
                                                (0, _vue.createTextVNode)(" Delete ")
                                            ]),
                                        _: 1
                                    }, 8, [
                                        "aria-label"
                                    ])) : (0, _vue.createCommentVNode)("", true)
                                ]),
                            _: 1
                        })
                    ]),
                _: 1
            }, 8, [
                "disabled",
                "aria-disabled"
            ]);
        };
    }
});

},{"vue":"gzxs9","../types.js":"5OjBK","../../../composables/useTranslation.js":"7S3aV","../../../composables/useStrictInject.js":"dIxtb","../../va-list/index.js":"iaP6m","../../va-button/index.js":"2vhcC","../../../../VaFileUploadSingleItem.css":"66yF6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"66yF6":[function() {},{}],"89Lnv":[function() {},{}],"85Ljx":[function() {},{}],"2IflX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaForm);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaFormVueVueTypeScriptSetupTrueLangJs = require("./VaForm.vue_vue_type_script_setup_true_lang.js");
const VaForm = (0, _withConfigTransportJs.w)((0, _vaFormVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaForm.vue_vue_type_script_setup_true_lang.js":"idH3J","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"idH3J":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useLocalConfigJs = require("../../composables/useLocalConfig.js");
var _useFormParentJs = require("../../composables/useForm/useFormParent.js");
var _vaFormCss = require("../../../VaForm.css");
const statefulProps = {
    stateful: true
};
const statefulConfig = {
    VaInput: statefulProps,
    VaSelect: statefulProps,
    VaCheckbox: statefulProps,
    VaRadio: statefulProps,
    VaDatePicker: statefulProps,
    VaTimePicker: statefulProps,
    VaColorPicker: statefulProps,
    VaSlider: statefulProps,
    VaSwitch: statefulProps,
    VaFileUpload: statefulProps,
    VaRating: statefulProps,
    VaDateInput: statefulProps,
    VaTimeInput: statefulProps
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaForm",
    __name: "VaForm",
    props: {
        ...(0, _useComponentPresetJs.u),
        autofocus: {
            type: Boolean,
            default: false
        },
        immediate: {
            type: Boolean,
            default: false
        },
        tag: {
            type: String,
            default: "form"
        },
        trigger: {
            type: String,
            default: "blur"
        },
        modelValue: {
            type: Boolean,
            default: true
        },
        hideErrors: {
            type: Boolean,
            default: false
        },
        hideErrorMessages: {
            type: Boolean,
            default: false
        },
        hideLoading: {
            type: Boolean,
            default: false
        },
        stateful: {
            type: Boolean,
            default: false
        }
    },
    emits: [
        "update:modelValue"
    ],
    setup (__props, { expose: __expose, emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const context = (0, _useFormParentJs.u)(props);
        (0, _vue.watch)(context.isValid, (value)=>{
            emit("update:modelValue", value);
        });
        (0, _vue.watch)(()=>props.autofocus, (value)=>{
            if (value) context.focus();
        });
        (0, _vue.onMounted)(()=>{
            if (props.autofocus) context.focus();
        });
        (0, _vue.watch)(context.fields, (newVal)=>{
            if (newVal.length && props.immediate) context.validate();
        }, {
            immediate: true
        });
        (0, _useLocalConfigJs.a)((0, _vue.computed)(()=>{
            if (!props.stateful) return {};
            return statefulConfig;
        }));
        const { immediate: immediateComputed, isDirty, isTouched, formData, fields, fieldsNamed, fieldNames, isValid, isLoading, errorMessages, errorMessagesNamed, validate, validateAsync, reset, resetValidation, focus, focusInvalidField } = context;
        __expose({
            immediate: immediateComputed,
            isDirty,
            formData,
            fields,
            fieldsNamed,
            fieldNames,
            isValid,
            isTouched,
            isLoading,
            errorMessages,
            errorMessagesNamed,
            validate,
            validateAsync,
            reset,
            resetValidation,
            focus,
            focusInvalidField
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.resolveDynamicComponent)(__props.tag), (0, _vue.mergeProps)({
                class: "va-form",
                onSubmit: _cache[0] || (_cache[0] = (e)=>_ctx.$attrs.action === void 0 && e.preventDefault())
            }, _ctx.$attrs), {
                default: (0, _vue.withCtx)(()=>[
                        (0, _vue.renderSlot)(_ctx.$slots, "default", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                            isValid: (0, _vue.unref)(isValid),
                            validate: (0, _vue.unref)(validate)
                        })))
                    ]),
                _: 3
            }, 16);
        };
    }
});

},{"vue":"gzxs9","../../composables/useComponentPreset.js":"2HoaT","../../composables/useLocalConfig.js":"dvyav","../../composables/useForm/useFormParent.js":"6kbb9","../../../VaForm.css":"12w2O","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6kbb9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useFormParent);
var _vue = require("vue");
var _constsJs = require("./consts.js");
var _useFormChildJs = require("./useFormChild.js");
var _formContextJs = require("./formContext.js");
const useFormParent = (options)=>{
    const formContext = (0, _formContextJs.c)(options);
    (0, _vue.provide)((0, _constsJs.F), formContext);
    const { fields, forceDirty } = formContext;
    const fieldNames = (0, _vue.computed)(()=>fields.value.map((field)=>(0, _vue.unref)(field.name)).filter(Boolean));
    const fieldsNamed = (0, _vue.computed)(()=>fields.value.reduce((acc, field)=>{
            if ((0, _vue.unref)(field.name)) acc[(0, _vue.unref)(field.name)] = field;
            return acc;
        }, {}));
    const formData = (0, _vue.computed)(()=>fields.value.reduce((acc, field)=>{
            if ((0, _vue.unref)(field.name)) acc[(0, _vue.unref)(field.name)] = field.value;
            return acc;
        }, {}));
    const isValid = (0, _vue.computed)(()=>fields.value.every((field)=>(0, _vue.unref)(field.isValid)));
    const isLoading = (0, _vue.computed)(()=>fields.value.some((field)=>(0, _vue.unref)(field.isLoading)));
    const errorMessages = (0, _vue.computed)(()=>fields.value.map((field)=>(0, _vue.unref)(field.errorMessages)).flat());
    const errorMessagesNamed = (0, _vue.computed)(()=>fields.value.reduce((acc, field)=>{
            if ((0, _vue.unref)(field.name)) acc[(0, _vue.unref)(field.name)] = (0, _vue.unref)(field.errorMessages);
            return acc;
        }, {}));
    const isDirty = (0, _vue.computed)({
        get () {
            return fields.value.some((field)=>(0, _vue.unref)(field.isDirty)) || forceDirty.value;
        },
        set (v) {
            forceDirty.value = v;
            fields.value.forEach((field)=>{
                field.isDirty = v;
            });
        }
    });
    const isTouched = (0, _vue.computed)({
        get () {
            console.log(fields.value);
            return fields.value.some((field)=>field.isTouched);
        },
        set (v) {
            fields.value.forEach((field)=>{
                field.isTouched = v;
            });
        }
    });
    const validate = ()=>{
        isDirty.value = true;
        return fields.value.reduce((acc, field)=>{
            return field.validate() && acc;
        }, true);
    };
    const validateAsync = ()=>{
        isDirty.value = true;
        return Promise.all(fields.value.map((field)=>field.validateAsync())).then((results)=>{
            return results.every(Boolean);
        });
    };
    const reset = ()=>{
        isDirty.value = false;
        fields.value.forEach((field)=>field.reset());
    };
    const resetValidation = ()=>{
        isDirty.value = false;
        fields.value.forEach((field)=>field.resetValidation());
    };
    const focus = ()=>{
        var _a;
        (_a = fields.value[0]) == null || _a.focus();
    };
    const focusInvalidField = ()=>{
        const invalidField = fields.value.find((field)=>!field.isValid);
        invalidField == null || invalidField.focus();
    };
    (0, _useFormChildJs.u)({
        name: (0, _vue.ref)(void 0),
        isValid,
        isLoading,
        isDirty,
        isTouched,
        validate,
        validateAsync,
        reset,
        resetValidation,
        focus,
        errorMessages
    });
    return {
        immediate: (0, _vue.computed)(()=>options.immediate),
        isDirty,
        isTouched,
        formData,
        fields,
        fieldsNamed,
        fieldNames,
        isValid,
        isLoading,
        errorMessages,
        errorMessagesNamed,
        validate,
        validateAsync,
        reset,
        resetValidation,
        focus,
        focusInvalidField
    };
};

},{"vue":"gzxs9","./consts.js":"7hyjD","./useFormChild.js":"X120o","./formContext.js":"jorNg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jorNg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "c", ()=>createFormContext);
var _vue = require("vue");
const createFormContext = (options)=>{
    const fields = (0, _vue.ref)(/* @__PURE__ */ new Map());
    return {
        // Vue unwrap ref automatically, but types are not for some reason
        immediate: (0, _vue.computed)(()=>options.immediate),
        fields: (0, _vue.computed)(()=>[
                ...fields.value.values()
            ]),
        forceHideErrors: (0, _vue.computed)(()=>options.hideErrors),
        forceHideErrorMessages: (0, _vue.computed)(()=>options.hideErrorMessages),
        forceHideLoading: (0, _vue.computed)(()=>options.hideLoading),
        forceDirty: (0, _vue.ref)(false),
        registerField: (uid, field)=>{
            fields.value.set(uid, field);
        },
        unregisterField: (uid)=>{
            fields.value.delete(uid);
        }
    };
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"12w2O":[function() {},{}],"b3W1W":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaInfiniteScroll);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaInfiniteScrollVueVueTypeScriptSetupTrueLangJs = require("./VaInfiniteScroll.vue_vue_type_script_setup_true_lang.js");
const VaInfiniteScroll = (0, _withConfigTransportJs.w)((0, _vaInfiniteScrollVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaInfiniteScroll.vue_vue_type_script_setup_true_lang.js":"4Is9A","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4Is9A":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../vendor.js");
var _sleepJs = require("../../utils/sleep.js");
var _useScrollJs = require("./hooks/useScroll.js");
var _indexJs = require("../va-progress-circle/index.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useColorsJs = require("../../composables/useColors.js");
var _vaInfiniteScrollCss = require("../../../VaInfiniteScroll.css");
const _hoisted_1 = {
    class: "va-infinite-scroll__spinner__default"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaInfiniteScroll",
    __name: "VaInfiniteScroll",
    props: {
        ...(0, _useComponentPresetJs.u),
        load: {
            type: Function,
            required: true
        },
        offset: {
            type: Number,
            default: 500
        },
        reverse: {
            type: Boolean,
            default: false
        },
        disabled: {
            type: Boolean,
            default: false
        },
        scrollTarget: {
            type: [
                String,
                Object
            ],
            default: null
        },
        debounce: {
            type: Number,
            default: 100
        },
        tag: {
            type: String,
            default: "div"
        }
    },
    emits: [
        "onload",
        "onerror"
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const element = (0, _vue.shallowRef)();
        const spinnerSlotContainer = (0, _vue.shallowRef)();
        const fetching = (0, _vue.ref)(false);
        const error = (0, _vue.ref)(false);
        const forcedScrolling = (0, _vue.ref)(false);
        const debouncedLoad = (0, _vue.ref)();
        const notScrolledContentBeforeLoad = (0, _vue.ref)(0);
        const prevScrollTop = (0, _vue.ref)(0);
        const scrollTargetElement = (0, _vue.computed)(()=>{
            var _a;
            let target;
            if (typeof props.scrollTarget === "string") target = document.querySelector(props.scrollTarget);
            else target = props.scrollTarget || ((_a = element.value) == null ? void 0 : _a.parentElement);
            return target || document.body;
        });
        const { addScrollListener, removeScrollListener } = (0, _useScrollJs.u)(props, scrollTargetElement, debouncedLoad);
        const { getColor } = (0, _useColorsJs.u)();
        const spinnerColor = (0, _vue.computed)(()=>{
            return error.value ? getColor("danger") : getColor("primary");
        });
        const spinnerHeight = (0, _vue.computed)(()=>{
            var _a;
            return ((_a = spinnerSlotContainer.value) == null ? void 0 : _a.offsetHeight) || 0;
        });
        const computedOffset = (0, _vue.computed)(()=>{
            return props.offset + spinnerHeight.value;
        });
        const stop = ()=>{
            if (props.disabled) return;
            fetching.value = false;
            removeScrollListener();
        };
        const resume = ()=>{
            if (props.disabled) return;
            addScrollListener();
        };
        const onLoad = ()=>{
            const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value;
            notScrolledContentBeforeLoad.value = scrollHeight - scrollTop;
            const scrollDelta = scrollTop - prevScrollTop.value;
            prevScrollTop.value = scrollTop;
            if (props.disabled || error.value || fetching.value) return;
            if (forcedScrolling.value) {
                forcedScrolling.value = false;
                return;
            }
            const isReverseScrollDirection = props.reverse && scrollDelta > 0 || !props.reverse && scrollDelta < 0;
            if (isReverseScrollDirection) return;
            const offset = props.reverse ? scrollTop : scrollHeight - scrollTop - clientHeight;
            if (offset > computedOffset.value) return;
            fetching.value = true;
            props.load().then(finishLoading).catch(onError);
        };
        const forceSetScrollTopToTarget = (value)=>{
            forcedScrolling.value = true;
            scrollTargetElement.value.scrollTop = value;
        };
        const updateTargetElementScrollTop = ()=>{
            const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value;
            if (props.reverse) {
                const isScrolledUp = scrollHeight - scrollTop < notScrolledContentBeforeLoad.value;
                const isSpinnerHidden = scrollTop >= spinnerHeight.value;
                if (isScrolledUp && isSpinnerHidden) return;
                scrollHeight - notScrolledContentBeforeLoad.value > spinnerHeight.value ? forceSetScrollTopToTarget(scrollHeight - notScrolledContentBeforeLoad.value) : forceSetScrollTopToTarget(spinnerHeight.value);
            }
            if (!props.reverse) {
                const isSpinnerHidden = scrollHeight - scrollTop - clientHeight >= spinnerHeight.value;
                !isSpinnerHidden && forceSetScrollTopToTarget(scrollHeight - clientHeight - spinnerHeight.value);
            }
        };
        const finishLoading = ()=>{
            updateTargetElementScrollTop();
            fetching.value = false;
            emit("onload");
        };
        const stopErrorDisplay = ()=>{
            updateTargetElementScrollTop();
            forcedScrolling.value = false;
            error.value = false;
            fetching.value = false;
            emit("onerror");
        };
        const onError = ()=>{
            stop();
            error.value = true;
            (0, _sleepJs.s)(1200).then(stopErrorDisplay).then(resume);
        };
        (0, _vue.watch)(()=>props.debounce, (value)=>{
            debouncedLoad.value = (0, _vendorJs.d)(onLoad, value);
        }, {
            immediate: true
        });
        (0, _vue.watch)(()=>props.disabled, (value)=>{
            value ? stop() : resume();
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.resolveDynamicComponent)(_ctx.$props.tag), {
                ref_key: "element",
                ref: element,
                role: "feed",
                class: (0, _vue.normalizeClass)([
                    "va-infinite-scroll",
                    {
                        "va-infinite-scroll--reversed": _ctx.$props.reverse
                    }
                ]),
                "aria-busy": fetching.value
            }, {
                default: (0, _vue.withCtx)(()=>[
                        (0, _vue.renderSlot)(_ctx.$slots, "default"),
                        (0, _vue.createElementVNode)("div", {
                            ref_key: "spinnerSlotContainer",
                            ref: spinnerSlotContainer,
                            class: (0, _vue.normalizeClass)([
                                "va-infinite-scroll__spinner",
                                {
                                    "va-infinite-scroll__spinner--invisible": !fetching.value
                                }
                            ])
                        }, [
                            !_ctx.$props.disabled ? (0, _vue.renderSlot)(_ctx.$slots, "loading", {
                                key: 0
                            }, ()=>[
                                    (0, _vue.createElementVNode)("div", _hoisted_1, [
                                        (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs.V)), {
                                            size: "small",
                                            thickness: 0.15,
                                            color: spinnerColor.value,
                                            indeterminate: ""
                                        }, null, 8, [
                                            "color"
                                        ])
                                    ])
                                ]) : (0, _vue.createCommentVNode)("", true)
                        ], 2)
                    ]),
                _: 3
            }, 8, [
                "class",
                "aria-busy"
            ]);
        };
    }
});

},{"vue":"gzxs9","../../../vendor.js":"l6TAc","../../utils/sleep.js":"d9uq4","./hooks/useScroll.js":"iPlhv","../va-progress-circle/index.js":"dZCnz","../../composables/useComponentPreset.js":"2HoaT","../../composables/useColors.js":"a4Qgv","../../../VaInfiniteScroll.css":"gGzKx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d9uq4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "s", ()=>sleep);
const sleep = (ms = 0)=>{
    return new Promise((resolve)=>setTimeout(resolve, ms));
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iPlhv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useScroll);
var _vue = require("vue");
const useScroll = (props, element, handler)=>{
    const addScrollListener = ()=>{
        var _a;
        (_a = element.value) == null || _a.addEventListener("scroll", handler.value, {
            passive: true
        });
    };
    const removeScrollListener = ()=>{
        var _a;
        (_a = element.value) == null || _a.removeEventListener("scroll", handler.value);
    };
    (0, _vue.onMounted)(()=>{
        if (!element.value) return;
        element.value.style.overflowY = "scroll";
        if (props.reverse) element.value.scrollTop = element.value.scrollHeight;
        addScrollListener();
    });
    (0, _vue.onBeforeUnmount)(removeScrollListener);
    return {
        addScrollListener,
        removeScrollListener
    };
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gGzKx":[function() {},{}],"jq32I":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaLayout);
var _vaLayoutVueVueTypeScriptSetupTrueLangJs = require("./VaLayout.vue_vue_type_script_setup_true_lang.js");
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
const VaLayout = (0, _withConfigTransportJs.a)((0, _vaLayoutVueVueTypeScriptSetupTrueLangJs._));

},{"./VaLayout.vue_vue_type_script_setup_true_lang.js":"26XeB","../../services/config-transport/withConfigTransport.js":"b7Tgy","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"26XeB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useGridTemplateAreaJs = require("./hooks/useGridTemplateArea.js");
var _useLayoutJs = require("./hooks/useLayout.js");
var _vaLayoutAreaVueVueTypeScriptSetupTrueLangJs = require("./components/VaLayoutArea.vue_vue_type_script_setup_true_lang.js");
var _useDocumentJs = require("../../composables/useDocument.js");
var _vaLayoutCss = require("../../../VaLayout.css");
const _hoisted_1 = {
    class: "va-layout__area va-layout__area--content"
};
const areaNames = [
    "top",
    "left",
    "right",
    "bottom"
];
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaLayout",
    __name: "VaLayout",
    props: {
        ...(0, _useLayoutJs.u),
        allowBodyScrollOnOverlay: {
            type: Boolean,
            default: false
        }
    },
    emits: [
        "top-overlay-click",
        "left-overlay-click",
        "right-overlay-click",
        "bottom-overlay-click"
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const { paddings } = (0, _useLayoutJs.a)(props);
        const doDisableScroll = (0, _vue.computed)(()=>{
            return !props.allowBodyScrollOnOverlay && areaNames.some((area)=>{
                var _a;
                return (_a = props[area]) == null ? void 0 : _a.overlay;
            });
        });
        const document = (0, _useDocumentJs.u)();
        (0, _vue.watchEffect)(()=>{
            var _a;
            const overflowParent = (_a = document.value) == null ? void 0 : _a.body;
            if (!overflowParent) return;
            if (doDisableScroll.value) overflowParent.style.overflow = "hidden";
            else overflowParent.style.overflow = "";
        });
        const templateArea = (0, _useGridTemplateAreaJs.u)(props);
        const slots = (0, _vue.useSlots)();
        const verticalTemplate = (0, _vue.computed)(()=>{
            return [
                slots.top ? "min-content" : "0fr",
                "1fr",
                slots.bottom ? "min-content" : "0fr"
            ].filter(Boolean).join(" ");
        });
        const horizontalTemplate = (0, _vue.computed)(()=>{
            return [
                slots.left ? "min-content" : "0fr",
                "1fr",
                slots.right ? "min-content" : "0fr"
            ].filter(Boolean).join(" ");
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: "va-layout",
                style: (0, _vue.normalizeStyle)(`--va-horizontal-template: ${String(horizontalTemplate.value)};--va-vertical-template: ${String(verticalTemplate.value)};--va-template-area: ${String((0, _vue.unref)(templateArea))};--va-paddings-top-px: ${String((0, _vue.unref)(paddings).top + "px")};--va-paddings-bottom-px: ${String((0, _vue.unref)(paddings).bottom + "px")};--va-paddings-left-px: ${String((0, _vue.unref)(paddings).left + "px")};--va-paddings-right-px: ${String((0, _vue.unref)(paddings).right + "px")}`)
            }, [
                ((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)(areaNames, (area)=>{
                    return (0, _vue.createVNode)((0, _vaLayoutAreaVueVueTypeScriptSetupTrueLangJs._), {
                        key: area,
                        area,
                        config: _ctx.$props[area] || {},
                        onOverlayClick: ($event)=>_ctx.$emit(`${area}-overlay-click`)
                    }, {
                        default: (0, _vue.withCtx)(()=>[
                                (0, _vue.renderSlot)(_ctx.$slots, area)
                            ]),
                        _: 2
                    }, 1032, [
                        "area",
                        "config",
                        "onOverlayClick"
                    ]);
                }), 64)),
                (0, _vue.createElementVNode)("div", _hoisted_1, [
                    (0, _vue.renderSlot)(_ctx.$slots, "default", {}, ()=>[
                            (0, _vue.renderSlot)(_ctx.$slots, "content")
                        ])
                ])
            ], 4);
        };
    }
});

},{"vue":"gzxs9","./hooks/useGridTemplateArea.js":"1mjrF","./hooks/useLayout.js":"5hCzJ","./components/VaLayoutArea.vue_vue_type_script_setup_true_lang.js":"a6YOA","../../composables/useDocument.js":"403q6","../../../VaLayout.css":"2GNVm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1mjrF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useGridTemplateArea);
var _vue = require("vue");
const areaIndexes = {
    top: [
        0,
        1,
        2
    ],
    left: [
        0,
        3,
        6
    ],
    right: [
        2,
        5,
        8
    ],
    bottom: [
        6,
        7,
        8
    ]
};
const areaElements = [
    "left",
    "right",
    "top",
    "bottom"
];
const useGridTemplateArea = (props)=>{
    const sort = ()=>{
        return [
            ...areaElements
        ].sort((a, b)=>{
            return (props[a].order ?? 0) - (props[b].order ?? 0);
        });
    };
    const applyTemplate = (template, areaIndexes2, areaName)=>{
        areaIndexes2.forEach((index)=>{
            template[index] = areaName;
        });
    };
    return (0, _vue.computed)(()=>{
        const sorted = sort();
        const template = [
            ".",
            ".",
            ".",
            ".",
            ".",
            ".",
            ".",
            ".",
            "."
        ].map(()=>"content");
        sorted.forEach((areaName)=>{
            applyTemplate(template, areaIndexes[areaName], areaName);
        });
        return [
            '"' + template.slice(0, 3).join(" ") + '"',
            '"' + template.slice(3, 6).join(" ") + '"',
            '"' + template.slice(6, 9).join(" ") + '"'
        ].join(" ");
    });
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5hCzJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useLayout);
parcelHelpers.export(exports, "b", ()=>useFixedLayoutChild);
parcelHelpers.export(exports, "u", ()=>useLayoutProps);
var _vue = require("vue");
const useLayoutProps = {
    top: {
        type: Object,
        default: ()=>({
                order: 2
            })
    },
    right: {
        type: Object,
        default: ()=>({
                order: 1
            })
    },
    left: {
        type: Object,
        default: ()=>({
                order: 1
            })
    },
    bottom: {
        type: Object,
        default: ()=>({
                order: 2
            })
    }
};
const VaLayoutKey = "VaLayout";
const useLayout = (props)=>{
    const items = (0, _vue.ref)({
        top: null,
        right: null,
        bottom: null,
        left: null
    });
    const paddings = (0, _vue.computed)(()=>{
        const { top, right, bottom, left } = items.value;
        const { top: topConfig, right: rightConfig, bottom: bottomConfig, left: leftConfig } = props;
        return {
            top: top && !topConfig.absolute ? top.sizes.height : 0,
            right: right && !rightConfig.absolute ? right.sizes.width : 0,
            bottom: bottom && !bottomConfig.absolute ? bottom.sizes.height : 0,
            left: left && !leftConfig.absolute ? left.sizes.width : 0
        };
    });
    const orders = (0, _vue.computed)(()=>({
            top: props.top.order || 0,
            right: props.right.order || 0,
            bottom: props.bottom.order || 0,
            left: props.left.order || 0
        }));
    (0, _vue.provide)(VaLayoutKey, {
        items,
        paddings,
        orders
    });
    return {
        paddings,
        orders,
        items
    };
};
const useFixedLayoutChild = (area, sizes)=>{
    const layout = (0, _vue.inject)(VaLayoutKey, null);
    if (!layout) throw new Error("VaLayoutChild must be used inside VaLayout");
    (0, _vue.watchEffect)(()=>{
        if (sizes.value) layout.items.value[area] = {
            sizes: sizes.value
        };
        else layout.items.value[area] = null;
    });
    (0, _vue.onBeforeUnmount)(()=>{
        layout.items.value[area] = null;
    });
    return {
        paddings: (0, _vue.computed)(()=>{
            return Object.keys(layout.paddings.value).reduce((acc, key)=>{
                if (layout.orders.value[key] > layout.orders.value[area]) acc[key] = layout.paddings.value[key];
                return acc;
            }, {});
        })
    };
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a6YOA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vaLayoutAbsoluteWrapperJs = require("./VaLayoutAbsoluteWrapper.js");
var _vaLayoutFixedWrapperVueVueTypeScriptSetupTrueLangJs = require("./VaLayoutFixedWrapper.vue_vue_type_script_setup_true_lang.js");
var _vaLayoutAreaCss = require("../../../../VaLayoutArea.css");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaLayoutArea",
    __name: "VaLayoutArea",
    props: {
        area: {
            type: String,
            required: true
        },
        config: {
            type: Object,
            required: true
        }
    },
    emits: [
        "overlay-click"
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const absolute = (0, _vue.computed)(()=>props.config.absolute || false);
        const fixed = (0, _vue.computed)(()=>props.config.fixed || false);
        const overlay = (0, _vue.computed)(()=>props.config.overlay || false);
        const zIndex = (0, _vue.computed)(()=>(props.config.order || 0) + 1);
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), null, [
                absolute.value ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vaLayoutAbsoluteWrapperJs.V), {
                    key: 0,
                    style: (0, _vue.normalizeStyle)(`--va-props-area: ${String(_ctx.$props.area)};--va-z-index: ${String(zIndex.value)};--va-z-index-1: ${String(zIndex.value - 1)}`)
                }, {
                    default: (0, _vue.withCtx)(()=>[
                            (0, _vue.createElementVNode)("div", {
                                class: (0, _vue.normalizeClass)(`va-layout-area va-layout__area va-layout__area--${__props.area}`)
                            }, [
                                fixed.value ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vaLayoutFixedWrapperVueVueTypeScriptSetupTrueLangJs._), {
                                    key: 0,
                                    area: __props.area
                                }, {
                                    default: (0, _vue.withCtx)(()=>[
                                            (0, _vue.renderSlot)(_ctx.$slots, "default")
                                        ]),
                                    _: 3
                                }, 8, [
                                    "area"
                                ])) : (0, _vue.renderSlot)(_ctx.$slots, "default", {
                                    key: 1
                                })
                            ], 2)
                        ]),
                    _: 3
                }, 8, [
                    "style"
                ])) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                    key: 1,
                    class: (0, _vue.normalizeClass)(`va-layout-area va-layout__area va-layout__area--${__props.area}`),
                    style: (0, _vue.normalizeStyle)(`--va-props-area: ${String(_ctx.$props.area)};--va-z-index: ${String(zIndex.value)};--va-z-index-1: ${String(zIndex.value - 1)}`)
                }, [
                    fixed.value ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vaLayoutFixedWrapperVueVueTypeScriptSetupTrueLangJs._), {
                        key: 0,
                        area: __props.area
                    }, {
                        default: (0, _vue.withCtx)(()=>[
                                (0, _vue.renderSlot)(_ctx.$slots, "default")
                            ]),
                        _: 3
                    }, 8, [
                        "area"
                    ])) : (0, _vue.renderSlot)(_ctx.$slots, "default", {
                        key: 1
                    })
                ], 6)),
                (0, _vue.createVNode)((0, _vue.Transition), {
                    style: (0, _vue.normalizeStyle)(`--va-props-area: ${String(_ctx.$props.area)};--va-z-index: ${String(zIndex.value)};--va-z-index-1: ${String(zIndex.value - 1)}`)
                }, {
                    default: (0, _vue.withCtx)(()=>[
                            overlay.value ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                key: 0,
                                class: (0, _vue.normalizeClass)([
                                    "va-layout-area__overlay",
                                    {
                                        "va-layout-area__overlay--fixed": fixed.value
                                    }
                                ]),
                                onClick: _cache[0] || (_cache[0] = ($event)=>_ctx.$emit("overlay-click"))
                            }, null, 2)) : (0, _vue.createCommentVNode)("", true)
                        ]),
                    _: 1
                }, 8, [
                    "style"
                ])
            ], 64);
        };
    }
});

},{"vue":"gzxs9","./VaLayoutAbsoluteWrapper.js":"1QeNE","./VaLayoutFixedWrapper.vue_vue_type_script_setup_true_lang.js":"2tNHB","../../../../VaLayoutArea.css":"XYeXA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1QeNE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaLayoutAbsoluteWrapper);
var _vue = require("vue");
var _pluginVueExportHelperJs = require("../../../../plugin-vue_export-helper.js");
var _vaLayoutAbsoluteWrapperCss = require("../../../../VaLayoutAbsoluteWrapper.css");
const VaLayoutAbsoluteWrapper_vue_vue_type_style_index_0_lang = "";
const _sfc_main = {};
const _hoisted_1 = {
    class: "va-layout__absolute-area-wrapper"
};
function _sfc_render(_ctx, _cache) {
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_1, [
        (0, _vue.renderSlot)(_ctx.$slots, "default")
    ]);
}
const VaLayoutAbsoluteWrapper = /* @__PURE__ */ (0, _pluginVueExportHelperJs._)(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../../plugin-vue_export-helper.js":"broGc","../../../../VaLayoutAbsoluteWrapper.css":"3al1Z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3al1Z":[function() {},{}],"2tNHB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vaResizeObserverVueVueTypeScriptSetupTrueLangJs = require("./VaResizeObserver.vue_vue_type_script_setup_true_lang.js");
var _useLayoutJs = require("../hooks/useLayout.js");
var _vaLayoutFixedWrapperCss = require("../../../../VaLayoutFixedWrapper.css");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaLayoutFixedWrapper",
    __name: "VaLayoutFixedWrapper",
    props: {
        area: {
            type: String,
            required: true
        }
    },
    setup (__props) {
        const props = __props;
        const size = (0, _vue.ref)(null);
        const direction = (0, _vue.computed)(()=>{
            if (props.area === "top" || props.area === "bottom") return "vertical";
            else return "horizontal";
        });
        const getPxOrZero = (value)=>{
            if (!value) return "0px";
            return value + "px";
        };
        const styles = (0, _vue.computed)(()=>{
            if (direction.value === "vertical") return {
                width: `calc(100% - ${getPxOrZero(paddings.value.left)} - ${getPxOrZero(paddings.value.right)})`,
                [props.area]: 0
            };
            else return {
                height: `calc(100% - ${getPxOrZero(paddings.value.top)} - ${getPxOrZero(paddings.value.bottom)})`,
                [props.area]: 0
            };
        });
        const { paddings } = (0, _useLayoutJs.b)(props.area, size);
        (0, _vue.computed)(()=>{
            return Object.keys(paddings.value).reduce((acc, key)=>{
                if (key === props.area) return acc;
                return {
                    ...acc,
                    [key]: `${paddings.value[key]}px`
                };
            }, {});
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: "va-layout-fixed-wrapper",
                style: (0, _vue.normalizeStyle)([
                    [
                        {
                            height: size.value && direction.value === "vertical" ? size.value.height + "px" : "auto",
                            width: size.value && direction.value === "horizontal" ? size.value.width + "px" : "auto"
                        }
                    ],
                    `--va-styles-width: ${String(styles.value.width)};--va-styles-height: ${String(styles.value.height)}`
                ])
            }, [
                (0, _vue.createVNode)((0, _vaResizeObserverVueVueTypeScriptSetupTrueLangJs._), {
                    class: (0, _vue.normalizeClass)([
                        "va-layout-fixed-wrapper__content",
                        `va-layout-fixed-wrapper__content--${__props.area}`
                    ]),
                    style: (0, _vue.normalizeStyle)(!size.value ? {
                        position: "relative"
                    } : {}),
                    onResize: _cache[0] || (_cache[0] = ($event)=>size.value = $event)
                }, {
                    default: (0, _vue.withCtx)(()=>[
                            (0, _vue.renderSlot)(_ctx.$slots, "default")
                        ]),
                    _: 3
                }, 8, [
                    "class",
                    "style"
                ])
            ], 4);
        };
    }
});

},{"vue":"gzxs9","./VaResizeObserver.vue_vue_type_script_setup_true_lang.js":"iYFD0","../hooks/useLayout.js":"5hCzJ","../../../../VaLayoutFixedWrapper.css":"iKMUw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iYFD0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaLayoutSizeKeeper",
    __name: "VaResizeObserver",
    emits: {
        resize: (size)=>true
    },
    setup (__props, { emit: __emit }) {
        const emit = __emit;
        const el = (0, _vue.ref)();
        let observer = null;
        (0, _vue.watch)(el, (newEl)=>{
            if (observer) observer.disconnect();
            observer = new ResizeObserver(([el2])=>{
                emit("resize", el2.contentRect);
            });
            observer.observe(newEl);
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: "va-resize-observer",
                ref_key: "el",
                ref: el
            }, [
                (0, _vue.renderSlot)(_ctx.$slots, "default")
            ], 512);
        };
    }
});

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iKMUw":[function() {},{}],"XYeXA":[function() {},{}],"2GNVm":[function() {},{}],"hIuhr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaNavbar);
parcelHelpers.export(exports, "a", ()=>VaNavbarItem);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaNavbarVueVueTypeScriptSetupTrueLangJs = require("./VaNavbar.vue_vue_type_script_setup_true_lang.js");
var _vaNavbarItemJs = require("./VaNavbarItem/VaNavbarItem.js");
const VaNavbar = (0, _withConfigTransportJs.w)((0, _vaNavbarVueVueTypeScriptSetupTrueLangJs._));
const VaNavbarItem = (0, _withConfigTransportJs.w)((0, _vaNavbarItemJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaNavbar.vue_vue_type_script_setup_true_lang.js":"jcIRb","./VaNavbarItem/VaNavbarItem.js":"hlmSL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jcIRb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useFixedBarJs = require("../../composables/useFixedBar.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useScrollJs = require("../../composables/useScroll.js");
var _useColorsJs = require("../../composables/useColors.js");
var _useTextColorJs = require("../../composables/useTextColor.js");
var _useBemJs = require("../../composables/useBem.js");
var _vaNavbarCss = require("../../../VaNavbar.css");
const _hoisted_1 = {
    class: "va-navbar__left"
};
const _hoisted_2 = {
    class: "va-navbar__center"
};
const _hoisted_3 = {
    class: "va-navbar__right"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaNavbar",
    __name: "VaNavbar",
    props: {
        ...(0, _useFixedBarJs.u),
        ...(0, _useComponentPresetJs.u),
        color: {
            type: String,
            default: "background-secondary"
        },
        textColor: {
            type: String
        },
        shape: {
            type: Boolean,
            default: false
        },
        shadowed: {
            type: Boolean,
            default: false
        },
        bordered: {
            type: Boolean,
            default: false
        }
    },
    setup (__props) {
        const props = __props;
        const { scrollRoot, isScrolledDown } = (0, _useScrollJs.s)(props.fixed);
        const { fixedBarStyleComputed } = (0, _useFixedBarJs.a)(props, isScrolledDown);
        const { getColor, shiftHSLAColor } = (0, _useColorsJs.u)();
        const color = (0, _vue.computed)(()=>getColor(props.color));
        const { textColorComputed } = (0, _useTextColorJs.u)(color);
        const shapeStyleComputed = (0, _vue.computed)(()=>({
                borderTopColor: shiftHSLAColor(color.value, {
                    h: -1,
                    s: -11,
                    l: 10
                })
            }));
        const computedStyle = (0, _vue.computed)(()=>({
                ...fixedBarStyleComputed.value,
                backgroundColor: color.value,
                color: textColorComputed.value,
                fill: textColorComputed.value
            }));
        const bemClasses = (0, _useBemJs.u)("va-navbar", ()=>({
                shadowed: props.shadowed,
                bordered: props.bordered
            }));
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("header", {
                ref_key: "scrollRoot",
                ref: scrollRoot,
                class: (0, _vue.normalizeClass)([
                    "va-navbar",
                    (0, _vue.unref)(bemClasses)
                ]),
                style: (0, _vue.normalizeStyle)(computedStyle.value)
            }, [
                (0, _vue.renderSlot)(_ctx.$slots, "default", {}, ()=>[
                        (0, _vue.createElementVNode)("div", _hoisted_1, [
                            (0, _vue.renderSlot)(_ctx.$slots, "left")
                        ]),
                        (0, _vue.createElementVNode)("div", _hoisted_2, [
                            (0, _vue.renderSlot)(_ctx.$slots, "center")
                        ]),
                        (0, _vue.createElementVNode)("div", _hoisted_3, [
                            (0, _vue.renderSlot)(_ctx.$slots, "right")
                        ])
                    ]),
                __props.shape ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                    key: 0,
                    class: "va-navbar__background-shape",
                    style: (0, _vue.normalizeStyle)(shapeStyleComputed.value)
                }, null, 4)) : (0, _vue.createCommentVNode)("", true)
            ], 6);
        };
    }
});

},{"vue":"gzxs9","../../composables/useFixedBar.js":"2bcxS","../../composables/useComponentPreset.js":"2HoaT","../../composables/useScroll.js":"dESBl","../../composables/useColors.js":"a4Qgv","../../composables/useTextColor.js":"5pfXb","../../composables/useBem.js":"igmjV","../../../VaNavbar.css":"ctKo2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ctKo2":[function() {},{}],"hlmSL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_VaNavbarItem);
var _vue = require("vue");
var _pluginVueExportHelperJs = require("../../../../plugin-vue_export-helper.js");
var _vaNavbarItemCss = require("../../../../VaNavbarItem.css");
const VaNavbarItem_vue_vue_type_style_index_0_lang = "";
const _sfc_main = (0, _vue.defineComponent)({
    name: "VaNavbarItem",
    props: {}
});
const _hoisted_1 = {
    class: "va-navbar__item"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_1, [
        (0, _vue.renderSlot)(_ctx.$slots, "default")
    ]);
}
const _VaNavbarItem = /* @__PURE__ */ (0, _pluginVueExportHelperJs._)(_sfc_main, [
    [
        "render",
        _sfc_render
    ]
]);

},{"vue":"gzxs9","../../../../plugin-vue_export-helper.js":"broGc","../../../../VaNavbarItem.css":"8TANt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8TANt":[function() {},{}],"15vCn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaOptionList);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaOptionListVueVueTypeScriptSetupTrueLangJs = require("./VaOptionList.vue_vue_type_script_setup_true_lang.js");
const VaOptionList = (0, _withConfigTransportJs.w)((0, _vaOptionListVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaOptionList.vue_vue_type_script_setup_true_lang.js":"2zrfH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2zrfH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../vendor.js");
var _envJs = require("../../utils/env.js");
var _indexJs = require("../va-checkbox/index.js");
var _indexJs1 = require("../va-radio/index.js");
var _indexJs2 = require("../va-switch/index.js");
var _useArrayRefsJs = require("../../composables/useArrayRefs.js");
var _vaMessageListWrapperVueVueTypeScriptSetupTrueLangJs = require("../va-message-list/VaMessageListWrapper.vue_vue_type_script_setup_true_lang.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useSelectableListJs = require("../../composables/useSelectableList.js");
var _useValidationJs = require("../../composables/useValidation.js");
var _useStatefulJs = require("../../composables/useStateful.js");
var _vaOptionListCss = require("../../../VaOptionList.css");
const _hoisted_1 = {
    class: "va-option-list__list"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaOptionList",
    __name: "VaOptionList",
    props: {
        ...(0, _useComponentPresetJs.u),
        ...(0, _useSelectableListJs.u),
        ...(0, _useValidationJs.b),
        ...(0, _useStatefulJs.u),
        type: {
            type: String,
            default: "checkbox",
            validator: (type)=>[
                    "radio",
                    "checkbox",
                    "switch"
                ].includes(type)
        },
        disabled: {
            type: Boolean,
            default: false
        },
        readonly: {
            type: Boolean,
            default: false
        },
        defaultValue: {
            type: [
                String,
                Number,
                Boolean,
                Object,
                Array
            ]
        },
        name: {
            type: String,
            default: ""
        },
        color: {
            type: String,
            default: "primary"
        },
        leftLabel: {
            type: Boolean,
            default: false
        },
        modelValue: {
            type: [
                String,
                Number,
                Boolean,
                Object,
                Array
            ]
        }
    },
    emits: [
        ...(0, _useStatefulJs.a),
        ...(0, _useValidationJs.u),
        "clear"
    ],
    setup (__props, { expose: __expose, emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const { valueComputed } = (0, _useStatefulJs.b)(props, emit, "modelValue", {
            defaultValue: props.defaultValue
        });
        const { getValue, getText, getTrackBy, getDisabled } = (0, _useSelectableListJs.a)(props);
        const { itemRefs, setItemRef } = (0, _useArrayRefsJs.u)();
        const isRadio = (0, _vue.computed)(()=>props.type === "radio");
        const selectedValue = (0, _vue.computed)({
            get () {
                const value = isRadio.value ? null : [];
                return valueComputed.value || value;
            },
            set (value) {
                if (props.readonly) return;
                if (isRadio.value && !Array.isArray(value)) valueComputed.value = value ? getValue(value) : value;
                else valueComputed.value = Array.isArray(value) ? value.map(getValue) : [
                    value ? getValue(value) : value
                ];
            }
        });
        const isDisabled = (option)=>props.disabled || getDisabled(option);
        const reset = ()=>withoutValidation(()=>{
                valueComputed.value = null;
                emit("clear");
                resetValidation();
            });
        const focus = ()=>{
            const firstActiveEl = Array.isArray(itemRefs.value) && itemRefs.value.find((el)=>!el.disabled);
            if (firstActiveEl && typeof firstActiveEl.focus === "function") firstActiveEl.focus();
        };
        const { computedError, computedErrorMessages, withoutValidation, resetValidation } = (0, _useValidationJs.a)(props, emit, {
            reset,
            focus,
            value: valueComputed
        });
        const computedProps = (0, _vue.computed)(()=>(0, _vendorJs.p)(props, [
                "name",
                "color",
                "readonly",
                "leftLabel"
            ]));
        (0, _vue.onMounted)(()=>{
            if ((0, _envJs.i) && props.type !== "radio" && !Array.isArray(props.modelValue)) console.warn(`Prop 'modelValue = ${props.modelValue}' has not a proper type!
 For component property 'type = ${props.type}' it must be of type 'array'.`);
        });
        __expose({
            focus,
            reset
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _vaMessageListWrapperVueVueTypeScriptSetupTrueLangJs._)), {
                error: (0, _vue.unref)(computedError),
                "error-messages": (0, _vue.unref)(computedErrorMessages),
                "error-count": _ctx.$props.errorCount
            }, {
                default: (0, _vue.withCtx)(()=>[
                        (0, _vue.createElementVNode)("ul", _hoisted_1, [
                            ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)(_ctx.$props.options, (option)=>{
                                return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("li", {
                                    key: (0, _vue.unref)(getTrackBy)(option)
                                }, [
                                    (0, _vue.renderSlot)(_ctx.$slots, "default", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                        option,
                                        selectedValue: selectedValue.value,
                                        isDisabled,
                                        getText: (0, _vue.unref)(getText),
                                        getValue: (0, _vue.unref)(getValue)
                                    })), ()=>[
                                            _ctx.$props.type === "radio" ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs1.V)), (0, _vue.mergeProps)({
                                                key: 0,
                                                ref_for: true,
                                                ref: (0, _vue.unref)(setItemRef),
                                                modelValue: selectedValue.value,
                                                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event)=>selectedValue.value = $event),
                                                label: (0, _vue.unref)(getText)(option),
                                                disabled: isDisabled(option),
                                                option: (0, _vue.unref)(getValue)(option)
                                            }, computedProps.value), null, 16, [
                                                "modelValue",
                                                "label",
                                                "disabled",
                                                "option"
                                            ])) : _ctx.$props.type === "checkbox" ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), (0, _vue.mergeProps)({
                                                key: 1,
                                                ref_for: true,
                                                ref: (0, _vue.unref)(setItemRef),
                                                modelValue: selectedValue.value,
                                                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event)=>selectedValue.value = $event),
                                                label: (0, _vue.unref)(getText)(option),
                                                disabled: isDisabled(option),
                                                "array-value": (0, _vue.unref)(getValue)(option)
                                            }, computedProps.value), null, 16, [
                                                "modelValue",
                                                "label",
                                                "disabled",
                                                "array-value"
                                            ])) : ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs2.V)), (0, _vue.mergeProps)({
                                                key: 2,
                                                ref_for: true,
                                                ref: (0, _vue.unref)(setItemRef),
                                                modelValue: selectedValue.value,
                                                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event)=>selectedValue.value = $event),
                                                label: (0, _vue.unref)(getText)(option),
                                                disabled: isDisabled(option),
                                                "array-value": (0, _vue.unref)(getValue)(option)
                                            }, computedProps.value), null, 16, [
                                                "modelValue",
                                                "label",
                                                "disabled",
                                                "array-value"
                                            ]))
                                        ])
                                ]);
                            }), 128))
                        ])
                    ]),
                _: 3
            }, 8, [
                "error",
                "error-messages",
                "error-count"
            ]);
        };
    }
});

},{"vue":"gzxs9","../../../vendor.js":"l6TAc","../../utils/env.js":"Fmkmq","../va-checkbox/index.js":"w8J04","../va-radio/index.js":"9hzhI","../va-switch/index.js":"3NSps","../../composables/useArrayRefs.js":"jgG1u","../va-message-list/VaMessageListWrapper.vue_vue_type_script_setup_true_lang.js":"050bm","../../composables/useComponentPreset.js":"2HoaT","../../composables/useSelectableList.js":"5kDaP","../../composables/useValidation.js":"iFHh2","../../composables/useStateful.js":"h9zUi","../../../VaOptionList.css":"5Dou2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9hzhI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaRadio);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaRadioVueVueTypeScriptSetupTrueLangJs = require("./VaRadio.vue_vue_type_script_setup_true_lang.js");
const VaRadio = (0, _withConfigTransportJs.w)((0, _vaRadioVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaRadio.vue_vue_type_script_setup_true_lang.js":"kSYAO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kSYAO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useComponentUuidJs = require("../../composables/useComponentUuid.js");
var _vaMessageListWrapperVueVueTypeScriptSetupTrueLangJs = require("../va-message-list/VaMessageListWrapper.vue_vue_type_script_setup_true_lang.js");
var _useSelectableJs = require("../../composables/useSelectable.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useSelectableListJs = require("../../composables/useSelectableList.js");
var _useColorsJs = require("../../composables/useColors.js");
var _vaRadioCss = require("../../../VaRadio.css");
const _hoisted_1 = [
    "role"
];
const _hoisted_2 = [
    "value",
    "checked",
    "aria-checked",
    "onChange"
];
const _hoisted_3 = /* @__PURE__ */ (0, _vue.createElementVNode)("span", {
    "aria-hidden": "true",
    class: "va-radio__icon"
}, [
    /* @__PURE__ */ (0, _vue.createElementVNode)("span", {
        class: "va-radio__icon__background"
    }),
    /* @__PURE__ */ (0, _vue.createElementVNode)("span", {
        class: "va-radio__icon__dot"
    })
], -1);
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaRadio",
    __name: "VaRadio",
    props: {
        ...(0, _useSelectableJs.u),
        ...(0, _useComponentPresetJs.u),
        ...(0, _useSelectableListJs.u),
        modelValue: {
            type: [
                Boolean,
                Array,
                String,
                Object,
                Number
            ],
            default: null
        },
        options: {
            type: Array,
            default: ()=>[]
        },
        name: {
            type: String,
            default: ""
        },
        label: {
            type: String,
            default: void 0
        },
        leftLabel: {
            type: Boolean,
            default: false
        },
        color: {
            type: String,
            default: "primary"
        },
        option: {
            type: [
                Object,
                String,
                Number
            ],
            default: void 0
        },
        vertical: {
            type: Boolean,
            default: false
        }
    },
    emits: (0, _useSelectableJs.a),
    setup (__props, { emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const { getColor } = (0, _useColorsJs.u)();
        const elements = {
            container: (0, _vue.shallowRef)(),
            input: (0, _vue.shallowRef)(),
            label: (0, _vue.shallowRef)()
        };
        const { computedError, computedErrorMessages, validationAriaAttributes, onBlur, onFocus } = (0, _useSelectableJs.b)(props, emit, elements);
        const { getText: originalGetText, getDisabled: originalGetDisabled, getValue } = (0, _useSelectableListJs.a)(props);
        const getText = (option)=>{
            if (props.options.length > 0) return originalGetText(option);
            return props.label ?? originalGetText(option);
        };
        const getDisabled = (option)=>originalGetDisabled(option) || props.disabled;
        const isNoOption = (0, _vue.computed)(()=>props.options.length === 0 && !props.option);
        const isChecked = (option)=>{
            if (isNoOption.value) return props.modelValue;
            return props.modelValue === getValue(option);
        };
        const computedOptions = (0, _vue.computed)(()=>{
            if (isNoOption.value) return [
                {}
            ];
            if (props.option) return [
                props.option
            ];
            else return props.options;
        });
        const radioClass = (option)=>({
                "va-radio--left-label": props.leftLabel,
                "va-radio--selected": isChecked(option),
                "va-radio--readonly": props.readonly,
                "va-radio--disabled": props.disabled,
                "va-radio--indeterminate": props.indeterminate,
                "va-radio--error": computedError.value,
                "va-radio--single-option": isNoOption.value
            });
        const selectOption = (option, event)=>{
            var _a;
            if (isNoOption.value) {
                emit("update:modelValue", ((_a = event == null ? void 0 : event.target) == null ? void 0 : _a.checked) || false);
                return;
            }
            emit("update:modelValue", option);
        };
        const labelStyle = (0, _vue.computed)(()=>{
            return {
                color: computedError.value ? getColor("danger") : ""
            };
        });
        (0, _vue.computed)(()=>{
            const style = {
                background: getColor(props.color),
                borderColor: getColor(props.color)
            };
            if (computedError.value) style.borderColor = getColor("danger");
            return style;
        });
        const iconBackgroundComputedStyles = (0, _vue.computed)(()=>({
                backgroundColor: getColor(props.color)
            }));
        const iconDotComputedStyles = (0, _vue.computed)(()=>{
            return {
                borderColor: computedError.value ? getColor("danger") : getColor(props.color),
                backgroundColor: getColor(props.color)
            };
        });
        const iconComputedStyles = (0, _vue.computed)(()=>{
            return {
                borderColor: computedError.value ? getColor("danger") : getColor(props.color)
            };
        });
        const componentId = (0, _useComponentUuidJs.u)();
        const computedName = (0, _vue.computed)(()=>props.name || componentId);
        const inputAttributesComputed = (option)=>{
            const disabled = getDisabled(option);
            return {
                name: computedName.value,
                disabled,
                readonly: props.readonly,
                tabindex: disabled ? -1 : 0
            };
        };
        const flexDirection = (0, _vue.computed)(()=>props.vertical ? "column" : "row");
        const roleComputed = (0, _vue.computed)(()=>{
            var _a;
            return ((_a = props.options) == null ? void 0 : _a.length) > 0 ? "radiogroup" : "";
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _vaMessageListWrapperVueVueTypeScriptSetupTrueLangJs._)), {
                disabled: _ctx.disabled,
                success: _ctx.success,
                messages: _ctx.messages,
                error: (0, _vue.unref)(computedError),
                "error-messages": (0, _vue.unref)(computedErrorMessages),
                "error-count": _ctx.errorCount,
                onBlur: (0, _vue.unref)(onBlur),
                style: (0, _vue.normalizeStyle)(`--va-flex-direction: ${String(flexDirection.value)};--va-label-style-color: ${String(labelStyle.value.color)};--va-icon-computed-styles-border-color: ${String(iconComputedStyles.value.borderColor)};--va-icon-dot-computed-styles-border-color: ${String(iconDotComputedStyles.value.borderColor)};--va-icon-dot-computed-styles-background-color: ${String(iconDotComputedStyles.value.backgroundColor)};--va-icon-background-computed-styles-background-color: ${String(iconBackgroundComputedStyles.value.backgroundColor)}`)
            }, {
                default: (0, _vue.withCtx)(({ ariaAttributes })=>[
                        (0, _vue.createElementVNode)("div", (0, _vue.mergeProps)({
                            ref: "container",
                            class: "va-radio",
                            role: roleComputed.value
                        }, ariaAttributes), [
                            ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)(computedOptions.value, (option, index)=>{
                                return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("label", {
                                    key: index,
                                    class: (0, _vue.normalizeClass)([
                                        radioClass(option),
                                        "va-radio__square"
                                    ])
                                }, [
                                    (0, _vue.createElementVNode)("input", (0, _vue.mergeProps)({
                                        ref_for: true,
                                        ref: "input",
                                        class: "va-radio__input",
                                        type: "radio",
                                        role: "radio",
                                        value: isChecked(option),
                                        checked: isChecked(option),
                                        "aria-checked": isChecked(option)
                                    }, {
                                        ...inputAttributesComputed(option),
                                        ...ariaAttributes
                                    }, {
                                        onChange: ($event)=>selectOption((0, _vue.unref)(getValue)(option), $event),
                                        onFocus: _cache[0] || (_cache[0] = (...args)=>(0, _vue.unref)(onFocus) && (0, _vue.unref)(onFocus)(...args)),
                                        onBlur: _cache[1] || (_cache[1] = (...args)=>(0, _vue.unref)(onBlur) && (0, _vue.unref)(onBlur)(...args))
                                    }), null, 16, _hoisted_2),
                                    (0, _vue.renderSlot)(_ctx.$slots, "icon", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                        value: isChecked(option),
                                        text: getText(option),
                                        disabled: getDisabled(option),
                                        index
                                    })), ()=>[
                                            _hoisted_3
                                        ]),
                                    getText(option) || _ctx.$slots.default ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                        key: 0,
                                        ref_for: true,
                                        ref: "label",
                                        class: "va-radio__text"
                                    }, [
                                        (0, _vue.renderSlot)(_ctx.$slots, "default", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                            value: isChecked(option),
                                            text: getText(option),
                                            disabled: getDisabled(option),
                                            index
                                        })), ()=>[
                                                (0, _vue.createTextVNode)((0, _vue.toDisplayString)(getText(option)), 1)
                                            ])
                                    ], 512)) : (0, _vue.createCommentVNode)("", true)
                                ], 2);
                            }), 128))
                        ], 16, _hoisted_1)
                    ]),
                _: 3
            }, 8, [
                "disabled",
                "success",
                "messages",
                "error",
                "error-messages",
                "error-count",
                "onBlur",
                "style"
            ]);
        };
    }
});

},{"vue":"gzxs9","../../composables/useComponentUuid.js":"cuNNa","../va-message-list/VaMessageListWrapper.vue_vue_type_script_setup_true_lang.js":"050bm","../../composables/useSelectable.js":"3Z4bC","../../composables/useComponentPreset.js":"2HoaT","../../composables/useSelectableList.js":"5kDaP","../../composables/useColors.js":"a4Qgv","../../../VaRadio.css":"2SJf5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2SJf5":[function() {},{}],"3NSps":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaSwitch);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaSwitchVueVueTypeScriptSetupTrueLangJs = require("./VaSwitch.vue_vue_type_script_setup_true_lang.js");
const VaSwitch = (0, _withConfigTransportJs.w)((0, _vaSwitchVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaSwitch.vue_vue_type_script_setup_true_lang.js":"aD8dI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aD8dI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../vendor.js");
var _indexJs = require("../va-progress-circle/index.js");
var _useComponentUuidJs = require("../../composables/useComponentUuid.js");
var _vaMessageListWrapperVueVueTypeScriptSetupTrueLangJs = require("../va-message-list/VaMessageListWrapper.vue_vue_type_script_setup_true_lang.js");
var _useSelectableJs = require("../../composables/useSelectable.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useColorsJs = require("../../composables/useColors.js");
var _useKeyboardOnlyFocusJs = require("../../composables/useKeyboardOnlyFocus.js");
var _useTextColorJs = require("../../composables/useTextColor.js");
var _useBemJs = require("../../composables/useBem.js");
var _vaSwitchCss = require("../../../VaSwitch.css");
const _hoisted_1 = {
    class: "va-switch__inner"
};
const _hoisted_2 = {
    class: "va-switch__checker-wrapper"
};
const _hoisted_3 = {
    class: "va-switch__checker"
};
const _hoisted_4 = {
    class: "va-switch__checker-circle"
};
const _hoisted_5 = [
    "id"
];
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaSwitch",
    __name: "VaSwitch",
    props: {
        ...(0, _useSelectableJs.u),
        ...(0, _useComponentPresetJs.u),
        id: {
            type: String,
            default: ""
        },
        name: {
            type: String,
            default: ""
        },
        modelValue: {
            type: [
                Number,
                Boolean,
                Array,
                String,
                Object
            ],
            default: false
        },
        trueLabel: {
            type: String,
            default: null
        },
        falseLabel: {
            type: String,
            default: null
        },
        trueInnerLabel: {
            type: String,
            default: null
        },
        falseInnerLabel: {
            type: String,
            default: null
        },
        ariaLabel: {
            type: String,
            default: "$t:switch"
        },
        color: {
            type: String,
            default: "primary"
        },
        offColor: {
            type: String,
            default: "background-element"
        },
        size: {
            type: String,
            default: "medium",
            validator: (value)=>[
                    "medium",
                    "small",
                    "large"
                ].includes(value)
        }
    },
    emits: [
        ...(0, _useSelectableJs.a),
        "focus",
        "blur",
        "update:modelValue"
    ],
    setup (__props, { expose: __expose, emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const elements = {
            container: (0, _vue.shallowRef)(),
            input: (0, _vue.shallowRef)(),
            label: (0, _vue.shallowRef)()
        };
        const { getColor } = (0, _useColorsJs.u)();
        const { hasKeyboardFocus, keyboardFocusListeners } = (0, _useKeyboardOnlyFocusJs.u)();
        const { isChecked, computedError, isIndeterminate, computedErrorMessages, validationAriaAttributes, toggleSelection, onBlur, onFocus, reset, focus } = (0, _useSelectableJs.b)(props, emit, elements);
        const computedBackground = (0, _vue.computed)(()=>getColor(isChecked.value ? props.color : props.offColor));
        const { textColorComputed } = (0, _useTextColorJs.u)(computedBackground);
        const computedInnerLabel = (0, _vue.computed)(()=>{
            if (props.trueInnerLabel && isChecked.value) return props.trueInnerLabel;
            if (props.falseInnerLabel && !isChecked.value) return props.falseInnerLabel;
            return "";
        });
        const computedLabel = (0, _vue.computed)(()=>{
            if (props.trueLabel && isChecked.value) return props.trueLabel;
            if (props.falseLabel && !isChecked.value) return props.falseLabel;
            return props.label;
        });
        const computedClass = (0, _useBemJs.u)("va-switch", ()=>({
                ...(0, _vendorJs.p)(props, [
                    "readonly",
                    "disabled",
                    "leftLabel"
                ]),
                checked: isChecked.value,
                indeterminate: isIndeterminate.value,
                small: props.size === "small",
                large: props.size === "large",
                error: computedError.value,
                keyboardFocus: hasKeyboardFocus.value
            }));
        const styleComputed = (0, _vue.computed)(()=>({
                lineHeight: computedErrorMessages.value.length ? 1 : 0
            }));
        const progressCircleSize = (0, _vue.computed)(()=>{
            const size = {
                small: "15px",
                medium: "20px",
                large: "25px"
            };
            return size[props.size];
        });
        const trackStyle = (0, _vue.computed)(()=>({
                borderColor: computedError.value ? getColor("danger") : "",
                backgroundColor: computedBackground.value
            }));
        const labelStyle = (0, _vue.computed)(()=>({
                color: computedError.value ? getColor("danger") : ""
            }));
        const trackLabelStyle = (0, _vue.computed)(()=>({
                color: textColorComputed.value,
                "text-align": isChecked.value ? "left" : "right"
            }));
        const slots = (0, _vue.useSlots)();
        const componentId = (0, _useComponentUuidJs.u)();
        const ariaLabelIdComputed = (0, _vue.computed)(()=>`aria-label-id-${componentId}`);
        const inputAttributesComputed = (0, _vue.computed)(()=>({
                id: props.id || void 0,
                name: props.name || void 0,
                disabled: props.disabled,
                readonly: props.readonly,
                "aria-disabled": props.disabled,
                "aria-readonly": props.readonly,
                "aria-checked": !!props.modelValue,
                "aria-label": !slots.default ? props.ariaLabel : void 0,
                "aria-labelledby": computedLabel.value || slots.default ? ariaLabelIdComputed.value : void 0,
                tabindex: props.disabled ? -1 : 0,
                checked: isChecked.value,
                ...validationAriaAttributes.value
            }));
        const onEnterKeyPress = ()=>{
            var _a;
            (_a = elements.input.value) == null || _a.click();
        };
        const input = elements.input;
        __expose({
            focus,
            reset
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _vaMessageListWrapperVueVueTypeScriptSetupTrueLangJs._)), {
                class: (0, _vue.normalizeClass)([
                    "va-switch",
                    (0, _vue.unref)(computedClass)
                ]),
                style: (0, _vue.normalizeStyle)(styleComputed.value),
                disabled: _ctx.$props.disabled,
                success: _ctx.$props.success,
                messages: _ctx.$props.messages,
                error: (0, _vue.unref)(computedError),
                "error-messages": (0, _vue.unref)(computedErrorMessages),
                "error-count": _ctx.$props.errorCount
            }, {
                default: (0, _vue.withCtx)(()=>[
                        (0, _vue.createElementVNode)("div", {
                            ref: "container",
                            class: "va-switch__container",
                            tabindex: "-1",
                            onBlur: _cache[5] || (_cache[5] = (...args)=>(0, _vue.unref)(onBlur) && (0, _vue.unref)(onBlur)(...args)),
                            onClick: _cache[6] || (_cache[6] = (...args)=>(0, _vue.unref)(toggleSelection) && (0, _vue.unref)(toggleSelection)(...args))
                        }, [
                            (0, _vue.createElementVNode)("div", _hoisted_1, [
                                (0, _vue.createElementVNode)("input", (0, _vue.mergeProps)({
                                    ref_key: "input",
                                    ref: input,
                                    type: "checkbox",
                                    class: "va-switch__input",
                                    role: "switch"
                                }, inputAttributesComputed.value, (0, _vue.toHandlers)((0, _vue.unref)(keyboardFocusListeners), true), {
                                    onFocus: _cache[0] || (_cache[0] = (...args)=>(0, _vue.unref)(onFocus) && (0, _vue.unref)(onFocus)(...args)),
                                    onBlur: _cache[1] || (_cache[1] = (...args)=>(0, _vue.unref)(onBlur) && (0, _vue.unref)(onBlur)(...args)),
                                    onKeypress: (0, _vue.withKeys)(onEnterKeyPress, [
                                        "enter"
                                    ])
                                }), null, 16),
                                (0, _vue.createElementVNode)("div", {
                                    class: "va-switch__track",
                                    "aria-hidden": "true",
                                    style: (0, _vue.normalizeStyle)(trackStyle.value)
                                }, [
                                    computedInnerLabel.value || _ctx.$slots.innerLabel ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                        key: 0,
                                        class: "va-switch__track-label",
                                        style: (0, _vue.normalizeStyle)(trackLabelStyle.value)
                                    }, [
                                        (0, _vue.renderSlot)(_ctx.$slots, "innerLabel", {}, ()=>[
                                                (0, _vue.createTextVNode)((0, _vue.toDisplayString)(computedInnerLabel.value), 1)
                                            ])
                                    ], 4)) : (0, _vue.createCommentVNode)("", true),
                                    (0, _vue.createElementVNode)("div", _hoisted_2, [
                                        (0, _vue.createElementVNode)("div", _hoisted_3, [
                                            (0, _vue.renderSlot)(_ctx.$slots, "checker", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                                value: (0, _vue.unref)(isChecked)
                                            })), ()=>[
                                                    (0, _vue.createElementVNode)("div", _hoisted_4, [
                                                        _ctx.$props.loading ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), {
                                                            key: 0,
                                                            indeterminate: "",
                                                            size: progressCircleSize.value,
                                                            color: trackStyle.value.backgroundColor
                                                        }, null, 8, [
                                                            "size",
                                                            "color"
                                                        ])) : (0, _vue.createCommentVNode)("", true)
                                                    ])
                                                ])
                                        ])
                                    ])
                                ], 4)
                            ]),
                            computedLabel.value || _ctx.$slots.default ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                key: 0,
                                ref: "label",
                                class: "va-switch__label",
                                style: (0, _vue.normalizeStyle)(labelStyle.value),
                                id: ariaLabelIdComputed.value,
                                onBlur: _cache[2] || (_cache[2] = (...args)=>(0, _vue.unref)(onBlur) && (0, _vue.unref)(onBlur)(...args)),
                                onClick: _cache[3] || (_cache[3] = (...args)=>(0, _vue.unref)(toggleSelection) && (0, _vue.unref)(toggleSelection)(...args)),
                                onKeydown: _cache[4] || (_cache[4] = (0, _vue.withKeys)((0, _vue.withModifiers)(//@ts-ignore
                                (...args)=>(0, _vue.unref)(toggleSelection) && (0, _vue.unref)(toggleSelection)(...args), [
                                    "stop"
                                ]), [
                                    "enter"
                                ]))
                            }, [
                                (0, _vue.renderSlot)(_ctx.$slots, "default", {}, ()=>[
                                        (0, _vue.createTextVNode)((0, _vue.toDisplayString)(computedLabel.value), 1)
                                    ])
                            ], 44, _hoisted_5)) : (0, _vue.createCommentVNode)("", true)
                        ], 544)
                    ]),
                _: 3
            }, 8, [
                "class",
                "style",
                "disabled",
                "success",
                "messages",
                "error",
                "error-messages",
                "error-count"
            ]);
        };
    }
});

},{"vue":"gzxs9","../../../vendor.js":"l6TAc","../va-progress-circle/index.js":"dZCnz","../../composables/useComponentUuid.js":"cuNNa","../va-message-list/VaMessageListWrapper.vue_vue_type_script_setup_true_lang.js":"050bm","../../composables/useSelectable.js":"3Z4bC","../../composables/useComponentPreset.js":"2HoaT","../../composables/useColors.js":"a4Qgv","../../composables/useKeyboardOnlyFocus.js":"lKbNJ","../../composables/useTextColor.js":"5pfXb","../../composables/useBem.js":"igmjV","../../../VaSwitch.css":"UCcjC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"UCcjC":[function() {},{}],"jgG1u":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useArrayRefs);
var _vue = require("vue");
const useArrayRefs = ()=>{
    const itemRefs = (0, _vue.shallowRef)([]);
    const setItemRef = (el)=>{
        if (!el) return;
        itemRefs.value.push(el);
    };
    const setItemRefByIndex = (index)=>(el)=>{
            if (!el) return;
            itemRefs.value[index] = el;
        };
    (0, _vue.onBeforeUpdate)(()=>{
        itemRefs.value = [];
    });
    return {
        itemRefs,
        setItemRef,
        setItemRefByIndex
    };
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5Dou2":[function() {},{}],"dctxF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaPagination);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaPaginationVueVueTypeScriptSetupTrueLangJs = require("./VaPagination.vue_vue_type_script_setup_true_lang.js");
const VaPagination = (0, _withConfigTransportJs.w)((0, _vaPaginationVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaPagination.vue_vue_type_script_setup_true_lang.js":"9uk5w","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9uk5w":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../vendor.js");
var _envJs = require("../../utils/env.js");
var _setPaginationRangeJs = require("./setPaginationRange.js");
var _indexJs = require("../va-button/index.js");
var _useStatefulJs = require("../../composables/useStateful.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useArrayRefsJs = require("../../composables/useArrayRefs.js");
var _useColorsJs = require("../../composables/useColors.js");
var _useBemJs = require("../../composables/useBem.js");
var _useTranslationJs = require("../../composables/useTranslation.js");
var _vaPaginationCss = require("../../../VaPagination.css");
const _hoisted_1 = [
    "aria-label",
    "onKeydown"
];
const _hoisted_2 = [
    "aria-label"
];
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaPagination",
    __name: "VaPagination",
    props: {
        ...(0, _useStatefulJs.u),
        ...(0, _useComponentPresetJs.u),
        modelValue: {
            type: Number,
            default: 1
        },
        visiblePages: {
            type: Number,
            default: 0
        },
        pages: {
            type: Number,
            default: 0
        },
        disabled: {
            type: Boolean,
            default: false
        },
        color: {
            type: String,
            default: "primary"
        },
        size: {
            type: String,
            default: "medium",
            validator: (v)=>[
                    "small",
                    "medium",
                    "large"
                ].includes(v)
        },
        boundaryLinks: {
            type: Boolean,
            default: true
        },
        boundaryNumbers: {
            type: Boolean,
            default: false
        },
        directionLinks: {
            type: Boolean,
            default: true
        },
        input: {
            type: Boolean,
            default: false
        },
        hideOnSinglePage: {
            type: Boolean,
            default: false
        },
        total: {
            type: Number,
            default: null
        },
        pageSize: {
            type: Number,
            default: null
        },
        boundaryIconLeft: {
            type: String,
            default: "va-arrow-first"
        },
        boundaryIconRight: {
            type: String,
            default: "va-arrow-last"
        },
        directionIconLeft: {
            type: String,
            default: "va-arrow-left"
        },
        directionIconRight: {
            type: String,
            default: "va-arrow-right"
        },
        gapped: {
            type: Boolean,
            default: false
        },
        borderColor: {
            type: String,
            default: ""
        },
        rounded: {
            type: Boolean,
            default: false
        },
        /** @deprecated Use activeButtonProps="{ color: 'myColor' }" */ activePageColor: {
            type: String,
            default: ""
        },
        activeButtonProps: {
            type: Object,
            default: ()=>({})
        },
        buttonProps: {
            type: Object,
            default: ()=>({})
        },
        buttonsPreset: {
            type: String,
            default: "primary"
        },
        ariaLabel: {
            type: String,
            default: "$t:pagination"
        },
        ariaGoToTheFirstPageLabel: {
            type: String,
            default: "$t:goToTheFirstPage"
        },
        ariaGoToPreviousPageLabel: {
            type: String,
            default: "$t:goToPreviousPage"
        },
        ariaGoToSpecificPageLabel: {
            type: String,
            default: "$t:goToSpecificPage"
        },
        ariaGoToSpecificPageInputLabel: {
            type: String,
            default: "$t:goToSpecificPageInput"
        },
        ariaGoToNextPageLabel: {
            type: String,
            default: "$t:goNextPage"
        },
        ariaGoToLastPageLabel: {
            type: String,
            default: "$t:goLastPage"
        }
    },
    emits: [
        ...(0, _useStatefulJs.a)
    ],
    setup (__props, { expose: __expose, emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const htmlInput = (0, _vue.shallowRef)();
        const inputValue = (0, _vue.ref)("");
        const usesTotal = (0, _vue.computed)(()=>!!((props.total || props.total === 0) && props.pageSize));
        const { valueComputed } = (0, _useStatefulJs.b)(props, emit);
        const currentValue = (0, _vue.computed)({
            get: ()=>usesTotal.value ? Math.ceil(valueComputed.value / props.pageSize) || 1 : valueComputed.value,
            set: (value)=>{
                valueComputed.value = value;
            }
        });
        const paginationRange = (0, _vue.computed)(()=>{
            const { visiblePages, total, pageSize, boundaryNumbers, pages } = props;
            const value = currentValue.value || 1;
            const totalPages = usesTotal.value ? Math.ceil(total / pageSize) : pages;
            return (0, _setPaginationRangeJs.s)(value, visiblePages, totalPages, boundaryNumbers);
        });
        const lastPage = (0, _vue.computed)(()=>usesTotal.value ? Math.ceil(props.total / props.pageSize) || 1 : +props.pages);
        const isLastPageNotVisible = (0, _vue.computed)(()=>!!props.visiblePages && lastPage.value > props.visiblePages || props.input);
        const showBoundaryLinks = (0, _vue.computed)(()=>{
            const { boundaryLinks, boundaryNumbers } = props;
            return isLastPageNotVisible.value && boundaryLinks && !boundaryNumbers;
        });
        const showDirectionLinks = (0, _vue.computed)(()=>isLastPageNotVisible.value && props.directionLinks);
        const showPagination = (0, _vue.computed)(()=>lastPage.value > 1 || !props.hideOnSinglePage && lastPage.value <= 1);
        const focusInput = ()=>{
            inputValue.value = String(currentValue.value);
            (0, _vue.nextTick)(()=>{
                var _a;
                return (_a = htmlInput.value) == null ? void 0 : _a.setSelectionRange(0, htmlInput.value.value.length);
            });
        };
        const { setItemRefByIndex, itemRefs } = (0, _useArrayRefsJs.u)();
        const onUserInput = (pageNum)=>{
            var _a;
            if (pageNum === "..." || pageNum === currentValue.value) return;
            const limitedPageNum = (0, _vendorJs.b)(pageNum, 1, lastPage.value);
            currentValue.value = usesTotal.value ? (limitedPageNum - 1) * props.pageSize + 1 : limitedPageNum;
            (_a = itemRefs.value[pageNum - 1]) == null || _a.focus();
        };
        const resetInput = ()=>{
            var _a;
            inputValue.value = "";
            (_a = htmlInput.value) == null || _a.blur();
        };
        const changeValue = ()=>{
            if (+inputValue.value === currentValue.value) resetInput();
            if (!inputValue.value.length) return;
            let pageNum = Number.parseInt(inputValue.value);
            switch(true){
                case pageNum < 1:
                    pageNum = 1;
                    break;
                case pageNum > lastPage.value:
                    pageNum = lastPage.value;
                    break;
                case isNaN(pageNum):
                    pageNum = currentValue.value;
                    break;
            }
            onUserInput(pageNum);
            resetInput();
        };
        const { getColor, colorToRgba } = (0, _useColorsJs.u)();
        const inputBorderColorComputed = (0, _vue.computed)(()=>{
            const { color, buttonsPreset } = (0, _vue.toRefs)(props);
            if (!color.value) return "transparent";
            switch(buttonsPreset.value){
                case "default":
                    return getColor(color.value);
                case void 0:
                case "primary":
                    return colorToRgba(getColor(color.value), 0.1);
                default:
                    return "transparent";
            }
        });
        const inputStyleComputed = (0, _vue.computed)(()=>({
                cursor: "default",
                color: getColor(props.color),
                opacity: props.disabled ? 0.4 : 1,
                borderColor: inputBorderColorComputed.value
            }));
        (0, _vue.watch)([
            usesTotal,
            ()=>props.pages
        ], ()=>{
            if ((0, _envJs.i) && usesTotal.value && props.pages) throw new Error("Please, use either `total` and `page-size` props, or `pages`.");
        });
        const inputAttributesComputed = (0, _vue.computed)(()=>({
                disabled: props.disabled,
                placeholder: `${currentValue.value}/${lastPage.value}`
            }));
        const buttonPropsComputed = (0, _vue.computed)(()=>({
                size: props.size,
                preset: props.buttonsPreset,
                color: props.color,
                borderColor: props.borderColor,
                round: props.rounded,
                ...props.buttonProps
            }));
        const currentPageButtonProps = (0, _vue.computed)(()=>({
                preset: props.buttonsPreset === "default" ? "primary" : "default",
                color: props.activePageColor || props.color,
                ...props.activeButtonProps
            }));
        const getPageButtonProps = (n)=>{
            if (!isNaN(+n) && n === currentValue.value) return Object.assign({}, buttonPropsComputed.value, currentPageButtonProps.value);
            return buttonPropsComputed.value;
        };
        const isStandAloneInput = (0, _vue.computed)(()=>props.input && !props.boundaryLinks && !props.directionLinks);
        const inputClassComputed = (0, _useBemJs.u)("va-pagination__input", ()=>({
                sm: props.size === "small" && isStandAloneInput.value,
                md: props.size === "medium" && isStandAloneInput.value,
                lg: props.size === "large" && isStandAloneInput.value,
                auto: !isStandAloneInput.value
            }));
        const classComputed = (0, _useBemJs.u)("va-pagination", ()=>({
                ...(0, _vendorJs.p)(props, [
                    "gapped",
                    "rounded",
                    "disabled"
                ]),
                bordered: !!props.borderColor
            }));
        const goNextPage = ()=>onUserInput(currentValue.value + 1);
        const goPrevPage = ()=>onUserInput(currentValue.value - 1);
        const { tp } = (0, _useTranslationJs.u)();
        __expose({
            goNextPage,
            goPrevPage
        });
        return (_ctx, _cache)=>{
            return showPagination.value ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("nav", {
                key: 0,
                class: (0, _vue.normalizeClass)([
                    "va-pagination",
                    (0, _vue.unref)(classComputed)
                ]),
                "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaLabel),
                onKeydown: [
                    (0, _vue.withKeys)((0, _vue.withModifiers)(goPrevPage, [
                        "stop"
                    ]), [
                        "left"
                    ]),
                    (0, _vue.withKeys)((0, _vue.withModifiers)(goNextPage, [
                        "stop"
                    ]), [
                        "right"
                    ]),
                    (0, _vue.withKeys)((0, _vue.withModifiers)(goPrevPage, [
                        "stop"
                    ]), [
                        "up"
                    ]),
                    (0, _vue.withKeys)((0, _vue.withModifiers)(goNextPage, [
                        "stop"
                    ]), [
                        "down"
                    ])
                ]
            }, [
                showBoundaryLinks.value ? (0, _vue.renderSlot)(_ctx.$slots, "firstPageLink", (0, _vue.normalizeProps)((0, _vue.mergeProps)({
                    key: 0
                }, {
                    onClick: ()=>onUserInput(1),
                    disabled: _ctx.$props.disabled || currentValue.value === 1
                })), ()=>[
                        showBoundaryLinks.value ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), (0, _vue.mergeProps)({
                            key: 0,
                            "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaGoToTheFirstPageLabel),
                            disabled: _ctx.$props.disabled || currentValue.value === 1,
                            icon: _ctx.$props.boundaryIconLeft
                        }, buttonPropsComputed.value, {
                            onClick: _cache[0] || (_cache[0] = ($event)=>onUserInput(1))
                        }), null, 16, [
                            "aria-label",
                            "disabled",
                            "icon"
                        ])) : (0, _vue.createCommentVNode)("", true)
                    ]) : (0, _vue.createCommentVNode)("", true),
                showDirectionLinks.value ? (0, _vue.renderSlot)(_ctx.$slots, "prevPageLink", (0, _vue.normalizeProps)((0, _vue.mergeProps)({
                    key: 1
                }, {
                    onClick: goPrevPage,
                    disabled: _ctx.$props.disabled || currentValue.value === 1
                })), ()=>[
                        showDirectionLinks.value ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), (0, _vue.mergeProps)({
                            key: 0,
                            "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaGoToPreviousPageLabel),
                            disabled: _ctx.$props.disabled || currentValue.value === 1,
                            icon: _ctx.$props.directionIconLeft
                        }, buttonPropsComputed.value, {
                            onClick: goPrevPage
                        }), null, 16, [
                            "aria-label",
                            "disabled",
                            "icon"
                        ])) : (0, _vue.createCommentVNode)("", true)
                    ]) : (0, _vue.createCommentVNode)("", true),
                !_ctx.$props.input ? (0, _vue.renderSlot)(_ctx.$slots, "default", {
                    key: 2
                }, ()=>[
                        ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)(paginationRange.value, (n, i)=>{
                            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), (0, _vue.mergeProps)({
                                key: i,
                                ref_for: true,
                                ref: (0, _vue.unref)(setItemRefByIndex)(i),
                                class: {
                                    "va-button--ellipsis": n === "...",
                                    "va-button--current": n === currentValue.value
                                },
                                "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaGoToSpecificPageLabel, {
                                    page: n
                                }),
                                "aria-current": n === currentValue.value,
                                disabled: _ctx.$props.disabled || n === "..."
                            }, getPageButtonProps(n), {
                                onClick: ($event)=>onUserInput(n)
                            }), {
                                default: (0, _vue.withCtx)(()=>[
                                        (0, _vue.createTextVNode)((0, _vue.toDisplayString)(n), 1)
                                    ]),
                                _: 2
                            }, 1040, [
                                "class",
                                "aria-label",
                                "aria-current",
                                "disabled",
                                "onClick"
                            ]);
                        }), 128))
                    ]) : (0, _vue.withDirectives)(((0, _vue.openBlock)(), (0, _vue.createElementBlock)("input", (0, _vue.mergeProps)({
                    key: 3,
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event)=>inputValue.value = $event),
                    ref_key: "htmlInput",
                    ref: htmlInput,
                    class: [
                        "va-pagination__input va-button",
                        (0, _vue.unref)(inputClassComputed)
                    ],
                    "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaGoToSpecificPageInputLabel),
                    style: inputStyleComputed.value
                }, inputAttributesComputed.value, {
                    onKeydown: (0, _vue.withKeys)(changeValue, [
                        "enter"
                    ]),
                    onFocus: focusInput,
                    onBlur: changeValue
                }), null, 16, _hoisted_2)), [
                    [
                        (0, _vue.vModelDynamic),
                        inputValue.value
                    ]
                ]),
                showDirectionLinks.value ? (0, _vue.renderSlot)(_ctx.$slots, "nextPageLink", (0, _vue.normalizeProps)((0, _vue.mergeProps)({
                    key: 4
                }, {
                    onClick: goNextPage,
                    disabled: _ctx.$props.disabled || currentValue.value === lastPage.value
                })), ()=>[
                        showDirectionLinks.value ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), (0, _vue.mergeProps)({
                            key: 0,
                            "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaGoToNextPageLabel),
                            disabled: _ctx.$props.disabled || currentValue.value === lastPage.value,
                            icon: _ctx.$props.directionIconRight
                        }, buttonPropsComputed.value, {
                            onClick: goNextPage
                        }), null, 16, [
                            "aria-label",
                            "disabled",
                            "icon"
                        ])) : (0, _vue.createCommentVNode)("", true)
                    ]) : (0, _vue.createCommentVNode)("", true),
                showBoundaryLinks.value ? (0, _vue.renderSlot)(_ctx.$slots, "lastPageLink", (0, _vue.normalizeProps)((0, _vue.mergeProps)({
                    key: 5
                }, {
                    onClick: ()=>onUserInput(lastPage.value),
                    disabled: _ctx.$props.disabled || currentValue.value === lastPage.value
                })), ()=>[
                        showBoundaryLinks.value ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), (0, _vue.mergeProps)({
                            key: 0,
                            "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaGoToLastPageLabel),
                            disabled: _ctx.$props.disabled || currentValue.value === lastPage.value,
                            icon: _ctx.$props.boundaryIconRight
                        }, buttonPropsComputed.value, {
                            onClick: _cache[2] || (_cache[2] = ($event)=>onUserInput(lastPage.value))
                        }), null, 16, [
                            "aria-label",
                            "disabled",
                            "icon"
                        ])) : (0, _vue.createCommentVNode)("", true)
                    ]) : (0, _vue.createCommentVNode)("", true)
            ], 42, _hoisted_1)) : (0, _vue.createCommentVNode)("", true);
        };
    }
});

},{"vue":"gzxs9","../../../vendor.js":"l6TAc","../../utils/env.js":"Fmkmq","./setPaginationRange.js":"f7pDE","../va-button/index.js":"2vhcC","../../composables/useStateful.js":"h9zUi","../../composables/useComponentPreset.js":"2HoaT","../../composables/useArrayRefs.js":"jgG1u","../../composables/useColors.js":"a4Qgv","../../composables/useBem.js":"igmjV","../../composables/useTranslation.js":"7S3aV","../../../VaPagination.css":"bjvzw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f7pDE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "s", ()=>setPaginationRange);
var _consoleJs = require("../../utils/console.js");
const setPaginationRange = (currentPage = 1, visiblePages, pages, includeBoundary = false)=>{
    let start = 0;
    if (pages === 0) pages = 1;
    if (visiblePages > pages) visiblePages = pages;
    if (visiblePages === 0) {
        start = 1;
        visiblePages = pages > 10 ? 10 : pages;
    } else {
        const paginationMiddlePage = visiblePages / 2;
        if (currentPage - paginationMiddlePage <= 0 || currentPage > pages) start = 1;
        else start = currentPage + paginationMiddlePage > pages ? pages - visiblePages + 1 : Math.ceil(currentPage - paginationMiddlePage);
    }
    const range = [];
    for(let i = 0; i < visiblePages; i++)range.push(start + i);
    if (includeBoundary && visiblePages < 7) pages >= 7 && (0, _consoleJs.w)("[va-pagination] To work in a proper way, the `boundaryNumbers` prop needs at least 7 visible pages to be set via the `visiblePages` prop (first, last, 2 boundaries, current, previous, next).");
    else if (includeBoundary) {
        start !== 1 && range.splice(0, 2, 1, "...");
        range[range.length - 1] !== pages && range.splice(-2, 2, "...", pages);
    }
    return range;
};

},{"../../utils/console.js":"58L6z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bjvzw":[function() {},{}],"4st8C":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaParallax);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaParallaxVueVueTypeScriptSetupTrueLangJs = require("./VaParallax.vue_vue_type_script_setup_true_lang.js");
const VaParallax = (0, _withConfigTransportJs.w)((0, _vaParallaxVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaParallax.vue_vue_type_script_setup_true_lang.js":"i2yGp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i2yGp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useScrollParentJs = require("../../composables/useScrollParent.js");
var _consoleJs = require("../../utils/console.js");
var _vaParallaxCss = require("../../../VaParallax.css");
const _hoisted_1 = {
    class: "va-parallax__image-container"
};
const _hoisted_2 = [
    "src",
    "alt"
];
const _hoisted_3 = {
    class: "va-parallax__item-container"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaParallax",
    __name: "VaParallax",
    props: {
        ...(0, _useComponentPresetJs.u),
        target: {
            type: [
                Object,
                String
            ]
        },
        src: {
            type: String,
            default: "",
            required: true
        },
        alt: {
            type: String,
            default: "parallax"
        },
        height: {
            type: Number,
            default: 400
        },
        reversed: {
            type: Boolean,
            default: false
        },
        speed: {
            type: Number,
            default: 0.5,
            validator: (value)=>value >= 0 && value <= 1
        }
    },
    setup (__props) {
        const props = __props;
        const rootElement = (0, _vue.shallowRef)();
        const img = (0, _vue.shallowRef)();
        const elOffsetTop = (0, _vue.ref)(0);
        const parallax = (0, _vue.ref)(0);
        const parallaxDist = (0, _vue.ref)(0);
        const percentScrolled = (0, _vue.ref)(0);
        const scrollTop = (0, _vue.ref)(0);
        const windowHeight = (0, _vue.ref)(0);
        const windowBottom = (0, _vue.ref)(0);
        const isLoaded = (0, _vue.ref)(false);
        const computedWrapperStyles = (0, _vue.computed)(()=>({
                height: props.height + "px"
            }));
        const computedImgStyles = (0, _vue.computed)(()=>({
                display: "block",
                transform: `translate(-50%, ${parallax.value}px)`,
                opacity: isLoaded.value ? 1 : 0,
                top: props.reversed ? 0 : "auto"
            }));
        const { getScrollableParent } = (0, _useScrollParentJs.u)();
        const targetElement = (0, _vue.computed)(()=>{
            var _a;
            if (!props.target) return getScrollableParent((_a = rootElement.value) == null ? void 0 : _a.parentElement);
            if (props.target instanceof HTMLElement) return props.target;
            const element = document.querySelector(props.target);
            if (element) return element;
            (0, _consoleJs.w)("VaParallax target prop got wrong selector. Target is null");
            return null;
        });
        const imgHeight = (0, _vue.computed)(()=>{
            var _a;
            return ((_a = img.value) == null ? void 0 : _a.naturalHeight) || 0;
        });
        const calcDimensions = ()=>{
            var _a, _b;
            const offset = ((_a = rootElement.value) == null ? void 0 : _a.getBoundingClientRect()) || {
                top: 0
            };
            scrollTop.value = ((_b = targetElement.value) == null ? void 0 : _b.scrollTop) || 0;
            parallaxDist.value = imgHeight.value - props.height;
            elOffsetTop.value = offset.top + scrollTop.value;
            windowHeight.value = window.innerHeight;
            windowBottom.value = scrollTop.value + windowHeight.value;
        };
        const translate = ()=>{
            calcDimensions();
            percentScrolled.value = (windowBottom.value - elOffsetTop.value) / (props.height + windowHeight.value);
            parallax.value = Math.round(parallaxDist.value * percentScrolled.value) * props.speed;
            if (props.reversed) parallax.value = -parallax.value;
        };
        const addEventListeners = ()=>{
            var _a, _b;
            (_a = targetElement.value) == null || _a.addEventListener("scroll", translate);
            (_b = targetElement.value) == null || _b.addEventListener("resize", translate);
        };
        const removeEventListeners = ()=>{
            var _a, _b;
            (_a = targetElement.value) == null || _a.removeEventListener("scroll", translate);
            (_b = targetElement.value) == null || _b.removeEventListener("resize", translate);
        };
        const initImage = ()=>{
            var _a, _b;
            if ((_a = img.value) == null ? void 0 : _a.complete) {
                translate();
                addEventListeners();
            } else (_b = img.value) == null || _b.addEventListener("load", ()=>{
                translate();
                addEventListeners();
            }, false);
            isLoaded.value = true;
        };
        (0, _vue.onMounted)(initImage);
        (0, _vue.onBeforeUnmount)(removeEventListeners);
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                ref_key: "rootElement",
                ref: rootElement,
                class: "va-parallax",
                style: (0, _vue.normalizeStyle)(computedWrapperStyles.value)
            }, [
                (0, _vue.createElementVNode)("div", _hoisted_1, [
                    (0, _vue.createElementVNode)("img", {
                        ref_key: "img",
                        ref: img,
                        class: "va-parallax__image",
                        src: _ctx.$props.src,
                        alt: _ctx.$props.alt,
                        style: (0, _vue.normalizeStyle)(computedImgStyles.value)
                    }, null, 12, _hoisted_2)
                ]),
                (0, _vue.createElementVNode)("div", _hoisted_3, [
                    (0, _vue.renderSlot)(_ctx.$slots, "default")
                ])
            ], 4);
        };
    }
});

},{"vue":"gzxs9","../../composables/useComponentPreset.js":"2HoaT","../../composables/useScrollParent.js":"ggp4A","../../utils/console.js":"58L6z","../../../VaParallax.css":"dQf7F","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ggp4A":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useScrollParent);
var _useWindowJs = require("./useWindow.js");
const useScrollParent = ()=>{
    const window = (0, _useWindowJs.u)();
    const fakeWindow = new Proxy(window.value || {}, {
        get: (target, key, rec)=>{
            var _a, _b;
            if (key === "scrollTop") return (_a = window.value) == null ? void 0 : _a.scrollY;
            if (key === "scrollLeft") return (_b = window.value) == null ? void 0 : _b.scrollX;
            const value = Reflect.get(target, key, rec);
            if (typeof value === "function") return value.bind(target);
            return value;
        }
    });
    const getScrollableParent = (element)=>{
        if (!element) return fakeWindow;
        if (element.scrollHeight > element.clientHeight) return element;
        return getScrollableParent(element.parentElement);
    };
    return {
        getScrollableParent
    };
};

},{"./useWindow.js":"bOeBT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dQf7F":[function() {},{}],"cTbKH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaPopover);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaPopoverVueVueTypeScriptSetupTrueLangJs = require("./VaPopover.vue_vue_type_script_setup_true_lang.js");
const VaPopover = (0, _withConfigTransportJs.w)((0, _vaPopoverVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaPopover.vue_vue_type_script_setup_true_lang.js":"dyDRe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dyDRe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _indexJs = require("../va-dropdown/index.js");
var _extractComponentOptionsJs = require("../../utils/component-options/extract-component-options.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _filterPropsJs = require("../../utils/component-options/filter-props.js");
var _useColorsJs = require("../../composables/useColors.js");
var _useTextColorJs = require("../../composables/useTextColor.js");
var _indexJs1 = require("../va-icon/index.js");
var _vaPopoverCss = require("../../../VaPopover.css");
const _hoisted_1 = {
    key: 0,
    "aria-hidden": "true",
    class: "va-popover__icon"
};
const _hoisted_2 = {
    key: 1
};
const _hoisted_3 = {
    key: 0,
    class: "va-popover__title"
};
const _hoisted_4 = {
    key: 1,
    class: "va-popover__body"
};
const VaDropdownProps = (0, _extractComponentOptionsJs.e)((0, _indexJs.V), [
    "closeOnClickOutside"
]);
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaPopover",
    __name: "VaPopover",
    props: {
        ...VaDropdownProps,
        ...(0, _useComponentPresetJs.u),
        trigger: {
            ...VaDropdownProps.trigger,
            default: [
                "hover",
                "enter",
                "space",
                "arrow-down",
                "arrow-up"
            ]
        },
        color: {
            type: String,
            default: "#1b1a1f"
        },
        // TODO: Make sure add this color to pallete
        textColor: {
            type: String
        },
        icon: {
            type: String,
            default: ""
        },
        title: {
            type: String,
            default: ""
        },
        message: {
            type: String,
            default: ""
        },
        autoHide: {
            type: Boolean,
            default: true
        },
        offset: {
            type: [
                Array,
                Number
            ],
            default: 4
        }
    },
    setup (__props) {
        const props = __props;
        const VaDropdownPropValues = (0, _filterPropsJs.f)(VaDropdownProps);
        const { getColor, getBoxShadowColor } = (0, _useColorsJs.u)();
        const slots = (0, _vue.useSlots)();
        const { textColorComputed } = (0, _useTextColorJs.u)((0, _vue.computed)(()=>getColor(props.color)));
        const showIconComputed = (0, _vue.computed)(()=>props.icon || slots.icon);
        const showTitleComputed = (0, _vue.computed)(()=>props.title || slots.title);
        const showBodyComputed = (0, _vue.computed)(()=>props.message || slots.body);
        const showPopoverContentComputed = (0, _vue.computed)(()=>showTitleComputed.value || showBodyComputed.value);
        const computedPopoverStyle = (0, _vue.computed)(()=>({
                boxShadow: `var(--va-popover-content-box-shadow) ${getBoxShadowColor(getColor(props.color))}`,
                backgroundColor: getColor(props.color),
                color: textColorComputed.value
            }));
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), (0, _vue.mergeProps)((0, _vue.unref)(VaDropdownPropValues), {
                "model-value": _ctx.modelValue,
                "close-on-click-outside": __props.autoHide,
                offset: _ctx.$props.offset,
                class: "va-popover"
            }), {
                default: (0, _vue.withCtx)(()=>[
                        (0, _vue.createElementVNode)("div", {
                            style: (0, _vue.normalizeStyle)(computedPopoverStyle.value),
                            class: "va-popover__content",
                            role: "tooltip"
                        }, [
                            showIconComputed.value ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_1, [
                                (0, _vue.renderSlot)(_ctx.$slots, "icon", {}, ()=>[
                                        (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs1.V)), {
                                            name: _ctx.$props.icon,
                                            color: (0, _vue.unref)(textColorComputed)
                                        }, null, 8, [
                                            "name",
                                            "color"
                                        ])
                                    ])
                            ])) : (0, _vue.createCommentVNode)("", true),
                            showPopoverContentComputed.value ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_2, [
                                showTitleComputed.value ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_3, [
                                    (0, _vue.renderSlot)(_ctx.$slots, "title", {}, ()=>[
                                            (0, _vue.createTextVNode)((0, _vue.toDisplayString)(_ctx.$props.title), 1)
                                        ])
                                ])) : (0, _vue.createCommentVNode)("", true),
                                showBodyComputed.value ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_4, [
                                    (0, _vue.renderSlot)(_ctx.$slots, "body", {}, ()=>[
                                            (0, _vue.createTextVNode)((0, _vue.toDisplayString)(_ctx.$props.message), 1)
                                        ])
                                ])) : (0, _vue.createCommentVNode)("", true)
                            ])) : (0, _vue.createCommentVNode)("", true)
                        ], 4)
                    ]),
                anchor: (0, _vue.withCtx)(()=>[
                        (0, _vue.renderSlot)(_ctx.$slots, "default")
                    ]),
                _: 3
            }, 16, [
                "model-value",
                "close-on-click-outside",
                "offset"
            ]);
        };
    }
});

},{"vue":"gzxs9","../va-dropdown/index.js":"2ag98","../../utils/component-options/extract-component-options.js":"1ODzH","../../composables/useComponentPreset.js":"2HoaT","../../utils/component-options/filter-props.js":"4HycW","../../composables/useColors.js":"a4Qgv","../../composables/useTextColor.js":"5pfXb","../va-icon/index.js":"82tPo","../../../VaPopover.css":"cyW5w","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cyW5w":[function() {},{}],"ihXDw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaRating);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaRatingVueVueTypeScriptSetupTrueLangJs = require("./VaRating.vue_vue_type_script_setup_true_lang.js");
const VaRating = (0, _withConfigTransportJs.w)((0, _vaRatingVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaRating.vue_vue_type_script_setup_true_lang.js":"fleDF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fleDF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useRatingJs = require("./hooks/useRating.js");
var _useVaRatingColorsJs = require("./hooks/useVaRatingColors.js");
var _typesJs = require("./types.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _vaRatingItemVueVueTypeScriptSetupTrueLangJs = require("./components/VaRatingItem/VaRatingItem.vue_vue_type_script_setup_true_lang.js");
var _vaRatingItemNumberButtonVueVueTypeScriptSetupTrueLangJs = require("./components/VaRatingItemNumberButton.vue_vue_type_script_setup_true_lang.js");
var _useFormFieldJs = require("../../composables/useFormField.js");
var _extractComponentOptionsJs = require("../../utils/component-options/extract-component-options.js");
var _useTranslationJs = require("../../composables/useTranslation.js");
var _filterPropsJs = require("../../utils/component-options/filter-props.js");
var _vaRatingCss = require("../../../VaRating.css");
const _hoisted_1 = [
    "aria-label"
];
const VaRatingItemPropsDeclarations = (0, _extractComponentOptionsJs.e)((0, _vaRatingItemVueVueTypeScriptSetupTrueLangJs._), [
    "modelValue",
    "itemNumber"
]);
const VaRatingItemNumberButtonPropsDeclarations = (0, _extractComponentOptionsJs.e)((0, _vaRatingItemNumberButtonVueVueTypeScriptSetupTrueLangJs._), [
    "modelValue",
    "itemNumber"
]);
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaRating",
    __name: "VaRating",
    props: {
        ...VaRatingItemNumberButtonPropsDeclarations,
        ...(0, _useRatingJs.u),
        ...(0, _useVaRatingColorsJs.u),
        ...(0, _useFormFieldJs.u),
        ...VaRatingItemPropsDeclarations,
        ...(0, _useComponentPresetJs.u),
        modelValue: {
            type: Number,
            default: 0
        },
        numbers: {
            type: Boolean,
            default: false
        },
        halves: {
            type: Boolean,
            default: false
        },
        max: {
            type: [
                Number,
                String
            ],
            default: 5
        },
        texts: {
            type: Array,
            default: ()=>[]
        },
        ariaLabel: {
            type: String,
            default: "$t:currentRating"
        },
        ariaItemLabel: {
            type: String,
            default: "$t:voteRating"
        }
    },
    emits: [
        "update:modelValue"
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const { computedClasses: rootClass } = (0, _useFormFieldJs.a)("va-rating", props);
        const { visibleValue, modelValue: vModel, hoveredValue, isHovered, onMouseEnter, onMouseLeave, onItemValueUpdate, onItemHoveredValueUpdate, getItemValue } = (0, _useRatingJs.a)(props);
        const isInteractionsEnabled = (0, _vue.computed)(()=>!props.disabled && !props.readonly);
        const onArrowKeyPress = (direction)=>{
            const max = Number(props.max);
            const step = props.halves ? (0, _typesJs.R).HALF : (0, _typesJs.R).FULL;
            const nextStep = visibleValue.value + step * direction;
            const min = props.clearable ? 0 : step;
            if (nextStep >= min && nextStep <= max) onItemValueUpdate(visibleValue.value, step * direction);
            else if (nextStep < min) onItemValueUpdate(min, 0);
            else onItemValueUpdate(max, direction === -1 ? step * direction : 0);
        };
        const { tp, t } = (0, _useTranslationJs.u)();
        const { computedColor, backgroundComputed, textColorComputed } = (0, _useVaRatingColorsJs.a)(props);
        const tabIndexComputed = (0, _vue.computed)(()=>isInteractionsEnabled.value ? 0 : void 0);
        const VaRatingItemProps = (0, _filterPropsJs.f)(VaRatingItemPropsDeclarations);
        const VaRatingItemNumberButtonProps = (0, _filterPropsJs.f)(VaRatingItemNumberButtonPropsDeclarations);
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: (0, _vue.normalizeClass)([
                    "va-rating",
                    (0, _vue.unref)(rootClass)
                ]),
                "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaLabel, {
                    max: _ctx.$props.max,
                    value: _ctx.$props.modelValue
                })
            }, [
                (0, _vue.createElementVNode)("div", {
                    class: "va-rating__item-wrapper",
                    onKeyup: [
                        _cache[0] || (_cache[0] = (0, _vue.withKeys)(($event)=>onArrowKeyPress(-1), [
                            "left"
                        ])),
                        _cache[1] || (_cache[1] = (0, _vue.withKeys)(($event)=>onArrowKeyPress(1), [
                            "right"
                        ]))
                    ],
                    onMouseenter: _cache[2] || (_cache[2] = (...args)=>(0, _vue.unref)(onMouseEnter) && (0, _vue.unref)(onMouseEnter)(...args)),
                    onMouseleave: _cache[3] || (_cache[3] = (...args)=>(0, _vue.unref)(onMouseLeave) && (0, _vue.unref)(onMouseLeave)(...args))
                }, [
                    ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)(Number(_ctx.$props.max), (itemNumber)=>{
                        return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vaRatingItemVueVueTypeScriptSetupTrueLangJs._), (0, _vue.mergeProps)({
                            key: itemNumber,
                            class: "va-rating__item"
                        }, (0, _vue.unref)(VaRatingItemProps), {
                            "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaItemLabel, {
                                max: _ctx.$props.max,
                                value: itemNumber
                            }),
                            "model-value": (0, _vue.unref)(getItemValue)(itemNumber - 1),
                            tabindex: tabIndexComputed.value,
                            disabled: _ctx.$props.disabled,
                            readonly: _ctx.$props.readonly,
                            onHover: ($event)=>isInteractionsEnabled.value && (0, _vue.unref)(onItemHoveredValueUpdate)(itemNumber - 1, $event),
                            "onUpdate:modelValue": ($event)=>isInteractionsEnabled.value && (0, _vue.unref)(onItemValueUpdate)(itemNumber - 1, $event)
                        }), {
                            default: (0, _vue.withCtx)(({ value, onClick })=>[
                                    (0, _vue.renderSlot)(_ctx.$slots, "item", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                        value,
                                        onClick,
                                        index: itemNumber
                                    })), ()=>[
                                            _ctx.$props.numbers ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vaRatingItemNumberButtonVueVueTypeScriptSetupTrueLangJs._), (0, _vue.mergeProps)({
                                                key: 0
                                            }, (0, _vue.unref)(VaRatingItemNumberButtonProps), {
                                                "model-value": value,
                                                "item-number": itemNumber
                                            }), null, 16, [
                                                "model-value",
                                                "item-number"
                                            ])) : (0, _vue.createCommentVNode)("", true)
                                        ])
                                ]),
                            _: 2
                        }, 1040, [
                            "aria-label",
                            "model-value",
                            "tabindex",
                            "disabled",
                            "readonly",
                            "onHover",
                            "onUpdate:modelValue"
                        ]);
                    }), 128))
                ], 32),
                _ctx.$props.texts && _ctx.$props.texts.length === _ctx.$props.max ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("span", {
                    key: 0,
                    class: "va-rating__text-wrapper",
                    style: (0, _vue.normalizeStyle)({
                        color: (0, _vue.unref)(computedColor)
                    })
                }, (0, _vue.toDisplayString)(_ctx.$props.texts[Math.round((0, _vue.unref)(visibleValue)) - 1]), 5)) : (0, _vue.createCommentVNode)("", true)
            ], 10, _hoisted_1);
        };
    }
});

},{"vue":"gzxs9","./hooks/useRating.js":"jjc8p","./hooks/useVaRatingColors.js":"7irTW","./types.js":"hiyRk","../../composables/useComponentPreset.js":"2HoaT","./components/VaRatingItem/VaRatingItem.vue_vue_type_script_setup_true_lang.js":"50u7M","./components/VaRatingItemNumberButton.vue_vue_type_script_setup_true_lang.js":"2CxPH","../../composables/useFormField.js":"676Eq","../../utils/component-options/extract-component-options.js":"1ODzH","../../composables/useTranslation.js":"7S3aV","../../utils/component-options/filter-props.js":"4HycW","../../../VaRating.css":"dftaB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jjc8p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useRating);
parcelHelpers.export(exports, "u", ()=>useRatingProps);
var _vue = require("vue");
var _vendorJs = require("../../../../vendor.js");
var _typesJs = require("../types.js");
var _useStatefulJs = require("../../../composables/useStateful.js");
var _useHoverJs = require("../../../composables/useHover.js");
const getContext = ()=>{
    const instance = (0, _vue.getCurrentInstance)();
    if (!instance) throw new Error("useRating hooks must be used on top of setup function");
    return {
        props: instance.props,
        emit: instance.emit
    };
};
const useRatingProps = {
    ...(0, _useStatefulJs.u),
    modelValue: {
        type: Number,
        default: 0
    },
    clearable: {
        type: Boolean,
        default: false
    },
    hover: {
        type: Boolean,
        default: false
    }
};
const useRating = (props)=>{
    const { emit } = getContext();
    const { isHovered, onMouseEnter, onMouseLeave } = (0, _useHoverJs.u)();
    const { valueComputed: modelValue } = (0, _useStatefulJs.b)(props, emit);
    const hoveredValue = (0, _vue.ref)(0);
    const visibleValue = (0, _vue.computed)(()=>!props.disabled && !props.readonly && props.hover && isHovered.value ? hoveredValue.value : modelValue.value);
    const onItemValueUpdate = (itemIndex, newValue)=>{
        const newModelValue = itemIndex + newValue;
        if (props.clearable) {
            if (modelValue.value === newModelValue) {
                modelValue.value = 0;
                return;
            }
        }
        modelValue.value = newModelValue;
    };
    const onItemHoveredValueUpdate = (itemIndex, newValue)=>{
        if (!props.hover) return;
        hoveredValue.value = itemIndex + newValue;
    };
    const getItemValue = (itemIndex)=>{
        const itemValue = visibleValue.value - itemIndex;
        return (0, _vendorJs.b)(itemValue, (0, _typesJs.R).EMPTY, (0, _typesJs.R).FULL);
    };
    return {
        visibleValue,
        modelValue,
        hoveredValue,
        isHovered,
        onMouseEnter,
        onMouseLeave,
        onItemValueUpdate,
        onItemHoveredValueUpdate,
        getItemValue
    };
};

},{"vue":"gzxs9","../../../../vendor.js":"l6TAc","../types.js":"hiyRk","../../../composables/useStateful.js":"h9zUi","../../../composables/useHover.js":"6F99t","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hiyRk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "R", ()=>RatingValue);
var RatingValue = /* @__PURE__ */ ((RatingValue2)=>{
    RatingValue2[RatingValue2["EMPTY"] = 0] = "EMPTY";
    RatingValue2[RatingValue2["HALF"] = 0.5] = "HALF";
    RatingValue2[RatingValue2["FULL"] = 1] = "FULL";
    return RatingValue2;
})(RatingValue || {});

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7irTW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useVaRatingColors);
parcelHelpers.export(exports, "u", ()=>useVaRatingColorsProps);
var _vue = require("vue");
var _typesJs = require("../types.js");
var _useColorsJs = require("../../../composables/useColors.js");
const useVaRatingColorsProps = {
    unselectedColor: {
        type: String
    },
    color: {
        type: String,
        default: "primary"
    },
    modelValue: {
        type: Number
    }
};
const useVaRatingColors = (props)=>{
    const { getColor, getFocusColor, getTextColor } = (0, _useColorsJs.u)();
    const computedColor = (0, _vue.computed)(()=>getColor(props.color));
    const backgroundColor = (0, _vue.computed)(()=>{
        if (props.unselectedColor) return getColor(props.unselectedColor);
        return getFocusColor(getColor(props.color));
    });
    const backgroundComputed = (0, _vue.computed)(()=>{
        if (props.modelValue === (0, _typesJs.R).HALF) return `linear-gradient(90deg, ${computedColor.value} 50%, ${backgroundColor.value} 50%`;
        if (props.modelValue === (0, _typesJs.R).EMPTY) return backgroundColor.value;
        return computedColor.value;
    });
    const textColorComputed = (0, _vue.computed)(()=>{
        if (props.modelValue === (0, _typesJs.R).FULL) return getColor(getTextColor(computedColor.value));
        return getColor(getTextColor(backgroundColor.value));
    });
    return {
        computedColor,
        backgroundComputed,
        textColorComputed
    };
};

},{"vue":"gzxs9","../types.js":"hiyRk","../../../composables/useColors.js":"a4Qgv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"50u7M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _typesJs = require("../../types.js");
var _indexJs = require("../../../va-icon/index.js");
var _useSyncPropJs = require("../../../../composables/useSyncProp.js");
var _useColorsJs = require("../../../../composables/useColors.js");
var _vaRatingItemCss = require("../../../../../VaRatingItem.css");
const _hoisted_1 = [
    "tabindex",
    "onKeydown"
];
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaRatingItem",
    __name: "VaRatingItem",
    props: {
        modelValue: {
            type: Number,
            default: 0
        },
        icon: {
            type: String,
            default: "star"
        },
        halfIcon: {
            type: String,
            default: "star_half"
        },
        emptyIcon: {
            type: String,
            default: "star_outline"
        },
        halves: {
            type: Boolean,
            default: false
        },
        hover: {
            type: Boolean,
            default: false
        },
        tabindex: {
            type: [
                String,
                Number
            ],
            default: 0
        },
        disabled: {
            type: Boolean,
            default: false
        },
        readonly: {
            type: Boolean,
            default: false
        },
        size: {
            type: [
                String,
                Number
            ],
            default: "medium"
        },
        unselectedColor: {
            type: String
        },
        color: {
            type: String,
            default: "primary"
        }
    },
    emits: [
        "update:modelValue",
        "click",
        "hover"
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const rootEl = (0, _vue.shallowRef)();
        const [modelValue] = (0, _useSyncPropJs.u)("modelValue", props, emit, (0, _typesJs.R).EMPTY);
        const hoveredValue = (0, _vue.ref)(null);
        const visibleValue = (0, _vue.computed)(()=>{
            if (props.hover && !props.disabled && !props.readonly) return hoveredValue.value || modelValue.value;
            return modelValue.value;
        });
        const { getColor } = (0, _useColorsJs.u)();
        const computedColor = (0, _vue.computed)(()=>getColor(props.unselectedColor && visibleValue.value === (0, _typesJs.R).EMPTY ? props.unselectedColor : props.color));
        const onMouseMove = (ev)=>{
            if (!rootEl.value) return;
            const { offsetX } = ev;
            const iconWidth = rootEl.value.clientWidth;
            if (props.halves) hoveredValue.value = offsetX / iconWidth <= (0, _typesJs.R).HALF ? (0, _typesJs.R).HALF : (0, _typesJs.R).FULL;
            else hoveredValue.value = (0, _typesJs.R).FULL;
        };
        const onMouseLeave = ()=>{
            hoveredValue.value = null;
        };
        const onClick = ()=>{
            modelValue.value = hoveredValue.value || (0, _typesJs.R).FULL;
            emit("click", hoveredValue.value || (0, _typesJs.R).FULL);
        };
        (0, _vue.watch)(hoveredValue, ()=>emit("hover", hoveredValue.value || (0, _typesJs.R).EMPTY));
        const computedIconName = (0, _vue.computed)(()=>{
            if (props.halves && visibleValue.value === (0, _typesJs.R).HALF) return props.halfIcon;
            if (visibleValue.value === (0, _typesJs.R).EMPTY) return props.emptyIcon;
            return props.icon;
        });
        const tabIndexComputed = (0, _vue.computed)(()=>props.disabled ? -1 : props.tabindex);
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                ref_key: "rootEl",
                ref: rootEl,
                role: "button",
                class: "va-rating-item",
                tabindex: tabIndexComputed.value,
                onKeydown: [
                    (0, _vue.withKeys)(onClick, [
                        "enter"
                    ]),
                    (0, _vue.withKeys)((0, _vue.withModifiers)(onClick, [
                        "prevent"
                    ]), [
                        "space"
                    ])
                ],
                onMousemove: onMouseMove,
                onMouseleave: onMouseLeave,
                onClick
            }, [
                (0, _vue.renderSlot)(_ctx.$slots, "default", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                    value: visibleValue.value,
                    onClick
                })), ()=>[
                        (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs.V)), {
                            class: "va-rating-item__wrapper",
                            tabindex: "-1",
                            tag: "button",
                            name: computedIconName.value,
                            size: _ctx.$props.size,
                            color: computedColor.value
                        }, null, 8, [
                            "name",
                            "size",
                            "color"
                        ])
                    ])
            ], 40, _hoisted_1);
        };
    }
});

},{"vue":"gzxs9","../../types.js":"hiyRk","../../../va-icon/index.js":"82tPo","../../../../composables/useSyncProp.js":"3q1sU","../../../../composables/useColors.js":"a4Qgv","../../../../../VaRatingItem.css":"jnPmP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jnPmP":[function() {},{}],"2CxPH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useVaRatingColorsJs = require("../hooks/useVaRatingColors.js");
var _useSizeJs = require("../../../composables/useSize.js");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaRatingItemNumberButton",
    __name: "VaRatingItemNumberButton",
    props: {
        ...(0, _useVaRatingColorsJs.u),
        ...(0, _useSizeJs.u),
        itemNumber: {
            type: Number,
            required: true
        },
        modelValue: {
            type: Number,
            required: true
        }
    },
    setup (__props) {
        const props = __props;
        const { textColorComputed, backgroundComputed } = (0, _useVaRatingColorsJs.a)(props);
        const { sizeComputed, fontSizeComputed, fontSizeInRem } = (0, _useSizeJs.a)(props, "VaRating");
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("button", {
                class: "va-rating__number-item",
                tabindex: "-1",
                "aria-hidden": "true",
                style: (0, _vue.normalizeStyle)({
                    background: (0, _vue.unref)(backgroundComputed),
                    color: (0, _vue.unref)(textColorComputed),
                    width: (0, _vue.unref)(sizeComputed),
                    height: (0, _vue.unref)(sizeComputed),
                    fontSize: (0, _vue.unref)(fontSizeComputed),
                    borderRadius: `${parseInt((0, _vue.unref)(fontSizeComputed)) * 0.125}rem`
                })
            }, (0, _vue.toDisplayString)(__props.itemNumber), 5);
        };
    }
});

},{"vue":"gzxs9","../hooks/useVaRatingColors.js":"7irTW","../../../composables/useSize.js":"d4gWT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dftaB":[function() {},{}],"7ypmM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaSelect);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaSelectVueVueTypeScriptSetupTrueLangJs = require("./VaSelect.vue_vue_type_script_setup_true_lang.js");
const VaSelect = (0, _withConfigTransportJs.w)((0, _vaSelectVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaSelect.vue_vue_type_script_setup_true_lang.js":"8BZOC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8BZOC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../vendor.js");
var _indexJs = require("../va-input-wrapper/index.js");
var _indexJs1 = require("../va-dropdown/index.js");
var _indexJs2 = require("../va-icon/index.js");
var _indexJs3 = require("./components/VaSelectOptionList/index.js");
var _indexJs4 = require("./components/VaSelectContent/index.js");
var _useMaxVisibleOptionsJs = require("./hooks/useMaxVisibleOptions.js");
var _useToggleIconJs = require("./hooks/useToggleIcon.js");
var _useStringValueJs = require("./hooks/useStringValue.js");
var _useAutocompleteJs = require("./hooks/useAutocomplete.js");
var _useSelectAriaJs = require("./hooks/useSelectAria.js");
var _focusJs = require("../../utils/focus.js");
var _unwrapElJs = require("../../utils/unwrapEl.js");
var _isNilValueJs = require("../../utils/isNilValue.js");
var _consoleJs = require("../../utils/console.js");
var _useMaxSelectionsJs = require("../../composables/useMaxSelections.js");
var _indexJs5 = require("../va-dropdown/components/VaDropdownContent/index.js");
var _extractComponentOptionsJs = require("../../utils/component-options/extract-component-options.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useSelectableListJs = require("../../composables/useSelectableList.js");
var _useValidationJs = require("../../composables/useValidation.js");
var _useLoadingJs = require("../../composables/useLoading.js");
var _useClearableJs = require("../../composables/useClearable.js");
var _useFormFieldJs = require("../../composables/useFormField.js");
var _useThrottleJs = require("../../composables/useThrottle.js");
var _useDropdownableJs = require("../../composables/useDropdownable.js");
var _useTranslationJs = require("../../composables/useTranslation.js");
var _useFocusDeepJs = require("../../composables/useFocusDeep.js");
var _useSyncPropJs = require("../../composables/useSyncProp.js");
var _useBemJs = require("../../composables/useBem.js");
var _filterPropsJs = require("../../utils/component-options/filter-props.js");
var _vaSelectCss = require("../../../VaSelect.css");
const VaInputWrapperProps = (0, _extractComponentOptionsJs.e)((0, _indexJs.V));
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaSelect",
    __name: "VaSelect",
    props: {
        ...VaInputWrapperProps,
        ...(0, _useComponentPresetJs.u),
        ...(0, _useSelectableListJs.u),
        ...(0, _useValidationJs.b),
        ...(0, _useLoadingJs.u),
        ...(0, _useMaxSelectionsJs.u),
        ...(0, _useClearableJs.u),
        ...(0, _useFormFieldJs.u),
        ...(0, _useMaxVisibleOptionsJs.u),
        ...(0, _useToggleIconJs.u),
        ...(0, _useThrottleJs.u),
        ...(0, _useStringValueJs.u),
        ...(0, _useAutocompleteJs.u),
        ...(0, _useDropdownableJs.u),
        modelValue: {
            type: [
                String,
                Number,
                Array,
                Object,
                Boolean
            ],
            default: void 0
        },
        // Dropdown placement
        placement: {
            ...(0, _useDropdownableJs.u).placement,
            default: "bottom"
        },
        keepAnchorWidth: {
            ...(0, _useDropdownableJs.u).keepAnchorWidth,
            default: true
        },
        offset: {
            ...(0, _useDropdownableJs.u).offset,
            default: [
                1,
                0
            ]
        },
        closeOnContentClick: {
            ...(0, _useDropdownableJs.u).closeOnContentClick,
            default: false
        },
        trigger: {
            ...(0, _useDropdownableJs.u).trigger,
            default: ()=>[
                    "click",
                    "right-click",
                    "space",
                    "enter"
                ]
        },
        // Select options
        allowCreate: {
            type: [
                Boolean,
                String
            ],
            default: false,
            validator: (mode)=>[
                    true,
                    false,
                    "unique"
                ].includes(mode)
        },
        color: {
            type: String,
            default: "primary"
        },
        multiple: {
            type: Boolean,
            default: false
        },
        searchable: {
            type: Boolean,
            default: false
        },
        width: {
            type: String,
            default: "100%"
        },
        maxHeight: {
            type: String,
            default: "256px"
        },
        noOptionsText: {
            type: String,
            default: "$t:noOptions"
        },
        hideSelected: {
            type: Boolean,
            default: false
        },
        tabindex: {
            type: [
                String,
                Number
            ],
            default: 0
        },
        virtualScroller: {
            type: Boolean,
            default: false
        },
        selectedTopShown: {
            type: Boolean,
            default: false
        },
        highlightMatchedText: {
            type: Boolean,
            default: true
        },
        minSearchChars: {
            type: Number,
            default: 0
        },
        autoSelectFirstOption: {
            type: Boolean,
            default: false
        },
        // Input style
        placeholder: {
            type: String,
            default: ""
        },
        searchPlaceholderText: {
            type: String,
            default: "$t:search"
        },
        ariaLabel: {
            type: String,
            default: "$t:select"
        },
        ariaSearchLabel: {
            type: String,
            default: "$t:optionsFilter"
        },
        ariaClearLabel: {
            type: String,
            default: "$t:reset"
        },
        search: {
            type: String,
            default: void 0
        }
    },
    emits: [
        "update:modelValue",
        "update-search",
        "create-new",
        "scroll-bottom",
        "update:search",
        ...(0, _useDropdownableJs.a),
        ...(0, _useValidationJs.u),
        ...(0, _useClearableJs.a)
    ],
    setup (__props, { expose: __expose, emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const { tp, t } = (0, _useTranslationJs.u)();
        const optionList = (0, _vue.shallowRef)();
        const input = (0, _vue.shallowRef)();
        const searchBar = (0, _vue.shallowRef)();
        const isInputFocused = (0, _useFocusDeepJs.u)(input);
        const { getValue, getText, getTrackBy, tryResolveByValue } = (0, _useSelectableListJs.a)(props);
        const getValueText = (option)=>getText(tryResolveByValue(option));
        const onScrollBottom = ()=>emit("scroll-bottom");
        const [searchVModel] = (0, _useSyncPropJs.u)("search", props, emit, "");
        const showSearchInput = (0, _vue.computed)(()=>props.searchable || props.allowCreate && !props.autocomplete);
        (0, _vue.watch)(searchVModel, (value)=>{
            emit("update-search", value);
            if (!props.autocomplete) hoveredOption.value = null;
        });
        const getOptionByValue = (value)=>{
            if ((0, _isNilValueJs.i)(value) || typeof value === "object") return value;
            const optionByValue = props.options.find((option)=>value === getValue(option));
            if (optionByValue === void 0) {
                (0, _consoleJs.w)(`[VaSelect]: can not find option in options list (${JSON.stringify(props.options)}) by provided value (${JSON.stringify(value)})!`);
                return value;
            }
            return optionByValue;
        };
        const { toggleHiddenOptionsState, isAllOptionsShown, visibleSelectedOptions, hiddenSelectedOptionsAmount, allSelectedOptions } = (0, _useMaxVisibleOptionsJs.a)(props, getOptionByValue);
        const valueComputed = (0, _vue.computed)({
            get () {
                if (props.multiple) return allSelectedOptions.value;
                const value = getOptionByValue(props.modelValue);
                if (Array.isArray(value)) {
                    (0, _consoleJs.w)("Model value should be a string, number, boolean or an object for a single Select.");
                    if (value.length) return value.at(-1);
                }
                return value;
            },
            set (option) {
                if (Array.isArray(option)) emit("update:modelValue", option.map(getValue));
                else emit("update:modelValue", getValue(option));
            }
        });
        const valueString = (0, _useStringValueJs.a)(props, visibleSelectedOptions, getValueText);
        const { canBeCleared, clearIconProps, onFocus, onBlur } = (0, _useClearableJs.b)(props, valueComputed);
        const showClearIcon = (0, _vue.computed)(()=>{
            if (!canBeCleared.value) return false;
            if (props.multiple && Array.isArray(valueComputed.value)) return !!valueComputed.value.length;
            return true;
        });
        const filteredOptions = (0, _vue.computed)(()=>{
            if (!props.options) return [];
            if (props.selectedTopShown) return props.options.slice().sort((a, b)=>{
                const isASelected = checkIsOptionSelected(a);
                const isBSelected = checkIsOptionSelected(b);
                if (isASelected && isBSelected) return 0;
                if (isASelected && !isBSelected) return -1;
                return 1;
            });
            if (props.hideSelected) return props.options.filter((option)=>!checkIsOptionSelected(option));
            return props.options;
        });
        const normalizedOptionValue = (0, _vue.computed)(()=>{
            if (Array.isArray(valueComputed.value)) return valueComputed.value.map((value)=>tryResolveByValue(value));
            return tryResolveByValue(valueComputed.value);
        });
        const checkIsOptionSelected = (option)=>{
            if (Array.isArray(normalizedOptionValue.value)) return !(0, _isNilValueJs.i)(normalizedOptionValue.value.find((valueItem)=>compareOptions(valueItem, option)));
            return compareOptions(normalizedOptionValue.value, option);
        };
        const compareOptions = (option1, option2)=>{
            const one = getValue(option1);
            const two = getValue(option2);
            if (one === two) return true;
            if (typeof one === "string" && typeof two === "string") return one === two;
            if (one === null || two === null) return false;
            if (typeof one === "object" && typeof two === "object") return getTrackBy(one) === getTrackBy(two);
            return false;
        };
        const isValueComputedArray = (v)=>Array.isArray(v.value);
        const selectOption = (option)=>{
            if (hoveredOption.value === null) {
                hideAndFocus();
                return;
            }
            if (showSearchInput.value) searchVModel.value = "";
            if (props.multiple && isValueComputedArray(valueComputed)) {
                const { exceedsMaxSelections, addOption } = (0, _useMaxSelectionsJs.a)(valueComputed, (0, _vue.ref)(props.maxSelections));
                const isSelected = checkIsOptionSelected(option);
                if (isSelected) valueComputed.value = valueComputed.value.filter((optionSelected)=>!compareOptions(option, optionSelected));
                else {
                    if (exceedsMaxSelections()) return;
                    valueComputed.value = addOption(option);
                }
            } else {
                valueComputed.value = typeof option !== "object" ? option : {
                    ...option
                };
                hideAndFocus();
            }
            focusAutocompleteInput();
        };
        const addNewOption = ()=>{
            var _a;
            const hasAddedOption = (_a = props.options) == null ? void 0 : _a.some((option)=>[
                    searchVModel.value,
                    autocompleteValue.value
                ].includes(getText(option)));
            const allowedToCreateCheck = !((props.allowCreate === "unique" || props.autocomplete) && hasAddedOption);
            if (allowedToCreateCheck) {
                emit("create-new", searchVModel.value || autocompleteValue.value);
                searchVModel.value = "";
                autocompleteValue.value = "";
            }
        };
        const hoveredOption = (0, _vue.ref)(null);
        const selectHoveredOption = ()=>{
            if (!isOpenSync.value) {
                handleDropdownOpen();
                return;
            }
            selectOption(hoveredOption.value);
        };
        const selectOrAddOption = ()=>{
            const allowedToCreate = !!props.allowCreate && (searchVModel.value || autocompleteValue.value);
            if (hoveredOption.value !== null) selectHoveredOption();
            else if (allowedToCreate) addNewOption();
        };
        const focusPreviousOption = ()=>{
            var _a;
            return (_a = optionList.value) == null ? void 0 : _a.focusPreviousOption();
        };
        const focusNextOption = ()=>{
            var _a;
            return (_a = optionList.value) == null ? void 0 : _a.focusNextOption();
        };
        const { isOpenSync, dropdownProps } = (0, _useDropdownableJs.b)(props, emit, {
            defaultCloseOnValueUpdate: (0, _vue.computed)(()=>!props.multiple)
        });
        const dropdownPropsComputed = (0, _vue.computed)(()=>({
                ...dropdownProps.value,
                stateful: false,
                innerAnchorSelector: ".va-input-wrapper__field"
            }));
        const showDropdownContentComputed = (0, _vue.computed)({
            get: ()=>isOpenSync.value,
            set: (show)=>{
                show ? handleDropdownOpen() : handleDropdownClose();
            }
        });
        const handleDropdownOpen = ()=>{
            if (props.disabled || props.readonly) return;
            isOpenSync.value = true;
            scrollToSelected();
            focusSearchOrOptions();
        };
        const handleDropdownClose = ()=>{
            isOpenSync.value = false;
            if (!props.autocomplete) searchVModel.value = "";
            (0, _vue.nextTick)(()=>{
                validate();
                isInputFocused.focusIfNothingIfFocused();
            });
        };
        const hideAndFocus = ()=>{
            handleDropdownClose();
            isInputFocused.value = true;
        };
        const focusSearchBar = ()=>{
            var _a;
            (_a = searchBar.value) == null || _a.focus();
        };
        const focusOptionList = ()=>{
            var _a, _b;
            (_a = optionList.value) == null || _a.focus();
            !props.modelValue && ((_b = optionList.value) == null || _b.focusFirstOption());
        };
        const focusSearchOrOptions = async ()=>{
            await (0, _vue.nextTick)();
            if (showSearchInput.value) focusSearchBar();
            else focusOptionList();
        };
        const onInputBlur = ()=>{
            if (showDropdownContentComputed.value) return;
            onBlur();
            isInputFocused.value ? isInputFocused.value = false : validate();
        };
        const tabIndexComputed = (0, _vue.computed)(()=>props.disabled ? -1 : props.tabindex);
        const openSelectButtonTabIndexComputed = (0, _vue.computed)(()=>props.disabled || props.autocomplete ? -1 : 0);
        const scrollToSelected = ()=>{
            const selected = valueComputed.value;
            const nothingSelected = typeof selected !== "object" && Array.isArray(selected) && !selected.length;
            if (nothingSelected) return;
            const scrollTo = Array.isArray(selected) ? selected[selected.length - 1] : selected;
            hoveredOption.value = scrollTo;
            (0, _vue.nextTick)(()=>{
                var _a;
                return (_a = optionList.value) == null ? void 0 : _a.scrollToOption(scrollTo);
            });
        };
        let hintedSearchQuery = "";
        let hintedSearchQueryTimeoutIndex;
        const navigationKeys = [
            "ArrowUp",
            "ArrowDown",
            "ArrowLeft",
            "ArrowRight",
            "Enter",
            " "
        ];
        const onHintedSearch = (event)=>{
            if (navigationKeys.some((key)=>key === event.key)) return;
            const isLetter = event.key.length === 1;
            const isDeleteKey = event.key === "Backspace" || event.key === "Delete";
            clearTimeout(hintedSearchQueryTimeoutIndex);
            if (isDeleteKey) hintedSearchQuery = hintedSearchQuery ? hintedSearchQuery.slice(0, -1) : "";
            else if (isLetter) hintedSearchQuery += event.key;
            if (showSearchInput.value) {
                searchVModel.value = hintedSearchQuery;
                return;
            }
            if (hintedSearchQuery) {
                const appropriateOption = props.options.find((option)=>getText(option).toLowerCase().startsWith(hintedSearchQuery.toLowerCase()));
                if (appropriateOption) hoveredOption.value = appropriateOption;
            }
            hintedSearchQueryTimeoutIndex = setTimeout(()=>{
                hintedSearchQuery = "";
            }, 1e3);
        };
        const optionsListPropsComputed = (0, _vue.computed)(()=>({
                ...(0, _vendorJs.p)(props, [
                    "textBy",
                    "trackBy",
                    "groupBy",
                    "valueBy",
                    "disabledBy",
                    "color",
                    "virtualScroller",
                    "highlightMatchedText",
                    "minSearchChars",
                    "delay",
                    "selectedTopShown"
                ]),
                autoSelectFirstOption: props.autoSelectFirstOption || props.autocomplete,
                search: searchVModel.value || autocompleteValue.value,
                tabindex: tabIndexComputed.value,
                selectedValue: valueComputed.value,
                options: filteredOptions.value,
                getSelectedState: checkIsOptionSelected,
                noOptionsText: tp(props.noOptionsText),
                doShowAllOptions: doShowAllOptions.value
            }));
        const { toggleIcon, toggleIconColor } = (0, _useToggleIconJs.a)(props, isOpenSync);
        const isFocused = (0, _vue.computed)(()=>isInputFocused.value || isOpenSync.value);
        const slots = (0, _vue.useSlots)();
        const inputWrapperClassComputed = (0, _useBemJs.u)("va-select-anchor", ()=>({
                nowrap: !!(props.maxVisibleOptions && !slots.content)
            }));
        const vaInputWrapperProps = (0, _filterPropsJs.f)(VaInputWrapperProps);
        const inputWrapperPropsComputed = (0, _vue.computed)(()=>({
                ...vaInputWrapperProps.value,
                error: computedError.value,
                errorMessages: computedErrorMessages.value,
                focused: isFocused.value,
                "aria-label": props.ariaLabel || (props.modelValue ? `${t("selectedOption")}: ${props.modelValue}` : t("noSelectedOption"))
            }));
        const selectContentPropsComputed = (0, _vue.computed)(()=>({
                ...(0, _vendorJs.p)(props, [
                    "placeholder",
                    "autocomplete",
                    "multiple",
                    "disabled",
                    "readonly"
                ]),
                tabindex: tabIndexComputed.value,
                value: visibleSelectedOptions.value,
                valueString: valueString.value,
                hiddenSelectedOptionsAmount: hiddenSelectedOptionsAmount.value,
                isAllOptionsShown: isAllOptionsShown.value,
                focused: isInputFocused.value,
                autocompleteInputValue: autocompleteValue.value,
                getText: getValueText
            }));
        const autocompleteValue = (0, _useAutocompleteJs.a)(searchVModel, props, visibleSelectedOptions, isOpenSync, getText);
        const setAutocompleteValue = (v)=>autocompleteValue.value = v;
        const doShowAllOptions = (0, _vue.ref)(true);
        (0, _vue.watch)(showDropdownContentComputed, ()=>{
            doShowAllOptions.value = true;
        });
        (0, _vue.watch)(searchVModel, ()=>{
            doShowAllOptions.value = false;
        });
        const focus = ()=>{
            if (props.disabled) return;
            (0, _focusJs.a)((0, _unwrapElJs.u)(input.value));
        };
        const blur = ()=>{
            if (showDropdownContentComputed.value) showDropdownContentComputed.value = false;
            (0, _vue.nextTick)(()=>{
                if (props.disabled) return;
                (0, _focusJs.b)((0, _unwrapElJs.u)(input.value));
            });
        };
        const reset = ()=>withoutValidation(()=>{
                if (props.multiple) valueComputed.value = Array.isArray(props.clearValue) ? props.clearValue : [];
                else valueComputed.value = props.clearValue;
                searchVModel.value = "";
                emit("clear");
                resetValidation();
                (0, _vue.nextTick)(()=>{
                    isInputFocused.value = true;
                });
            });
        const focusAutocompleteInput = (e)=>{
            if (props.autocomplete && !props.disabled && !props.readonly) {
                e == null || e.stopImmediatePropagation();
                isInputFocused.value = true;
                isOpenSync.value = true;
            }
        };
        const toggleDropdown = (e)=>{
            if (props.disabled || props.readonly) return;
            const isInInput = e.target && "tagName" in e.target && e.target.tagName === "INPUT";
            if (e.code === "Space" && isInInput) return;
            e.preventDefault();
            showDropdownContentComputed.value = !showDropdownContentComputed.value;
        };
        const deleteLastSelected = ()=>{
            if (!Array.isArray(valueComputed.value)) return;
            valueComputed.value = valueComputed.value.slice(0, -1);
        };
        const { validate, computedError, computedErrorMessages, withoutValidation, resetValidation } = (0, _useValidationJs.a)(props, emit, {
            reset,
            focus,
            value: valueComputed
        });
        const { popupId } = (0, _useSelectAriaJs.u)();
        const searchInput = searchVModel;
        const onInputFocus = onFocus;
        __expose({
            focus,
            blur,
            reset
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs1.V)), (0, _vue.mergeProps)({
                ref: "dropdown",
                modelValue: showDropdownContentComputed.value,
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event)=>showDropdownContentComputed.value = $event),
                class: "va-select va-select__dropdown va-select-dropdown"
            }, dropdownPropsComputed.value, {
                role: "combobox",
                "inner-anchor-selector": ".va-input-wrapper__field",
                "keyboard-navigation": false
            }), {
                anchor: (0, _vue.withCtx)(()=>[
                        (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs.V)), (0, _vue.mergeProps)(inputWrapperPropsComputed.value, {
                            ref_key: "input",
                            ref: input,
                            class: [
                                "va-select__anchor va-select-anchor__input",
                                (0, _vue.unref)(inputWrapperClassComputed)
                            ],
                            "aria-haspopup": "listbox",
                            "model-value": (0, _vue.unref)(valueString),
                            readonly: true,
                            "aria-label": _ctx.$props.ariaLabel,
                            "aria-controls": (0, _vue.unref)(popupId),
                            "aria-owns": (0, _vue.unref)(popupId),
                            onFocus: (0, _vue.unref)(onInputFocus),
                            onBlur: onInputBlur
                        }), (0, _vue.createSlots)({
                            icon: (0, _vue.withCtx)(()=>[
                                    showClearIcon.value ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs2.V)), (0, _vue.mergeProps)({
                                        key: 0,
                                        role: "button",
                                        "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaClearLabel)
                                    }, (0, _vue.unref)(clearIconProps), {
                                        onClick: (0, _vue.withModifiers)(reset, [
                                            "stop"
                                        ]),
                                        onKeydown: [
                                            (0, _vue.withKeys)((0, _vue.withModifiers)(reset, [
                                                "stop"
                                            ]), [
                                                "enter"
                                            ]),
                                            (0, _vue.withKeys)((0, _vue.withModifiers)(reset, [
                                                "stop"
                                            ]), [
                                                "space"
                                            ])
                                        ]
                                    }), null, 16, [
                                        "aria-label",
                                        "onKeydown"
                                    ])) : (0, _vue.createCommentVNode)("", true)
                                ]),
                            appendInner: (0, _vue.withCtx)(()=>[
                                    (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs2.V)), {
                                        color: (0, _vue.unref)(toggleIconColor),
                                        name: (0, _vue.unref)(toggleIcon),
                                        class: "va-select__toggle-icon",
                                        role: "button",
                                        tabindex: openSelectButtonTabIndexComputed.value,
                                        "aria-expanded": showDropdownContentComputed.value,
                                        onKeydown: (0, _vue.withKeys)(toggleDropdown, [
                                            "enter"
                                        ])
                                    }, null, 8, [
                                        "color",
                                        "name",
                                        "tabindex",
                                        "aria-expanded"
                                    ])
                                ]),
                            default: (0, _vue.withCtx)(({ ariaAttributes })=>[
                                    (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs4.V)), (0, _vue.mergeProps)(selectContentPropsComputed.value, {
                                        ariaAttributes,
                                        separator: _ctx.$props.separator,
                                        onToggleHidden: (0, _vue.unref)(toggleHiddenOptionsState),
                                        onAutocompleteInput: setAutocompleteValue,
                                        onFocusPrev: focusPreviousOption,
                                        onFocusNext: focusNextOption,
                                        onSelectOption: selectOrAddOption,
                                        onDeleteLastSelected: deleteLastSelected
                                    }), (0, _vue.createSlots)({
                                        _: 2
                                    }, [
                                        (0, _vue.renderList)(_ctx.$slots, (_, name)=>{
                                            return {
                                                name,
                                                fn: (0, _vue.withCtx)((slotScope)=>[
                                                        (0, _vue.renderSlot)(_ctx.$slots, name, (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(slotScope)))
                                                    ])
                                            };
                                        })
                                    ]), 1040, [
                                        "ariaAttributes",
                                        "separator",
                                        "onToggleHidden"
                                    ])
                                ]),
                            _: 2
                        }, [
                            (0, _vue.renderList)(_ctx.$slots, (_, name)=>{
                                return {
                                    name,
                                    fn: (0, _vue.withCtx)((slotScope)=>[
                                            (0, _vue.renderSlot)(_ctx.$slots, name, (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(slotScope)))
                                        ])
                                };
                            })
                        ]), 1040, [
                            "class",
                            "model-value",
                            "aria-label",
                            "aria-controls",
                            "aria-owns",
                            "onFocus"
                        ])
                    ]),
                default: (0, _vue.withCtx)(()=>[
                        (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs5.V)), {
                            class: "va-select-dropdown__content",
                            style: (0, _vue.normalizeStyle)({
                                width: _ctx.$props.width
                            }),
                            onKeydown: (0, _vue.withKeys)(hideAndFocus, [
                                "esc"
                            ]),
                            role: "dialog"
                        }, {
                            default: (0, _vue.withCtx)(()=>[
                                    showSearchInput.value ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), {
                                        key: 0,
                                        ref_key: "searchBar",
                                        ref: searchBar,
                                        class: "va-select-dropdown__content-search-input",
                                        modelValue: (0, _vue.unref)(searchInput),
                                        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event)=>(0, _vue.isRef)(searchInput) ? searchInput.value = $event : null),
                                        "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaSearchLabel),
                                        tabindex: tabIndexComputed.value,
                                        placeholder: (0, _vue.unref)(tp)(_ctx.$props.searchPlaceholderText),
                                        preset: "bordered",
                                        onKeydown: [
                                            (0, _vue.withKeys)((0, _vue.withModifiers)(focusPreviousOption, [
                                                "stop",
                                                "prevent"
                                            ]), [
                                                "up"
                                            ]),
                                            (0, _vue.withKeys)((0, _vue.withModifiers)(focusPreviousOption, [
                                                "stop",
                                                "prevent"
                                            ]), [
                                                "left"
                                            ]),
                                            (0, _vue.withKeys)((0, _vue.withModifiers)(focusNextOption, [
                                                "stop",
                                                "prevent"
                                            ]), [
                                                "down"
                                            ]),
                                            (0, _vue.withKeys)((0, _vue.withModifiers)(focusNextOption, [
                                                "stop",
                                                "prevent"
                                            ]), [
                                                "right"
                                            ]),
                                            (0, _vue.withKeys)((0, _vue.withModifiers)(selectOrAddOption, [
                                                "prevent"
                                            ]), [
                                                "enter"
                                            ])
                                        ],
                                        onFocus: _cache[1] || (_cache[1] = ($event)=>hoveredOption.value = null)
                                    }, null, 8, [
                                        "modelValue",
                                        "aria-label",
                                        "tabindex",
                                        "placeholder",
                                        "onKeydown"
                                    ])) : (0, _vue.createCommentVNode)("", true),
                                    (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs3.V)), (0, _vue.mergeProps)({
                                        ref_key: "optionList",
                                        ref: optionList,
                                        class: "va-select-dropdown__options-wrapper",
                                        hoveredOption: hoveredOption.value,
                                        "onUpdate:hoveredOption": _cache[2] || (_cache[2] = ($event)=>hoveredOption.value = $event),
                                        style: {
                                            maxHeight: _ctx.$props.maxHeight
                                        },
                                        id: (0, _vue.unref)(popupId)
                                    }, optionsListPropsComputed.value, {
                                        onSelectOption: selectHoveredOption,
                                        onNoPreviousOptionToHover: focusSearchBar,
                                        onKeydown: [
                                            _cache[3] || (_cache[3] = (0, _vue.withKeys)((0, _vue.withModifiers)(($event)=>searchBar.value && searchBar.value.focus(), [
                                                "stop",
                                                "prevent"
                                            ]), [
                                                "tab"
                                            ])),
                                            onHintedSearch
                                        ],
                                        onScrollBottom
                                    }), {
                                        default: (0, _vue.withCtx)((slotData)=>[
                                                (0, _vue.renderSlot)(_ctx.$slots, "option", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(slotData)))
                                            ]),
                                        "option-content": (0, _vue.withCtx)((slotData)=>[
                                                (0, _vue.renderSlot)(_ctx.$slots, "option-content", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(slotData)))
                                            ]),
                                        _: 3
                                    }, 16, [
                                        "hoveredOption",
                                        "style",
                                        "id"
                                    ])
                                ]),
                            _: 3
                        }, 8, [
                            "style"
                        ])
                    ]),
                _: 3
            }, 16, [
                "modelValue"
            ]);
        };
    }
});

},{"vue":"gzxs9","../../../vendor.js":"l6TAc","../va-input-wrapper/index.js":"7MuId","../va-dropdown/index.js":"2ag98","../va-icon/index.js":"82tPo","./components/VaSelectOptionList/index.js":"33kSb","./components/VaSelectContent/index.js":"i1xf7","./hooks/useMaxVisibleOptions.js":"lsc0z","./hooks/useToggleIcon.js":"cr3F9","./hooks/useStringValue.js":"5Duy4","./hooks/useAutocomplete.js":"h0GTt","./hooks/useSelectAria.js":"kXAft","../../utils/focus.js":"e1Xlj","../../utils/unwrapEl.js":"bYHKv","../../utils/isNilValue.js":"7ZWWV","../../utils/console.js":"58L6z","../../composables/useMaxSelections.js":"7fbrI","../va-dropdown/components/VaDropdownContent/index.js":"eUpbA","../../utils/component-options/extract-component-options.js":"1ODzH","../../composables/useComponentPreset.js":"2HoaT","../../composables/useSelectableList.js":"5kDaP","../../composables/useValidation.js":"iFHh2","../../composables/useLoading.js":"jYmWj","../../composables/useClearable.js":"h8vES","../../composables/useFormField.js":"676Eq","../../composables/useThrottle.js":"8b3Ic","../../composables/useDropdownable.js":"iz6O5","../../composables/useTranslation.js":"7S3aV","../../composables/useFocusDeep.js":"ay8Fe","../../composables/useSyncProp.js":"3q1sU","../../composables/useBem.js":"igmjV","../../utils/component-options/filter-props.js":"4HycW","../../../VaSelect.css":"aZaVh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"33kSb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaSelectOptionList);
var _withConfigTransportJs = require("../../../../services/config-transport/withConfigTransport.js");
var _vaSelectOptionListVueVueTypeScriptSetupTrueLangJs = require("./VaSelectOptionList.vue_vue_type_script_setup_true_lang.js");
const VaSelectOptionList = (0, _withConfigTransportJs.w)((0, _vaSelectOptionListVueVueTypeScriptSetupTrueLangJs._));

},{"../../../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaSelectOptionList.vue_vue_type_script_setup_true_lang.js":"e0PEY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e0PEY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../../../vendor.js");
var _scrollToElementJs = require("../../../../utils/scroll-to-element.js");
var _indexJs = require("../../../va-virtual-scroller/index.js");
var _indexJs1 = require("../VaSelectOption/index.js");
var _isNilValueJs = require("../../../../utils/isNilValue.js");
var _unwrapElJs = require("../../../../utils/unwrapEl.js");
var _useObjectRefsJs = require("../../../../composables/useObjectRefs.js");
var _useColorsJs = require("../../../../composables/useColors.js");
var _useComponentPresetJs = require("../../../../composables/useComponentPreset.js");
var _useSelectableListJs = require("../../../../composables/useSelectableList.js");
var _useThrottleJs = require("../../../../composables/useThrottle.js");
var _vaSelectOptionListCss = require("../../../../../VaSelectOptionList.css");
const _hoisted_1 = [
    "tabindex",
    "onKeydown",
    "aria-multiselectable"
];
const _hoisted_2 = {
    key: 0,
    class: "va-select-option-list__group-name",
    role: "presentation"
};
const _hoisted_3 = {
    key: 0,
    class: "va-select-option-list--empty"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaSelectOptionList",
    __name: "VaSelectOptionList",
    props: {
        ...(0, _useColorsJs.a),
        ...(0, _useComponentPresetJs.u),
        ...(0, _useSelectableListJs.u),
        ...(0, _useThrottleJs.u),
        noOptionsText: {
            type: String,
            default: "Items not found"
        },
        getSelectedState: {
            type: Function,
            required: true
        },
        multiple: {
            type: Boolean,
            default: false
        },
        search: {
            type: String,
            default: ""
        },
        tabindex: {
            type: [
                String,
                Number
            ],
            default: 0
        },
        hoveredOption: {
            type: [
                String,
                Number,
                Boolean,
                Object
            ],
            default: null
        },
        virtualScroller: {
            type: Boolean,
            default: true
        },
        highlightMatchedText: {
            type: Boolean,
            default: true
        },
        minSearchChars: {
            type: Number,
            default: 0
        },
        autoSelectFirstOption: {
            type: Boolean,
            default: false
        },
        selectedTopShown: {
            type: Boolean,
            default: false
        },
        doShowAllOptions: {
            type: Boolean,
            default: false
        }
    },
    emits: [
        "select-option",
        "update:hoveredOption",
        "no-previous-option-to-hover",
        "scroll-bottom"
    ],
    setup (__props, { expose: __expose, emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const root = (0, _vue.shallowRef)();
        const focus = ()=>{
            var _a;
            (_a = root.value) == null || _a.focus({
                preventScroll: true
            });
        };
        const rootHeight = (0, _vue.computed)(()=>{
            var _a;
            return ((_a = root.value) == null ? void 0 : _a.clientHeight) ?? 200;
        });
        const handleScrollToBottom = ()=>emit("scroll-bottom");
        const onScroll = (event)=>{
            const target = event.target;
            if (!target) return;
            if (target.scrollTop + target.clientHeight === target.scrollHeight) handleScrollToBottom();
        };
        const lastInteractionSource = (0, _vue.ref)("");
        const currentOptionComputed = (0, _vue.computed)(()=>props.hoveredOption ?? null);
        const updateCurrentOption = (option, source)=>{
            emit("update:hoveredOption", option);
            lastInteractionSource.value = source;
        };
        const { getText, getGroupBy, getTrackBy, getDisabled } = (0, _useSelectableListJs.a)(props);
        const currentSelectedOptionText = (0, _vue.computed)(()=>{
            var _a;
            const getSelectedState = props.getSelectedState;
            const selected = (_a = props.options) == null ? void 0 : _a.find((option)=>getSelectedState(option));
            return selected ? getText(selected) : "";
        });
        const isSearchedOptionSelected = (0, _vue.computed)(()=>{
            var _a;
            return currentSelectedOptionText.value.toLowerCase() === ((_a = props.search) == null ? void 0 : _a.toLowerCase());
        });
        const filteredOptions = (0, _vue.computed)(()=>{
            if (props.doShowAllOptions && isSearchedOptionSelected.value) return props.options;
            if (!props.search || props.search.length < props.minSearchChars) return props.options;
            const search = props.search.toUpperCase().trim();
            return props.options.filter((option)=>{
                const optionText = getText(option).toUpperCase();
                return optionText.includes(search);
            });
        });
        const optionGroups = (0, _vue.computed)(()=>{
            if (!props.groupBy) return {
                _noGroup: filteredOptions.value
            };
            return filteredOptions.value.reduce((groups, option)=>{
                const groupBy = getGroupBy(option);
                if (!groupBy) groups._noGroup.push(option);
                else {
                    if (!groups[groupBy]) groups[groupBy] = [];
                    groups[groupBy].push(option);
                }
                return groups;
            }, {
                _noGroup: []
            });
        });
        const optionGroupsThrottled = (0, _useThrottleJs.a)(optionGroups, props);
        const isValueExists = (value)=>!(0, _isNilValueJs.i)(value);
        const updateHoveredOption = (option)=>{
            if (option === currentOptionComputed.value || isValueExists(option) && getDisabled(option)) return;
            updateCurrentOption(option ?? null, "mouse");
        };
        const updateFocusedOption = (option)=>{
            updateCurrentOption(option ?? null, "keyboard");
        };
        const selectHoveredOption = ()=>{
            const previousOption = previousOptionComputed.value && typeof previousOptionComputed.value === "object" ? {
                ...previousOptionComputed.value
            } : previousOptionComputed.value;
            emit("select-option");
            if (props.selectedTopShown) updateHoveredOption(previousOption);
        };
        const groupedOptions = (0, _vue.computed)(()=>Object.values(optionGroupsThrottled.value).flat());
        const currentOptions = (0, _vue.computed)(()=>filteredOptions.value.some((el)=>getGroupBy(el)) ? groupedOptions.value : filteredOptions.value);
        const currentOptionIndex = (0, _vue.computed)(()=>currentOptions.value.findIndex((option)=>{
                return isValueExists(currentOptionComputed.value) && getTrackBy(option) === getTrackBy(currentOptionComputed.value);
            }));
        const selectOptionProps = (0, _vue.computed)(()=>({
                ...(0, _vendorJs.p)(props, [
                    "getSelectedState",
                    "color",
                    "search",
                    "highlightMatchedText",
                    "minSearchChars"
                ]),
                getText,
                getTrackBy
            }));
        const findNextActiveOption = (startSearchIndex, reversedSearch = false)=>{
            const searchBase = [
                ...currentOptions.value || []
            ];
            const searchBaseOrdered = reversedSearch ? searchBase.reverse() : searchBase;
            const startIndex = reversedSearch ? startSearchIndex * -1 - 1 : startSearchIndex;
            return searchBaseOrdered.slice(startIndex).find((option)=>!getDisabled(option));
        };
        const previousOptionComputed = (0, _vue.computed)(()=>{
            const previousOptionIndex = currentOptionIndex.value - 1;
            const previousOption = currentOptions.value[previousOptionIndex];
            const previousOptionCheck = isValueExists(previousOption) && !(previousOptionIndex === 0 && getDisabled(previousOption));
            if (previousOptionCheck) return findNextActiveOption(currentOptionIndex.value - 1, true);
            return void 0;
        });
        const selectOption = (option)=>{
            updateHoveredOption(option);
            emit("select-option");
        };
        const handleMouseMove = (option)=>{
            if (!props.selectedTopShown) updateHoveredOption(option);
        };
        const handleMouseEnter = (option)=>{
            if (props.selectedTopShown) updateHoveredOption(option);
        };
        const focusPreviousOption = ()=>{
            if (!isValueExists(currentOptionComputed.value)) {
                updateFocusedOption(findNextActiveOption(0, true));
                return;
            }
            if (isValueExists(previousOptionComputed.value)) updateFocusedOption(previousOptionComputed.value);
            else emit("no-previous-option-to-hover");
        };
        const focusNextOption = ()=>{
            if (!isValueExists(currentOptionComputed.value)) {
                focusFirstOption();
                return;
            }
            const nextOptionIndex = currentOptionIndex.value + 1;
            const nextOption = currentOptions.value[nextOptionIndex];
            const nextOptionCheck = isValueExists(nextOption) && !(nextOptionIndex === currentOptions.value.length - 1 && getDisabled(nextOption));
            if (nextOptionCheck) updateFocusedOption(findNextActiveOption(currentOptionIndex.value + 1));
        };
        const focusFirstOption = ()=>updateFocusedOption(findNextActiveOption(0));
        const { itemRefs, setItemRef } = (0, _useObjectRefsJs.u)();
        const virtualScrollerRef = (0, _vue.shallowRef)();
        const scrollToOption = (option)=>{
            var _a;
            if (!isValueExists(option)) return;
            const element = (0, _unwrapElJs.u)(itemRefs.value[getTrackBy(option)]);
            if (element) (0, _scrollToElementJs.s)(element);
            const virtualScroller = (_a = virtualScrollerRef.value) == null ? void 0 : _a[0];
            if (props.virtualScroller) virtualScroller.virtualScrollTo(currentOptionIndex.value);
        };
        (0, _vue.watch)(()=>props.hoveredOption, (newOption)=>{
            (!lastInteractionSource.value || lastInteractionSource.value === "keyboard") && isValueExists(newOption) && scrollToOption(newOption);
        });
        (0, _vue.watch)(filteredOptions, ()=>{
            if (!props.autoSelectFirstOption) return;
            focusFirstOption();
        }, {
            immediate: true
        });
        __expose({
            focusPreviousOption,
            focusNextOption,
            focusFirstOption,
            scrollToOption,
            focus
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                ref_key: "root",
                ref: root,
                class: "va-select-option-list",
                tabindex: __props.tabindex,
                onKeydown: [
                    (0, _vue.withKeys)((0, _vue.withModifiers)(focusPreviousOption, [
                        "stop",
                        "prevent"
                    ]), [
                        "up"
                    ]),
                    (0, _vue.withKeys)((0, _vue.withModifiers)(focusPreviousOption, [
                        "stop",
                        "prevent"
                    ]), [
                        "left"
                    ]),
                    (0, _vue.withKeys)((0, _vue.withModifiers)(focusNextOption, [
                        "stop",
                        "prevent"
                    ]), [
                        "down"
                    ]),
                    (0, _vue.withKeys)((0, _vue.withModifiers)(focusNextOption, [
                        "stop",
                        "prevent"
                    ]), [
                        "right"
                    ]),
                    (0, _vue.withKeys)((0, _vue.withModifiers)(selectHoveredOption, [
                        "stop",
                        "prevent"
                    ]), [
                        "enter"
                    ]),
                    (0, _vue.withKeys)((0, _vue.withModifiers)(selectHoveredOption, [
                        "stop",
                        "prevent"
                    ]), [
                        "space"
                    ])
                ],
                onScrollPassive: onScroll,
                role: "listbox",
                "aria-multiselectable": _ctx.$props.multiple
            }, [
                ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)((0, _vue.unref)(optionGroupsThrottled), (options, groupName)=>{
                    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                        key: groupName
                    }, [
                        groupName !== "_noGroup" ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("span", _hoisted_2, (0, _vue.toDisplayString)(groupName), 1)) : (0, _vue.createCommentVNode)("", true),
                        _ctx.$props.virtualScroller ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), {
                            key: 1,
                            ref_for: true,
                            ref_key: "virtualScrollerRef",
                            ref: virtualScrollerRef,
                            items: options,
                            "track-by": (0, _vue.unref)(getTrackBy),
                            "wrapper-size": rootHeight.value,
                            "onScroll:bottom": handleScrollToBottom
                        }, {
                            default: (0, _vue.withCtx)(({ item: option, index })=>[
                                    (0, _vue.renderSlot)(_ctx.$slots, "default", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                        option,
                                        index,
                                        selectOption: (o = option)=>selectOption(o)
                                    })), ()=>[
                                            (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs1.V)), (0, _vue.mergeProps)({
                                                option,
                                                "current-option": currentOptionComputed.value,
                                                disabled: (0, _vue.unref)(getDisabled)(option)
                                            }, selectOptionProps.value, {
                                                onClick: (0, _vue.withModifiers)(selectHoveredOption, [
                                                    "stop"
                                                ]),
                                                onMouseenter: ($event)=>handleMouseEnter(option),
                                                onMousemove: ($event)=>handleMouseMove(option)
                                            }), null, 16, [
                                                "option",
                                                "current-option",
                                                "disabled",
                                                "onMouseenter",
                                                "onMousemove"
                                            ])
                                        ])
                                ]),
                            _: 2
                        }, 1032, [
                            "items",
                            "track-by",
                            "wrapper-size"
                        ])) : ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                            key: 2
                        }, (0, _vue.renderList)(options, (option, index)=>{
                            return (0, _vue.renderSlot)(_ctx.$slots, "default", (0, _vue.normalizeProps)((0, _vue.mergeProps)({
                                key: (0, _vue.unref)(getTrackBy)(option)
                            }, {
                                option,
                                index,
                                selectOption
                            })), ()=>[
                                    (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs1.V)), (0, _vue.mergeProps)({
                                        ref_for: true,
                                        ref: (0, _vue.unref)(setItemRef)((0, _vue.unref)(getTrackBy)(option)),
                                        "current-option": currentOptionComputed.value,
                                        option,
                                        disabled: (0, _vue.unref)(getDisabled)(option)
                                    }, selectOptionProps.value, {
                                        onClick: (0, _vue.withModifiers)(selectHoveredOption, [
                                            "stop"
                                        ]),
                                        onMouseenter: ($event)=>handleMouseEnter(option),
                                        onMousemove: ($event)=>handleMouseMove(option)
                                    }), {
                                        "option-content": (0, _vue.withCtx)(()=>[
                                                (0, _vue.renderSlot)(_ctx.$slots, "option-content", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                                    option,
                                                    index
                                                })))
                                            ]),
                                        _: 2
                                    }, 1040, [
                                        "current-option",
                                        "option",
                                        "disabled",
                                        "onMouseenter",
                                        "onMousemove"
                                    ])
                                ]);
                        }), 128))
                    ], 64);
                }), 128)),
                !filteredOptions.value.length ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_3, (0, _vue.toDisplayString)(__props.noOptionsText), 1)) : (0, _vue.createCommentVNode)("", true)
            ], 40, _hoisted_1);
        };
    }
});

},{"vue":"gzxs9","../../../../../vendor.js":"l6TAc","../../../../utils/scroll-to-element.js":"bhchX","../../../va-virtual-scroller/index.js":"cvrbR","../VaSelectOption/index.js":"FUx4p","../../../../utils/isNilValue.js":"7ZWWV","../../../../utils/unwrapEl.js":"bYHKv","../../../../composables/useObjectRefs.js":"5mRvj","../../../../composables/useColors.js":"a4Qgv","../../../../composables/useComponentPreset.js":"2HoaT","../../../../composables/useSelectableList.js":"5kDaP","../../../../composables/useThrottle.js":"8b3Ic","../../../../../VaSelectOptionList.css":"96ecH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bhchX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "s", ()=>scrollToElement);
const getTopCoordinate = (element)=>element.offsetTop;
const getBottomCoordinate = (element)=>element.offsetTop + element.offsetHeight;
const getCenterCoordinate = (element)=>element.offsetTop + element.offsetHeight / 2;
const getScrollTop = (element, scrollTarget, verticalAlignment)=>{
    const viewHeight = scrollTarget.offsetHeight;
    const currentPosition = scrollTarget.scrollTop;
    const top = getTopCoordinate(element) - scrollTarget.offsetTop;
    const center = getCenterCoordinate(element) - scrollTarget.offsetTop;
    const bottom = getBottomCoordinate(element) - scrollTarget.offsetTop;
    if (verticalAlignment === "start") return top;
    if (verticalAlignment === "end") return bottom - viewHeight;
    if (verticalAlignment === "center") return center - viewHeight / 2;
    if (verticalAlignment === "any") {
        if (top - currentPosition < 0) return top;
        if (bottom - currentPosition > viewHeight) return bottom - viewHeight;
    }
};
const scrollToElement = (element, options = {
    scrollTarget: element.parentElement,
    verticalAlignment: "any",
    smooth: false
})=>{
    const scrollTarget = options.scrollTarget || element.parentElement;
    const top = getScrollTop(element, scrollTarget, options.verticalAlignment);
    if (top === void 0) return;
    scrollTarget.scroll({
        top,
        behavior: options.smooth ? "smooth" : "auto"
    });
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"FUx4p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaSelectOption);
var _withConfigTransportJs = require("../../../../services/config-transport/withConfigTransport.js");
var _vaSelectOptionVueVueTypeScriptSetupTrueLangJs = require("./VaSelectOption.vue_vue_type_script_setup_true_lang.js");
const VaSelectOption = (0, _withConfigTransportJs.w)((0, _vaSelectOptionVueVueTypeScriptSetupTrueLangJs._));

},{"../../../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaSelectOption.vue_vue_type_script_setup_true_lang.js":"36Vvo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"36Vvo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _indexJs = require("../../../va-icon/index.js");
var _isObjectJs = require("../../../../utils/is-object.js");
var _useColorsJs = require("../../../../composables/useColors.js");
var _useBemJs = require("../../../../composables/useBem.js");
var _vaSelectOptionCss = require("../../../../../VaSelectOption.css");
const _hoisted_1 = [
    "aria-selected"
];
const _hoisted_2 = {
    key: 1,
    class: "va-select-option__highlighted"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaSelectOption",
    __name: "VaSelectOption",
    props: {
        ...(0, _useColorsJs.a),
        disabled: {
            type: Boolean,
            default: false
        },
        option: {
            type: [
                Number,
                String,
                Boolean,
                Object
            ],
            default: ()=>({})
        },
        getText: {
            type: Function,
            required: true
        },
        getTrackBy: {
            type: Function,
            required: true
        },
        currentOption: {
            type: [
                String,
                Number,
                Boolean,
                Object
            ],
            default: null
        },
        getSelectedState: {
            type: Function,
            required: true
        },
        search: {
            type: String,
            default: ""
        },
        highlightMatchedText: {
            type: Boolean,
            default: true
        },
        inputFocused: {
            type: Boolean,
            default: false
        },
        minSearchChars: {
            type: Number,
            default: 0
        }
    },
    setup (__props, { expose: __expose }) {
        const props = __props;
        const { getColor, getHoverColor } = (0, _useColorsJs.u)();
        const optionIcon = (0, _vue.computed)(()=>(0, _isObjectJs.i)(props.option) ? props.option.icon : void 0);
        const optionIconColor = (0, _vue.computed)(()=>getColor(props.color));
        const optionText = (0, _vue.computed)(()=>props.getText(props.option));
        const optionTextSplitted = (0, _vue.computed)(()=>{
            const defaultSplit = {
                start: optionText.value,
                searchedSubString: "",
                end: ""
            };
            if (!optionText.value || !props.search || !props.highlightMatchedText || props.search.length < props.minSearchChars) return defaultSplit;
            const substringStartIndex = optionText.value.toLowerCase().indexOf(props.search.toLowerCase());
            if (substringStartIndex < 0) return defaultSplit;
            const start = optionText.value.slice(0, substringStartIndex);
            const searchedSubString = optionText.value.slice(substringStartIndex, substringStartIndex + props.search.length);
            const end = optionText.value.slice(substringStartIndex + props.search.length);
            return {
                start,
                searchedSubString,
                end
            };
        });
        const isSelected = (0, _vue.computed)(()=>props.getSelectedState(props.option));
        const isFocused = (0, _vue.computed)(()=>{
            if (typeof props.option === "string") return props.option === props.currentOption;
            return props.getTrackBy(props.currentOption) === props.getTrackBy(props.option);
        });
        const optionClass = (0, _useBemJs.u)("va-select-option", ()=>({
                selected: isSelected.value
            }));
        const optionStyle = (0, _vue.computed)(()=>({
                color: isSelected.value ? getColor(props.color) : "inherit",
                backgroundColor: isFocused.value ? getHoverColor(getColor(props.color)) : "transparent",
                cursor: props.disabled ? "default" : void 0,
                opacity: props.disabled ? "var(--va-select-option-list-option-disabled-opacity)" : void 0
            }));
        __expose({
            isFocused,
            isSelected
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                role: "option",
                class: (0, _vue.normalizeClass)([
                    "va-select-option",
                    (0, _vue.unref)(optionClass)
                ]),
                style: (0, _vue.normalizeStyle)(optionStyle.value),
                "aria-selected": isSelected.value
            }, [
                (0, _vue.renderSlot)(_ctx.$slots, "option-content", {}, ()=>[
                        optionIcon.value ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), {
                            key: 0,
                            size: "small",
                            class: "va-select-option__icon",
                            name: optionIcon.value
                        }, null, 8, [
                            "name"
                        ])) : (0, _vue.createCommentVNode)("", true),
                        (0, _vue.createTextVNode)(" " + (0, _vue.toDisplayString)(optionTextSplitted.value.start) + " ", 1),
                        optionTextSplitted.value.searchedSubString ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("span", _hoisted_2, (0, _vue.toDisplayString)(optionTextSplitted.value.searchedSubString), 1)) : (0, _vue.createCommentVNode)("", true),
                        (0, _vue.createTextVNode)(" " + (0, _vue.toDisplayString)(optionTextSplitted.value.end), 1)
                    ]),
                (0, _vue.withDirectives)((0, _vue.createVNode)((0, _vue.unref)((0, _indexJs.V)), {
                    class: "va-select-option__selected-icon",
                    size: "small",
                    name: "va-check",
                    color: optionIconColor.value
                }, null, 8, [
                    "color"
                ]), [
                    [
                        (0, _vue.vShow),
                        isSelected.value
                    ]
                ])
            ], 14, _hoisted_1);
        };
    }
});

},{"vue":"gzxs9","../../../va-icon/index.js":"82tPo","../../../../utils/is-object.js":"4iaiI","../../../../composables/useColors.js":"a4Qgv","../../../../composables/useBem.js":"igmjV","../../../../../VaSelectOption.css":"wvZbK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"wvZbK":[function() {},{}],"5mRvj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useObjectRefs);
var _vue = require("vue");
const useObjectRefs = ()=>{
    const itemRefs = (0, _vue.shallowRef)({});
    const setItemRef = (key)=>(el)=>{
            if (!el) return;
            itemRefs.value[key] = el;
            return String(key);
        };
    (0, _vue.onBeforeUpdate)(()=>{
        itemRefs.value = {};
    });
    return {
        itemRefs,
        setItemRef
    };
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"96ecH":[function() {},{}],"i1xf7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaSelectContent);
var _withConfigTransportJs = require("../../../../services/config-transport/withConfigTransport.js");
var _vaSelectContentVueVueTypeScriptSetupTrueLangJs = require("./VaSelectContent.vue_vue_type_script_setup_true_lang.js");
const VaSelectContent = (0, _withConfigTransportJs.w)((0, _vaSelectContentVueVueTypeScriptSetupTrueLangJs._));

},{"../../../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaSelectContent.vue_vue_type_script_setup_true_lang.js":"hOvly","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hOvly":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _indexJs = require("../../../va-icon/index.js");
var _indexJs1 = require("../../../va-badge/index.js");
var _isObjectJs = require("../../../../utils/is-object.js");
var _useFormFieldJs = require("../../../../composables/useFormField.js");
var _vaSelectContentCss = require("../../../../../VaSelectContent.css");
const _hoisted_1 = {
    key: 0,
    class: "va-select-content__placeholder"
};
const _hoisted_2 = [
    "placeholder"
];
const _hoisted_3 = {
    key: 0,
    class: "va-select-content__option"
};
const _hoisted_4 = {
    key: 1,
    class: "va-select-content__separator"
};
const _hoisted_5 = [
    "placeholder",
    "disabled",
    "readonly"
];
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaSelectContent",
    __name: "VaSelectContent",
    props: {
        ...(0, _useFormFieldJs.u),
        ariaAttributes: {
            type: Object
        },
        value: {
            type: Array,
            required: true
        },
        valueString: {
            type: String
        },
        separator: {
            type: String,
            default: ", "
        },
        placeholder: {
            type: String,
            default: ""
        },
        tabindex: {
            type: [
                String,
                Number
            ],
            default: 0
        },
        hiddenSelectedOptionsAmount: {
            type: Number,
            default: 0
        },
        isAllOptionsShown: {
            type: Boolean,
            default: false
        },
        autocomplete: {
            type: Boolean,
            default: false
        },
        focused: {
            type: Boolean,
            default: false
        },
        multiple: {
            type: Boolean,
            default: false
        },
        getText: {
            type: Function,
            required: true
        },
        autocompleteInputValue: {
            type: String,
            default: ""
        }
    },
    emits: [
        "toggle-hidden",
        "autocomplete-input",
        "focus-prev",
        "focus-next",
        "select-option",
        "delete-last-selected"
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const autocompleteInput = (0, _vue.ref)();
        const isPlaceholder = (0, _vue.computed)(()=>props.placeholder && !props.valueString);
        const toggleHiddenOptionsState = ()=>emit("toggle-hidden");
        const { value, focused } = (0, _vue.toRefs)(props);
        const autocompleteInputValueComputed = (0, _vue.computed)({
            get: ()=>props.autocompleteInputValue,
            set: (v)=>emit("autocomplete-input", v)
        });
        (0, _vue.onMounted)(()=>{
            if (props.multiple) return;
            if (!props.autocomplete) return;
            autocompleteInputValueComputed.value = props.valueString;
        });
        (0, _vue.watch)(focused, (newValue)=>{
            var _a, _b;
            if (!props.autocomplete || !newValue) return;
            if (autocompleteInputValueComputed.value) (_a = autocompleteInput.value) == null || _a.setSelectionRange(0, autocompleteInputValueComputed.value.length);
            else (_b = autocompleteInput.value) == null || _b.focus();
        });
        const handleBackspace = (e)=>{
            if (props.multiple && value.value.length && e.key === "Backspace" && !autocompleteInputValueComputed.value) emit("delete-last-selected");
        };
        const handleClick = (e)=>{
            var _a;
            if (props.autocomplete) {
                (_a = autocompleteInput.value) == null || _a.focus();
                e.stopPropagation();
            }
        };
        const getIcon = (option)=>(0, _isObjectJs.i)(option) ? option.icon : void 0;
        const slotValue = (0, _vue.computed)(()=>{
            if (props.multiple) return value.value;
            return value.value[0];
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: "va-select-content",
                onClick: handleClick
            }, [
                isPlaceholder.value && !_ctx.$props.autocomplete ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("span", _hoisted_1, [
                    (0, _vue.createElementVNode)("input", (0, _vue.mergeProps)(__props.ariaAttributes, {
                        placeholder: _ctx.$props.placeholder,
                        readonly: ""
                    }), null, 16, _hoisted_2)
                ])) : !(props.autocomplete && !props.multiple) ? (0, _vue.renderSlot)(_ctx.$slots, "content", (0, _vue.normalizeProps)((0, _vue.mergeProps)({
                    key: 1
                }, {
                    value: slotValue.value,
                    valueString: _ctx.$props.valueString,
                    valueArray: _ctx.$props.value,
                    tabindex: _ctx.$props.tabindex,
                    ariaAttributes: __props.ariaAttributes
                })), ()=>[
                        ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)(_ctx.$props.value, (option, index)=>{
                            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                                key: index
                            }, [
                                option !== "" ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("span", _hoisted_3, [
                                    (0, _vue.renderSlot)(_ctx.$slots, "option-content", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                        option,
                                        index,
                                        selectOption: ()=>void 0
                                    })), ()=>[
                                            getIcon(option) ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), {
                                                key: 0,
                                                size: "small",
                                                class: "va-select-option__icon",
                                                name: getIcon(option)
                                            }, null, 8, [
                                                "name"
                                            ])) : (0, _vue.createCommentVNode)("", true),
                                            (0, _vue.createTextVNode)(" " + (0, _vue.toDisplayString)(__props.getText(option)), 1)
                                        ])
                                ])) : (0, _vue.createCommentVNode)("", true),
                                index < _ctx.$props.value.length - 1 ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("span", _hoisted_4, (0, _vue.toDisplayString)(_ctx.$props.separator), 1)) : (0, _vue.createCommentVNode)("", true)
                            ], 64);
                        }), 128))
                    ]) : (0, _vue.createCommentVNode)("", true),
                _ctx.$props.autocomplete ? (0, _vue.withDirectives)(((0, _vue.openBlock)(), (0, _vue.createElementBlock)("input", (0, _vue.mergeProps)({
                    key: 2
                }, __props.ariaAttributes, {
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event)=>autocompleteInputValueComputed.value = $event),
                    class: "va-select-content__autocomplete",
                    ref_key: "autocompleteInput",
                    ref: autocompleteInput,
                    autocomplete: "off",
                    "aria-autocomplete": "list",
                    placeholder: _ctx.$props.placeholder,
                    disabled: _ctx.$props.disabled,
                    readonly: _ctx.$props.readonly,
                    onKeydown: [
                        _cache[1] || (_cache[1] = (0, _vue.withKeys)((0, _vue.withModifiers)(($event)=>_ctx.$emit("focus-prev"), [
                            "stop",
                            "prevent"
                        ]), [
                            "up"
                        ])),
                        _cache[2] || (_cache[2] = (0, _vue.withKeys)((0, _vue.withModifiers)(($event)=>_ctx.$emit("focus-next"), [
                            "stop",
                            "prevent"
                        ]), [
                            "down"
                        ])),
                        _cache[3] || (_cache[3] = (0, _vue.withKeys)((0, _vue.withModifiers)(($event)=>_ctx.$emit("select-option"), [
                            "stop",
                            "prevent"
                        ]), [
                            "enter"
                        ])),
                        handleBackspace
                    ]
                }), null, 16, _hoisted_5)), [
                    [
                        (0, _vue.vModelDynamic),
                        autocompleteInputValueComputed.value
                    ]
                ]) : (0, _vue.createCommentVNode)("", true),
                (0, _vue.renderSlot)(_ctx.$slots, "hiddenOptionsBadge", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                    amount: _ctx.$props.hiddenSelectedOptionsAmount,
                    isShown: _ctx.$props.isAllOptionsShown,
                    toggle: toggleHiddenOptionsState
                })), ()=>[
                        _ctx.$props.hiddenSelectedOptionsAmount && !_ctx.$props.isAllOptionsShown ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs1.V)), {
                            key: 0,
                            class: "va-select-content__state-icon",
                            color: "info",
                            text: `+${_ctx.$props.hiddenSelectedOptionsAmount}`,
                            tabindex: _ctx.$props.tabindex,
                            onClick: (0, _vue.withModifiers)(toggleHiddenOptionsState, [
                                "stop"
                            ])
                        }, null, 8, [
                            "text",
                            "tabindex"
                        ])) : (0, _vue.createCommentVNode)("", true)
                    ]),
                (0, _vue.renderSlot)(_ctx.$slots, "hideOptionsButton", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                    isShown: _ctx.$props.isAllOptionsShown,
                    toggle: toggleHiddenOptionsState
                })), ()=>[
                        _ctx.$props.isAllOptionsShown ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), {
                            key: 0,
                            role: "button",
                            class: "va-select-content__state-icon",
                            size: "small",
                            name: "reply",
                            tabindex: _ctx.$props.tabindex,
                            onClick: (0, _vue.withModifiers)(toggleHiddenOptionsState, [
                                "stop"
                            ])
                        }, null, 8, [
                            "tabindex"
                        ])) : (0, _vue.createCommentVNode)("", true)
                    ])
            ]);
        };
    }
});

},{"vue":"gzxs9","../../../va-icon/index.js":"82tPo","../../../va-badge/index.js":"aHODx","../../../../utils/is-object.js":"4iaiI","../../../../composables/useFormField.js":"676Eq","../../../../../VaSelectContent.css":"7LCg0","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7LCg0":[function() {},{}],"lsc0z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useMaxVisibleOptions);
parcelHelpers.export(exports, "u", ()=>useMaxVisibleOptionsProps);
var _vue = require("vue");
var _isNilValueJs = require("../../../utils/isNilValue.js");
const useMaxVisibleOptionsProps = {
    maxVisibleOptions: {
        type: Number || String,
        default: 0
    }
};
const useMaxVisibleOptions = (props, getOptionByValue)=>{
    const modelValue = (0, _vue.toRef)(props, "modelValue");
    const isAllOptionsShown = (0, _vue.ref)(false);
    const belowLimitSelectedOptions = (0, _vue.ref)([]);
    const hiddenSelectedOptions = (0, _vue.ref)([]);
    const hiddenSelectedOptionsAmount = (0, _vue.computed)(()=>hiddenSelectedOptions.value.length);
    const allSelectedOptions = (0, _vue.computed)(()=>[
            ...belowLimitSelectedOptions.value,
            ...hiddenSelectedOptions.value
        ]);
    const visibleSelectedOptions = (0, _vue.computed)(()=>{
        if (!props.maxVisibleOptions || isAllOptionsShown.value) return allSelectedOptions.value;
        return belowLimitSelectedOptions.value;
    });
    (0, _vue.watch)(modelValue, ()=>{
        if (!Array.isArray(modelValue.value)) {
            belowLimitSelectedOptions.value = [
                getOptionByValue(modelValue.value)
            ];
            hiddenSelectedOptions.value = [];
            return;
        }
        const value = modelValue.value.filter((v)=>!(0, _isNilValueJs.i)(v)).map(getOptionByValue);
        if (props.maxVisibleOptions) {
            belowLimitSelectedOptions.value = value.slice(0, props.maxVisibleOptions);
            hiddenSelectedOptions.value = value.slice(props.maxVisibleOptions);
        } else {
            belowLimitSelectedOptions.value = [
                ...value
            ];
            hiddenSelectedOptions.value = [];
        }
    }, {
        immediate: true
    });
    const toggleHiddenOptionsState = ()=>isAllOptionsShown.value = !isAllOptionsShown.value;
    return {
        toggleHiddenOptionsState,
        isAllOptionsShown,
        visibleSelectedOptions,
        hiddenSelectedOptionsAmount,
        allSelectedOptions
    };
};

},{"vue":"gzxs9","../../../utils/isNilValue.js":"7ZWWV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cr3F9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useToggleIcon);
parcelHelpers.export(exports, "u", ()=>useToggleIconProps);
var _vue = require("vue");
var _useColorsJs = require("../../../composables/useColors.js");
const useToggleIconProps = {
    dropdownIcon: {
        type: [
            String,
            Object
        ],
        default: ()=>({
                open: "va-arrow-down",
                close: "va-arrow-up"
            }),
        validator: (value)=>{
            if (typeof value === "string") return true;
            return Object.entries(value).every(([prop, propValue])=>[
                    "open",
                    "close"
                ].includes(prop) && typeof propValue === "string");
        }
    }
};
const useToggleIcon = (props, showDropdownContent)=>{
    const toggleIcon = (0, _vue.computed)(()=>{
        if (!props.dropdownIcon) return "";
        if (typeof props.dropdownIcon === "string") return props.dropdownIcon;
        return showDropdownContent.value ? props.dropdownIcon.close : props.dropdownIcon.open;
    });
    const { getHoverColor, getColor } = (0, _useColorsJs.u)();
    const colorComputed = (0, _vue.computed)(()=>getColor("secondary"));
    const toggleIconColor = (0, _vue.computed)(()=>props.readonly ? getHoverColor(colorComputed.value) : colorComputed.value);
    return {
        toggleIcon,
        toggleIconColor
    };
};

},{"vue":"gzxs9","../../../composables/useColors.js":"a4Qgv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5Duy4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useStringValue);
parcelHelpers.export(exports, "u", ()=>useStringValueProps);
var _vue = require("vue");
const useStringValueProps = {
    separator: {
        type: String,
        default: ", "
    }
};
const useStringValue = (props, visibleSelectedOptions, getText)=>{
    return (0, _vue.computed)(()=>{
        var _a;
        if (!((_a = visibleSelectedOptions.value) == null ? void 0 : _a.length)) return props.clearValue;
        return visibleSelectedOptions.value.map(getText).join(props.separator) || props.clearValue;
    });
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h0GTt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useAutocomplete);
parcelHelpers.export(exports, "u", ()=>useAutocompleteProps);
var _vue = require("vue");
const useAutocompleteProps = {
    autocomplete: {
        type: Boolean,
        default: false
    }
};
const useAutocomplete = (autocompleteValue, props, value, dropdownShown, getText)=>{
    const getLastOptionText = (v)=>(v == null ? void 0 : v.length) ? getText(v.at(-1)) : "";
    if (props.autocomplete && !props.multiple) autocompleteValue.value = getLastOptionText(value.value);
    (0, _vue.watch)(value, (newValue, oldValue)=>{
        if (!props.autocomplete) return;
        const newValueStringConverted = getLastOptionText(newValue);
        const oldValueStringConverted = getLastOptionText(oldValue);
        if (newValueStringConverted !== oldValueStringConverted) {
            autocompleteValue.value = props.multiple ? "" : newValueStringConverted;
            if (!props.multiple) dropdownShown.value = false;
        }
    });
    (0, _vue.watch)(autocompleteValue, (newValue)=>{
        if (!props.autocomplete) return;
        if (newValue && newValue !== getLastOptionText(value.value)) dropdownShown.value = true;
    });
    const onDropdownClosed = ()=>{
        autocompleteValue.value = props.multiple ? "" : getLastOptionText(value.value);
    };
    (0, _vue.watch)(dropdownShown, (newValue, oldValue)=>{
        if (!props.autocomplete) return;
        if (!newValue || oldValue) onDropdownClosed();
    });
    return autocompleteValue;
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kXAft":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useSelectAria);
var _useComponentUuidJs = require("../../../composables/useComponentUuid.js");
const useSelectAria = ()=>{
    const id = (0, _useComponentUuidJs.u)();
    const popupId = `combobox-controls-${id}`;
    return {
        popupId
    };
};

},{"../../../composables/useComponentUuid.js":"cuNNa","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7fbrI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useMaxSelections);
parcelHelpers.export(exports, "u", ()=>useMaxSelectionsProps);
const useMaxSelectionsProps = {
    maxSelections: {
        type: [
            Number,
            String
        ],
        default: void 0
    }
};
function useMaxSelections(selections, maxSelections) {
    const exceedsMaxSelections = ()=>{
        if (maxSelections.value === void 0 || isNaN(+maxSelections.value)) return false;
        return selections.value.length >= Number(maxSelections.value);
    };
    const addOption = (optionToAdd)=>{
        return [
            ...selections.value,
            optionToAdd
        ];
    };
    return {
        exceedsMaxSelections,
        addOption
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aZaVh":[function() {},{}],"bljVI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaSkeleton);
parcelHelpers.export(exports, "a", ()=>VaSkeletonGroup);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaSkeletonVueVueTypeScriptSetupTrueLangJs = require("./VaSkeleton.vue_vue_type_script_setup_true_lang.js");
var _vaSkeletonGroupJs = require("./components/VaSkeletonGroup.js");
const VaSkeleton = (0, _withConfigTransportJs.w)((0, _vaSkeletonVueVueTypeScriptSetupTrueLangJs._));
const VaSkeletonGroup = (0, _withConfigTransportJs.w)((0, _vaSkeletonGroupJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaSkeleton.vue_vue_type_script_setup_true_lang.js":"4X0k9","./components/VaSkeletonGroup.js":"fY4k1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4X0k9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useColorsJs = require("../../composables/useColors.js");
var _useBemJs = require("../../composables/useBem.js");
var _useTranslationJs = require("../../composables/useTranslation.js");
var _vaSkeletonCss = require("../../../VaSkeleton.css");
const _hoisted_1 = {
    key: 0,
    class: "va-skeleton__wave"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaSkeleton",
    __name: "VaSkeleton",
    props: {
        color: {
            type: String,
            default: "backgroundElement"
        },
        delay: {
            type: Number,
            default: 100
        },
        tag: {
            type: String,
            default: "div"
        },
        animation: {
            type: String,
            default: "pulse"
        },
        lines: {
            type: [
                String,
                Number
            ],
            default: 1
        },
        height: {
            type: [
                String
            ],
            default: "5em"
        },
        width: {
            type: [
                String
            ],
            default: "100%"
        },
        lineGap: {
            type: String,
            default: "8px"
        },
        lastLineWidth: {
            type: [
                String
            ],
            default: "75%"
        },
        variant: {
            type: String,
            default: "squared"
        },
        ariaLabel: {
            type: String,
            default: "$t:loading"
        }
    },
    setup (__props) {
        const props = __props;
        const doShow = (0, _vue.ref)(false);
        let timeoutId;
        (0, _vue.onMounted)(()=>{
            clearTimeout(timeoutId);
            setTimeout(()=>{
                doShow.value = true;
            }, props.delay);
        });
        (0, _vue.onBeforeUnmount)(()=>{
            clearTimeout(timeoutId);
        });
        const heightComputed = (0, _vue.computed)(()=>{
            if (props.variant === "text") return `${props.lines}em`;
            return props.height;
        });
        const widthComputed = (0, _vue.computed)(()=>{
            if (props.variant === "circle") return heightComputed.value;
            return props.width;
        });
        const { getColor } = (0, _useColorsJs.u)();
        const colorComputed = (0, _vue.computed)(()=>getColor(props.color));
        (0, _vue.computed)(()=>`-${props.lineGap}`);
        const bem = (0, _useBemJs.u)("va-skeleton", ()=>({
                lines: Number(props.lines) > 1,
                text: props.variant === "text",
                circle: props.variant === "circle",
                hidden: !doShow.value,
                pulse: props.animation === "pulse",
                wave: props.animation === "wave"
            }));
        const borderRadius = (0, _vue.computed)(()=>{
            if (props.variant === "circle") return "50%";
            if (props.variant === "rounded") return `var(--va-skeleton-border-radius, calc(${heightComputed.value} / 5))`;
            return "0px";
        });
        const { tp } = (0, _useTranslationJs.u)();
        const attrs = (0, _vue.useAttrs)();
        const classes = (0, _vue.computed)(()=>[
                ...Object.keys(bem),
                attrs.class
            ]);
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.resolveDynamicComponent)(__props.tag), {
                class: (0, _vue.normalizeClass)([
                    "va-skeleton",
                    classes.value
                ]),
                role: "status",
                "aria-live": "polite",
                "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaLabel),
                "aria-atomic": "true",
                style: (0, _vue.normalizeStyle)(`--va-color-computed: ${String(colorComputed.value)};--va-height-computed: ${String(heightComputed.value)};--va-width-computed: ${String(widthComputed.value)};--va-border-radius: ${String(borderRadius.value)};--va-line-gap: ${String(__props.lineGap)};--va-last-line-width: ${String(__props.lastLineWidth)}`)
            }, {
                default: (0, _vue.withCtx)(()=>[
                        (0, _vue.renderSlot)(_ctx.$slots, "default"),
                        __props.animation === "wave" ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_1)) : (0, _vue.createCommentVNode)("", true)
                    ]),
                _: 3
            }, 8, [
                "aria-label",
                "class",
                "style"
            ]);
        };
    }
});

},{"vue":"gzxs9","../../composables/useColors.js":"a4Qgv","../../composables/useBem.js":"igmjV","../../composables/useTranslation.js":"7S3aV","../../../VaSkeleton.css":"lmhJU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lmhJU":[function() {},{}],"fY4k1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_VaSkeletonGroup);
var _vaSkeletonGroupVueVueTypeScriptSetupTrueLangJs = require("./VaSkeletonGroup.vue_vue_type_script_setup_true_lang.js");
var _pluginVueExportHelperJs = require("../../../../plugin-vue_export-helper.js");
var _vaSkeletonGroupCss = require("../../../../VaSkeletonGroup.css");
const VaSkeletonGroup_vue_vue_type_style_index_0_scoped_c27755d1_lang = "";
const _VaSkeletonGroup = /* @__PURE__ */ (0, _pluginVueExportHelperJs._)((0, _vaSkeletonGroupVueVueTypeScriptSetupTrueLangJs._), [
    [
        "__scopeId",
        "data-v-c27755d1"
    ]
]);

},{"./VaSkeletonGroup.vue_vue_type_script_setup_true_lang.js":"hkJz3","../../../../plugin-vue_export-helper.js":"broGc","../../../../VaSkeletonGroup.css":"fKnDf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hkJz3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vaConfigVueVueTypeScriptSetupTrueLangJs = require("../../va-config/VaConfig.vue_vue_type_script_setup_true_lang.js");
var _useBemJs = require("../../../composables/useBem.js");
var _vaSkeletonGroupCss = require("../../../../VaSkeletonGroup.css");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaSkeletonGroup",
    __name: "VaSkeletonGroup",
    props: {
        color: {
            type: String,
            default: "backgroundElement"
        },
        delay: {
            type: Number,
            default: 100
        },
        animation: {
            type: String,
            default: "pulse"
        },
        lines: {
            type: Number,
            default: 1
        },
        lineGap: {
            type: String,
            default: "8px"
        },
        lastLineWidth: {
            type: [
                String
            ],
            default: "75%"
        }
    },
    setup (__props) {
        const props = __props;
        const doShow = (0, _vue.ref)(false);
        let timeoutId;
        (0, _vue.onMounted)(()=>{
            timeoutId = setTimeout(()=>{
                doShow.value = true;
            }, props.delay);
        });
        (0, _vue.onBeforeMount)(()=>{
            clearTimeout(timeoutId);
        });
        const bem = (0, _useBemJs.u)("va-skeleton-group", ()=>({
                hidden: doShow.value === false
            }));
        const config = (0, _vue.computed)(()=>({
                ...props,
                delay: 0
            }));
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _vaConfigVueVueTypeScriptSetupTrueLangJs._)), {
                components: {
                    VaSkeleton: config.value
                }
            }, {
                default: (0, _vue.withCtx)(()=>[
                        (0, _vue.createElementVNode)("div", (0, _vue.mergeProps)({
                            class: [
                                "va-skeleton-group",
                                (0, _vue.unref)(bem)
                            ]
                        }, _ctx.$attrs), [
                            (0, _vue.renderSlot)(_ctx.$slots, "default", {}, void 0, true)
                        ], 16)
                    ]),
                _: 3
            }, 8, [
                "components"
            ]);
        };
    }
});

},{"vue":"gzxs9","../../va-config/VaConfig.vue_vue_type_script_setup_true_lang.js":"kIv2h","../../../composables/useBem.js":"igmjV","../../../../VaSkeletonGroup.css":"fKnDf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fKnDf":[function() {},{}],"fKnDf":[function() {},{}],"1Qb9Q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaSidebar);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaSidebarVueVueTypeScriptSetupTrueLangJs = require("./VaSidebar.vue_vue_type_script_setup_true_lang.js");
const VaSidebar = (0, _withConfigTransportJs.w)((0, _vaSidebarVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaSidebar.vue_vue_type_script_setup_true_lang.js":"9IA72","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9IA72":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useSidebarJs = require("./hooks/useSidebar.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useElementWidthJs = require("../../composables/useElementWidth.js");
var _vaConfigVueVueTypeScriptSetupTrueLangJs = require("../va-config/VaConfig.vue_vue_type_script_setup_true_lang.js");
var _useColorsJs = require("../../composables/useColors.js");
var _useTextColorJs = require("../../composables/useTextColor.js");
var _utilsJs = require("../../services/color/utils.js");
var _useBemJs = require("../../composables/useBem.js");
var _useClickOutsideJs = require("../../composables/useClickOutside.js");
var _vaSidebarCss = require("../../../VaSidebar.css");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaSidebar",
    __name: "VaSidebar",
    props: {
        ...(0, _useComponentPresetJs.u),
        activeColor: {
            type: String,
            default: "primary"
        },
        hoverColor: {
            type: String,
            default: void 0
        },
        hoverOpacity: {
            type: [
                Number,
                String
            ],
            default: 0.2,
            validator: (v)=>Number(v) >= 0 && Number(v) <= 1
        },
        borderColor: {
            type: String,
            default: void 0
        },
        color: {
            type: String,
            default: "background-element"
        },
        textColor: {
            type: String
        },
        gradient: {
            type: Boolean,
            default: false
        },
        minimized: {
            type: Boolean,
            default: false
        },
        hoverable: {
            type: Boolean,
            default: false
        },
        width: {
            type: String,
            default: "16rem"
        },
        minimizedWidth: {
            type: String,
            default: "4rem"
        },
        modelValue: {
            type: Boolean,
            default: true
        },
        animated: {
            type: [
                Boolean,
                String
            ],
            default: true
        },
        closeOnClickOutside: {
            type: Boolean,
            default: false
        }
    },
    emits: [
        "update:modelValue"
    ],
    setup (__props, { expose: __expose, emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const { getColor } = (0, _useColorsJs.u)();
        (0, _useSidebarJs.u)(props);
        const isHovered = (0, _vue.ref)(false);
        const isMinimized = (0, _vue.computed)(()=>props.minimized || props.hoverable && !isHovered.value);
        const menu = (0, _vue.ref)();
        const currentMenuWidth = (0, _useElementWidthJs.u)(menu);
        const doShowMenu = (0, _vue.computed)(()=>{
            if (props.modelValue === true) return true;
            if (currentMenuWidth.value === null) return true;
            return currentMenuWidth.value > 0;
        });
        const sidebarWidth = (0, _vue.ref)();
        const getSidebarWidth = ()=>{
            if (!props.modelValue) return 0;
            return isMinimized.value ? props.minimizedWidth : props.width;
        };
        const menuWidth = (0, _vue.computed)(()=>isMinimized.value ? props.minimizedWidth : props.width);
        (0, _vue.watchEffect)(()=>{
            const width = getSidebarWidth();
            setTimeout(()=>{
                sidebarWidth.value = width;
            });
        });
        const backgroundColorComputed = (0, _vue.computed)(()=>getColor(props.color));
        const { textColorComputed } = (0, _useTextColorJs.u)(backgroundColorComputed);
        const computedStyle = (0, _vue.computed)(()=>{
            const backgroundColor = getColor(backgroundColorComputed.value);
            const color = textColorComputed.value;
            return {
                color,
                backgroundColor,
                backgroundImage: props.gradient ? (0, _utilsJs.g)(backgroundColor) : void 0,
                overflowX: currentMenuWidth.value === sidebarWidth.value ? void 0 : "hidden",
                width: sidebarWidth.value,
                minWidth: sidebarWidth.value
            };
        });
        const computedClass = (0, _useBemJs.u)("va-sidebar", ()=>({
                minimized: isMinimized.value,
                animated: Boolean(props.animated),
                "animated-right": props.animated === "right",
                "animated-left": props.animated === "left" || props.animated === true
            }));
        const updateHoverState = (newHoverState)=>{
            isHovered.value = props.hoverable && newHoverState;
        };
        const rootElement = (0, _vue.shallowRef)();
        (0, _useClickOutsideJs.u)([
            rootElement
        ], ()=>{
            if (props.closeOnClickOutside && props.modelValue) setTimeout(()=>{
                emit("update:modelValue", false);
            }, 0);
        });
        const vaSidebarItemProps = (0, _vue.computed)(()=>({
                textColor: props.textColor,
                activeColor: props.activeColor,
                hoverColor: props.hoverColor,
                borderColor: props.borderColor,
                hoverOpacity: props.hoverOpacity
            }));
        __expose({
            isMinimized,
            isHovered,
            updateHoverState,
            rootElement,
            menu,
            doShowMenu,
            menuWidth,
            sidebarWidth
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("aside", {
                ref_key: "rootElement",
                ref: rootElement,
                class: (0, _vue.normalizeClass)([
                    "va-sidebar",
                    (0, _vue.unref)(computedClass)
                ]),
                style: (0, _vue.normalizeStyle)(computedStyle.value),
                onMouseenter: _cache[0] || (_cache[0] = ($event)=>updateHoverState(true)),
                onMouseleave: _cache[1] || (_cache[1] = ($event)=>updateHoverState(false))
            }, [
                (0, _vue.withDirectives)((0, _vue.createElementVNode)("div", {
                    class: "va-sidebar__menu",
                    ref_key: "menu",
                    ref: menu,
                    style: (0, _vue.normalizeStyle)({
                        width: menuWidth.value,
                        minWidth: menuWidth.value
                    })
                }, [
                    (0, _vue.createVNode)((0, _vue.unref)((0, _vaConfigVueVueTypeScriptSetupTrueLangJs._)), {
                        components: {
                            VaSidebarItem: vaSidebarItemProps.value
                        }
                    }, {
                        default: (0, _vue.withCtx)(()=>[
                                (0, _vue.renderSlot)(_ctx.$slots, "default")
                            ]),
                        _: 3
                    }, 8, [
                        "components"
                    ])
                ], 4), [
                    [
                        (0, _vue.vShow),
                        doShowMenu.value
                    ]
                ])
            ], 38);
        };
    }
});

},{"vue":"gzxs9","./hooks/useSidebar.js":"83oAC","../../composables/useComponentPreset.js":"2HoaT","../../composables/useElementWidth.js":"5hRLg","../va-config/VaConfig.vue_vue_type_script_setup_true_lang.js":"kIv2h","../../composables/useColors.js":"a4Qgv","../../composables/useTextColor.js":"5pfXb","../../services/color/utils.js":"4SMXK","../../composables/useBem.js":"igmjV","../../composables/useClickOutside.js":"4ZW8J","../../../VaSidebar.css":"kMDkx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"83oAC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useSidebarItem);
parcelHelpers.export(exports, "u", ()=>useSidebar);
var _vue = require("vue");
const VaSidebarKey = Symbol("VaSidebar");
const useSidebar = (props)=>{
    (0, _vue.provide)(VaSidebarKey, props);
};
const useSidebarItem = ()=>{
    return (0, _vue.inject)(VaSidebarKey, {
        color: "background-element"
    });
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5hRLg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useElementWidth);
var _vue = require("vue");
var _useResizeObserverJs = require("./useResizeObserver.js");
const useElementWidth = (el)=>{
    const width = (0, _vue.ref)(null);
    (0, _useResizeObserverJs.u)([
        el
    ], ()=>{
        var _a;
        width.value = ((_a = el.value) == null ? void 0 : _a.clientWidth) ?? null;
    });
    (0, _vue.watchEffect)(()=>{
        var _a;
        width.value = ((_a = el.value) == null ? void 0 : _a.clientWidth) ?? null;
    });
    return width;
};

},{"vue":"gzxs9","./useResizeObserver.js":"4ylh3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kMDkx":[function() {},{}],"5vyTd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaSidebarItem);
parcelHelpers.export(exports, "a", ()=>VaSidebarItemContent);
parcelHelpers.export(exports, "b", ()=>VaSidebarItemTitle);
var _withConfigTransportJs = require("../../../services/config-transport/withConfigTransport.js");
var _vaSidebarItemVueVueTypeScriptSetupTrueLangJs = require("./VaSidebarItem.vue_vue_type_script_setup_true_lang.js");
var _vaSidebarItemContentVueVueTypeScriptSetupTrueLangJs = require("./VaSidebarItemContent.vue_vue_type_script_setup_true_lang.js");
var _vaSidebarItemTitleVueVueTypeScriptSetupTrueLangJs = require("./VaSidebarItemTitle.vue_vue_type_script_setup_true_lang.js");
const VaSidebarItemContent = (0, _withConfigTransportJs.w)((0, _vaSidebarItemContentVueVueTypeScriptSetupTrueLangJs._));
const VaSidebarItemTitle = (0, _withConfigTransportJs.w)((0, _vaSidebarItemTitleVueVueTypeScriptSetupTrueLangJs._));
const VaSidebarItem = (0, _withConfigTransportJs.w)((0, _vaSidebarItemVueVueTypeScriptSetupTrueLangJs._));

},{"../../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaSidebarItem.vue_vue_type_script_setup_true_lang.js":"3fxK1","./VaSidebarItemContent.vue_vue_type_script_setup_true_lang.js":"dZ2RD","./VaSidebarItemTitle.vue_vue_type_script_setup_true_lang.js":"jcqP7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3fxK1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useSidebarJs = require("../hooks/useSidebar.js");
var _useComponentPresetJs = require("../../../composables/useComponentPreset.js");
var _utilsJs = require("../../../services/color/utils.js");
var _useRouterLinkJs = require("../../../composables/useRouterLink.js");
var _useElementRefJs = require("../../../composables/useElementRef.js");
var _useHoverJs = require("../../../composables/useHover.js");
var _useColorsJs = require("../../../composables/useColors.js");
var _useKeyboardOnlyFocusJs = require("../../../composables/useKeyboardOnlyFocus.js");
var _useTextColorJs = require("../../../composables/useTextColor.js");
var _vaSidebarItemCss = require("../../../../VaSidebarItem.css");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaSidebarItem",
    __name: "VaSidebarItem",
    props: {
        ...(0, _useRouterLinkJs.u),
        ...(0, _useComponentPresetJs.u),
        active: {
            type: Boolean,
            default: false
        },
        textColor: {
            type: String,
            default: void 0
        },
        activeColor: {
            type: String,
            default: "primary"
        },
        hoverColor: {
            type: String,
            default: void 0
        },
        hoverOpacity: {
            type: [
                Number,
                String
            ],
            default: 0.2
        },
        borderColor: {
            type: String,
            default: void 0
        }
    },
    setup (__props) {
        const props = __props;
        const rootElement = (0, _useElementRefJs.u)();
        const sidebar = (0, _useSidebarJs.a)();
        const { isHovered } = (0, _useHoverJs.u)(rootElement);
        const { getColor, getHoverColor, getFocusColor } = (0, _useColorsJs.u)();
        const { hasKeyboardFocus, keyboardFocusListeners } = (0, _useKeyboardOnlyFocusJs.u)();
        const backgroundColorComputed = (0, _vue.computed)(()=>{
            if (props.active && !isHovered.value && !hasKeyboardFocus.value) return getColor(props.activeColor);
            if (hasKeyboardFocus.value) return getFocusColor(getColor(props.hoverColor || props.activeColor));
            return "#ffffff00";
        });
        const textBackground = (0, _vue.computed)(()=>(0, _utilsJs.e)(getColor(sidebar == null ? void 0 : sidebar.color), backgroundColorComputed.value));
        const { textColorComputed } = (0, _useTextColorJs.u)(textBackground);
        const computedStyle = (0, _vue.computed)(()=>{
            const style = {
                color: textColorComputed.value
            };
            if (isHovered.value || props.active || hasKeyboardFocus.value) style.backgroundColor = backgroundColorComputed.value;
            if (props.active) {
                const mergedProps = {
                    ...sidebar,
                    ...props
                };
                style.borderColor = getColor(mergedProps.borderColor || mergedProps.activeColor);
            }
            if (hasKeyboardFocus.value) style.backgroundColor = getFocusColor(getColor(props.hoverColor || props.activeColor));
            if (isHovered.value) style.backgroundColor = getHoverColor(getColor(props.hoverColor || props.activeColor), Number(props.hoverOpacity));
            return style;
        });
        const { tagComputed, hrefComputed, linkAttributesComputed } = (0, _useRouterLinkJs.a)(props);
        getColor(sidebar == null ? void 0 : sidebar.color);
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.resolveDynamicComponent)((0, _vue.unref)(tagComputed)), (0, _vue.mergeProps)({
                ref_key: "rootElement",
                ref: rootElement,
                class: [
                    "va-sidebar__item va-sidebar-item",
                    {
                        "va-sidebar-item--active": _ctx.$props.active
                    }
                ],
                tabindex: "0",
                style: computedStyle.value
            }, (0, _vue.unref)(linkAttributesComputed), (0, _vue.toHandlers)((0, _vue.unref)(keyboardFocusListeners))), {
                default: (0, _vue.withCtx)(()=>[
                        (0, _vue.renderSlot)(_ctx.$slots, "default")
                    ]),
                _: 3
            }, 16, [
                "class",
                "style"
            ]);
        };
    }
});

},{"vue":"gzxs9","../hooks/useSidebar.js":"83oAC","../../../composables/useComponentPreset.js":"2HoaT","../../../services/color/utils.js":"4SMXK","../../../composables/useRouterLink.js":"bep51","../../../composables/useElementRef.js":"3HFKq","../../../composables/useHover.js":"6F99t","../../../composables/useColors.js":"a4Qgv","../../../composables/useKeyboardOnlyFocus.js":"lKbNJ","../../../composables/useTextColor.js":"5pfXb","../../../../VaSidebarItem.css":"h5ZPM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h5ZPM":[function() {},{}],"dZ2RD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vaSidebarItemContentCss = require("../../../../VaSidebarItemContent.css");
const _hoisted_1 = {
    class: "va-sidebar__item__content va-sidebar-item-content"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaSidebarItemContent",
    __name: "VaSidebarItemContent",
    setup (__props) {
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_1, [
                (0, _vue.renderSlot)(_ctx.$slots, "default")
            ]);
        };
    }
});

},{"vue":"gzxs9","../../../../VaSidebarItemContent.css":"kk1UX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kk1UX":[function() {},{}],"jcqP7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vaSidebarItemTitleCss = require("../../../../VaSidebarItemTitle.css");
const _hoisted_1 = {
    class: "va-sidebar__title va-sidebar-item-title"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaSidebarItemTitle",
    __name: "VaSidebarItemTitle",
    setup (__props) {
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_1, [
                (0, _vue.renderSlot)(_ctx.$slots, "default")
            ]);
        };
    }
});

},{"vue":"gzxs9","../../../../VaSidebarItemTitle.css":"kk0EW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kk0EW":[function() {},{}],"4lRy1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaSlider);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaSliderVueVueTypeScriptSetupTrueLangJs = require("./VaSlider.vue_vue_type_script_setup_true_lang.js");
const VaSlider = (0, _withConfigTransportJs.w)((0, _vaSliderVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaSlider.vue_vue_type_script_setup_true_lang.js":"vwdp5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"vwdp5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../vendor.js");
var _validateSliderJs = require("./validateSlider.js");
var _indexJs = require("../va-icon/index.js");
var _useComponentUuidJs = require("../../composables/useComponentUuid.js");
var _useStatefulJs = require("../../composables/useStateful.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useColorsJs = require("../../composables/useColors.js");
var _useArrayRefsJs = require("../../composables/useArrayRefs.js");
var _useBemJs = require("../../composables/useBem.js");
var _useTranslationJs = require("../../composables/useTranslation.js");
var _vaSliderCss = require("../../../VaSlider.css");
const _hoisted_1 = {
    key: 0,
    class: "va-slider__input-wrapper",
    "aria-hidden": "true"
};
const _hoisted_2 = [
    "id"
];
const _hoisted_3 = {
    key: 2,
    class: "va-input__label",
    "aria-hidden": "true"
};
const _hoisted_4 = [
    "tabindex",
    "onFocus"
];
const _hoisted_5 = [
    "tabindex"
];
const _hoisted_6 = {
    key: 3,
    class: "va-input__label--inverse",
    "aria-hidden": "true"
};
const _hoisted_7 = [
    "id"
];
const _hoisted_8 = {
    key: 5,
    class: "va-slider__input-wrapper"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaSlider",
    __name: "VaSlider",
    props: {
        ...(0, _useStatefulJs.u),
        ...(0, _useComponentPresetJs.u),
        range: {
            type: Boolean,
            default: false
        },
        modelValue: {
            type: [
                Number,
                Array
            ],
            default: 0
        },
        trackLabel: {
            type: [
                Function,
                String
            ]
        },
        color: {
            type: String,
            default: "primary"
        },
        trackColor: {
            type: String,
            default: ""
        },
        labelColor: {
            type: String,
            default: ""
        },
        trackLabelVisible: {
            type: Boolean,
            default: false
        },
        min: {
            type: Number,
            default: 0
        },
        max: {
            type: Number,
            default: 100
        },
        step: {
            type: Number,
            default: 1
        },
        label: {
            type: String,
            default: ""
        },
        invertLabel: {
            type: Boolean,
            default: false
        },
        disabled: {
            type: Boolean,
            default: false
        },
        readonly: {
            type: Boolean,
            default: false
        },
        pins: {
            type: Boolean,
            default: false
        },
        iconPrepend: {
            type: String,
            default: ""
        },
        iconAppend: {
            type: String,
            default: ""
        },
        vertical: {
            type: Boolean,
            default: false
        },
        showTrack: {
            type: Boolean,
            default: true
        },
        ariaLabel: {
            type: String,
            default: "$t:sliderValue"
        }
    },
    emits: [
        "drag-start",
        "drag-end",
        "change",
        "update:modelValue"
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const { getColor, getHoverColor } = (0, _useColorsJs.u)();
        const sliderContainer = (0, _vue.shallowRef)();
        const dot = (0, _vue.shallowRef)();
        const { setItemRefByIndex, itemRefs: dots } = (0, _useArrayRefsJs.u)();
        const isFocused = (0, _vue.ref)(false);
        const flag = (0, _vue.ref)(false);
        const offset = (0, _vue.ref)(0);
        const size = (0, _vue.ref)(0);
        const defaultValue = props.range ? [
            0,
            100
        ] : 0;
        const { valueComputed } = (0, _useStatefulJs.b)(props, emit, "modelValue", {
            defaultValue
        });
        const currentSliderDotIndex = (0, _vue.ref)(0);
        const hasMouseDown = (0, _vue.ref)(false);
        const orders = (0, _vue.computed)(()=>props.vertical ? [
                1,
                0
            ] : [
                0,
                1
            ]);
        const pinPositionStyle = (0, _vue.computed)(()=>props.vertical ? "bottom" : "left");
        const trackSizeStyle = (0, _vue.computed)(()=>props.vertical ? "height" : "width");
        const moreToLess = (0, _vue.computed)(()=>Array.isArray(val.value) && val.value[1] - props.step < val.value[0]);
        const lessToMore = (0, _vue.computed)(()=>Array.isArray(val.value) && val.value[0] + props.step > val.value[1]);
        const sliderClass = (0, _useBemJs.u)("va-slider", ()=>({
                ...(0, _vendorJs.p)(props, [
                    "disabled",
                    "readonly",
                    "vertical"
                ]),
                active: isFocused.value,
                horizontal: !props.vertical,
                grabbing: hasMouseDown.value
            }));
        const dotClass = (0, _useBemJs.u)("va-slider__handler", ()=>({
                onFocus: !props.range && (flag.value || isFocused.value),
                inactive: !isFocused.value
            }));
        const labelStyles = (0, _vue.computed)(()=>({
                color: props.labelColor ? getColor(props.labelColor) : getColor(props.color)
            }));
        const trackStyles = (0, _vue.computed)(()=>({
                backgroundColor: props.trackColor ? getColor(props.trackColor) : getHoverColor(getColor(props.color))
            }));
        const processedStyles = (0, _vue.computed)(()=>{
            if (Array.isArray(val.value)) {
                const val0 = (val.value[0] - props.min) / (props.max - props.min) * 100;
                const val1 = (val.value[1] - props.min) / (props.max - props.min) * 100;
                return {
                    [pinPositionStyle.value]: `${val0}%`,
                    [trackSizeStyle.value]: `${val1 - val0}%`,
                    backgroundColor: getColor(props.color),
                    visibility: props.showTrack ? "visible" : "hidden"
                };
            } else {
                const val0 = (val.value - props.min) / (props.max - props.min) * 100;
                return {
                    [trackSizeStyle.value]: `${val0}%`,
                    backgroundColor: getColor(props.color),
                    visibility: props.showTrack ? "visible" : "hidden"
                };
            }
        });
        const dottedStyles = (0, _vue.computed)(()=>{
            if (Array.isArray(val.value)) {
                const val0 = (val.value[0] - props.min) / (props.max - props.min) * 100;
                const val1 = (val.value[1] - props.min) / (props.max - props.min) * 100;
                return [
                    {
                        [pinPositionStyle.value]: `${val0}%`,
                        backgroundColor: isActiveDot(0) ? getColor(props.color) : "#ffffff",
                        borderColor: getColor(props.color)
                    },
                    {
                        [pinPositionStyle.value]: `${val1}%`,
                        backgroundColor: isActiveDot(1) ? getColor(props.color) : "#ffffff",
                        borderColor: getColor(props.color)
                    }
                ];
            } else {
                const val0 = (val.value - props.min) / (props.max - props.min) * 100;
                return {
                    [pinPositionStyle.value]: `${val0}%`,
                    backgroundColor: isActiveDot(0) ? getColor(props.color) : "#ffffff",
                    borderColor: getColor(props.color)
                };
            }
        });
        const getDottedStyles = (index)=>props.range ? dottedStyles.value[index] : dottedStyles.value;
        const val = (0, _vue.computed)({
            get: ()=>valueComputed.value,
            set: (val2)=>{
                if (!flag.value) emit("change", val2);
                valueComputed.value = val2;
            }
        });
        const getValueByOrder = (order)=>props.range && order !== void 0 ? val.value[order] : val.value;
        const gap = (0, _vue.computed)(()=>{
            const total = (props.max - props.min) / props.step;
            return size.value / total;
        });
        const multiple = (0, _vue.computed)(()=>{
            const decimals = `${props.step}`.split(".")[1];
            return decimals ? Math.pow(10, decimals.length) : 1;
        });
        const pinsCol = (0, _vue.computed)(()=>(props.max - props.min) / props.step - 1);
        const position = (0, _vue.computed)(()=>{
            return Array.isArray(val.value) ? [
                (val.value[0] - props.min) / props.step * gap.value,
                (val.value[1] - props.min) / props.step * gap.value
            ] : (val.value - props.min) / props.step * gap.value;
        });
        const limit = (0, _vue.computed)(()=>[
                0,
                size.value
            ]);
        const valueLimit = (0, _vue.computed)(()=>[
                props.min,
                props.max
            ]);
        const isActiveDot = (index)=>{
            if (!isFocused.value && !flag.value || props.disabled || props.readonly) return false;
            return props.range ? currentSliderDotIndex.value === index : currentSliderDotIndex.value === 0;
        };
        const moveStart = (e, index = currentSliderDotIndex.value)=>{
            var _a, _b;
            e.preventDefault();
            if (!index) {
                if (!props.range) index = 0;
                else if (Array.isArray(position.value)) {
                    const touch = "touches" in e ? e.touches[0] : e;
                    const pos = getPos(touch);
                    index = pos > (position.value[1] - position.value[0]) / 2 + position.value[0] ? 1 : 0;
                }
            }
            if (Array.isArray(val.value)) currentSliderDotIndex.value = index;
            Array.isArray(val.value) ? (_a = dots.value[index]) == null || _a.focus() : (_b = dot.value) == null || _b.focus();
            flag.value = true;
            emit("drag-start");
        };
        const moving = (e)=>{
            if (!hasMouseDown.value || !flag.value || props.disabled || props.readonly) return;
            e.preventDefault();
            if ("touches" in e) setValueOnPos(getPos(e.touches[0]));
            else setValueOnPos(getPos(e));
        };
        const moveEnd = ()=>{
            if (!props.disabled && !props.readonly) {
                if (flag.value) {
                    emit("drag-end");
                    emit("change", val.value);
                }
                flag.value = false;
                hasMouseDown.value = false;
            }
        };
        const clamp = (min, v, max)=>Math.max(Math.min(v, max), min);
        const moveWithKeys = (event)=>{
            var _a, _b;
            if (![
                dots.value[0],
                dots.value[1],
                dot.value
            ].includes(document.activeElement)) return;
            if (props.disabled || props.readonly) return;
            const moveDot = (where, which)=>{
                if (Array.isArray(val.value)) {
                    const value = val.value[which] + (where ? props.step : -props.step);
                    const limitedValue = clamp(props.min, value, props.max);
                    val.value = [
                        which === 0 ? limitedValue : val.value[0],
                        which === 1 ? limitedValue : val.value[1]
                    ];
                } else {
                    const value = val.value + (where ? props.step : -props.step);
                    const limitedValue = clamp(props.min, value, props.max);
                    val.value = limitedValue;
                }
            };
            if ([
                "ArrowLeft",
                "ArrowUp",
                "ArrowRight",
                "ArrowDown"
            ].includes(event.key)) event.preventDefault();
            const isActive = (el)=>el === document.activeElement;
            if (props.range && Array.isArray(val.value)) {
                const isVerticalDot0More = (event2)=>props.vertical && isActive(dots.value[0]) && event2.key === "ArrowUp";
                const isVerticalDot0Less = (event2)=>props.vertical && isActive(dots.value[0]) && event2.key === "ArrowDown";
                const isVerticalDot1More = (event2)=>props.vertical && isActive(dots.value[1]) && event2.key === "ArrowUp";
                const isVerticalDot1Less = (event2)=>props.vertical && isActive(dots.value[1]) && event2.key === "ArrowDown";
                const isHorizontalDot0Less = (event2)=>!props.vertical && isActive(dots.value[0]) && event2.key === "ArrowLeft";
                const isHorizontalDot0More = (event2)=>!props.vertical && isActive(dots.value[0]) && event2.key === "ArrowRight";
                const isHorizontalDot1Less = (event2)=>!props.vertical && isActive(dots.value[1]) && event2.key === "ArrowLeft";
                const isHorizontalDot1More = (event2)=>!props.vertical && isActive(dots.value[1]) && event2.key === "ArrowRight";
                switch(true){
                    case (isVerticalDot1Less(event) || isHorizontalDot1Less(event)) && moreToLess.value && val.value[0] !== props.min:
                        (_a = dots.value[0]) == null || _a.focus();
                        moveDot(0, 0);
                        break;
                    case (isVerticalDot0More(event) || isHorizontalDot0More(event)) && lessToMore.value && val.value[1] !== props.max:
                        (_b = dots.value[1]) == null || _b.focus();
                        moveDot(1, 1);
                        break;
                    case (isVerticalDot0Less(event) || isHorizontalDot0Less(event)) && val.value[0] !== props.min:
                        moveDot(0, 0);
                        break;
                    case (isVerticalDot1More(event) || isHorizontalDot1More(event)) && val.value[1] !== props.max:
                        moveDot(1, 1);
                        break;
                    case (isVerticalDot1Less(event) || isHorizontalDot1Less(event)) && val.value[1] !== props.min:
                        moveDot(0, 1);
                        break;
                    case (isVerticalDot0More(event) || isHorizontalDot0More(event)) && val.value[0] !== props.max:
                        moveDot(1, 0);
                        break;
                }
            } else if (props.vertical) {
                if (event.key === "ArrowDown") moveDot(0, 0);
                if (event.key === "ArrowUp") moveDot(1, 0);
            } else {
                if (event.key === "ArrowLeft") moveDot(0, 0);
                if (event.key === "ArrowRight") moveDot(1, 0);
            }
        };
        const checkActivePin = (pin)=>{
            if (Array.isArray(val.value)) return pin * props.step > val.value[0] && pin * props.step < val.value[1];
            else return pin * props.step < val.value;
        };
        const pinPositionStep = (0, _vue.computed)(()=>props.step / (props.max - props.min) * 100);
        const getPinStyles = (pin)=>({
                backgroundColor: checkActivePin(pin) ? getColor(props.color) : getHoverColor(getColor(props.color)),
                [pinPositionStyle.value]: `${pin * pinPositionStep.value}%`,
                transition: hasMouseDown.value ? "none" : "var(--va-slider-pin-transition)"
            });
        const getPos = (e)=>{
            getStaticData();
            return props.vertical ? offset.value - e.clientY : e.clientX - offset.value;
        };
        const getStaticData = ()=>{
            if (sliderContainer.value) {
                size.value = sliderContainer.value[props.vertical ? "offsetHeight" : "offsetWidth"];
                offset.value = sliderContainer.value.getBoundingClientRect()[pinPositionStyle.value];
            }
        };
        const getValueByIndex = (index)=>{
            return (props.step * multiple.value * index + props.min * multiple.value) / multiple.value;
        };
        const getTrackLabel = (val2, order)=>{
            if (!props.trackLabel) return val2;
            return typeof props.trackLabel === "function" ? props.trackLabel(val2, order) : props.trackLabel;
        };
        const setCurrentValue = (newValue)=>{
            const slider = currentSliderDotIndex.value;
            if (Array.isArray(val.value)) {
                if (isDiff(val.value[slider], newValue)) {
                    if (slider === 0) val.value = [
                        newValue,
                        val.value[1]
                    ];
                    else val.value = [
                        val.value[0],
                        newValue
                    ];
                }
            } else {
                if (newValue < props.min) val.value = props.min;
                else if (newValue > props.max) val.value = props.max;
                else if (isDiff(val.value, newValue)) val.value = newValue;
            }
        };
        const setValueOnPos = (pixelPosition)=>{
            const range = limit.value;
            const valueRange = valueLimit.value;
            const dotToFocus = Array.isArray(val.value) ? dots.value[currentSliderDotIndex.value] : dot.value;
            dotToFocus == null || dotToFocus.focus();
            if (pixelPosition >= range[0] && pixelPosition <= range[1]) {
                const v = getValueByIndex(Math.round(pixelPosition / gap.value));
                if (currentSliderDotIndex.value) {
                    if (Array.isArray(position.value) && Array.isArray(val.value) && pixelPosition <= position.value[0]) {
                        val.value = [
                            v,
                            val.value[0]
                        ];
                        currentSliderDotIndex.value = 0;
                    } else setCurrentValue(v);
                } else if (Array.isArray(position.value) && Array.isArray(val.value) && pixelPosition >= position.value[1]) {
                    val.value = [
                        val.value[1],
                        v
                    ];
                    currentSliderDotIndex.value = 1;
                } else setCurrentValue(v);
            } else if (pixelPosition < range[0]) setCurrentValue(valueRange[0]);
            else setCurrentValue(valueRange[1]);
        };
        const isDiff = (a, b)=>JSON.stringify(a) !== JSON.stringify(b);
        const clickOnContainer = (e)=>{
            if (props.disabled || props.readonly) return;
            const pos = "touches" in e ? getPos(e.touches[0]) : getPos(e);
            if (Array.isArray(position.value)) currentSliderDotIndex.value = pos > (position.value[1] - position.value[0]) / 2 + position.value[0] ? 1 : 0;
            hasMouseDown.value = true;
            setValueOnPos(pos);
            moveStart(e, currentSliderDotIndex.value);
        };
        const bindEvents = ()=>{
            document.addEventListener("mousemove", moving);
            document.addEventListener("touchmove", moving, {
                passive: false
            });
            document.addEventListener("mouseup", moveEnd);
            document.addEventListener("mouseleave", moveEnd);
            document.addEventListener("touchcancel", moveEnd);
            document.addEventListener("touchend", moveEnd);
            document.addEventListener("keydown", moveWithKeys);
        };
        const unbindEvents = ()=>{
            document.removeEventListener("mousemove", moving);
            document.removeEventListener("touchmove", moving);
            document.removeEventListener("mouseup", moveEnd);
            document.removeEventListener("mouseleave", moveEnd);
            document.removeEventListener("touchcancel", moveEnd);
            document.removeEventListener("touchend", moveEnd);
            document.removeEventListener("keydown", moveWithKeys);
        };
        const componentId = (0, _useComponentUuidJs.u)();
        const ariaLabelIdComputed = (0, _vue.computed)(()=>`aria-label-id-${componentId}`);
        const { tp } = (0, _useTranslationJs.u)();
        const slots = (0, _vue.useSlots)();
        const ariaAttributesComputed = (0, _vue.computed)(()=>({
                role: "slider",
                "aria-valuemin": props.min,
                "aria-valuemax": props.max,
                "aria-label": !slots.label && !props.label ? tp(props.ariaLabel, {
                    value: String(val.value)
                }) : void 0,
                "aria-labelledby": slots.label || props.label ? ariaLabelIdComputed.value : void 0,
                "aria-orientation": props.vertical ? "vertical" : "horizontal",
                "aria-disabled": props.disabled,
                "aria-readonly": props.readonly,
                "aria-valuenow": !Array.isArray(val.value) ? val.value : void 0,
                "aria-valuetext": Array.isArray(val.value) ? String(val.value) : void 0
            }));
        (0, _vue.onMounted)(()=>{
            if ((0, _validateSliderJs.v)(val.value, props.step, props.min, props.max, props.range)) {
                getStaticData();
                bindEvents();
            }
        });
        (0, _vue.onBeforeUnmount)(unbindEvents);
        (0, _vue.watch)([
            val,
            ()=>props.step,
            ()=>props.min,
            ()=>props.max,
            ()=>props.range
        ], ([value, step, min, max, range])=>{
            (0, _validateSliderJs.v)(value, step, min, max, range);
        });
        (0, _vue.watch)(hasMouseDown, (hasMouseDown2)=>{
            document.documentElement.style.cursor = hasMouseDown2 ? "grabbing" : "";
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", (0, _vue.mergeProps)({
                class: [
                    "va-slider",
                    (0, _vue.unref)(sliderClass)
                ]
            }, ariaAttributesComputed.value), [
                (__props.vertical ? _ctx.$slots.append : _ctx.$slots.prepend) ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_1, [
                    (0, _vue.renderSlot)(_ctx.$slots, __props.vertical ? "append" : "prepend")
                ])) : (0, _vue.createCommentVNode)("", true),
                (_ctx.$slots.label || __props.label) && !__props.invertLabel ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("span", {
                    key: 1,
                    class: "va-input__label",
                    id: ariaLabelIdComputed.value,
                    style: (0, _vue.normalizeStyle)(labelStyles.value)
                }, [
                    (0, _vue.renderSlot)(_ctx.$slots, "label", {}, ()=>[
                            (0, _vue.createTextVNode)((0, _vue.toDisplayString)(__props.label), 1)
                        ])
                ], 12, _hoisted_2)) : (0, _vue.createCommentVNode)("", true),
                (__props.vertical ? __props.iconAppend : __props.iconPrepend) ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("span", _hoisted_3, [
                    (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs.V)), {
                        name: __props.vertical ? __props.iconAppend : __props.iconPrepend,
                        color: (0, _vue.unref)(getColor)(_ctx.$props.color),
                        size: 16
                    }, null, 8, [
                        "name",
                        "color"
                    ])
                ])) : (0, _vue.createCommentVNode)("", true),
                (0, _vue.createElementVNode)("div", {
                    ref_key: "sliderContainer",
                    ref: sliderContainer,
                    class: "va-slider__container",
                    onMousedown: clickOnContainer,
                    onTouchstart: clickOnContainer
                }, [
                    (0, _vue.createElementVNode)("div", {
                        class: "va-slider__track",
                        "aria-hidden": "true",
                        style: (0, _vue.normalizeStyle)(trackStyles.value)
                    }, null, 4),
                    __props.pins ? ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                        key: 0
                    }, (0, _vue.renderList)(pinsCol.value, (pin, i)=>{
                        return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                            key: i,
                            class: (0, _vue.normalizeClass)([
                                "va-slider__mark",
                                {
                                    "va-slider__mark--active": checkActivePin(pin)
                                }
                            ]),
                            style: (0, _vue.normalizeStyle)(getPinStyles(pin))
                        }, null, 6);
                    }), 128)) : (0, _vue.createCommentVNode)("", true),
                    _ctx.$props.range ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                        key: 1
                    }, [
                        (0, _vue.createElementVNode)("div", {
                            ref: "process",
                            class: (0, _vue.normalizeClass)([
                                "va-slider__track va-slider__track--selected",
                                {
                                    "va-slider__track--active": isFocused.value
                                }
                            ]),
                            "aria-hidden": "true",
                            style: (0, _vue.normalizeStyle)(processedStyles.value)
                        }, null, 6),
                        ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)(orders.value, (order)=>{
                            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                key: "dot" + order,
                                ref_for: true,
                                ref: (0, _vue.unref)(setItemRefByIndex)(order),
                                class: (0, _vue.normalizeClass)([
                                    "va-slider__handler",
                                    (0, _vue.unref)(dotClass)
                                ]),
                                style: (0, _vue.normalizeStyle)(getDottedStyles(order)),
                                tabindex: __props.disabled || __props.readonly ? void 0 : 0,
                                onFocus: ($event)=>(isFocused.value = true, currentSliderDotIndex.value = order),
                                onBlur: _cache[0] || (_cache[0] = ($event)=>isFocused.value = false)
                            }, [
                                isActiveDot(order) ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                    key: 0,
                                    style: (0, _vue.normalizeStyle)({
                                        backgroundColor: (0, _vue.unref)(getColor)(_ctx.$props.color)
                                    }),
                                    class: "va-slider__handler__dot--focus"
                                }, null, 4)) : (0, _vue.createCommentVNode)("", true),
                                __props.trackLabelVisible ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                    key: 1,
                                    style: (0, _vue.normalizeStyle)(labelStyles.value),
                                    class: "va-slider__handler__dot--value"
                                }, [
                                    (0, _vue.renderSlot)(_ctx.$slots, "trackLabel", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                        value: getValueByOrder(order),
                                        order
                                    })), ()=>[
                                            (0, _vue.createTextVNode)((0, _vue.toDisplayString)(getTrackLabel(getValueByOrder(order), order)), 1)
                                        ])
                                ], 4)) : (0, _vue.createCommentVNode)("", true)
                            ], 46, _hoisted_4);
                        }), 128))
                    ], 64)) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                        key: 2
                    }, [
                        (0, _vue.createElementVNode)("div", {
                            ref: "process",
                            "aria-hidden": "true",
                            class: (0, _vue.normalizeClass)([
                                "va-slider__track va-slider__track--selected",
                                {
                                    "va-slider__track--active": isFocused.value
                                }
                            ]),
                            style: (0, _vue.normalizeStyle)(processedStyles.value)
                        }, null, 6),
                        (0, _vue.createElementVNode)("div", {
                            ref_key: "dot",
                            ref: dot,
                            class: (0, _vue.normalizeClass)([
                                "va-slider__handler",
                                (0, _vue.unref)(dotClass)
                            ]),
                            style: (0, _vue.normalizeStyle)(dottedStyles.value),
                            tabindex: _ctx.$props.disabled || _ctx.$props.readonly ? void 0 : 0,
                            onFocus: _cache[1] || (_cache[1] = ($event)=>isFocused.value = true),
                            onBlur: _cache[2] || (_cache[2] = ($event)=>isFocused.value = false)
                        }, [
                            isActiveDot(0) ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                key: 0,
                                class: "va-slider__handler__dot--focus",
                                style: (0, _vue.normalizeStyle)({
                                    backgroundColor: (0, _vue.unref)(getColor)(_ctx.$props.color)
                                })
                            }, null, 4)) : (0, _vue.createCommentVNode)("", true),
                            __props.trackLabelVisible ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                                key: 1,
                                class: "va-slider__handler__dot--value",
                                style: (0, _vue.normalizeStyle)(labelStyles.value)
                            }, [
                                (0, _vue.renderSlot)(_ctx.$slots, "trackLabel", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                    value: getValueByOrder()
                                })), ()=>[
                                        (0, _vue.createTextVNode)((0, _vue.toDisplayString)(getTrackLabel(getValueByOrder())), 1)
                                    ])
                            ], 4)) : (0, _vue.createCommentVNode)("", true)
                        ], 46, _hoisted_5)
                    ], 64))
                ], 544),
                (__props.vertical ? __props.iconPrepend : __props.iconAppend) ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("span", _hoisted_6, [
                    (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs.V)), {
                        name: __props.vertical ? __props.iconPrepend : __props.iconAppend,
                        color: (0, _vue.unref)(getColor)(_ctx.$props.color),
                        size: 16
                    }, null, 8, [
                        "name",
                        "color"
                    ])
                ])) : (0, _vue.createCommentVNode)("", true),
                (_ctx.$slots.label || __props.label) && __props.invertLabel ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("span", {
                    key: 4,
                    class: "va-input__label va-input__label--inverse",
                    style: (0, _vue.normalizeStyle)(labelStyles.value),
                    id: ariaLabelIdComputed.value
                }, [
                    (0, _vue.renderSlot)(_ctx.$slots, "label", {}, ()=>[
                            (0, _vue.createTextVNode)((0, _vue.toDisplayString)(__props.label), 1)
                        ])
                ], 12, _hoisted_7)) : (0, _vue.createCommentVNode)("", true),
                (__props.vertical ? _ctx.$slots.prepend : _ctx.$slots.append) ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_8, [
                    (0, _vue.renderSlot)(_ctx.$slots, __props.vertical ? "prepend" : "append")
                ])) : (0, _vue.createCommentVNode)("", true)
            ], 16);
        };
    }
});

},{"vue":"gzxs9","../../../vendor.js":"l6TAc","./validateSlider.js":"gemFm","../va-icon/index.js":"82tPo","../../composables/useComponentUuid.js":"cuNNa","../../composables/useStateful.js":"h9zUi","../../composables/useComponentPreset.js":"2HoaT","../../composables/useColors.js":"a4Qgv","../../composables/useArrayRefs.js":"jgG1u","../../composables/useBem.js":"igmjV","../../composables/useTranslation.js":"7S3aV","../../../VaSlider.css":"2fSac","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gemFm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "v", ()=>validateSlider);
var _consoleJs = require("../../utils/console.js");
const validateSlider = (value, step, min, max, range)=>{
    if (Array.isArray(value) && !range || !Array.isArray(value) && range) (0, _consoleJs.w)(`The type "${Array.isArray(value) ? "array" : typeof value}" of prop "model-value" does not match prop "range = ${range}".`);
    if (max < min) (0, _consoleJs.w)(`The maximum value (${max}) can not be less than the minimum value (${min}).`);
    if ((max - min) % step !== 0) (0, _consoleJs.w)(`Step ${step} is illegal. Slider is non-divisible (Min:Max-${min}:${max}).`);
    const inRange = (v)=>{
        if (v < min) (0, _consoleJs.w)(`The value of the slider is ${v}, the minimum value is ${min}, the value of this slider can not be less than the minimum value`);
        else if (v > max) (0, _consoleJs.w)(`The value of the slider is ${v}, the maximum value is ${max}, the value of this slider can not be greater than the maximum value`);
    };
    if (Array.isArray(value)) value.map(inRange);
    else inRange(value);
    return true;
};

},{"../../utils/console.js":"58L6z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2fSac":[function() {},{}],"7GFfZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaSplit);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaSplitVueVueTypeScriptSetupTrueLangJs = require("./VaSplit.vue_vue_type_script_setup_true_lang.js");
const VaSplit = (0, _withConfigTransportJs.w)((0, _vaSplitVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaSplit.vue_vue_type_script_setup_true_lang.js":"asppm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"asppm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../vendor.js");
var _useSplitDraggerJs = require("./useSplitDragger.js");
var _consoleJs = require("../../utils/console.js");
var _indexJs = require("../va-divider/index.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useStatefulJs = require("../../composables/useStateful.js");
var _useResizeObserverJs = require("../../composables/useResizeObserver.js");
var _useBemJs = require("../../composables/useBem.js");
var _useTranslationJs = require("../../composables/useTranslation.js");
var _vaSplitCss = require("../../../VaSplit.css");
const _hoisted_1 = [
    "aria-label"
];
const _hoisted_2 = {
    class: "va-split__dragger"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaSplit",
    __name: "VaSplit",
    props: {
        ...(0, _useComponentPresetJs.u),
        ...(0, _useSplitDraggerJs.u),
        ...(0, _useStatefulJs.u),
        modelValue: {
            type: Number,
            default: 50,
            validator: (v)=>v <= 100
        },
        maximization: {
            type: Boolean,
            default: false
        },
        maximizeStart: {
            type: Boolean,
            default: false
        },
        limits: {
            type: Array,
            default: ()=>[
                    0,
                    0
                ]
        },
        snapping: {
            type: Array,
            default: void 0
        },
        snappingRange: {
            type: [
                Number,
                String
            ],
            default: 4
        },
        ariaLabel: {
            type: String,
            default: "$t:splitPanels"
        }
    },
    emits: [
        ...(0, _useStatefulJs.a)
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const splitPanelsContainer = (0, _vue.shallowRef)();
        const { valueComputed } = (0, _useStatefulJs.b)(props, emit);
        const containerSize = (0, _vue.ref)();
        const bodyFontSize = (0, _vue.ref)(16);
        const handleContainerResize = ()=>{
            var _a;
            const { width, height } = ((_a = splitPanelsContainer.value) == null ? void 0 : _a.getBoundingClientRect()) || {
                width: 0,
                height: 0
            };
            containerSize.value = props.vertical ? height : width;
            bodyFontSize.value = parseFloat(getComputedStyle(document.documentElement).fontSize);
        };
        (0, _vue.onMounted)(handleContainerResize);
        (0, _useResizeObserverJs.u)([
            splitPanelsContainer
        ], handleContainerResize);
        const convertToPercents = (v, type)=>{
            let numberValue = "";
            let measureValue = "";
            if ((0, _vendorJs.e)(v)) return v;
            v.split("").filter((char)=>char && char !== " ").forEach((char)=>{
                !isNaN(+char) ? numberValue += char : measureValue += char;
            });
            switch(measureValue){
                case "%":
                    return +numberValue;
                case "px":
                    return +numberValue / containerSize.value * 100;
                case "rem":
                    return +numberValue * bodyFontSize.value / containerSize.value * 100;
                case "any":
                    return [
                        "min",
                        "snapping"
                    ].includes(type) ? 0 : 100;
                case "":
                    return 100;
                default:
                    (0, _consoleJs.w)("Invalid limits measure!");
                    return 0;
            }
        };
        const getPanelMinMax = (v)=>{
            if (v === "undefined" || !containerSize.value) return;
            let minPercents = 0;
            let maxPercents = 100;
            if ((0, _vendorJs.f)(v) || (0, _vendorJs.e)(v)) minPercents = convertToPercents(v, "min");
            if (Array.isArray(v)) {
                minPercents = convertToPercents(v[0], "min");
                maxPercents = convertToPercents(v[1], "max");
            }
            if (minPercents > maxPercents) {
                (0, _consoleJs.w)(`Min panels size can not be larger than max one! Passed limit: ${v}.`);
                maxPercents = minPercents;
            }
            return {
                min: minPercents ?? 0,
                max: maxPercents ?? 100
            };
        };
        const startPanelMinMax = (0, _vue.computed)(()=>getPanelMinMax(props.limits[0]) ?? {
                min: 0,
                max: 100
            });
        const endPanelMinMax = (0, _vue.computed)(()=>getPanelMinMax(props.limits[1]) ?? {
                min: 0,
                max: 100
            });
        const endPanelMinChecked = (0, _vue.computed)(()=>{
            const passedCheck = !(startPanelMinMax.value.min + endPanelMinMax.value.min > 100);
            if (!passedCheck) (0, _consoleJs.w)("The sum of different panels min sizes should be lesser or equal to 100% of the container size!");
            return !passedCheck ? 100 - startPanelMinMax.value.min : endPanelMinMax.value.min;
        });
        const panelsMinMax = (0, _vue.computed)(()=>{
            if (Math.ceil(endPanelMinMax.value.max + startPanelMinMax.value.max) < 100) (0, _consoleJs.w)("The sum of different panels max sizes should be equal to 100% of the container size!");
            return {
                start: {
                    min: startPanelMinMax.value.min,
                    max: Math.min(startPanelMinMax.value.max, 100 - endPanelMinChecked.value)
                },
                end: {
                    min: endPanelMinChecked.value,
                    max: Math.min(endPanelMinMax.value.max, 100 - startPanelMinMax.value.min)
                }
            };
        });
        const checkSnappingLimitsCondition = (el)=>el >= panelsMinMax.value.start.min && el >= panelsMinMax.value.end.min && el <= panelsMinMax.value.start.max && el <= panelsMinMax.value.end.max;
        const snappingMarksPosition = (0, _vue.computed)(()=>{
            if (!Array.isArray(props.snapping) || !containerSize.value) return;
            let result = props.snapping.map((el)=>convertToPercents(el, "snapping"));
            if (!result.every(checkSnappingLimitsCondition)) {
                const filteredMarks = result.filter(checkSnappingLimitsCondition);
                (0, _consoleJs.w)(`Some of the snapping marks (${result}) are not in allowed range (${Object.values(panelsMinMax.value.start).join("-")} / ${Object.values(panelsMinMax.value.end).join("-")}) and will be removed (${filteredMarks})!`);
                result = filteredMarks;
            }
            const checkSnappingRange = ()=>{
                return result.every((el, index, array)=>{
                    if (!array[index + 1]) return true;
                    return Math.abs(el - array[index + 1]) > Number(props.snappingRange);
                });
            };
            if (!checkSnappingRange()) (0, _consoleJs.w)("Distance between some snapping marks is lesser than snapping range!");
            return result;
        });
        const snappingRangeParsed = (0, _vue.computed)(()=>convertToPercents(props.snappingRange, "snapping"));
        const splitterPosition = (0, _vue.ref)(valueComputed.value);
        const splitterPositionComputed = (0, _vue.computed)(()=>{
            if (snappingMarksPosition.value) {
                const nearestSnappingMark = snappingMarksPosition.value.find((el)=>{
                    return splitterPosition.value + snappingRangeParsed.value > el && splitterPosition.value - snappingRangeParsed.value < el;
                });
                if (nearestSnappingMark) return nearestSnappingMark;
            }
            return (0, _vendorJs.b)(splitterPosition.value, Math.max(panelsMinMax.value.start.min, 100 - panelsMinMax.value.end.max), Math.min(panelsMinMax.value.start.max, 100 - panelsMinMax.value.end.min));
        });
        const { isDragging, startDragging, currentSplitterPosition } = (0, _useSplitDraggerJs.a)(containerSize, splitterPositionComputed, props);
        const maximizePanel = ()=>{
            if (!props.maximization || props.disabled) return;
            splitterPosition.value = props.maximizeStart ? panelsMinMax.value.start.max : 100 - panelsMinMax.value.end.max;
        };
        (0, _vue.watch)(valueComputed, (v)=>{
            if (v < panelsMinMax.value.start.min || v > 100 - panelsMinMax.value.end.min) (0, _consoleJs.w)("Incorrect `modelValue`. Check current `limits` prop value.");
            splitterPosition.value = v;
        }, {
            immediate: true
        });
        (0, _vue.watch)(currentSplitterPosition, (v)=>{
            splitterPosition.value = v;
        });
        (0, _vue.watch)(isDragging, (v)=>{
            if (!v) valueComputed.value = splitterPositionComputed.value;
            document.documentElement.style.cursor = v ? "var(--va-split-dragging-cursor)" : "";
        });
        const sizePropertyComputed = (0, _vue.computed)(()=>props.vertical ? "height" : "width");
        const getPanelStyle = (position)=>{
            let sizeValue = position === "start" ? splitterPositionComputed.value : 100 - splitterPositionComputed.value;
            if (sizeValue < 0) sizeValue = 0;
            if (sizeValue > 100) sizeValue = 100;
            return {
                [sizePropertyComputed.value]: `${sizeValue}%`
            };
        };
        const draggerStyleComputed = (0, _vue.computed)(()=>{
            if (props.disabled) return {};
            if (isDragging.value) return {
                cursor: "var(--va-split-dragging-cursor)"
            };
            return {
                cursor: props.vertical ? "var(--va-split-vertical-dragger-cursor)" : "var(--va-split-horizontal-dragger-cursor)"
            };
        });
        const classComputed = (0, _useBemJs.u)("va-split", ()=>({
                horizontal: !props.vertical,
                vertical: props.vertical,
                dragging: isDragging.value
            }));
        const { t, tp } = (0, _useTranslationJs.u)();
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("section", {
                ref_key: "splitPanelsContainer",
                ref: splitPanelsContainer,
                class: (0, _vue.normalizeClass)([
                    "va-split",
                    (0, _vue.unref)(classComputed)
                ]),
                "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaLabel)
            }, [
                (0, _vue.createElementVNode)("div", {
                    class: "va-split__panel",
                    style: (0, _vue.normalizeStyle)(getPanelStyle("start"))
                }, [
                    (0, _vue.renderSlot)(_ctx.$slots, "start", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                        containerSize: containerSize.value
                    })))
                ], 4),
                (0, _vue.createElementVNode)("div", _hoisted_2, [
                    (0, _vue.createElementVNode)("div", {
                        class: "va-split__dragger__overlay",
                        style: (0, _vue.normalizeStyle)(draggerStyleComputed.value),
                        onMousedown: _cache[0] || (_cache[0] = (0, _vue.withModifiers)(//@ts-ignore
                        (...args)=>(0, _vue.unref)(startDragging) && (0, _vue.unref)(startDragging)(...args), [
                            "prevent"
                        ])),
                        onTouchstart: _cache[1] || (_cache[1] = (0, _vue.withModifiers)(//@ts-ignore
                        (...args)=>(0, _vue.unref)(startDragging) && (0, _vue.unref)(startDragging)(...args), [
                            "prevent"
                        ])),
                        onDblclick: (0, _vue.withModifiers)(maximizePanel, [
                            "prevent"
                        ]),
                        onContextmenu: _cache[2] || (_cache[2] = (0, _vue.withModifiers)(()=>{}, [
                            "prevent"
                        ])),
                        onDragstart: _cache[3] || (_cache[3] = (0, _vue.withModifiers)(()=>{}, [
                            "prevent"
                        ]))
                    }, [
                        (0, _vue.renderSlot)(_ctx.$slots, "grabber", {}, ()=>[
                                (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs.V)), {
                                    class: "va-split__dragger__default",
                                    vertical: !_ctx.$props.vertical
                                }, null, 8, [
                                    "vertical"
                                ])
                            ])
                    ], 36)
                ]),
                (0, _vue.createElementVNode)("div", {
                    class: "va-split__panel",
                    style: (0, _vue.normalizeStyle)(getPanelStyle("end"))
                }, [
                    (0, _vue.renderSlot)(_ctx.$slots, "end", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                        containerSize: containerSize.value
                    })))
                ], 4)
            ], 10, _hoisted_1);
        };
    }
});

},{"vue":"gzxs9","../../../vendor.js":"l6TAc","./useSplitDragger.js":"1Ycds","../../utils/console.js":"58L6z","../va-divider/index.js":"wiQvd","../../composables/useComponentPreset.js":"2HoaT","../../composables/useStateful.js":"h9zUi","../../composables/useResizeObserver.js":"4ylh3","../../composables/useBem.js":"igmjV","../../composables/useTranslation.js":"7S3aV","../../../VaSplit.css":"8In5s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Ycds":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useSplitDragger);
parcelHelpers.export(exports, "u", ()=>useSplitDraggerProps);
var _vue = require("vue");
var _useEventJs = require("../../composables/useEvent.js");
const useSplitDraggerProps = {
    vertical: {
        type: Boolean,
        default: false
    },
    disabled: {
        type: Boolean,
        default: false
    }
};
const useSplitDragger = (containerSizeComputed, splitterPositionComputed, props)=>{
    const isDragging = (0, _vue.ref)(false);
    const dragStartPosition = (0, _vue.ref)(0);
    const dragStartSplitterPosition = (0, _vue.ref)(0);
    const currentSplitterPosition = (0, _vue.ref)(0);
    const getEventPosition = (e, eventName)=>{
        const event = e.type === eventName ? e : e.changedTouches[0];
        return props.vertical ? event.pageY : event.pageX;
    };
    const startDragging = (e)=>{
        if (props.disabled || !containerSizeComputed.value) return;
        isDragging.value = true;
        dragStartPosition.value = getEventPosition(e, "mousedown");
        dragStartSplitterPosition.value = splitterPositionComputed.value;
    };
    const processDragging = (e)=>{
        if (!isDragging.value) return;
        const currentPosition = getEventPosition(e, "mousemove");
        const distance = currentPosition - dragStartPosition.value;
        currentSplitterPosition.value = dragStartSplitterPosition.value + Math.floor(distance / containerSizeComputed.value * 100);
    };
    const stopDragging = ()=>{
        isDragging.value = false;
    };
    (0, _useEventJs.u)([
        "mousemove",
        "touchmove"
    ], processDragging);
    (0, _useEventJs.u)([
        "mouseup",
        "touchcancel"
    ], stopDragging);
    return {
        isDragging,
        startDragging,
        currentSplitterPosition
    };
};

},{"vue":"gzxs9","../../composables/useEvent.js":"9kzUn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8In5s":[function() {},{}],"6zoJR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaTabs);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaTabsVueVueTypeScriptSetupTrueLangJs = require("./VaTabs.vue_vue_type_script_setup_true_lang.js");
const VaTabs = (0, _withConfigTransportJs.w)((0, _vaTabsVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaTabs.vue_vue_type_script_setup_true_lang.js":"8AkMh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8AkMh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _typesJs = require("./types.js");
var _indexJs = require("../va-button/index.js");
var _vaConfigVueVueTypeScriptSetupTrueLangJs = require("../va-config/VaConfig.vue_vue_type_script_setup_true_lang.js");
var _useStatefulJs = require("../../composables/useStateful.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useTranslationJs = require("../../composables/useTranslation.js");
var _useColorsJs = require("../../composables/useColors.js");
var _useResizeObserverJs = require("../../composables/useResizeObserver.js");
var _vaTabsCss = require("../../../VaTabs.css");
const _hoisted_1 = [
    "aria-disabled"
];
const _hoisted_2 = /* @__PURE__ */ (0, _vue.createElementVNode)("div", {
    class: "va-tabs__slider"
}, null, -1);
const _hoisted_3 = [
    _hoisted_2
];
const _hoisted_4 = {
    class: "va-tabs__tabs-items"
};
const _hoisted_5 = {
    class: "va-tabs__content"
};
const getClientWidth = (element)=>(element == null ? void 0 : element.clientWidth) || 0;
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaTabs",
    __name: "VaTabs",
    props: {
        ...(0, _useStatefulJs.u),
        ...(0, _useComponentPresetJs.u),
        modelValue: {
            type: [
                String,
                Number
            ],
            default: null
        },
        left: {
            type: Boolean,
            default: true
        },
        right: {
            type: Boolean,
            default: false
        },
        center: {
            type: Boolean,
            default: false
        },
        grow: {
            type: Boolean,
            default: false
        },
        hidePagination: {
            type: Boolean,
            default: false
        },
        disabled: {
            type: Boolean,
            default: false
        },
        hideSlider: {
            type: Boolean,
            default: false
        },
        vertical: {
            type: Boolean,
            default: false
        },
        color: {
            type: String,
            default: "primary"
        },
        prevIcon: {
            type: String,
            default: "va-arrow-left"
        },
        nextIcon: {
            type: String,
            default: "va-arrow-right"
        },
        ariaMoveRightLabel: {
            type: String,
            default: "$t:movePaginationLeft"
        },
        ariaMoveLeftLabel: {
            type: String,
            default: "$t:movePaginationRight"
        }
    },
    emits: [
        "update:modelValue",
        "click:next",
        "click:prev"
    ],
    setup (__props, { expose: __expose, emit: __emit }) {
        const { tp } = (0, _useTranslationJs.u)();
        const props = __props;
        const emit = __emit;
        const wrapper = (0, _vue.shallowRef)();
        const container = (0, _vue.shallowRef)();
        const tabs = (0, _vue.shallowRef)();
        const tabsList = (0, _vue.ref)([]);
        const sliderHeight = (0, _vue.ref)(null);
        const sliderWidth = (0, _vue.ref)(null);
        const sliderOffsetX = (0, _vue.ref)(0);
        const sliderOffsetY = (0, _vue.ref)(0);
        const showPagination = (0, _vue.ref)(false);
        const tabsContentOffset = (0, _vue.ref)(0);
        const startingXPoint = (0, _vue.ref)(0);
        const animationIncluded = (0, _vue.ref)(false);
        const { valueComputed: tabSelected } = (0, _useStatefulJs.b)(props, emit);
        const tabConfig = (0, _vue.reactive)({
            VaTab: {
                color: props.color
            }
        });
        const computedClass = (0, _vue.computed)(()=>{
            const { left, right, center, grow, disabled } = props;
            return {
                "va-tabs__container--left": left && !right && !center && !grow,
                "va-tabs__container--right": right,
                "va-tabs__container--center": center,
                "va-tabs__container--grow": grow,
                "va-tabs__container--disabled": disabled
            };
        });
        const computedTabsClass = (0, _vue.computed)(()=>({
                "va-tabs--vertical": props.vertical
            }));
        const { getColor } = (0, _useColorsJs.u)();
        const colorComputed = (0, _vue.computed)(()=>getColor(props.color));
        const sliderStyles = (0, _vue.computed)(()=>{
            if (props.hideSlider) return {
                display: "none"
            };
            return {
                backgroundColor: colorComputed.value,
                height: props.vertical ? `${sliderHeight.value}px` : "",
                width: props.vertical ? "" : `${sliderWidth.value}px`,
                transform: `translateY(-${sliderOffsetY.value}px) translateX(${sliderOffsetX.value}px)`,
                transition: animationIncluded.value ? "var(--va-tabs-slider-wrapper-transition)" : ""
            };
        });
        const paginationControlledStyles = (0, _vue.computed)(()=>{
            if (props.vertical) return {
                transform: "translateX(0px)"
            };
            return {
                transform: `translateX(${startingXPoint.value - tabsContentOffset.value}px)`,
                transition: animationIncluded.value ? "var(--va-tabs-slider-transition)" : "",
                position: props.hidePagination ? "unset" : "absolute"
            };
        });
        const disablePaginationLeft = (0, _vue.computed)(()=>tabsContentOffset.value === 0);
        const disablePaginationRight = (0, _vue.computed)(()=>{
            const lastTab = tabsList.value[tabsList.value.length - 1];
            const leftSidePosition = (0, _vue.unref)(lastTab.leftSidePosition);
            const rightSidePosition = (0, _vue.unref)(lastTab.rightSidePosition);
            const containerClientWidth = getClientWidth(container.value);
            return rightSidePosition <= tabsContentOffset.value + containerClientWidth || leftSidePosition <= tabsContentOffset.value;
        });
        const resetSliderSizes = ()=>{
            sliderWidth.value = 0;
            sliderHeight.value = 0;
        };
        const moveToTab = (tab)=>{
            const containerClientWidth = getClientWidth(container.value);
            const leftSidePosition = (0, _vue.unref)(tab.leftSidePosition);
            const rightSidePosition = (0, _vue.unref)(tab.rightSidePosition);
            if (!showPagination.value) {
                tabsContentOffset.value = 0;
                return;
            }
            if (leftSidePosition - tabsContentOffset.value >= 0 && rightSidePosition - tabsContentOffset.value <= containerClientWidth) return;
            if (leftSidePosition - tabsContentOffset.value < 0) {
                tabsContentOffset.value = leftSidePosition;
                return;
            }
            if (rightSidePosition - tabsContentOffset.value > containerClientWidth) {
                tabsContentOffset.value = rightSidePosition - containerClientWidth;
                return;
            }
            tabsContentOffset.value = 0;
        };
        const updateStartingXPoint = ()=>{
            startingXPoint.value = 0;
            if (!showPagination.value) return;
            const containerClientWidth = getClientWidth(container.value);
            const tabsClientWidth = getClientWidth(tabs.value);
            if (props.right) startingXPoint.value = tabsClientWidth - containerClientWidth;
            else if (props.center) startingXPoint.value = Math.floor((tabsClientWidth - containerClientWidth) / 2);
        };
        const updateTabsState = ()=>{
            resetSliderSizes();
            tabsList.value.forEach((tab)=>{
                var _a;
                tab.updateSidePositions();
                const isTabSelected = (((_a = tab.name) == null ? void 0 : _a.value) || tab.id) === tabSelected.value;
                tab.isActive = tab.isActiveRouterLink || isTabSelected;
                if (tab.isActive) {
                    moveToTab(tab);
                    updateSlider(tab);
                }
            });
            updateStartingXPoint();
        };
        const updatePagination = ()=>{
            const tabsClientWidth = getClientWidth(tabs.value);
            const wrapperClientWidth = getClientWidth(wrapper.value);
            requestAnimationFrame(()=>{
                showPagination.value = !!(tabs.value && wrapper.value && tabsClientWidth > wrapperClientWidth);
            });
        };
        const movePaginationLeft = ()=>{
            var _a, _b;
            const containerClientWidth = getClientWidth(container.value);
            let offsetToSet = tabsContentOffset.value - containerClientWidth;
            for(let i = 0; i < tabsList.value.length - 1; i++){
                const currentTabLeftSidePosition = (0, _vue.unref)((_a = tabsList.value[i]) == null ? void 0 : _a.leftSidePosition);
                const nextTabLeftSidePosition = (0, _vue.unref)((_b = tabsList.value[i + 1]) == null ? void 0 : _b.leftSidePosition);
                if (currentTabLeftSidePosition > offsetToSet && currentTabLeftSidePosition < tabsContentOffset.value || nextTabLeftSidePosition >= tabsContentOffset.value) {
                    offsetToSet = currentTabLeftSidePosition;
                    break;
                }
            }
            tabsContentOffset.value = Math.max(0, offsetToSet);
            emit("click:prev");
        };
        const movePaginationRight = ()=>{
            var _a;
            const containerClientWidth = getClientWidth(container.value);
            const containerRightSide = tabsContentOffset.value + containerClientWidth;
            let offsetToSet = containerRightSide;
            for(let i = 0; i < tabsList.value.length - 1; i++){
                const rightSidePosition2 = (0, _vue.unref)(tabsList.value[i].rightSidePosition);
                if (rightSidePosition2 > containerRightSide) {
                    offsetToSet = (0, _vue.unref)(tabsList.value[i].leftSidePosition);
                    if (tabsContentOffset.value < offsetToSet) break;
                }
            }
            const rightSidePosition = (0, _vue.unref)((_a = tabsList.value[tabsList.value.length - 1]) == null ? void 0 : _a.rightSidePosition);
            const maxOffset = rightSidePosition - containerClientWidth;
            offsetToSet = Math.min(maxOffset, offsetToSet);
            tabsContentOffset.value = Math.max(0, offsetToSet);
            emit("click:next");
        };
        const updateSlider = (tab)=>{
            var _a;
            const tabElement = (0, _vue.unref)(tab.tabElement);
            const tabOffsetTop = (tabElement == null ? void 0 : tabElement.offsetTop) || 0;
            const tabOffsetLeft = (tabElement == null ? void 0 : tabElement.offsetLeft) || 0;
            const tabClientHeight = (tabElement == null ? void 0 : tabElement.clientHeight) || 0;
            const tabClientWidth = (tabElement == null ? void 0 : tabElement.clientWidth) || 0;
            if (props.vertical) {
                const containerClientHeight = ((_a = container.value) == null ? void 0 : _a.clientHeight) || 0;
                const calculatedSliderOffsetY = containerClientHeight - tabOffsetTop - tabClientHeight;
                sliderOffsetY.value = Math.max(calculatedSliderOffsetY, 0);
                sliderHeight.value = tabClientHeight;
                sliderOffsetX.value = 0;
                sliderWidth.value = 0;
            } else {
                sliderOffsetX.value = tabOffsetLeft;
                sliderWidth.value = tabClientWidth;
                sliderOffsetY.value = 0;
                sliderHeight.value = 0;
            }
        };
        const includeAnimation = ()=>{
            if (!animationIncluded.value) requestAnimationFrame(()=>{
                animationIncluded.value = true;
            });
        };
        const selectTab = (tab)=>{
            var _a;
            if (!tab) return;
            tabSelected.value = ((_a = tab.name) == null ? void 0 : _a.value) || tab.id;
            if (props.stateful) updateTabsState();
        };
        const registerTab = (tab)=>{
            var _a;
            const idx = tabsList.value.push(tab) - 1;
            tab.id = ((_a = tab.name) == null ? void 0 : _a.value) || idx;
        };
        const unregisterTab = (tab)=>{
            tabsList.value = tabsList.value.filter((filteredTab)=>filteredTab.id !== tab.id);
            tabsList.value.forEach((tabListItem, idx)=>{
                var _a;
                tabListItem.id = ((_a = tabListItem.name) == null ? void 0 : _a.value) || idx;
            });
        };
        (0, _vue.provide)((0, _typesJs.T), {
            parentDisabled: props.disabled,
            selectTab,
            moveToTab,
            registerTab,
            unregisterTab
        });
        (0, _vue.watch)(()=>props.modelValue, updateTabsState);
        (0, _useResizeObserverJs.u)([
            wrapper
        ], updatePagination);
        (0, _useResizeObserverJs.u)([
            container
        ], updateTabsState);
        (0, _vue.onMounted)(()=>{
            requestAnimationFrame(()=>{
                includeAnimation();
            });
        });
        __expose({
            selectTab,
            moveToTab,
            movePaginationLeft,
            movePaginationRight
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: (0, _vue.normalizeClass)([
                    "va-tabs",
                    computedTabsClass.value
                ])
            }, [
                (0, _vue.createElementVNode)("div", {
                    ref_key: "wrapper",
                    ref: wrapper,
                    class: "va-tabs__wrapper",
                    role: "tablist",
                    "aria-disabled": _ctx.$props.disabled
                }, [
                    showPagination.value && !_ctx.$props.hidePagination ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), {
                        key: 0,
                        class: "va-tabs__pagination",
                        "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaMoveLeftLabel),
                        size: "medium",
                        disabled: disablePaginationLeft.value,
                        color: __props.color,
                        preset: "secondary",
                        icon: _ctx.$props.prevIcon,
                        onClick: movePaginationLeft
                    }, null, 8, [
                        "aria-label",
                        "disabled",
                        "color",
                        "icon"
                    ])) : (0, _vue.createCommentVNode)("", true),
                    (0, _vue.createElementVNode)("div", {
                        ref_key: "container",
                        ref: container,
                        class: (0, _vue.normalizeClass)([
                            "va-tabs__container",
                            computedClass.value
                        ])
                    }, [
                        (0, _vue.createElementVNode)("div", {
                            ref_key: "tabs",
                            ref: tabs,
                            class: "va-tabs__tabs",
                            style: (0, _vue.normalizeStyle)(paginationControlledStyles.value)
                        }, [
                            (0, _vue.createElementVNode)("div", {
                                class: "va-tabs__slider-wrapper",
                                "aria-hidden": "true",
                                style: (0, _vue.normalizeStyle)(sliderStyles.value)
                            }, _hoisted_3, 4),
                            (0, _vue.createVNode)((0, _vue.unref)((0, _vaConfigVueVueTypeScriptSetupTrueLangJs._)), {
                                components: tabConfig
                            }, {
                                default: (0, _vue.withCtx)(()=>[
                                        (0, _vue.createElementVNode)("div", _hoisted_4, [
                                            (0, _vue.renderSlot)(_ctx.$slots, "tabs")
                                        ])
                                    ]),
                                _: 3
                            }, 8, [
                                "components"
                            ])
                        ], 4)
                    ], 2),
                    showPagination.value && !_ctx.$props.hidePagination ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), {
                        key: 1,
                        class: "va-tabs__pagination",
                        "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaMoveRightLabel),
                        size: "medium",
                        color: __props.color,
                        disabled: disablePaginationRight.value,
                        preset: "secondary",
                        icon: _ctx.$props.nextIcon,
                        onClick: movePaginationRight
                    }, null, 8, [
                        "aria-label",
                        "color",
                        "disabled",
                        "icon"
                    ])) : (0, _vue.createCommentVNode)("", true)
                ], 8, _hoisted_1),
                (0, _vue.createElementVNode)("div", _hoisted_5, [
                    (0, _vue.renderSlot)(_ctx.$slots, "default")
                ])
            ], 2);
        };
    }
});

},{"vue":"gzxs9","./types.js":"a69us","../va-button/index.js":"2vhcC","../va-config/VaConfig.vue_vue_type_script_setup_true_lang.js":"kIv2h","../../composables/useStateful.js":"h9zUi","../../composables/useComponentPreset.js":"2HoaT","../../composables/useTranslation.js":"7S3aV","../../composables/useColors.js":"a4Qgv","../../composables/useResizeObserver.js":"4ylh3","../../../VaTabs.css":"97eWk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a69us":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "T", ()=>TabsViewKey);
const TabsViewKey = Symbol("TabsView");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"97eWk":[function() {},{}],"3xTrP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaTab);
var _withConfigTransportJs = require("../../../../services/config-transport/withConfigTransport.js");
var _vaTabVueVueTypeScriptSetupTrueLangJs = require("./VaTab.vue_vue_type_script_setup_true_lang.js");
const VaTab = (0, _withConfigTransportJs.w)((0, _vaTabVueVueTypeScriptSetupTrueLangJs._));

},{"../../../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaTab.vue_vue_type_script_setup_true_lang.js":"c68fu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c68fu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _typesJs = require("../../types.js");
var _indexJs = require("../../../va-icon/index.js");
var _useRouterLinkJs = require("../../../../composables/useRouterLink.js");
var _useComponentPresetJs = require("../../../../composables/useComponentPreset.js");
var _useKeyboardOnlyFocusJs = require("../../../../composables/useKeyboardOnlyFocus.js");
var _useColorsJs = require("../../../../composables/useColors.js");
var _vaTabCss = require("../../../../../VaTab.css");
const _hoisted_1 = [
    "tabindex"
];
const _hoisted_2 = [
    "textContent"
];
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaTab",
    __name: "VaTab",
    props: {
        ...(0, _useRouterLinkJs.u),
        ...(0, _useComponentPresetJs.u),
        selected: {
            type: Boolean,
            default: false
        },
        color: {
            type: String,
            default: ""
        },
        icon: {
            type: String,
            default: ""
        },
        label: {
            type: String,
            default: ""
        },
        disabled: {
            type: Boolean
        },
        name: {
            type: [
                String,
                Number
            ]
        },
        tag: {
            type: String,
            default: "div"
        }
    },
    emits: [
        "click",
        "keydown-enter",
        "focus"
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const tabElement = (0, _vue.shallowRef)();
        const isActive = (0, _vue.ref)(false);
        const hoverState = (0, _vue.ref)(false);
        const rightSidePosition = (0, _vue.ref)(0);
        const leftSidePosition = (0, _vue.ref)(0);
        const { keyboardFocusListeners, hasKeyboardFocus } = (0, _useKeyboardOnlyFocusJs.u)();
        const { tagComputed, hrefComputed, isActiveRouterLink } = (0, _useRouterLinkJs.a)(props);
        const classComputed = (0, _vue.computed)(()=>({
                "va-tab--disabled": props.disabled
            }));
        const { parentDisabled, selectTab, moveToTab, registerTab, unregisterTab } = (0, _vue.inject)((0, _typesJs.T), {
            parentDisabled: false,
            tabsList: [],
            selectTab: (tab)=>tab,
            moveToTab: (tab)=>tab,
            registerTab: (tab)=>tab,
            unregisterTab: (tab)=>tab
        });
        const tabIndexComputed = (0, _vue.computed)(()=>props.disabled || parentDisabled ? -1 : 0);
        const { getColor } = (0, _useColorsJs.u)();
        const colorComputed = (0, _vue.computed)(()=>getColor(props.color));
        const computedStyle = (0, _vue.computed)(()=>({
                color: hoverState.value || isActive.value ? colorComputed.value : "inherit"
            }));
        const updateHoverState = (isHover)=>{
            hoverState.value = isHover;
        };
        const updateSidePositions = ()=>{
            var _a, _b;
            const componentOffsetLeft = ((_a = tabElement.value) == null ? void 0 : _a.offsetLeft) || 0;
            const componentOffsetWidth = ((_b = tabElement.value) == null ? void 0 : _b.offsetWidth) || 0;
            rightSidePosition.value = componentOffsetLeft + componentOffsetWidth;
            leftSidePosition.value = componentOffsetLeft;
        };
        const onTabClick = ()=>{
            selectTab(tabComponent);
            emit("click");
        };
        const onTabKeydown = ()=>{
            selectTab(tabComponent);
            emit("keydown-enter");
        };
        const onFocus = ()=>{
            if (hasKeyboardFocus.value) moveToTab(tabComponent);
            emit("focus");
        };
        const tabComponent = {
            name: (0, _vue.computed)(()=>props.name),
            id: null,
            tabElement,
            isActive,
            tabIndexComputed,
            isActiveRouterLink,
            rightSidePosition,
            leftSidePosition,
            onTabClick,
            onTabKeydown,
            onFocus,
            updateSidePositions
        };
        (0, _vue.onMounted)(()=>{
            registerTab(tabComponent);
        });
        (0, _vue.onBeforeUnmount)(()=>{
            unregisterTab(tabComponent);
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.resolveDynamicComponent)((0, _vue.unref)(tagComputed)), {
                ref_key: "tabElement",
                ref: tabElement,
                class: (0, _vue.normalizeClass)([
                    "va-tab",
                    classComputed.value
                ]),
                role: "tab",
                "aria-selected": isActive.value,
                "aria-disabled": _ctx.$props.disabled || (0, _vue.unref)(parentDisabled),
                href: (0, _vue.unref)(hrefComputed),
                target: _ctx.target,
                to: _ctx.to,
                replace: _ctx.replace,
                exact: _ctx.exact,
                "active-class": _ctx.activeClass,
                "exact-active-class": _ctx.exactActiveClass,
                style: (0, _vue.normalizeStyle)(computedStyle.value),
                onMouseenter: _cache[0] || (_cache[0] = ($event)=>updateHoverState(true)),
                onMouseleave: _cache[1] || (_cache[1] = ($event)=>updateHoverState(false))
            }, {
                default: (0, _vue.withCtx)(()=>[
                        (0, _vue.createElementVNode)("div", (0, _vue.mergeProps)({
                            class: "va-tab__content",
                            tabindex: tabIndexComputed.value,
                            onFocus,
                            onClick: onTabClick,
                            onKeydown: (0, _vue.withKeys)(onTabKeydown, [
                                "enter"
                            ])
                        }, (0, _vue.toHandlers)((0, _vue.unref)(keyboardFocusListeners), true)), [
                            (0, _vue.renderSlot)(_ctx.$slots, "default", {}, ()=>[
                                    __props.icon ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), {
                                        key: 0,
                                        class: "va-tab__icon",
                                        size: "small",
                                        name: __props.icon
                                    }, null, 8, [
                                        "name"
                                    ])) : (0, _vue.createCommentVNode)("", true),
                                    (0, _vue.createElementVNode)("span", {
                                        class: "va-tab__label",
                                        textContent: (0, _vue.toDisplayString)(__props.label)
                                    }, null, 8, _hoisted_2)
                                ])
                        ], 16, _hoisted_1)
                    ]),
                _: 3
            }, 40, [
                "aria-selected",
                "aria-disabled",
                "href",
                "target",
                "to",
                "replace",
                "exact",
                "active-class",
                "exact-active-class",
                "class",
                "style"
            ]);
        };
    }
});

},{"vue":"gzxs9","../../types.js":"a69us","../../../va-icon/index.js":"82tPo","../../../../composables/useRouterLink.js":"bep51","../../../../composables/useComponentPreset.js":"2HoaT","../../../../composables/useKeyboardOnlyFocus.js":"lKbNJ","../../../../composables/useColors.js":"a4Qgv","../../../../../VaTab.css":"cO0kR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cO0kR":[function() {},{}],"4Z50z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaStepper);
parcelHelpers.export(exports, "d", ()=>defineVaStepperSteps);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaStepperVueVueTypeScriptSetupTrueLangJs = require("./VaStepper.vue_vue_type_script_setup_true_lang.js");
const VaStepper = (0, _withConfigTransportJs.w)((0, _vaStepperVueVueTypeScriptSetupTrueLangJs._));
const defineVaStepperSteps = (steps)=>steps;

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaStepper.vue_vue_type_script_setup_true_lang.js":"3VBgo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3VBgo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vaStepperControlsVueVueTypeScriptSetupTrueLangJs = require("./VaStepperControls.vue_vue_type_script_setup_true_lang.js");
var _vaStepperStepButtonVueVueTypeScriptSetupTrueLangJs = require("./VaStepperStepButton.vue_vue_type_script_setup_true_lang.js");
var _stepJs = require("./step.js");
var _useStatefulJs = require("../../composables/useStateful.js");
var _useColorsJs = require("../../composables/useColors.js");
var _useTranslationJs = require("../../composables/useTranslation.js");
var _vaStepperCss = require("../../../VaStepper.css");
const _hoisted_1 = {
    key: 0,
    class: "va-stepper__step-content"
};
const _hoisted_2 = {
    class: "va-stepper__controls"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaStepper",
    __name: "VaStepper",
    props: {
        ...(0, _useStatefulJs.u),
        modelValue: {
            type: Number,
            default: 0
        },
        steps: {
            type: Array,
            default: ()=>[],
            required: true
        },
        color: {
            type: String,
            default: "primary"
        },
        vertical: {
            type: Boolean,
            default: false
        },
        navigationDisabled: {
            type: Boolean,
            default: false
        },
        controlsHidden: {
            type: Boolean,
            default: false
        },
        nextDisabled: {
            type: Boolean,
            default: false
        },
        nextDisabledOnError: {
            type: Boolean,
            default: false
        },
        finishButtonHidden: {
            type: Boolean,
            default: false
        },
        ariaLabel: {
            type: String,
            default: "$t:progress"
        },
        linear: {
            type: Boolean,
            default: false
        }
    },
    emits: [
        "update:modelValue",
        "finish",
        "update:steps"
    ],
    setup (__props, { expose: __expose, emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const stepperNavigation = (0, _vue.shallowRef)();
        const { valueComputed: modelValue } = (0, _useStatefulJs.b)(props, emit, "modelValue");
        const focusedStep = (0, _vue.ref)({
            trigger: false,
            stepIndex: props.navigationDisabled ? -1 : props.modelValue
        });
        const { getColor } = (0, _useColorsJs.u)();
        const isNextStepDisabled = (index)=>{
            if (props.nextDisabledOnError && (0, _stepJs.i)(props.steps[index])) return true;
            return props.nextDisabled;
        };
        const findFirstNonDisabled = (from, direction)=>{
            while(from >= 0 && from < props.steps.length){
                from += direction;
                const step = props.steps[from];
                if (!step) return;
                if (!step.disabled) return step;
            }
        };
        const findFirstWithErrorIndex = (from, direction)=>{
            while(from >= 0 && from < props.steps.length){
                from += direction;
                const step = props.steps[from];
                if (!step) return;
                if ((0, _stepJs.i)(step) === true) return from;
            }
        };
        const validateMovingToStep = (stepIndex)=>{
            var _a;
            const newStep = props.steps[stepIndex];
            const currentStep = props.steps[modelValue.value];
            const beforeNewStep = findFirstNonDisabled(stepIndex, -1);
            if (newStep.disabled) return false;
            if (props.linear && stepIndex < modelValue.value) return true;
            const nextNonError = findFirstWithErrorIndex(modelValue.value, 1);
            if (props.linear && nextNonError !== void 0 && nextNonError < stepIndex) return false;
            if (((_a = currentStep.beforeLeave) == null ? void 0 : _a.call(currentStep, currentStep, newStep)) === false) return false;
            if (currentStep.completed === void 0) currentStep.completed = true;
            if (props.linear && beforeNewStep && !beforeNewStep.completed) return false;
            if (props.linear && (0, _stepJs.i)(currentStep)) return false;
            return true;
        };
        const setStep = (index)=>{
            if (!validateMovingToStep(index)) return;
            emit("update:modelValue", index);
        };
        const setFocus = (direction)=>{
            if (props.navigationDisabled) return;
            if (direction === "next") setFocusNextStep(1);
            else setFocusPrevStep(1);
        };
        const setFocusNextStep = (idx)=>{
            const newValue = focusedStep.value.stepIndex + idx;
            if (isNextStepDisabled(newValue)) return;
            if (newValue < props.steps.length) {
                if (props.steps[newValue].disabled) {
                    setFocusNextStep(idx + 1);
                    return;
                }
                focusedStep.value.stepIndex = newValue;
                focusedStep.value.trigger = true;
            } else {
                for(let availableIdx = 0; availableIdx < props.steps.length; availableIdx++)if (!props.steps[availableIdx].disabled) {
                    focusedStep.value.stepIndex = availableIdx;
                    focusedStep.value.trigger = true;
                    break;
                }
            }
        };
        const setFocusPrevStep = (idx)=>{
            const newValue = focusedStep.value.stepIndex - idx;
            if (newValue >= 0) {
                if (props.steps[newValue].disabled) {
                    setFocusPrevStep(idx + 1);
                    return;
                }
                focusedStep.value.stepIndex = newValue;
                focusedStep.value.trigger = true;
            } else {
                for(let availableIdx = props.steps.length - 1; availableIdx >= 0; availableIdx--)if (!props.steps[availableIdx].disabled && !isNextStepDisabled(availableIdx)) {
                    focusedStep.value.stepIndex = availableIdx;
                    focusedStep.value.trigger = true;
                    break;
                }
            }
        };
        const resetFocus = ()=>{
            requestAnimationFrame(()=>{
                var _a;
                if (!((_a = stepperNavigation.value) == null ? void 0 : _a.contains(document.activeElement))) {
                    focusedStep.value.stepIndex = props.modelValue;
                    focusedStep.value.trigger = false;
                }
            });
        };
        (0, _vue.watch)(()=>props.modelValue, ()=>{
            focusedStep.value.stepIndex = props.modelValue;
            focusedStep.value.trigger = false;
        });
        const nextStep = (stepsToSkip = 0)=>{
            const targetIndex = modelValue.value + 1 + stepsToSkip;
            if (!props.steps[targetIndex]) return;
            if (props.steps[targetIndex].disabled) nextStep(stepsToSkip + 1);
            setStep(targetIndex);
        };
        const prevStep = (stepsToSkip = 0)=>{
            const targetIndex = modelValue.value - 1 - stepsToSkip;
            if (!props.steps[targetIndex]) return;
            if (props.steps[targetIndex].disabled) prevStep(stepsToSkip + 1);
            setStep(targetIndex);
        };
        const stepControls = {
            setStep,
            nextStep,
            prevStep
        };
        const getIterableSlotData = (step, index)=>({
                ...stepControls,
                focus: focusedStep,
                isActive: props.modelValue === index,
                isCompleted: props.modelValue > index,
                isLastStep: props.steps.length - 1 === index,
                isNextStepDisabled: isNextStepDisabled(index),
                isPrevStepDisabled: index === 0,
                index,
                step,
                hasError: (0, _stepJs.i)(step)
            });
        const { tp } = (0, _useTranslationJs.u)();
        const onArrowKeyPress = (direction)=>{
            setFocus(direction);
        };
        const onValueChange = ()=>{
            focusedStep.value.stepIndex = props.modelValue;
            focusedStep.value.trigger = true;
        };
        const ariaAttributesComputed = (0, _vue.computed)(()=>({
                role: "group",
                "aria-label": tp(props.ariaLabel),
                "aria-orientation": props.vertical ? "vertical" : "horizontal"
            }));
        function getStepperButtonColor(index) {
            return (0, _stepJs.i)(props.steps[index]) ? "danger" : getColor(props.color);
        }
        const completeStep = (shouldCompleteStep)=>{
            const steps = {
                ...props.steps
            };
            if (shouldCompleteStep === true) steps[props.modelValue].hasError = false;
            steps[props.modelValue].completed = shouldCompleteStep ?? true;
            emit("update:steps", steps);
        };
        const setError = (shouldSetError)=>{
            const steps = {
                ...props.steps
            };
            steps[props.modelValue].hasError = shouldSetError ?? true;
            steps[props.modelValue].completed = !shouldSetError;
            emit("update:steps", steps);
        };
        __expose({
            modelValue,
            focusedStep,
            getIterableSlotData,
            stepControls,
            nextStep,
            prevStep,
            setStep,
            setFocus,
            completeStep,
            setError
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", (0, _vue.mergeProps)({
                class: [
                    "va-stepper",
                    {
                        "va-stepper--vertical": _ctx.$props.vertical
                    }
                ]
            }, ariaAttributesComputed.value), [
                (0, _vue.createElementVNode)("ol", {
                    class: (0, _vue.normalizeClass)([
                        "va-stepper__navigation",
                        {
                            "va-stepper__navigation--vertical": _ctx.$props.vertical
                        }
                    ]),
                    ref_key: "stepperNavigation",
                    ref: stepperNavigation,
                    onClick: onValueChange,
                    onKeyup: [
                        (0, _vue.withKeys)(onValueChange, [
                            "enter"
                        ]),
                        (0, _vue.withKeys)(onValueChange, [
                            "space"
                        ]),
                        _cache[0] || (_cache[0] = (0, _vue.withKeys)(($event)=>onArrowKeyPress("prev"), [
                            "left"
                        ])),
                        _cache[1] || (_cache[1] = (0, _vue.withKeys)(($event)=>onArrowKeyPress("next"), [
                            "right"
                        ]))
                    ],
                    onFocusout: resetFocus
                }, [
                    ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)(_ctx.$props.steps, (step, i)=>{
                        return (0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                            key: i + step.label
                        }, [
                            i > 0 ? (0, _vue.renderSlot)(_ctx.$slots, "divider", (0, _vue.normalizeProps)((0, _vue.mergeProps)({
                                key: 0
                            }, getIterableSlotData(step, i))), ()=>[
                                    (0, _vue.createElementVNode)("span", {
                                        class: (0, _vue.normalizeClass)([
                                            "va-stepper__divider",
                                            {
                                                "va-stepper__divider--vertical": _ctx.$props.vertical
                                            }
                                        ]),
                                        "aria-hidden": "true"
                                    }, null, 2)
                                ]) : (0, _vue.createCommentVNode)("", true),
                            (0, _vue.renderSlot)(_ctx.$slots, `step-button-${i}`, (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(getIterableSlotData(step, i))), ()=>[
                                    (0, _vue.createVNode)((0, _vaStepperStepButtonVueVueTypeScriptSetupTrueLangJs._), {
                                        stepIndex: i,
                                        color: getStepperButtonColor(i),
                                        modelValue: (0, _vue.unref)(modelValue),
                                        nextDisabled: __props.nextDisabled,
                                        step,
                                        stepControls,
                                        navigationDisabled: __props.navigationDisabled,
                                        focus: focusedStep.value
                                    }, null, 8, [
                                        "stepIndex",
                                        "color",
                                        "modelValue",
                                        "nextDisabled",
                                        "step",
                                        "navigationDisabled",
                                        "focus"
                                    ])
                                ])
                        ], 64);
                    }), 128))
                ], 34),
                (0, _vue.createElementVNode)("div", {
                    class: (0, _vue.normalizeClass)([
                        "va-stepper__step-content-wrapper",
                        {
                            "va-stepper__step-content-wrapper--vertical": _ctx.$props.vertical
                        }
                    ])
                }, [
                    ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)(_ctx.$props.steps, (step, i)=>{
                        return (0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                            key: i
                        }, [
                            _ctx.$slots[`step-content-${i}`] && (0, _vue.unref)(modelValue) === i ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_1, [
                                (0, _vue.renderSlot)(_ctx.$slots, `step-content-${i}`, (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(getIterableSlotData(step, i))))
                            ])) : (0, _vue.createCommentVNode)("", true)
                        ], 64);
                    }), 128)),
                    (0, _vue.createElementVNode)("div", _hoisted_2, [
                        (0, _vue.renderSlot)(_ctx.$slots, "controls", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(getIterableSlotData(__props.steps[(0, _vue.unref)(modelValue)], (0, _vue.unref)(modelValue)))), ()=>[
                                !__props.controlsHidden ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vaStepperControlsVueVueTypeScriptSetupTrueLangJs._), {
                                    key: 0,
                                    modelValue: (0, _vue.unref)(modelValue),
                                    nextDisabled: isNextStepDisabled((0, _vue.unref)(modelValue)),
                                    steps: __props.steps,
                                    stepControls,
                                    finishButtonHidden: __props.finishButtonHidden,
                                    onFinish: _cache[2] || (_cache[2] = ($event)=>_ctx.$emit("finish"))
                                }, null, 8, [
                                    "modelValue",
                                    "nextDisabled",
                                    "steps",
                                    "finishButtonHidden"
                                ])) : (0, _vue.createCommentVNode)("", true)
                            ])
                    ])
                ], 2)
            ], 16);
        };
    }
});

},{"vue":"gzxs9","./VaStepperControls.vue_vue_type_script_setup_true_lang.js":"69zEq","./VaStepperStepButton.vue_vue_type_script_setup_true_lang.js":"h07vV","./step.js":"aMovt","../../composables/useStateful.js":"h9zUi","../../composables/useColors.js":"a4Qgv","../../composables/useTranslation.js":"7S3aV","../../../VaStepper.css":"h04Zm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"69zEq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useTranslationJs = require("../../composables/useTranslation.js");
var _indexJs = require("../va-button/index.js");
var _vaStepperControlsCss = require("../../../VaStepperControls.css");
const _hoisted_1 = {
    class: "va-stepper__default-controls"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaStepperControls",
    __name: "VaStepperControls",
    props: {
        modelValue: {
            type: [
                Number,
                String
            ],
            required: true
        },
        steps: {
            type: Array,
            required: true
        },
        nextDisabled: {
            type: Boolean,
            required: true
        },
        stepControls: {
            type: Object,
            required: true
        },
        finishButtonHidden: {
            type: Boolean,
            default: false
        }
    },
    setup (__props) {
        const props = __props;
        const { t } = (0, _useTranslationJs.u)();
        const isLastStep = (0, _vue.computed)(()=>{
            const lastEnabledStepIndex = props.steps.length - 1;
            return Number(props.modelValue) >= lastEnabledStepIndex;
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_1, [
                (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs.V)), {
                    preset: "primary",
                    disabled: Number(_ctx.$props.modelValue) <= 0,
                    onClick: _cache[0] || (_cache[0] = ($event)=>_ctx.$props.stepControls.prevStep())
                }, {
                    default: (0, _vue.withCtx)(()=>[
                            (0, _vue.createTextVNode)((0, _vue.toDisplayString)((0, _vue.unref)(t)("back")), 1)
                        ]),
                    _: 1
                }, 8, [
                    "disabled"
                ]),
                !isLastStep.value ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), {
                    key: 0,
                    onClick: _cache[1] || (_cache[1] = ($event)=>_ctx.$props.stepControls.nextStep()),
                    disabled: _ctx.$props.nextDisabled
                }, {
                    default: (0, _vue.withCtx)(()=>[
                            (0, _vue.createTextVNode)((0, _vue.toDisplayString)((0, _vue.unref)(t)("next")), 1)
                        ]),
                    _: 1
                }, 8, [
                    "disabled"
                ])) : !_ctx.$props.finishButtonHidden ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), {
                    key: 1,
                    onClick: _cache[2] || (_cache[2] = ($event)=>_ctx.$emit("finish"))
                }, {
                    default: (0, _vue.withCtx)(()=>[
                            (0, _vue.createTextVNode)((0, _vue.toDisplayString)((0, _vue.unref)(t)("finish")), 1)
                        ]),
                    _: 1
                })) : (0, _vue.createCommentVNode)("", true)
            ]);
        };
    }
});

},{"vue":"gzxs9","../../composables/useTranslation.js":"7S3aV","../va-button/index.js":"2vhcC","../../../VaStepperControls.css":"8RTpU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8RTpU":[function() {},{}],"h07vV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _indexJs = require("../va-icon/index.js");
var _stepJs = require("./step.js");
var _useColorsJs = require("../../composables/useColors.js");
var _useTranslationJs = require("../../composables/useTranslation.js");
var _useBemJs = require("../../composables/useBem.js");
var _vaStepperStepButtonCss = require("../../../VaStepperStepButton.css");
const _hoisted_1 = {
    class: "va-stepper__step-button__icon"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaStepperStepButton",
    __name: "VaStepperStepButton",
    props: {
        modelValue: {
            type: Number,
            required: true
        },
        step: {
            type: Object,
            required: true
        },
        color: {
            type: String,
            required: true
        },
        stepIndex: {
            type: Number,
            required: true
        },
        navigationDisabled: {
            type: Boolean,
            required: true
        },
        nextDisabled: {
            type: Boolean,
            required: true
        },
        focus: {
            type: Object,
            required: true
        },
        stepControls: {
            type: Object,
            required: true
        }
    },
    emits: [
        "update:modelValue"
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const stepElement = (0, _vue.shallowRef)();
        const hasError = (0, _vue.computed)(()=>(0, _stepJs.i)(props.step));
        const displayError = (0, _vue.computed)(()=>hasError.value && props.modelValue === props.stepIndex);
        const { getColor } = (0, _useColorsJs.u)();
        const stepperColor = (0, _vue.computed)(()=>getColor(hasError.value ? "danger" : props.color));
        const isNextStepDisabled = (index)=>props.nextDisabled && index > props.modelValue;
        const { t } = (0, _useTranslationJs.u)();
        const computedClass = (0, _useBemJs.u)("va-stepper__step-button", ()=>({
                active: props.modelValue >= props.stepIndex,
                disabled: props.step.disabled || isNextStepDisabled(props.stepIndex),
                "navigation-disabled": props.navigationDisabled,
                error: displayError.value
            }));
        (0, _vue.watch)(()=>props.focus, ()=>{
            if (props.focus.trigger) (0, _vue.nextTick)(()=>{
                var _a;
                return (_a = stepElement.value) == null ? void 0 : _a.focus();
            });
        }, {
            deep: true
        });
        const ariaAttributesComputed = (0, _vue.computed)(()=>({
                tabindex: props.focus.stepIndex === props.stepIndex && !props.navigationDisabled ? 0 : void 0,
                "aria-disabled": props.step.disabled || isNextStepDisabled(props.stepIndex) ? true : void 0,
                "aria-current": props.modelValue === props.stepIndex ? t("step") : void 0
            }));
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("li", (0, _vue.mergeProps)({
                ref_key: "stepElement",
                ref: stepElement,
                class: [
                    "va-stepper__step-button",
                    (0, _vue.unref)(computedClass)
                ],
                onClick: _cache[0] || (_cache[0] = ($event)=>!_ctx.$props.navigationDisabled && _ctx.$props.stepControls.setStep(_ctx.$props.stepIndex)),
                onKeyup: [
                    _cache[1] || (_cache[1] = (0, _vue.withKeys)(($event)=>!_ctx.$props.navigationDisabled && _ctx.$props.stepControls.setStep(_ctx.$props.stepIndex), [
                        "enter"
                    ])),
                    _cache[2] || (_cache[2] = (0, _vue.withKeys)(($event)=>!_ctx.$props.navigationDisabled && _ctx.$props.stepControls.setStep(_ctx.$props.stepIndex), [
                        "space"
                    ]))
                ]
            }, ariaAttributesComputed.value, {
                style: `--va-stepper-color: ${String(stepperColor.value)}`
            }), [
                (0, _vue.createElementVNode)("div", _hoisted_1, [
                    __props.step.icon ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), {
                        key: 0,
                        name: __props.step.icon,
                        size: "1.3rem"
                    }, null, 8, [
                        "name"
                    ])) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                        key: 1
                    }, [
                        (0, _vue.createTextVNode)((0, _vue.toDisplayString)(_ctx.$props.stepIndex + 1), 1)
                    ], 64))
                ]),
                (0, _vue.createTextVNode)(" " + (0, _vue.toDisplayString)(__props.step.label), 1)
            ], 16);
        };
    }
});

},{"vue":"gzxs9","../va-icon/index.js":"82tPo","./step.js":"aMovt","../../composables/useColors.js":"a4Qgv","../../composables/useTranslation.js":"7S3aV","../../composables/useBem.js":"igmjV","../../../VaStepperStepButton.css":"7dSli","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aMovt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "i", ()=>isStepHasError);
var _unFunctionJs = require("../../utils/un-function.js");
const isStepHasError = (step)=>{
    return (0, _unFunctionJs.u)(step.hasError, step) || false;
};

},{"../../utils/un-function.js":"1FlZo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1FlZo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>unFunction);
const unFunction = (fn, ...args)=>{
    if (typeof fn === "function") return fn(...args);
    return fn;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7dSli":[function() {},{}],"h04Zm":[function() {},{}],"jofdb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaTimeInput);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaTimeInputVueVueTypeScriptSetupTrueLangJs = require("./VaTimeInput.vue_vue_type_script_setup_true_lang.js");
const VaTimeInput = (0, _withConfigTransportJs.w)((0, _vaTimeInputVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaTimeInput.vue_vue_type_script_setup_true_lang.js":"7jhxu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7jhxu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _timeTextParserJs = require("./hooks/time-text-parser.js");
var _timeTextFormatterJs = require("./hooks/time-text-formatter.js");
var _indexJs = require("../va-input-wrapper/index.js");
var _indexJs1 = require("../va-icon/index.js");
var _indexJs2 = require("../va-dropdown/index.js");
var _vaTimePickerVueVueTypeScriptSetupTrueLangJs = require("../va-time-picker/VaTimePicker.vue_vue_type_script_setup_true_lang.js");
var _useLongPresKeyJs = require("../../composables/useLongPresKey.js");
var _indexJs3 = require("../va-dropdown/components/VaDropdownContent/index.js");
var _extractComponentOptionsJs = require("../../utils/component-options/extract-component-options.js");
var _useDropdownableJs = require("../../composables/useDropdownable.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useClearableJs = require("../../composables/useClearable.js");
var _useValidationJs = require("../../composables/useValidation.js");
var _useStatefulJs = require("../../composables/useStateful.js");
var _useFocusJs = require("../../composables/useFocus.js");
var _filterPropsJs = require("../../utils/component-options/filter-props.js");
var _useTranslationJs = require("../../composables/useTranslation.js");
const VaInputWrapperProps = (0, _extractComponentOptionsJs.e)((0, _indexJs.V), [
    "focused",
    "maxLength",
    "counterValue"
]);
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaTimeInput",
    inheritAttrs: false,
    __name: "VaTimeInput",
    props: {
        ...VaInputWrapperProps,
        ...(0, _useDropdownableJs.u),
        ...(0, _useComponentPresetJs.u),
        ...(0, _useClearableJs.u),
        ...(0, _extractComponentOptionsJs.e)((0, _vaTimePickerVueVueTypeScriptSetupTrueLangJs._)),
        ...(0, _useValidationJs.b),
        ...(0, _useStatefulJs.u),
        closeOnContentClick: {
            type: Boolean,
            default: false
        },
        offset: {
            ...(0, _useDropdownableJs.u).offset,
            default: ()=>[
                    2,
                    0
                ]
        },
        placement: {
            ...(0, _useDropdownableJs.u).placement,
            default: "bottom-end"
        },
        modelValue: {
            type: Date,
            default: void 0
        },
        clearValue: {
            type: Date,
            default: null
        },
        format: {
            type: Function
        },
        parse: {
            type: Function
        },
        manualInput: {
            type: Boolean,
            default: false
        },
        leftIcon: {
            type: Boolean,
            default: false
        },
        icon: {
            type: String,
            default: "schedule"
        },
        ariaLabel: {
            type: String,
            default: "$t:selectedTime"
        },
        ariaResetLabel: {
            type: String,
            default: "$t:resetTime"
        },
        ariaToggleDropdownLabel: {
            type: String,
            default: "$t:toggleDropdown"
        }
    },
    emits: [
        ...(0, _useFocusJs.a),
        ...(0, _useValidationJs.u),
        ...(0, _useClearableJs.a),
        ...(0, _useStatefulJs.a),
        ...(0, _useDropdownableJs.a),
        "update:modelValue"
    ],
    setup (__props, { expose: __expose, emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const input = (0, _vue.shallowRef)();
        const timePicker = (0, _vue.shallowRef)();
        const { isOpenSync, dropdownProps } = (0, _useDropdownableJs.b)(props, emit, {
            defaultCloseOnValueUpdate: (0, _vue.computed)(()=>Array.isArray(props.view) && props.view.length === 1)
        });
        const { valueComputed } = (0, _useStatefulJs.b)(props, emit);
        const { parse, isValid } = (0, _timeTextParserJs.u)(props);
        const { format } = (0, _timeTextFormatterJs.u)(props);
        const valueText = (0, _vue.computed)(()=>format(valueComputed.value || props.clearValue));
        const doShowDropdown = (0, _vue.computed)({
            get () {
                if (props.disabled || props.readonly) return false;
                return isOpenSync.value;
            },
            set (v) {
                isOpenSync.value = v;
                if (v) (0, _vue.nextTick)(()=>{
                    var _a;
                    return (_a = timePicker.value) == null ? void 0 : _a.focus();
                });
                else (0, _vue.nextTick)(()=>{
                    var _a;
                    return (_a = input.value) == null ? void 0 : _a.focus();
                });
            }
        });
        const { isFocused, focus, blur, onFocus: focusListener, onBlur: blurListener } = (0, _useFocusJs.u)(input);
        const onInputTextChanged = (e)=>{
            var _a;
            if (props.disabled) return;
            const val = (_a = e.target) == null ? void 0 : _a.value;
            if (!val) return reset();
            const v = parse(val);
            if (isValid.value && v) valueComputed.value = v;
            else {
                valueComputed.value = void 0;
                isValid.value = true;
            }
        };
        const reset = ()=>withoutValidation(()=>{
                emit("update:modelValue", props.clearValue);
                emit("clear");
                resetValidation();
                hideDropdown();
            });
        const { computedError, computedErrorMessages, listeners, validationAriaAttributes, withoutValidation, resetValidation, isDirty } = (0, _useValidationJs.a)(props, emit, {
            reset,
            focus,
            value: valueComputed
        });
        const { canBeCleared, clearIconProps, onFocus, onBlur } = (0, _useClearableJs.b)(props, valueText);
        const canBeClearedComputed = (0, _vue.computed)(()=>canBeCleared.value && valueText.value !== format(props.clearValue));
        const filteredWrapperProps = (0, _filterPropsJs.f)(VaInputWrapperProps);
        const computedInputWrapperProps = (0, _vue.computed)(()=>({
                ...filteredWrapperProps.value,
                focused: isFocused.value,
                error: computedError.value,
                errorMessages: computedErrorMessages.value,
                readonly: props.readonly || !props.manualInput,
                modelValue: valueText.value
            }));
        const viewToNumber = {
            seconds: 1e3,
            minutes: 60000,
            hours: 3600000
        };
        const onKeyPress = (e)=>{
            if (!("key" in e)) return;
            if (e.key === "ArrowDown") {
                valueComputed.value = new Date(Number(valueComputed.value) - viewToNumber[props.view]);
                e.preventDefault();
            }
            if (e.key === "ArrowUp") {
                valueComputed.value = new Date(Number(valueComputed.value) + viewToNumber[props.view]);
                e.preventDefault();
            }
        };
        (0, _useLongPresKeyJs.u)(input, {
            onStart: onKeyPress,
            onUpdate: onKeyPress
        });
        const computedInputListeners = {
            focus: ()=>{
                if (props.disabled) return;
                focusListener();
                if (props.readonly) return;
                onFocus();
            },
            blur: ()=>{
                if (props.disabled) return;
                blurListener();
                if (props.readonly) return;
                onBlur();
                listeners.onBlur();
            }
        };
        const slots = (0, _vue.useSlots)();
        const filteredSlots = (0, _vue.computed)(()=>{
            const slotsWithIcons = [
                props.leftIcon && "prependInner",
                (!props.leftIcon || props.clearable) && "icon"
            ];
            return Object.keys(slots).filter((slot)=>!slotsWithIcons.includes(slot));
        });
        const hideDropdown = ()=>{
            doShowDropdown.value = false;
        };
        const showDropdown = (event, cancel, prevent)=>{
            doShowDropdown.value = true;
        };
        const checkProhibitedDropdownOpening = (e)=>{
            if (isOpenSync.value) return false;
            if (props.disabled || props.readonly) return true;
            if (e === void 0) return false;
            return props.manualInput && (e == null ? void 0 : e.code) !== "Space";
        };
        const toggleDropdown = (event)=>{
            if (checkProhibitedDropdownOpening(event instanceof KeyboardEvent ? event : void 0)) return;
            doShowDropdown.value = !doShowDropdown.value;
        };
        const cursorStyleComputed = (0, _vue.computed)(()=>{
            if (props.disabled) return {};
            if (props.manualInput) return {
                cursor: "text"
            };
            return {
                cursor: "pointer"
            };
        });
        const iconTabindexComputed = (0, _vue.computed)(()=>{
            if (!props.manualInput) return -1;
            return props.disabled || props.readonly ? -1 : 0;
        });
        const iconProps = (0, _vue.computed)(()=>({
                role: "button",
                "aria-hidden": false,
                name: props.icon,
                color: "secondary",
                tabindex: iconTabindexComputed.value
            }));
        const { tp } = (0, _useTranslationJs.u)();
        (0, _vue.useAttrs)();
        const dropdownPropsComputed = (0, _vue.computed)(()=>({
                ...dropdownProps.value,
                innerAnchorSelector: ".va-input-wrapper__field",
                trigger: [
                    "click",
                    "right-click",
                    "space",
                    "enter"
                ]
            }));
        const timePickerProps = (0, _filterPropsJs.f)((0, _extractComponentOptionsJs.e)((0, _vaTimePickerVueVueTypeScriptSetupTrueLangJs._)));
        __expose({
            isFocused,
            isValid,
            value: valueComputed,
            isDirty,
            focus,
            blur,
            reset,
            withoutValidation,
            resetValidation,
            toggleDropdown,
            showDropdown,
            hideDropdown
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs2.V)), (0, _vue.mergeProps)({
                modelValue: doShowDropdown.value,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event)=>doShowDropdown.value = $event),
                class: [
                    "va-time-input",
                    _ctx.$attrs.class
                ],
                style: _ctx.$attrs.style
            }, dropdownPropsComputed.value), {
                anchor: (0, _vue.withCtx)(()=>[
                        (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs.V)), (0, _vue.mergeProps)({
                            class: "va-time-input__anchor",
                            ref_key: "input",
                            ref: input,
                            style: cursorStyleComputed.value
                        }, computedInputWrapperProps.value, (0, _vue.toHandlers)(computedInputListeners), {
                            onChange: onInputTextChanged
                        }), (0, _vue.createSlots)({
                            icon: (0, _vue.withCtx)(()=>[
                                    canBeClearedComputed.value ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs1.V)), (0, _vue.mergeProps)({
                                        key: 0,
                                        class: "va-time-input__clear-button"
                                    }, {
                                        ...iconProps.value,
                                        ...(0, _vue.unref)(clearIconProps)
                                    }, {
                                        "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaResetLabel),
                                        onClick: (0, _vue.withModifiers)(reset, [
                                            "stop"
                                        ]),
                                        onKeydown: [
                                            (0, _vue.withKeys)((0, _vue.withModifiers)(reset, [
                                                "stop"
                                            ]), [
                                                "enter"
                                            ]),
                                            (0, _vue.withKeys)((0, _vue.withModifiers)(reset, [
                                                "stop"
                                            ]), [
                                                "space"
                                            ])
                                        ]
                                    }), null, 16, [
                                        "aria-label",
                                        "onKeydown"
                                    ])) : (0, _vue.createCommentVNode)("", true),
                                    !_ctx.$props.leftIcon && _ctx.$props.icon ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs1.V)), (0, _vue.mergeProps)({
                                        key: 1,
                                        class: "va-time-input__right-button va-time-input__side-button",
                                        "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaToggleDropdownLabel)
                                    }, iconProps.value), null, 16, [
                                        "aria-label"
                                    ])) : (0, _vue.createCommentVNode)("", true)
                                ]),
                            _: 2
                        }, [
                            (0, _vue.renderList)(filteredSlots.value, (name)=>{
                                return {
                                    name,
                                    fn: (0, _vue.withCtx)((slotScope)=>[
                                            (0, _vue.renderSlot)(_ctx.$slots, name, (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                                ...slotScope,
                                                toggleDropdown,
                                                showDropdown,
                                                hideDropdown,
                                                isOpen: (0, _vue.unref)(isOpenSync),
                                                focus: (0, _vue.unref)(focus)
                                            })))
                                        ])
                                };
                            }),
                            _ctx.$slots.prependInner || _ctx.$props.leftIcon ? {
                                name: "prependInner",
                                fn: (0, _vue.withCtx)((slotScope)=>[
                                        (0, _vue.renderSlot)(_ctx.$slots, "prependInner", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                            ...slotScope,
                                            toggleDropdown,
                                            showDropdown,
                                            hideDropdown,
                                            isOpen: (0, _vue.unref)(isOpenSync),
                                            focus: (0, _vue.unref)(focus)
                                        }))),
                                        _ctx.$props.leftIcon ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs1.V)), (0, _vue.mergeProps)({
                                            key: 0,
                                            class: "va-time-input__left-button va-time-input__side-button",
                                            "aria-label": (0, _vue.unref)(tp)(_ctx.$props.ariaToggleDropdownLabel)
                                        }, iconProps.value), null, 16, [
                                            "aria-label"
                                        ])) : (0, _vue.createCommentVNode)("", true)
                                    ]),
                                key: "0"
                            } : void 0
                        ]), 1040, [
                            "style"
                        ])
                    ]),
                default: (0, _vue.withCtx)(()=>[
                        (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs3.V)), {
                            "no-padding": "",
                            onKeydown: [
                                (0, _vue.withKeys)((0, _vue.withModifiers)(hideDropdown, [
                                    "prevent"
                                ]), [
                                    "esc"
                                ]),
                                (0, _vue.withKeys)((0, _vue.withModifiers)(hideDropdown, [
                                    "prevent"
                                ]), [
                                    "enter"
                                ])
                            ]
                        }, {
                            default: (0, _vue.withCtx)(()=>[
                                    (0, _vue.createVNode)((0, _vaTimePickerVueVueTypeScriptSetupTrueLangJs._), (0, _vue.mergeProps)({
                                        ref_key: "timePicker",
                                        ref: timePicker
                                    }, (0, _vue.unref)(timePickerProps), {
                                        modelValue: (0, _vue.unref)(valueComputed),
                                        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event)=>(0, _vue.isRef)(valueComputed) ? valueComputed.value = $event : null)
                                    }), null, 16, [
                                        "modelValue"
                                    ])
                                ]),
                            _: 1
                        }, 8, [
                            "onKeydown"
                        ])
                    ]),
                _: 3
            }, 16, [
                "modelValue",
                "class",
                "style"
            ]);
        };
    }
});

},{"vue":"gzxs9","./hooks/time-text-parser.js":"29RYy","./hooks/time-text-formatter.js":"63Jwx","../va-input-wrapper/index.js":"7MuId","../va-icon/index.js":"82tPo","../va-dropdown/index.js":"2ag98","../va-time-picker/VaTimePicker.vue_vue_type_script_setup_true_lang.js":"hOLT5","../../composables/useLongPresKey.js":"8XwNg","../va-dropdown/components/VaDropdownContent/index.js":"eUpbA","../../utils/component-options/extract-component-options.js":"1ODzH","../../composables/useDropdownable.js":"iz6O5","../../composables/useComponentPreset.js":"2HoaT","../../composables/useClearable.js":"h8vES","../../composables/useValidation.js":"iFHh2","../../composables/useStateful.js":"h9zUi","../../composables/useFocus.js":"8TBqW","../../utils/component-options/filter-props.js":"4HycW","../../composables/useTranslation.js":"7S3aV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"29RYy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useTimeParser);
var _vue = require("vue");
const parse = (text)=>{
    const m = text.match(/[0-9]{1,2}/g);
    if (!m) return [];
    return m.map((s)=>Number(s));
};
const parsePeriod = (text)=>{
    const m = text.match(/pm|am/i);
    if (!m) return null;
    return Number(m[0].toLowerCase() === "pm");
};
const defaultParseDateFunction = (text)=>{
    const d = /* @__PURE__ */ new Date();
    const [h, m, s] = parse(text);
    const period = parsePeriod(text);
    if (!h) return null;
    const is12format = period !== null && h <= 12;
    const isPM = is12format && !!period;
    const fh = is12format ? h === 12 ? 0 : h : h;
    d.setHours(Math.min(fh || 0, is12format ? 12 : 24) + (isPM ? 12 : 0));
    d.setMinutes(Math.min(m || 0, 60));
    d.setSeconds(Math.min(s || 0, 60));
    return d;
};
const useTimeParser = (props)=>{
    const getParseDateFn = ()=>props.parse || defaultParseDateFunction;
    const isValid = (0, _vue.ref)(true);
    const parseDate = (text)=>{
        const parse3 = getParseDateFn();
        const result = parse3(text);
        if (!result) isValid.value = false;
        return result;
    };
    const parse2 = (text)=>{
        isValid.value = true;
        return parseDate(text);
    };
    return {
        parse: parse2,
        isValid
    };
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"63Jwx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useTimeFormatter);
const useTimeFormatter = (props)=>{
    const formatDate = (date)=>{
        if (!date) return "";
        if (props.ampm) return date.toLocaleTimeString("en-US");
        return date.toLocaleTimeString("en-GB");
    };
    const sliceTime = (time, start, end)=>time.split(":").slice(start, end).join(":");
    const formatWithView = (date)=>{
        if (props.view === "seconds") return formatDate(date);
        const [time, period] = formatDate(date).split(" ");
        if (props.view === "minutes") {
            if (!period) return sliceTime(time, 0, 2);
            return [
                sliceTime(time, 0, 2),
                period
            ].join(" ");
        }
        if (props.view === "hours") {
            if (!period) return sliceTime(time, 0, 1);
            return [
                sliceTime(time, 0, 1),
                period
            ].join(" ");
        }
        return "";
    };
    return {
        format: (date)=>props.format ? props.format(date) : formatWithView(date)
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hOLT5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useTimePickerJs = require("./hooks/useTimePicker.js");
var _indexJs = require("./components/VaTimePickerColumn/index.js");
var _useCSSVariablesJs = require("../../composables/useCSSVariables.js");
var _useStatefulJs = require("../../composables/useStateful.js");
var _useFormFieldJs = require("../../composables/useFormField.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _useArrayRefsJs = require("../../composables/useArrayRefs.js");
var _vaTimePickerCss = require("../../../VaTimePicker.css");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaTimePicker",
    __name: "VaTimePicker",
    props: {
        ...(0, _useStatefulJs.u),
        ...(0, _useFormFieldJs.u),
        ...(0, _useComponentPresetJs.u),
        modelValue: {
            type: Date,
            required: false
        },
        ampm: {
            type: Boolean,
            default: false
        },
        hidePeriodSwitch: {
            type: Boolean,
            default: false
        },
        periodUpdatesModelValue: {
            type: Boolean,
            default: true
        },
        // Update model value when switching period automatically
        view: {
            type: String,
            default: "minutes"
        },
        hoursFilter: {
            type: Function
        },
        minutesFilter: {
            type: Function
        },
        secondsFilter: {
            type: Function
        },
        framed: {
            type: Boolean,
            default: false
        },
        cellHeight: {
            type: Number,
            default: 30
        },
        visibleCellsCount: {
            type: Number,
            default: 7
        }
    },
    emits: [
        ...(0, _useStatefulJs.a)
    ],
    setup (__props, { expose: __expose, emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const { valueComputed } = (0, _useStatefulJs.b)(props, emit);
        const { columns, isPM } = (0, _useTimePickerJs.u)(props, valueComputed);
        const { setItemRef, itemRefs: pickers } = (0, _useArrayRefsJs.u)();
        const activeColumnIndex = (0, _vue.ref)();
        const focus = (idx = 0)=>{
            var _a;
            (_a = pickers.value[idx]) == null || _a.focus();
        };
        const blur = (idx)=>{
            var _a;
            idx ? (_a = pickers.value[idx]) == null || _a.blur() : pickers.value.forEach((el)=>el == null ? void 0 : el.blur());
        };
        const { computedClasses: computedFormClasses } = (0, _useFormFieldJs.a)("va-time-picker", props);
        const focusNext = ()=>{
            const nextIndex = ((activeColumnIndex == null ? void 0 : activeColumnIndex.value) || 0) + 1;
            activeColumnIndex.value = nextIndex % columns.value.length;
            focus(activeColumnIndex.value);
        };
        const focusPrev = ()=>{
            const nextIndex = ((activeColumnIndex == null ? void 0 : activeColumnIndex.value) || 0) - 1 + columns.value.length;
            activeColumnIndex.value = nextIndex % columns.value.length;
            focus(activeColumnIndex.value);
        };
        const computedClasses = (0, _vue.computed)(()=>({
                ...computedFormClasses,
                "va-time-picker--framed": props.framed
            }));
        const computedStyles = (0, _useCSSVariablesJs.u)("va-time-picker", ()=>{
            const gapHeight = (props.visibleCellsCount - 1) / 2 * props.cellHeight;
            return {
                height: `${props.cellHeight * props.visibleCellsCount}px`,
                "cell-height": `${props.cellHeight}px`,
                "column-gap-height": `${gapHeight}px`
            };
        });
        __expose({
            focus,
            blur,
            focusNext,
            focusPrev
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: (0, _vue.normalizeClass)([
                    "va-time-picker",
                    computedClasses.value
                ]),
                style: (0, _vue.normalizeStyle)((0, _vue.unref)(computedStyles))
            }, [
                ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)((0, _vue.unref)(columns), (column, idx)=>{
                    return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), {
                        key: idx,
                        ref_for: true,
                        ref: (0, _vue.unref)(setItemRef),
                        items: column.items,
                        tabindex: _ctx.disabled ? -1 : 0,
                        "cell-height": _ctx.$props.cellHeight,
                        activeItemIndex: column.activeItem.value,
                        "onUpdate:activeItemIndex": ($event)=>column.activeItem.value = $event,
                        onKeydown: [
                            _cache[0] || (_cache[0] = (0, _vue.withKeys)((0, _vue.withModifiers)(($event)=>focusNext(), [
                                "stop",
                                "prevent"
                            ]), [
                                "right"
                            ])),
                            _cache[1] || (_cache[1] = (0, _vue.withKeys)((0, _vue.withModifiers)(($event)=>focusNext(), [
                                "exact",
                                "stop",
                                "prevent"
                            ]), [
                                "tab"
                            ])),
                            _cache[2] || (_cache[2] = (0, _vue.withKeys)((0, _vue.withModifiers)(($event)=>focusPrev(), [
                                "stop",
                                "prevent"
                            ]), [
                                "left"
                            ])),
                            _cache[3] || (_cache[3] = (0, _vue.withKeys)((0, _vue.withModifiers)(($event)=>focusPrev(), [
                                "shift",
                                "stop",
                                "prevent"
                            ]), [
                                "tab"
                            ]))
                        ],
                        onFocus: ($event)=>activeColumnIndex.value = idx
                    }, null, 8, [
                        "items",
                        "tabindex",
                        "cell-height",
                        "activeItemIndex",
                        "onUpdate:activeItemIndex",
                        "onFocus"
                    ]);
                }), 128))
            ], 6);
        };
    }
});

},{"vue":"gzxs9","./hooks/useTimePicker.js":"3iLZA","./components/VaTimePickerColumn/index.js":"jZG3k","../../composables/useCSSVariables.js":"heOBZ","../../composables/useStateful.js":"h9zUi","../../composables/useFormField.js":"676Eq","../../composables/useComponentPreset.js":"2HoaT","../../composables/useArrayRefs.js":"jgG1u","../../../VaTimePicker.css":"kYjtL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3iLZA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useTimePicker);
var _vue = require("vue");
const safeModelValue = (m)=>m.value ? m.value : new Date(/* @__PURE__ */ new Date().setHours(0, 0, 0, 0));
const createNumbersArray = (length)=>Array.from(Array(length).keys());
const from24to12 = (h)=>(h === 0 ? 12 : h) - Number(h > 12) * 12;
const from12to24 = (h, isAM = false)=>(h === 12 ? 0 : h) + Number(isAM) * 12;
const createHoursColumn = (props, modelValue, isPM)=>{
    const computedSize = (0, _vue.computed)(()=>props.ampm ? 12 : 24);
    const items = (0, _vue.computed)(()=>{
        let array = createNumbersArray(computedSize.value);
        if (props.hoursFilter) array = array.filter((i)=>props.hoursFilter(props.ampm ? i + 12 * Number(isPM.value) : i));
        return array.map((n)=>{
            return props.ampm ? from24to12(n) : n;
        });
    });
    const activeItem = (0, _vue.computed)({
        get: ()=>{
            if (!modelValue.value) return -1;
            if (props.ampm) {
                const h2 = from24to12(modelValue.value.getHours() - 12 * Number(isPM.value));
                return items.value.findIndex((i)=>i === h2);
            }
            const h = modelValue.value.getHours();
            return items.value.findIndex((i)=>i === h);
        },
        set: (newIndex)=>{
            if (props.readonly) return;
            const hours = props.ampm ? from12to24(items.value[newIndex], isPM.value) : items.value[newIndex];
            modelValue.value = new Date(safeModelValue(modelValue).setHours(hours));
        }
    });
    return (0, _vue.computed)(()=>({
            items: items.value,
            activeItem
        }));
};
const createMinutesColumn = (props, modelValue)=>{
    const items = (0, _vue.computed)(()=>{
        const array = createNumbersArray(60);
        if (!props.minutesFilter) return array;
        return array.filter(props.minutesFilter);
    });
    const activeItem = (0, _vue.computed)({
        get: ()=>{
            if (!modelValue.value) return -1;
            const m = modelValue.value.getMinutes();
            return items.value.findIndex((i)=>i === m);
        },
        set: (newIndex)=>{
            if (props.readonly) return;
            const v = items.value[newIndex];
            modelValue.value = new Date(safeModelValue(modelValue).setMinutes(v));
        }
    });
    return (0, _vue.computed)(()=>({
            items: items.value,
            activeItem
        }));
};
const createSecondsColumn = (props, modelValue)=>{
    const items = (0, _vue.computed)(()=>{
        const array = createNumbersArray(60);
        if (!props.secondsFilter) return array;
        return array.filter(props.secondsFilter);
    });
    const activeItem = (0, _vue.computed)({
        get: ()=>{
            if (!modelValue.value) return -1;
            const s = modelValue.value.getSeconds();
            return items.value.findIndex((i)=>i === s);
        },
        set: (newIndex)=>{
            if (props.readonly) return;
            const v = items.value[newIndex];
            modelValue.value = new Date(safeModelValue(modelValue).setSeconds(v));
        }
    });
    return (0, _vue.computed)(()=>({
            items: items.value,
            activeItem
        }));
};
const createPeriodColumn = (props, modelValue, isPM)=>{
    return (0, _vue.computed)(()=>({
            items: [
                "AM",
                "PM"
            ],
            activeItem: (0, _vue.computed)({
                get: ()=>{
                    if (!modelValue.value) return -1;
                    return Number(isPM.value);
                },
                set: (val)=>{
                    isPM.value = Boolean(val);
                    const h = safeModelValue(modelValue).getHours();
                    let h24 = isPM.value ? h + 12 : h;
                    if (isPM.value && h <= 12) h24 = h + 12;
                    if (!isPM.value && h >= 12) h24 = h - 12;
                    const isValidFilteredHour = !props.hoursFilter || props.hoursFilter(h24);
                    if (props.periodUpdatesModelValue && isValidFilteredHour) modelValue.value = new Date(safeModelValue(modelValue).setHours(h24));
                }
            })
        }));
};
const useTimePicker = (props, modelValue)=>{
    const { view } = (0, _vue.toRefs)(props);
    const isPM = (0, _vue.ref)(false);
    (0, _vue.watch)(modelValue, ()=>{
        isPM.value = safeModelValue(modelValue).getHours() >= 12;
    }, {
        immediate: true
    });
    const hoursColumn = createHoursColumn(props, modelValue, isPM);
    const minutesColumn = createMinutesColumn(props, modelValue);
    const secondsColumn = createSecondsColumn(props, modelValue);
    const periodColumn = createPeriodColumn(props, modelValue, isPM);
    const columns = (0, _vue.computed)(()=>{
        const array = [];
        if (view.value === "hours") array.push(hoursColumn.value);
        else if (view.value === "minutes") array.push(hoursColumn.value, minutesColumn.value);
        else if (view.value === "seconds") array.push(hoursColumn.value, minutesColumn.value, secondsColumn.value);
        if (props.ampm && !props.hidePeriodSwitch) array.push(periodColumn.value);
        return array;
    });
    return {
        columns,
        isPM
    };
};

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jZG3k":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaTimePickerColumn);
var _withConfigTransportJs = require("../../../../services/config-transport/withConfigTransport.js");
var _vaTimePickerColumnVueVueTypeScriptSetupTrueLangJs = require("./VaTimePickerColumn.vue_vue_type_script_setup_true_lang.js");
const VaTimePickerColumn = (0, _withConfigTransportJs.w)((0, _vaTimePickerColumnVueVueTypeScriptSetupTrueLangJs._));

},{"../../../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaTimePickerColumn.vue_vue_type_script_setup_true_lang.js":"4LWdc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4LWdc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vaTimePickerColumnCellVueVueTypeScriptSetupTrueLangJs = require("../VaTimePickerColumnCell.vue_vue_type_script_setup_true_lang.js");
var _vendorJs = require("../../../../../vendor.js");
var _useFocusJs = require("../../../../composables/useFocus.js");
var _useSyncPropJs = require("../../../../composables/useSyncProp.js");
var _vaTimePickerColumnCss = require("../../../../../VaTimePickerColumn.css");
const _hoisted_1 = [
    "onClick"
];
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaTimePickerColumn",
    __name: "VaTimePickerColumn",
    props: {
        items: {
            type: Array,
            default: ()=>[]
        },
        activeItemIndex: {
            type: Number,
            default: 0
        },
        cellHeight: {
            type: Number,
            default: 30
        }
    },
    emits: [
        "item-selected",
        "update:activeItemIndex",
        ...(0, _useFocusJs.a)
    ],
    setup (__props, { expose: __expose, emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const rootElement = (0, _vue.shallowRef)();
        const { focus, blur } = (0, _useFocusJs.u)(rootElement, emit);
        const [syncActiveItemIndex] = (0, _useSyncPropJs.u)("activeItemIndex", props, emit);
        (0, _vue.watch)(syncActiveItemIndex, (newVal)=>{
            scrollTo(newVal);
        });
        (0, _vue.onMounted)(()=>scrollTo(syncActiveItemIndex.value, false));
        const scrollTo = (index, animated = true)=>{
            (0, _vue.nextTick)(()=>{
                var _a, _b;
                (_b = (_a = rootElement.value) == null ? void 0 : _a.scrollTo) == null || _b.call(_a, {
                    behavior: animated ? "smooth" : "auto",
                    top: index * props.cellHeight
                });
            });
        };
        const makeActiveNext = (times)=>{
            syncActiveItemIndex.value = (syncActiveItemIndex.value + (times || 1)) % props.items.length;
            (0, _vue.nextTick)(()=>scrollTo(syncActiveItemIndex.value));
        };
        const makeActivePrev = (times)=>{
            syncActiveItemIndex.value = (syncActiveItemIndex.value - (times || 1) + props.items.length) % props.items.length;
            (0, _vue.nextTick)(()=>scrollTo(syncActiveItemIndex.value));
        };
        const onCellClick = (index)=>{
            syncActiveItemIndex.value = index;
        };
        const formatCell = (n)=>{
            if (!Number.isInteger(n)) return n;
            return Number(n) < 10 ? `0${n}` : `${n}`;
        };
        const getIndex = ()=>{
            const scrollTop = rootElement.value.scrollTop;
            const calculatedIndex = Math.max((scrollTop - scrollTop % props.cellHeight) / props.cellHeight, scrollTop / props.cellHeight);
            if (calculatedIndex >= props.items.length) return props.items.length - 1;
            if (calculatedIndex < 0) return 0;
            if (syncActiveItemIndex.value * props.cellHeight < scrollTop) return Math.ceil(calculatedIndex);
            else if (syncActiveItemIndex.value * props.cellHeight > scrollTop) return Math.floor(calculatedIndex);
            else return Math.round(calculatedIndex);
        };
        const onScroll = (0, _vendorJs.d)(()=>{
            if (rootElement.value && syncActiveItemIndex.value !== -1) syncActiveItemIndex.value = getIndex();
        }, 200);
        __expose({
            focus,
            blur
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                ref_key: "rootElement",
                ref: rootElement,
                tabindex: "0",
                class: "va-time-picker-column",
                onKeydown: [
                    _cache[0] || (_cache[0] = (0, _vue.withKeys)((0, _vue.withModifiers)(($event)=>makeActiveNext(), [
                        "stop",
                        "prevent"
                    ]), [
                        "down"
                    ])),
                    _cache[1] || (_cache[1] = (0, _vue.withKeys)((0, _vue.withModifiers)(($event)=>makeActiveNext(5), [
                        "stop",
                        "prevent"
                    ]), [
                        "space"
                    ])),
                    _cache[2] || (_cache[2] = (0, _vue.withKeys)((0, _vue.withModifiers)(($event)=>makeActivePrev(), [
                        "stop",
                        "prevent"
                    ]), [
                        "up"
                    ]))
                ]
            }, [
                ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)(__props.items, (item, index)=>{
                    return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vaTimePickerColumnCellVueVueTypeScriptSetupTrueLangJs._), {
                        key: item,
                        onScrollPassive: (0, _vue.unref)(onScroll),
                        onTouchmovePassive: (0, _vue.unref)(onScroll),
                        onMousewheelPassive: (0, _vue.unref)(onScroll)
                    }, {
                        default: (0, _vue.withCtx)(()=>[
                                (0, _vue.createElementVNode)("div", {
                                    class: (0, _vue.normalizeClass)([
                                        "va-time-picker-cell",
                                        {
                                            "va-time-picker-cell--active": index === _ctx.$props.activeItemIndex
                                        }
                                    ]),
                                    onClick: ($event)=>onCellClick(index)
                                }, [
                                    (0, _vue.renderSlot)(_ctx.$slots, "cell", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                        item,
                                        index,
                                        activeItemIndex: __props.activeItemIndex,
                                        items: __props.items,
                                        formattedItem: formatCell(item)
                                    })), ()=>[
                                            (0, _vue.createTextVNode)((0, _vue.toDisplayString)(formatCell(item)), 1)
                                        ])
                                ], 10, _hoisted_1)
                            ]),
                        _: 2
                    }, 1032, [
                        "onScrollPassive",
                        "onTouchmovePassive",
                        "onMousewheelPassive"
                    ]);
                }), 128))
            ], 544);
        };
    }
});

},{"vue":"gzxs9","../VaTimePickerColumnCell.vue_vue_type_script_setup_true_lang.js":"chT62","../../../../../vendor.js":"l6TAc","../../../../composables/useFocus.js":"8TBqW","../../../../composables/useSyncProp.js":"3q1sU","../../../../../VaTimePickerColumn.css":"6dFLB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"chT62":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useHoverJs = require("../../../composables/useHover.js");
var _useColorsJs = require("../../../composables/useColors.js");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaTimePickerColumnCell",
    __name: "VaTimePickerColumnCell",
    setup (__props) {
        const { isHovered, onMouseEnter, onMouseLeave } = (0, _useHoverJs.u)();
        const { getTextColor, getColor } = (0, _useColorsJs.u)();
        const styleComputed = (0, _vue.computed)(()=>isHovered.value ? {
                color: getColor(getTextColor(getColor("background-secondary"))),
                background: getColor("background-secondary")
            } : void 0);
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                onMouseenter: _cache[0] || (_cache[0] = (...args)=>(0, _vue.unref)(onMouseEnter) && (0, _vue.unref)(onMouseEnter)(...args)),
                onMouseleave: _cache[1] || (_cache[1] = (...args)=>(0, _vue.unref)(onMouseLeave) && (0, _vue.unref)(onMouseLeave)(...args)),
                style: (0, _vue.normalizeStyle)(styleComputed.value)
            }, [
                (0, _vue.renderSlot)(_ctx.$slots, "default")
            ], 36);
        };
    }
});

},{"vue":"gzxs9","../../../composables/useHover.js":"6F99t","../../../composables/useColors.js":"a4Qgv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6dFLB":[function() {},{}],"heOBZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useCSSVariables);
var _vue = require("vue");
var _vendorJs = require("../../vendor.js");
const useCSSVariables = (prefix, cb)=>{
    return (0, _vue.computed)(()=>Object.entries(cb()).reduce((acc, [key, value])=>{
            acc[`--${prefix}-${(0, _vendorJs.k)(key)}`] = value;
            return acc;
        }, {}));
};

},{"vue":"gzxs9","../../vendor.js":"l6TAc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kYjtL":[function() {},{}],"8XwNg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useLongPressKey);
var _vue = require("vue");
var _useEventJs = require("./useEvent.js");
var _useHTMLElementJs = require("./useHTMLElement.js");
function useLongPressKey(el, options) {
    let timeoutId = -1;
    let intervalId = -1;
    const handleMouseDown = (e)=>{
        var _a;
        (_a = options.onStart) == null || _a.call(options, e);
        clearTimeout(timeoutId);
        timeoutId = setTimeout(()=>{
            intervalId = setInterval(()=>{
                var _a2;
                return (_a2 = options.onUpdate) == null ? void 0 : _a2.call(options, e);
            }, options.interval || 100);
        }, (0, _vue.unref)(options.delay) || 500);
    };
    const handleMouseUp = (e)=>{
        var _a;
        clearTimeout(timeoutId);
        clearInterval(intervalId);
        (_a = options.onEnd) == null || _a.call(options, e);
    };
    const htmlElement = (0, _useHTMLElementJs.u)(el);
    (0, _useEventJs.u)([
        "keydown"
    ], handleMouseDown, htmlElement);
    (0, _useEventJs.u)([
        "keyup",
        "blur"
    ], handleMouseUp, true);
}

},{"vue":"gzxs9","./useEvent.js":"9kzUn","./useHTMLElement.js":"1Yk4Z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jGtdD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaTimeline);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaTimelineJs = require("./VaTimeline.js");
const VaTimeline = (0, _withConfigTransportJs.w)((0, _vaTimelineJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaTimeline.js":"jPLod","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jPLod":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _vaTimelineCss = require("../../../VaTimeline.css");
const VaTimeline_vue_vue_type_style_index_0_lang = "";
const getPropsData = (slot)=>slot == null ? void 0 : slot.props;
const getIsActive = (slot)=>{
    var _a;
    return !!((_a = slot == null ? void 0 : slot.props) == null ? void 0 : _a.active) || false;
};
const isVueFragment = (slot)=>slot.type === (0, _vue.Fragment);
const isEmptyArray = (arr)=>arr && arr.length === 0;
function getSlots(slots) {
    var _a;
    const defaultSlots = (_a = slots.default) == null ? void 0 : _a.call(slots);
    if (!defaultSlots || isEmptyArray(defaultSlots)) return [];
    if (isVueFragment(defaultSlots[0])) return defaultSlots[0].children;
    return defaultSlots;
}
const processSlots = (context)=>{
    const slots = getSlots(context.slots);
    slots.forEach((slot, index)=>{
        if (!getPropsData(slot)) slot.props = {};
        const propsData = getPropsData(slot);
        propsData.vertical = context.props.vertical;
        if (context.props.centered) propsData.inverted = !!(index % 2);
        if (index === 0) propsData.isFirst = true;
        if (index === slots.length - 1) propsData.isLast = true;
        const currentSlotActive = propsData.active;
        if (!currentSlotActive) return;
        if (index === 0) propsData.activePrevious = currentSlotActive;
        if (index === slots.length - 1) propsData.activeNext = currentSlotActive;
        const previousSlotActive = getIsActive(slots[index - 1]);
        if (previousSlotActive) propsData.activePrevious = true;
        const nextSlotActive = getIsActive(slots[index + 1]);
        if (nextSlotActive) propsData.activeNext = true;
    });
    return slots;
};
const COMPONENT_NAME = "va-timeline";
const _sfc_main = {
    name: COMPONENT_NAME,
    props: {
        ...(0, _useComponentPresetJs.u),
        vertical: {
            type: Boolean
        },
        centered: {
            type: Boolean
        },
        alignTop: {
            type: Boolean
        }
    },
    setup (props, { slots }) {
        return ()=>(0, _vue.h)("div", {
                class: {
                    [COMPONENT_NAME]: true,
                    [`${COMPONENT_NAME}--vertical`]: props.vertical,
                    [`${COMPONENT_NAME}--align-top`]: props.alignTop
                }
            }, processSlots({
                props,
                slots
            }));
    }
};

},{"vue":"gzxs9","../../composables/useComponentPreset.js":"2HoaT","../../../VaTimeline.css":"41SJJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"41SJJ":[function() {},{}],"gL62Z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaTimelineItem);
var _withConfigTransportJs = require("../../../services/config-transport/withConfigTransport.js");
var _vaTimelineItemVueVueTypeScriptLangJs = require("./VaTimelineItem.vue_vue_type_script_lang.js");
const VaTimelineItem = (0, _withConfigTransportJs.w)((0, _vaTimelineItemVueVueTypeScriptLangJs._));

},{"../../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaTimelineItem.vue_vue_type_script_lang.js":"j9yOe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j9yOe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _indexJs = require("../VaTimelineSeparator/index.js");
var _extractComponentOptionsJs = require("../../../utils/component-options/extract-component-options.js");
var _useComponentPresetJs = require("../../../composables/useComponentPreset.js");
var _filterPropsJs = require("../../../utils/component-options/filter-props.js");
var _vaTimelineItemCss = require("../../../../VaTimelineItem.css");
const COMPONENT_NAME = "va-timeline-item";
const VaTimelineSeparatorProps = (0, _extractComponentOptionsJs.e)((0, _indexJs.V));
const _sfc_main = (0, _vue.defineComponent)({
    name: COMPONENT_NAME,
    props: {
        ...(0, _useComponentPresetJs.u),
        ...VaTimelineSeparatorProps,
        color: {
            type: String,
            default: "primary"
        },
        isFirst: {
            type: Boolean
        },
        isLast: {
            type: Boolean
        },
        inverted: {
            type: Boolean
        }
    },
    setup (props, { slots }) {
        const children = [
            (0, _vue.h)((0, _indexJs.V), {
                ...(0, _filterPropsJs.f)(VaTimelineSeparatorProps).value
            })
        ];
        const before = props.inverted ? slots.after : slots.before;
        if (before) children.unshift((0, _vue.h)("div", {
            class: `${COMPONENT_NAME}__before`
        }, before()));
        const after = props.inverted ? slots.before : slots.after;
        if (after) children.push((0, _vue.h)("div", {
            class: `${COMPONENT_NAME}__after`
        }, after()));
        return ()=>(0, _vue.h)("div", {
                class: [
                    {
                        [COMPONENT_NAME]: true
                    },
                    {
                        [`${COMPONENT_NAME}--vertical`]: props.vertical
                    },
                    {
                        [`${COMPONENT_NAME}--is-first`]: props.isFirst
                    },
                    {
                        [`${COMPONENT_NAME}--is-last`]: props.isLast
                    }
                ]
            }, children);
    }
});

},{"vue":"gzxs9","../VaTimelineSeparator/index.js":"8vXXH","../../../utils/component-options/extract-component-options.js":"1ODzH","../../../composables/useComponentPreset.js":"2HoaT","../../../utils/component-options/filter-props.js":"4HycW","../../../../VaTimelineItem.css":"2NmCA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8vXXH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaTimelineSeparator);
var _withConfigTransportJs = require("../../../services/config-transport/withConfigTransport.js");
var _vaTimelineSeparatorVueVueTypeScriptLangJs = require("./VaTimelineSeparator.vue_vue_type_script_lang.js");
const VaTimelineSeparator = (0, _withConfigTransportJs.w)((0, _vaTimelineSeparatorVueVueTypeScriptLangJs._));

},{"../../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaTimelineSeparator.vue_vue_type_script_lang.js":"dzRgf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dzRgf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useComponentPresetJs = require("../../../composables/useComponentPreset.js");
var _useColorsJs = require("../../../composables/useColors.js");
var _vaTimelineSeparatorCss = require("../../../../VaTimelineSeparator.css");
const componentName = "va-timeline-separator";
const _sfc_main = (0, _vue.defineComponent)({
    name: componentName,
    props: {
        ...(0, _useComponentPresetJs.u),
        color: {
            type: String,
            default: "primary"
        },
        vertical: {
            type: Boolean
        },
        active: {
            type: Boolean
        },
        activePrevious: {
            type: Boolean
        },
        activeNext: {
            type: Boolean
        }
    },
    setup (props) {
        const { getColor } = (0, _useColorsJs.u)();
        return ()=>(0, _vue.h)("div", {
                class: {
                    [componentName]: true,
                    [`${componentName}--vertical`]: props.vertical
                }
            }, [
                (0, _vue.h)("div", {
                    class: {
                        [`${componentName}__line`]: true,
                        [`${componentName}__line--active`]: props.activePrevious
                    },
                    style: {
                        backgroundColor: getColor(props.activePrevious ? props.color : "divider")
                    }
                }),
                (0, _vue.h)("div", {
                    class: {
                        [`${componentName}__center`]: true,
                        [`${componentName}__center--active`]: props.active
                    },
                    style: {
                        backgroundColor: getColor(props.active ? props.color : "divider")
                    }
                }),
                (0, _vue.h)("div", {
                    class: {
                        [`${componentName}__line`]: true,
                        [`${componentName}__line--active`]: props.activeNext
                    },
                    style: {
                        backgroundColor: getColor(props.activeNext ? props.color : "divider")
                    }
                })
            ]);
    }
});

},{"vue":"gzxs9","../../../composables/useComponentPreset.js":"2HoaT","../../../composables/useColors.js":"a4Qgv","../../../../VaTimelineSeparator.css":"hrrwq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hrrwq":[function() {},{}],"2NmCA":[function() {},{}],"iUilR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaTimePicker);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaTimePickerVueVueTypeScriptSetupTrueLangJs = require("./VaTimePicker.vue_vue_type_script_setup_true_lang.js");
const VaTimePicker = (0, _withConfigTransportJs.w)((0, _vaTimePickerVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaTimePicker.vue_vue_type_script_setup_true_lang.js":"hOLT5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1JPW1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaTreeView);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaTreeViewVueVueTypeScriptSetupTrueLangJs = require("./VaTreeView.vue_vue_type_script_setup_true_lang.js");
const VaTreeView = (0, _withConfigTransportJs.w)((0, _vaTreeViewVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaTreeView.vue_vue_type_script_setup_true_lang.js":"27Zp0","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"27Zp0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useTreeViewJs = require("./hooks/useTreeView.js");
var _useTreeHelpersJs = require("./hooks/useTreeHelpers.js");
var _indexJs = require("./components/VaTreeNode/index.js");
var _vaTreeViewCss = require("../../../VaTreeView.css");
const _hoisted_1 = {
    class: "va-tree-view",
    role: "tree"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaTreeView",
    __name: "VaTreeView",
    props: {
        ...(0, _useTreeHelpersJs.u)
    },
    emits: [
        ...(0, _useTreeHelpersJs.a)
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const { treeItems, getTrackBy } = (0, _useTreeViewJs.u)(props, emit);
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_1, [
                _ctx.$props.filter && !(0, _vue.unref)(treeItems).length ? (0, _vue.renderSlot)(_ctx.$slots, "not-found", {
                    key: 0
                }, ()=>[
                        (0, _vue.createTextVNode)("No matching nodes found")
                    ]) : ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                    key: 1
                }, (0, _vue.renderList)((0, _vue.unref)(treeItems), (nodeItem)=>{
                    return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), {
                        key: (0, _vue.unref)(getTrackBy)(nodeItem),
                        node: nodeItem
                    }, (0, _vue.createSlots)({
                        _: 2
                    }, [
                        (0, _vue.renderList)(_ctx.$slots, (_, name)=>{
                            return {
                                name,
                                fn: (0, _vue.withCtx)((slotScope)=>[
                                        (0, _vue.renderSlot)(_ctx.$slots, name, (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(slotScope)))
                                    ])
                            };
                        })
                    ]), 1032, [
                        "node"
                    ]);
                }), 128))
            ]);
        };
    }
});

},{"vue":"gzxs9","./hooks/useTreeView.js":"1UBAb","./hooks/useTreeHelpers.js":"55Gjh","./components/VaTreeNode/index.js":"234cp","../../../VaTreeView.css":"d2LOy","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1UBAb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useTreeView$1);
var _vue = require("vue");
var _useTreeHelpersJs = require("./useTreeHelpers.js");
var _typesJs = require("../types.js");
var _useTreeKeyboardNavigationJs = require("./useTreeKeyboardNavigation.js");
var _useColorsJs = require("../../../composables/useColors.js");
var _useStatefulJs = require("../../../composables/useStateful.js");
const useTreeView = (props, emit)=>{
    const { getColor } = (0, _useColorsJs.u)();
    const colorComputed = (0, _vue.computed)(()=>getColor(props.color));
    const isLeafSelectionComputed = (0, _vue.computed)(()=>props.selectionType === "leaf");
    const { getText, getValue, getChecked, getTrackBy, getChildren, getDisabled, getExpanded, iterateNodes, getNodeProperty } = (0, _useTreeHelpersJs.b)(props);
    const { nodes, expandAll, filter, filterMethod, textBy } = (0, _vue.toRefs)(props);
    const { valueComputed: expandedList } = (0, _useStatefulJs.b)(props, emit, "expanded");
    const { valueComputed: checkedList } = (0, _useStatefulJs.b)(props, emit, "checked");
    const selectedNode = (0, _vue.ref)();
    const selectedNodeComputed = (0, _vue.computed)({
        get: ()=>selectedNode.value,
        set: (node)=>{
            const value = getValue(node);
            if (selectedNode.value !== value) {
                selectedNode.value = value;
                emit("update:selected", node);
            }
        }
    });
    const updateModel = (model, values, state)=>{
        if (state) model.value = model.value.concat(values).filter((value, idx, self)=>self.indexOf(value) === idx);
        else model.value = model.value.filter((v)=>!values.includes(v));
    };
    const toggleCheckbox = (node, state)=>{
        let stateValue = state === null ? true : state;
        if (state && node.indeterminate) stateValue = false;
        const values = [
            getValue(node)
        ];
        if (isLeafSelectionComputed.value && node.hasChildren) {
            const toggleChildren = (nodes2)=>{
                nodes2.forEach((node2)=>{
                    if (node2.disabled) return;
                    const children = getChildren(node2);
                    if (children.length) toggleChildren(children);
                    values.push(getValue(node2));
                });
            };
            toggleChildren(getChildren(node));
        }
        updateModel(checkedList, values, stateValue);
    };
    const toggleNode = (node)=>{
        if (node.hasChildren) updateModel(expandedList, [
            getValue(node)
        ], !node.expanded);
    };
    const createNode = ({ node, level, children = [], computedFilterMethod: computedFilterMethod2 })=>{
        var _a;
        const valueBy = getValue(node);
        let matchesFilter = true;
        const hasChildren = !!children.length;
        const disabled = getDisabled(node) || false;
        let indeterminate = false;
        let checked = checkedList.value.includes(valueBy) || false;
        if (isLeafSelectionComputed.value && hasChildren) {
            const isAllChildrenChecked = children.every((c)=>c.checked);
            checked = isAllChildrenChecked;
            indeterminate = !isAllChildrenChecked && children.some((c)=>c.indeterminate || c.checked);
            if (indeterminate) checked = null;
        }
        if (filter.value) matchesFilter = (children == null ? void 0 : children.some((c)=>c.matchesFilter)) || ((_a = computedFilterMethod2.value) == null ? void 0 : _a.call(computedFilterMethod2, node, filter.value, textBy.value));
        return {
            ...node,
            level,
            checked,
            children,
            disabled,
            expanded: expandedList.value.includes(valueBy) || false,
            hasChildren,
            matchesFilter,
            indeterminate
        };
    };
    const computedFilterMethod = (0, _vue.computed)(()=>{
        if (filterMethod == null ? void 0 : filterMethod.value) return filterMethod.value;
        return (node, filter2)=>getText(node).toLowerCase().includes(filter2.toLowerCase());
    });
    const buildTree = (nodes2, level = 0)=>nodes2.map((node)=>{
            const treeItemChildren = getChildren(node);
            if (treeItemChildren.length) {
                const children = buildTree(treeItemChildren, level + 1);
                return createNode({
                    node,
                    level,
                    children,
                    computedFilterMethod
                });
            }
            return createNode({
                node,
                level,
                computedFilterMethod
            });
        });
    const getFilteredNodes = (nodes2)=>nodes2.filter((node)=>{
            if (node.children) node.children = getFilteredNodes(node.children);
            if (node.children.length === 0) node.hasChildren = false;
            return node.matchesFilter;
        });
    const { handleKeyboardNavigation } = (0, _useTreeKeyboardNavigationJs.u)(props, {
        emit,
        toggleCheckbox,
        toggleNode
    });
    (0, _vue.provide)((0, _typesJs.T), {
        selectedNodeComputed,
        colorComputed,
        iconBy: props.iconBy,
        selectable: props.selectable,
        expandNodeBy: props.expandNodeBy,
        getText,
        getValue,
        getTrackBy,
        toggleNode,
        toggleCheckbox,
        getNodeProperty,
        handleKeyboardNavigation
    });
    const treeItems = (0, _vue.computed)(()=>buildTree(nodes.value));
    const checkForInitialValues = ()=>{
        const expandedValues = [];
        const checkedValues = [];
        iterateNodes(nodes.value, (node)=>{
            if (expandAll.value) expandedValues.push(getValue(node));
            else getExpanded(node) && expandedValues.push(getValue(node));
            if (getChecked(node)) checkedValues.push(getValue(node));
        });
        if (expandedValues.length) updateModel(expandedList, expandedValues, true);
        if (checkedValues.length) updateModel(checkedList, checkedValues, true);
    };
    checkForInitialValues();
    return {
        treeItems: (0, _vue.computed)(()=>getFilteredNodes(treeItems.value)),
        getText,
        getTrackBy,
        toggleCheckbox
    };
};
const useTreeView$1 = useTreeView;

},{"vue":"gzxs9","./useTreeHelpers.js":"55Gjh","../types.js":"kn200","./useTreeKeyboardNavigation.js":"hLWJf","../../../composables/useColors.js":"a4Qgv","../../../composables/useStateful.js":"h9zUi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"55Gjh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>useTreeViewEmits);
parcelHelpers.export(exports, "b", ()=>useTreeHelpers);
parcelHelpers.export(exports, "u", ()=>useTreeViewProps);
var _valueByKeyJs = require("../../../utils/value-by-key.js");
const useTreeViewProps = {
    nodes: {
        type: Array,
        default: []
    },
    stateful: {
        type: Boolean,
        default: true
    },
    selectable: {
        type: Boolean,
        default: false
    },
    selectionType: {
        type: String,
        default: "leaf",
        validator: (v)=>[
                "leaf",
                "independent"
            ].includes(v)
    },
    valueBy: {
        type: [
            String,
            Function
        ],
        default: "id"
    },
    textBy: {
        type: [
            String,
            Function
        ],
        default: "label"
    },
    trackBy: {
        type: [
            String,
            Function
        ],
        default: "id"
    },
    iconBy: {
        type: [
            String,
            Function
        ],
        default: "icon"
    },
    disabledBy: {
        type: [
            String,
            Function
        ],
        default: "disabled"
    },
    expandedBy: {
        type: [
            String,
            Function
        ],
        default: "expanded"
    },
    checkedBy: {
        type: [
            String,
            Function
        ],
        default: "checked"
    },
    childrenBy: {
        type: [
            String,
            Function
        ],
        default: "children"
    },
    expandAll: {
        type: Boolean,
        default: false
    },
    expanded: {
        type: Array,
        default: []
    },
    expandNodeBy: {
        type: String,
        default: "leaf"
    },
    filter: {
        type: String,
        default: ""
    },
    filterMethod: {
        type: Function,
        default: void 0
    },
    checked: {
        type: Array,
        default: []
    },
    color: {
        type: String,
        default: "primary"
    }
};
const useTreeViewEmits = [
    "update:modelValue",
    "update:checked",
    "update:expanded",
    "update:selected"
];
const useTreeHelpers = (props)=>{
    const isStringOrNumber = (node)=>{
        const typeOfNode = typeof node;
        return typeOfNode === "string" || typeOfNode === "number";
    };
    const getNodeProperty = (node, key)=>!key || isStringOrNumber(node) ? node : (0, _valueByKeyJs.a)(node, key);
    const getValue = (node)=>getNodeProperty(node, props.valueBy);
    const getNodeByValue = (value)=>{
        if (!props.valueBy) return value;
        return props.nodes.find((node)=>value === getValue(node)) || value;
    };
    const getText = (node)=>getNodeProperty(node, props.textBy);
    const getChecked = (node)=>getNodeProperty(node, props.checkedBy);
    const getDisabled = (node)=>getNodeProperty(node, props.disabledBy);
    const getExpanded = (node)=>getNodeProperty(node, props.expandedBy);
    const getTrackBy = (node)=>getNodeProperty(node, props.trackBy);
    const getChildren = (node)=>getNodeProperty(node, props.childrenBy) ?? [];
    const iterateNodes = (nodes, cb)=>{
        nodes.forEach((node)=>{
            const children = node.children || [];
            if (children.length) iterateNodes(children, cb);
            cb(node);
        });
    };
    return {
        getText,
        getValue,
        getChecked,
        getTrackBy,
        getChildren,
        getDisabled,
        getExpanded,
        iterateNodes,
        getNodeByValue,
        getNodeProperty
    };
};

},{"../../../utils/value-by-key.js":"aZDG9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kn200":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "T", ()=>TreeViewKey);
const TreeViewKey = Symbol("TreeView");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hLWJf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useTreeKeyboardNavigation$1);
const useTreeKeyboardNavigation = (props, methods)=>{
    const { emit, toggleNode, toggleCheckbox } = methods;
    const isElementExpanded = (currentElement)=>(currentElement == null ? void 0 : currentElement.getAttribute("aria-expanded")) === "true";
    const getParentElement = (currentElement)=>{
        var _a;
        return ((_a = currentElement == null ? void 0 : currentElement.parentElement) == null ? void 0 : _a.closest(".va-tree-node")) || null;
    };
    const getPreviousElement = (currentElement)=>currentElement == null ? void 0 : currentElement.previousElementSibling;
    const findPreviousElement = (currentElement)=>{
        if (!currentElement) return null;
        let previousElement = getPreviousElement(currentElement);
        let lastChildElement = isElementExpanded(previousElement) && getLastChildElement(previousElement);
        if (lastChildElement) {
            do if (isElementExpanded(lastChildElement)) {
                lastChildElement = getLastChildElement(lastChildElement);
                if (lastChildElement) continue;
                else break;
            } else {
                previousElement = lastChildElement;
                break;
            }
            while (true);
        }
        if (!previousElement) return getParentElement(currentElement);
        return previousElement;
    };
    const getNextElement = (currentElement)=>currentElement == null ? void 0 : currentElement.nextElementSibling;
    const findNextElement = (currentElement)=>{
        if (!currentElement) return null;
        let nextElement = getNextElement(currentElement);
        const isCurrentExpanded = isElementExpanded(currentElement);
        if (!nextElement) {
            let parentElement = getParentElement(currentElement);
            do if (!getNextElement(parentElement)) {
                parentElement = getParentElement(parentElement);
                if (!parentElement) break;
                else continue;
            } else {
                nextElement = getNextElement(parentElement);
                break;
            }
            while (true);
        }
        if (isCurrentExpanded) return getFirstChildElement(currentElement);
        return nextElement;
    };
    const getFirstChildElement = (currentElement)=>{
        var _a;
        return ((_a = currentElement == null ? void 0 : currentElement.querySelector(".va-tree-node-children")) == null ? void 0 : _a.firstElementChild) || null;
    };
    const getLastChildElement = (currentElement)=>{
        var _a;
        return ((_a = currentElement == null ? void 0 : currentElement.querySelector(".va-tree-node-children")) == null ? void 0 : _a.lastElementChild) || null;
    };
    const onHorizontalMove = (currentElement, dir, node)=>{
        var _a, _b;
        const isCurrentElementExpanded = isElementExpanded(currentElement);
        if (dir === "left") {
            if (isCurrentElementExpanded) toggleNode(node);
            else (_a = getParentElement(currentElement)) == null || _a.focus();
        } else if (!isCurrentElementExpanded) toggleNode(node);
        else (_b = getFirstChildElement(currentElement)) == null || _b.focus();
    };
    const onVerticalMove = (currentElement, dir)=>{
        var _a, _b;
        if (dir === "up") (_a = findPreviousElement(currentElement)) == null || _a.focus();
        else (_b = findNextElement(currentElement)) == null || _b.focus();
    };
    const handleKeyboardNavigation = (event, node)=>{
        const currentElement = event.target;
        switch(event.code){
            case "ArrowUp":
                onVerticalMove(currentElement, "up");
                break;
            case "ArrowRight":
                onHorizontalMove(currentElement, "right", node);
                break;
            case "ArrowDown":
                onVerticalMove(currentElement, "down");
                break;
            case "ArrowLeft":
                onHorizontalMove(currentElement, "left", node);
                break;
            case "Space":
                if (props.selectable) {
                    const state = typeof node.checked !== "undefined" ? !node.checked : null;
                    toggleCheckbox(node, state);
                } else emit("update:selected", node);
                break;
            case "Escape":
                if (!props.selectable) emit("update:selected", null);
                currentElement.blur();
                break;
            default:
                currentElement.blur();
        }
    };
    return {
        handleKeyboardNavigation
    };
};
const useTreeKeyboardNavigation$1 = useTreeKeyboardNavigation;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"234cp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaTreeNode);
var _withConfigTransportJs = require("../../../../services/config-transport/withConfigTransport.js");
var _vaTreeNodeVueVueTypeScriptSetupTrueLangJs = require("./VaTreeNode.vue_vue_type_script_setup_true_lang.js");
const VaTreeNode = (0, _withConfigTransportJs.w)((0, _vaTreeNodeVueVueTypeScriptSetupTrueLangJs._));

},{"../../../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaTreeNode.vue_vue_type_script_setup_true_lang.js":"f0zY4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f0zY4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _typesJs = require("../../types.js");
var _useStrictInjectJs = require("../../../../composables/useStrictInject.js");
var _indexJs = require("../../../va-checkbox/index.js");
var _useBemJs = require("../../../../composables/useBem.js");
var _indexJs1 = require("../../../va-icon/index.js");
var _vaTreeNodeCss = require("../../../../../VaTreeNode.css");
const _hoisted_1 = [
    "role",
    "aria-expanded",
    "aria-disabled",
    "aria-checked",
    "tabindex"
];
const _hoisted_2 = {
    class: "va-tree-node-root"
};
const _hoisted_3 = {
    key: 2,
    class: "va-tree-node-content__item"
};
const _hoisted_4 = [
    "aria-hidden"
];
const INJECTION_ERROR_MESSAGE = "The VaTreeNode component should be used in the context of VaTreeView component";
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaTreeNode",
    __name: "VaTreeNode",
    props: {
        node: {
            type: Object,
            required: true
        }
    },
    setup (__props) {
        const props = __props;
        const { iconBy, selectable, expandNodeBy, colorComputed, selectedNodeComputed, getText, getTrackBy, toggleNode, toggleCheckbox, getNodeProperty, handleKeyboardNavigation } = (0, _useStrictInjectJs.u)((0, _typesJs.T), INJECTION_ERROR_MESSAGE);
        const labelComputed = (0, _vue.computed)(()=>getText(props.node) || "");
        const isExpandedComputed = (0, _vue.computed)(()=>props.node.hasChildren ? !!props.node.expanded : void 0);
        const iconComputed = (0, _vue.computed)(()=>getNodeProperty(props.node, iconBy));
        const roleComputed = (0, _vue.computed)(()=>props.node.hasChildren ? "group" : "treeitem");
        const treeNodeClassComputed = (0, _useBemJs.u)("va-tree-node", ()=>({
                disabled: Boolean(props.node.disabled),
                checked: Boolean(props.node.checked),
                hasChildren: Boolean(props.node.hasChildren),
                [`level-${props.node.level}`]: true,
                [`expand-by-${expandNodeBy}`]: true
            }));
        const expandedClassComputed = (0, _useBemJs.u)("va-tree-node-children", ()=>({
                expanded: !!isExpandedComputed.value
            }));
        const indentClassComputed = (0, _useBemJs.u)("va-tree-node-content", ()=>({
                indent: props.node.hasChildren === false
            }));
        const cursorClassComputed = (0, _useBemJs.u)("va-tree-node-content", ()=>({
                clickable: props.node.hasChildren === true && expandNodeBy === "node"
            }));
        const tabIndexComputed = (0, _vue.computed)(()=>props.node.disabled ? -1 : 0);
        const onNodeClick = (type)=>{
            const nodeType = expandNodeBy === "node" && type === "leaf" ? "node" : type;
            if (expandNodeBy === nodeType) toggleNode(props.node);
            selectedNodeComputed.value = props.node;
        };
        return (_ctx, _cache)=>{
            const _component_va_tree_node = (0, _vue.resolveComponent)("va-tree-node", true);
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: (0, _vue.normalizeClass)([
                    "va-tree-node",
                    (0, _vue.unref)(treeNodeClassComputed)
                ]),
                role: roleComputed.value,
                "aria-expanded": isExpandedComputed.value,
                "aria-disabled": _ctx.$props.node.disabled,
                "aria-checked": !!_ctx.$props.node.checked,
                tabindex: tabIndexComputed.value,
                onKeydown: [
                    _cache[4] || (_cache[4] = (0, _vue.withKeys)((0, _vue.withModifiers)(($event)=>(0, _vue.unref)(handleKeyboardNavigation)($event, _ctx.$props.node), [
                        "stop",
                        "prevent"
                    ]), [
                        "up"
                    ])),
                    _cache[5] || (_cache[5] = (0, _vue.withKeys)((0, _vue.withModifiers)(($event)=>(0, _vue.unref)(handleKeyboardNavigation)($event, _ctx.$props.node), [
                        "stop",
                        "prevent"
                    ]), [
                        "right"
                    ])),
                    _cache[6] || (_cache[6] = (0, _vue.withKeys)((0, _vue.withModifiers)(($event)=>(0, _vue.unref)(handleKeyboardNavigation)($event, _ctx.$props.node), [
                        "stop",
                        "prevent"
                    ]), [
                        "down"
                    ])),
                    _cache[7] || (_cache[7] = (0, _vue.withKeys)((0, _vue.withModifiers)(($event)=>(0, _vue.unref)(handleKeyboardNavigation)($event, _ctx.$props.node), [
                        "stop",
                        "prevent"
                    ]), [
                        "left"
                    ])),
                    _cache[8] || (_cache[8] = (0, _vue.withKeys)((0, _vue.withModifiers)(($event)=>(0, _vue.unref)(handleKeyboardNavigation)($event, _ctx.$props.node), [
                        "stop",
                        "prevent"
                    ]), [
                        "space"
                    ])),
                    _cache[9] || (_cache[9] = (0, _vue.withKeys)((0, _vue.withModifiers)(($event)=>(0, _vue.unref)(handleKeyboardNavigation)($event, _ctx.$props.node), [
                        "stop",
                        "prevent"
                    ]), [
                        "esc"
                    ]))
                ]
            }, [
                (0, _vue.createElementVNode)("div", _hoisted_2, [
                    (0, _vue.createElementVNode)("div", {
                        class: (0, _vue.normalizeClass)([
                            "va-tree-node-content",
                            (0, _vue.unref)(indentClassComputed)
                        ]),
                        onClick: _cache[3] || (_cache[3] = ($event)=>onNodeClick("node"))
                    }, [
                        _ctx.$props.node.hasChildren ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                            key: 0,
                            class: "va-tree-node-content__item va-tree-node-content__item--leaf",
                            onClick: _cache[0] || (_cache[0] = (0, _vue.withModifiers)(($event)=>onNodeClick("leaf"), [
                                "stop"
                            ]))
                        }, [
                            (0, _vue.renderSlot)(_ctx.$slots, "icon-toggle", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(_ctx.$props.node)), ()=>[
                                    (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs1.V)), {
                                        name: isExpandedComputed.value ? "keyboard_arrow_down" : "keyboard_arrow_right",
                                        size: "20px"
                                    }, null, 8, [
                                        "name"
                                    ])
                                ])
                        ])) : (0, _vue.createCommentVNode)("", true),
                        (0, _vue.unref)(selectable) ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                            key: 1,
                            class: "va-tree-node-content__item",
                            onClick: _cache[2] || (_cache[2] = (0, _vue.withModifiers)(()=>{}, [
                                "stop"
                            ]))
                        }, [
                            (0, _vue.renderSlot)(_ctx.$slots, "checkbox", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(_ctx.$props.node)), ()=>[
                                    (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs.V)), {
                                        "model-value": _ctx.$props.node.checked,
                                        color: (0, _vue.unref)(colorComputed),
                                        indeterminate: "",
                                        "onUpdate:modelValue": _cache[1] || (_cache[1] = (v)=>(0, _vue.unref)(toggleCheckbox)(_ctx.$props.node, v)),
                                        class: "va-tree-node__checkbox"
                                    }, null, 8, [
                                        "model-value",
                                        "color"
                                    ])
                                ])
                        ])) : (0, _vue.createCommentVNode)("", true),
                        iconComputed.value ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_3, [
                            (0, _vue.renderSlot)(_ctx.$slots, "icon", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(_ctx.$props.node)), ()=>[
                                    (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs1.V)), {
                                        name: iconComputed.value,
                                        size: "small"
                                    }, null, 8, [
                                        "name"
                                    ])
                                ])
                        ])) : (0, _vue.createCommentVNode)("", true),
                        (0, _vue.createElementVNode)("div", {
                            class: (0, _vue.normalizeClass)([
                                "va-tree-node-content__body",
                                (0, _vue.unref)(cursorClassComputed)
                            ])
                        }, [
                            (0, _vue.renderSlot)(_ctx.$slots, "content", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(_ctx.$props.node)), ()=>[
                                    (0, _vue.createTextVNode)((0, _vue.toDisplayString)(labelComputed.value), 1)
                                ])
                        ], 2)
                    ], 2)
                ]),
                (0, _vue.withDirectives)((0, _vue.createElementVNode)("div", {
                    "aria-hidden": !_ctx.$props.node.expanded,
                    class: (0, _vue.normalizeClass)([
                        "va-tree-node-children",
                        (0, _vue.unref)(expandedClassComputed)
                    ])
                }, [
                    ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)(_ctx.$props.node.children, (childNode)=>{
                        return (0, _vue.openBlock)(), (0, _vue.createBlock)(_component_va_tree_node, {
                            key: (0, _vue.unref)(getTrackBy)(childNode),
                            node: childNode
                        }, (0, _vue.createSlots)({
                            _: 2
                        }, [
                            (0, _vue.renderList)(_ctx.$slots, (_, name)=>{
                                return {
                                    name,
                                    fn: (0, _vue.withCtx)((slotScope)=>[
                                            (0, _vue.renderSlot)(_ctx.$slots, name, (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(slotScope)))
                                        ])
                                };
                            })
                        ]), 1032, [
                            "node"
                        ]);
                    }), 128))
                ], 10, _hoisted_4), [
                    [
                        (0, _vue.vShow),
                        _ctx.$props.node.hasChildren
                    ]
                ])
            ], 42, _hoisted_1);
        };
    }
});

},{"vue":"gzxs9","../../types.js":"kn200","../../../../composables/useStrictInject.js":"dIxtb","../../../va-checkbox/index.js":"w8J04","../../../../composables/useBem.js":"igmjV","../../../va-icon/index.js":"82tPo","../../../../../VaTreeNode.css":"6iyP8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6iyP8":[function() {},{}],"d2LOy":[function() {},{}],"kLo8x":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaScrollContainer);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaScrollContainerVueVueTypeScriptSetupTrueLangJs = require("./VaScrollContainer.vue_vue_type_script_setup_true_lang.js");
const VaScrollContainer = (0, _withConfigTransportJs.w)((0, _vaScrollContainerVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaScrollContainer.vue_vue_type_script_setup_true_lang.js":"iHB3S","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iHB3S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useSizeJs = require("../../composables/useSize.js");
var _useColorsJs = require("../../composables/useColors.js");
var _vaScrollContainerCss = require("../../../VaScrollContainer.css");
const _hoisted_1 = {
    class: "va-scroll-container__content"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaScrollContainer",
    __name: "VaScrollContainer",
    props: {
        ...(0, _useSizeJs.u),
        vertical: {
            type: Boolean,
            default: false
        },
        horizontal: {
            type: Boolean,
            default: false
        },
        color: {
            type: String,
            default: "secondary"
        },
        rtl: {
            type: Boolean,
            default: false
        },
        gradient: {
            type: Boolean,
            default: false
        },
        sizesConfig: {
            type: Object,
            default: ()=>({
                    defaultSize: 4,
                    sizes: {
                        small: 4,
                        medium: 6,
                        large: 8
                    }
                })
        },
        size: {
            type: String,
            default: "small",
            validator: (v)=>[
                    "small",
                    "medium",
                    "large"
                ].includes(v)
        }
    },
    setup (__props) {
        const props = __props;
        const { getColor } = (0, _useColorsJs.u)();
        const { sizeComputed } = (0, _useSizeJs.a)(props);
        const overflowX = (0, _vue.computed)(()=>props.horizontal ? "auto" : "hidden");
        const overflowY = (0, _vue.computed)(()=>props.vertical ? "auto" : "hidden");
        const scrollColor = (0, _vue.computed)(()=>{
            const color = getColor(props.color);
            return props.gradient ? `linear-gradient(0deg, var(--va-scroll-container-scrollbar-gradient-to) 0%, ${color} 100%)` : color;
        });
        const scrollbarSize = (0, _vue.computed)(()=>sizeComputed.value);
        const scrollbarPosition = (0, _vue.computed)(()=>props.rtl ? "rtl" : "ltr");
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
                class: "va-scroll-container",
                style: (0, _vue.normalizeStyle)(`--va-scroll-color: ${String(scrollColor.value)};--va-scrollbar-size: ${String(scrollbarSize.value)};--va-overflow-x: ${String(overflowX.value)};--va-overflow-y: ${String(overflowY.value)};--va-scrollbar-position: ${String(scrollbarPosition.value)}`)
            }, [
                (0, _vue.createElementVNode)("div", _hoisted_1, [
                    (0, _vue.renderSlot)(_ctx.$slots, "default")
                ])
            ], 4);
        };
    }
});

},{"vue":"gzxs9","../../composables/useSize.js":"d4gWT","../../composables/useColors.js":"a4Qgv","../../../VaScrollContainer.css":"gqsw6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gqsw6":[function() {},{}],"lhYsR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaViewer);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaViewerVueVueTypeScriptSetupTrueLangJs = require("./VaViewer.vue_vue_type_script_setup_true_lang.js");
const VaViewer = (0, _withConfigTransportJs.w)((0, _vaViewerVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaViewer.vue_vue_type_script_setup_true_lang.js":"esFzT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"esFzT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _indexJs = require("../va-icon/index.js");
var _useIsMountedJs = require("../../composables/useIsMounted.js");
var _useClickOutsideJs = require("../../composables/useClickOutside.js");
var _useDocumentJs = require("../../composables/useDocument.js");
var _vaViewerCss = require("../../../VaViewer.css");
const _hoisted_1 = {
    class: "va-viewer-content"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaViewer",
    inheritAttrs: false,
    __name: "VaViewer",
    setup (__props, { expose: __expose }) {
        const content = (0, _vue.ref)();
        const controls = (0, _vue.ref)();
        const isMounted = (0, _useIsMountedJs.u)();
        const isClosed = (0, _vue.ref)(true);
        const isOpened = (0, _vue.computed)(()=>isMounted.value && !isClosed.value);
        const openViewer = ()=>isClosed.value = false;
        const closeViewer = ()=>isClosed.value = true;
        const slots = (0, _vue.useSlots)();
        const handleAnchorClick = ()=>{
            if (!slots.anchor) openViewer();
        };
        (0, _useClickOutsideJs.u)([
            content,
            controls
        ], closeViewer);
        const document = (0, _useDocumentJs.u)();
        const teleportTarget = (0, _vue.computed)(()=>{
            var _a;
            return (_a = document.value) == null ? void 0 : _a.body;
        });
        __expose({
            openViewer,
            closeViewer
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), null, [
                (0, _vue.createElementVNode)("div", (0, _vue.mergeProps)({
                    class: "va-viewer"
                }, _ctx.$attrs, {
                    onClick: handleAnchorClick
                }), [
                    (0, _vue.renderSlot)(_ctx.$slots, "anchor", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                        openViewer
                    }))),
                    !_ctx.$slots.anchor ? (0, _vue.renderSlot)(_ctx.$slots, "default", {
                        key: 0
                    }) : (0, _vue.createCommentVNode)("", true)
                ], 16),
                isOpened.value ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.Teleport), {
                    key: 0,
                    to: teleportTarget.value
                }, [
                    (0, _vue.createElementVNode)("div", _hoisted_1, [
                        (0, _vue.createElementVNode)("div", {
                            ref_key: "content",
                            ref: content,
                            class: "va-viewer-content__main-area"
                        }, [
                            !_ctx.$slots.image ? (0, _vue.renderSlot)(_ctx.$slots, "default", {
                                key: 0
                            }) : (0, _vue.createCommentVNode)("", true),
                            (0, _vue.renderSlot)(_ctx.$slots, "image")
                        ], 512),
                        (0, _vue.createElementVNode)("div", {
                            ref_key: "controls",
                            ref: controls,
                            class: "va-viewer-content__controls-panel"
                        }, [
                            (0, _vue.renderSlot)(_ctx.$slots, "controls"),
                            (0, _vue.renderSlot)(_ctx.$slots, "close", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                                close: closeViewer
                            })), ()=>[
                                    (0, _vue.createElementVNode)("button", {
                                        class: "va-viewer-content__close-button",
                                        onClick: closeViewer
                                    }, [
                                        (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs.V)), {
                                            name: "close",
                                            color: "backgroundPrimary"
                                        })
                                    ])
                                ])
                        ], 512)
                    ])
                ], 8, [
                    "to"
                ])) : (0, _vue.createCommentVNode)("", true)
            ], 64);
        };
    }
});

},{"vue":"gzxs9","../va-icon/index.js":"82tPo","../../composables/useIsMounted.js":"dEE9p","../../composables/useClickOutside.js":"4ZW8J","../../composables/useDocument.js":"403q6","../../../VaViewer.css":"ke3qv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ke3qv":[function() {},{}],"lL9OB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaValue);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaValueVueVueTypeScriptLangJs = require("./VaValue.vue_vue_type_script_lang.js");
const VaValue = (0, _withConfigTransportJs.w)((0, _vaValueVueVueTypeScriptLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaValue.vue_vue_type_script_lang.js":"8seZi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8seZi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _headlessJs = require("../../utils/headless.js");
const _sfc_main = (0, _vue.defineComponent)({
    name: "VaValue",
    props: {
        defaultValue: {
            type: null,
            required: false,
            default: false
        }
    },
    setup (props, { slots }) {
        const value = (0, _vue.ref)(props.defaultValue);
        const slotBind = new Proxy(value, {
            get (target, prop) {
                if (prop === "value") return target.value;
                return target[prop];
            },
            set (target, prop, value2) {
                if (prop === "value") target.value = value2;
                return true;
            }
        });
        return ()=>{
            return (0, _vue.h)((0, _vue.Fragment), [
                (0, _headlessJs.r)(slots.default, slotBind)
            ]);
        };
    }
});

},{"vue":"gzxs9","../../utils/headless.js":"fM1sq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fwDgH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaTextarea);
var _vaTextareaVueVueTypeScriptSetupTrueLangJs = require("./VaTextarea.vue_vue_type_script_setup_true_lang.js");
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
const VaTextarea = (0, _withConfigTransportJs.a)((0, _vaTextareaVueVueTypeScriptSetupTrueLangJs._));

},{"./VaTextarea.vue_vue_type_script_setup_true_lang.js":"hWIVv","../../services/config-transport/withConfigTransport.js":"b7Tgy","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hWIVv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vendorJs = require("../../../vendor.js");
var _indexJs = require("../va-input-wrapper/index.js");
var _focusJs = require("../../utils/focus.js");
var _useLineHeightJs = require("./composables/useLineHeight.js");
var _extractComponentOptionsJs = require("../../utils/component-options/extract-component-options.js");
var _useFormFieldJs = require("../../composables/useFormField.js");
var _useStatefulJs = require("../../composables/useStateful.js");
var _useValidationJs = require("../../composables/useValidation.js");
var _filterPropsJs = require("../../utils/component-options/filter-props.js");
var _useEmitProxyJs = require("../../composables/useEmitProxy.js");
var _vaTextareaCss = require("../../../VaTextarea.css");
const _hoisted_1 = [
    "rows",
    "loading",
    "ariaLabel"
];
const positiveNumberValidator = (val)=>{
    if (val > 0) return true;
    throw new Error(`\`minRows|maxRows\` must be a positive integer greater than 0, but ${val} is provided`);
};
const { createEmits, createListeners } = (0, _useEmitProxyJs.u)([
    "input",
    "change",
    "click",
    "update:modelValue"
]);
const VaInputWrapperProps = (0, _extractComponentOptionsJs.e)((0, _indexJs.V));
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaTextarea",
    __name: "VaTextarea",
    props: {
        ...(0, _useFormFieldJs.u),
        ...VaInputWrapperProps,
        ...(0, _useStatefulJs.u),
        ...(0, _useValidationJs.b),
        modelValue: {
            type: [
                String,
                Number
            ],
            default: ""
        },
        placeholder: {
            type: String
        },
        autosize: {
            type: Boolean,
            default: false
        },
        minRows: {
            type: [
                Number,
                String
            ],
            default: 1,
            validator: positiveNumberValidator
        },
        maxRows: {
            type: [
                Number,
                String
            ],
            validator: positiveNumberValidator
        },
        resize: {
            type: Boolean,
            default: true
        },
        clearValue: {
            type: [
                String
            ],
            default: ""
        }
    },
    emits: [
        ...createEmits(),
        ...(0, _useValidationJs.u)
    ],
    setup (__props, { expose: __expose, emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const textarea = (0, _vue.shallowRef)();
        const { valueComputed } = (0, _useStatefulJs.b)(props, emit, "modelValue", {
            defaultValue: ""
        });
        const focus = ()=>{
            (0, _focusJs.a)(textarea.value);
        };
        const blur = ()=>{
            (0, _focusJs.b)(textarea.value);
        };
        const reset = ()=>withoutValidation(()=>{
                emit("update:modelValue", props.clearValue);
                emit("clear");
                resetValidation();
            });
        const { isDirty, computedError, computedErrorMessages, listeners: validationListeners, validationAriaAttributes, isLoading, resetValidation, withoutValidation } = (0, _useValidationJs.a)(props, emit, {
            value: valueComputed,
            focus,
            reset
        });
        const isResizable = (0, _vue.computed)(()=>{
            return props.resize && !props.autosize;
        });
        const rows = (0, _vue.ref)(props.minRows);
        const textHeight = (0, _useLineHeightJs.u)(textarea, valueComputed);
        function calculateInputHeight() {
            let minRows = parseFloat(String(props.minRows));
            let maxRows = parseFloat(String(props.maxRows));
            minRows = isNaN(minRows) ? 1 : minRows;
            maxRows = isNaN(maxRows) ? Infinity : maxRows;
            if (!props.autosize) {
                rows.value = Math.max(maxRows, Math.min(minRows, maxRows ?? 0));
                return;
            }
            if (!textHeight.value || !textarea.value) return;
            const style = getComputedStyle(textarea.value);
            const height = textHeight.value;
            const lineHeight = parseFloat(style.lineHeight);
            const minHeight = Math.max(minRows * lineHeight, minRows + Math.round(lineHeight));
            const maxHeight = maxRows * lineHeight || Infinity;
            const newHeight = Math.max(minHeight, Math.min(maxHeight, height ?? 0));
            rows.value = Math.round(newHeight / lineHeight);
            textarea.value.style.height = `${newHeight + 1}px`;
        }
        (0, _vue.watchEffect)(()=>{
            calculateInputHeight();
        });
        const computedStyle = (0, _vue.computed)(()=>({
                resize: isResizable.value ? void 0 : "none"
            }));
        const computedProps = (0, _vue.computed)(()=>({
                ...(0, _vendorJs.p)(props, [
                    "disabled",
                    "readonly",
                    "placeholder",
                    "ariaLabel"
                ])
            }));
        const vaInputWrapperProps = (0, _filterPropsJs.f)(VaInputWrapperProps);
        const listeners = createListeners(emit);
        __expose({
            isDirty,
            isLoading,
            computedError,
            computedErrorMessages,
            reset,
            focus,
            blur,
            value: valueComputed,
            withoutValidation,
            resetValidation
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), (0, _vue.mergeProps)({
                class: "va-textarea"
            }, (0, _vue.unref)(vaInputWrapperProps), {
                error: (0, _vue.unref)(computedError),
                "error-messages": (0, _vue.unref)(computedErrorMessages)
            }), {
                default: (0, _vue.withCtx)(()=>[
                        (0, _vue.createElementVNode)("div", {
                            class: (0, _vue.normalizeClass)([
                                "va-textarea__resize-wrapper",
                                {
                                    "va-textarea__resize-wrapper--resizable": isResizable.value
                                }
                            ])
                        }, [
                            (0, _vue.withDirectives)((0, _vue.createElementVNode)("textarea", (0, _vue.mergeProps)({
                                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event)=>(0, _vue.isRef)(valueComputed) ? valueComputed.value = $event : null)
                            }, {
                                ...computedProps.value,
                                ...(0, _vue.unref)(listeners),
                                ...(0, _vue.unref)(validationAriaAttributes),
                                ...(0, _vue.unref)(validationListeners)
                            }, {
                                class: [
                                    "va-textarea__textarea",
                                    {
                                        "va-textarea__textarea--autosize": __props.autosize
                                    }
                                ],
                                ref_key: "textarea",
                                ref: textarea,
                                rows: rows.value,
                                style: computedStyle.value,
                                loading: (0, _vue.unref)(isLoading),
                                ariaLabel: _ctx.$props.label
                            }), null, 16, _hoisted_1), [
                                [
                                    (0, _vue.vModelText),
                                    (0, _vue.unref)(valueComputed)
                                ]
                            ])
                        ], 2)
                    ]),
                _: 1
            }, 16, [
                "error",
                "error-messages"
            ]);
        };
    }
});

},{"vue":"gzxs9","../../../vendor.js":"l6TAc","../va-input-wrapper/index.js":"7MuId","../../utils/focus.js":"e1Xlj","./composables/useLineHeight.js":"cUhfU","../../utils/component-options/extract-component-options.js":"1ODzH","../../composables/useFormField.js":"676Eq","../../composables/useStateful.js":"h9zUi","../../composables/useValidation.js":"iFHh2","../../utils/component-options/filter-props.js":"4HycW","../../composables/useEmitProxy.js":"koywY","../../../VaTextarea.css":"6xNSQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cUhfU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useTextHeight);
var _vue = require("vue");
var _useResizeObserverJs = require("../../../composables/useResizeObserver.js");
const makeTextElement = (textarea)=>{
    const div = document.createElement("div");
    div.style.position = "absolute";
    div.style.top = "0";
    div.style.left = "0";
    div.style.width = "auto";
    const { font } = window.getComputedStyle(textarea);
    div.style.font = font;
    div.textContent = "Vuestic";
    div.style.zIndex = "-1";
    div.style.pointerEvents = "none";
    div.style.opacity = "0";
    div.ariaHidden = "true";
    div.innerText = textarea.value;
    return div;
};
const useTextHeight = (textarea, text)=>{
    const textElement = (0, _vue.ref)();
    const textHeight = (0, _vue.ref)();
    (0, _vue.watch)(textarea, (el)=>{
        var _a, _b;
        if (el) {
            textElement.value = makeTextElement(el);
            (_b = (_a = textarea.value) == null ? void 0 : _a.parentElement) == null || _b.appendChild(textElement.value);
        }
    });
    (0, _useResizeObserverJs.u)(textElement, (newElement)=>{
        if (!newElement || !textarea.value) return;
        textHeight.value = newElement[0].contentRect.height;
    });
    (0, _vue.watch)(text, (newText)=>{
        if (!textElement.value) return;
        textElement.value.innerText = String(newText);
        textElement.value.innerHTML += "&nbsp;;";
    });
    return textHeight;
};

},{"vue":"gzxs9","../../../composables/useResizeObserver.js":"4ylh3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6xNSQ":[function() {},{}],"5U4oY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaMenu);
var _vaMenuVueVueTypeScriptSetupTrueLangJs = require("./VaMenu.vue_vue_type_script_setup_true_lang.js");
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
const VaMenu = (0, _withConfigTransportJs.a)((0, _vaMenuVueVueTypeScriptSetupTrueLangJs._));

},{"./VaMenu.vue_vue_type_script_setup_true_lang.js":"5CD75","../../services/config-transport/withConfigTransport.js":"b7Tgy","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5CD75":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _indexJs = require("../va-dropdown/index.js");
var _indexJs1 = require("../va-menu-list/index.js");
var _focusJs = require("../../utils/focus.js");
var _unwrapElJs = require("../../utils/unwrapEl.js");
var _useImmediateFocusJs = require("../../composables/useImmediateFocus.js");
var _indexJs2 = require("../va-dropdown/components/VaDropdownContent/index.js");
var _extractComponentOptionsJs = require("../../utils/component-options/extract-component-options.js");
var _useComponentPresetJs = require("../../composables/useComponentPreset.js");
var _filterPropsJs = require("../../utils/component-options/filter-props.js");
const VaMenuListProps = (0, _extractComponentOptionsJs.e)((0, _indexJs1.V));
const VaMenuListEmits = (0, _extractComponentOptionsJs.a)((0, _indexJs1.V));
const VaDropdownProps = (0, _extractComponentOptionsJs.e)((0, _indexJs.V));
const VaDropdownEmits = (0, _extractComponentOptionsJs.a)((0, _indexJs.V));
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaMenu",
    __name: "VaMenu",
    props: {
        ...(0, _useComponentPresetJs.u),
        ...VaMenuListProps,
        ...VaDropdownProps,
        stickToEdges: {
            type: Boolean,
            default: true
        }
    },
    emits: [
        ...VaDropdownEmits,
        ...VaMenuListEmits
    ],
    setup (__props, { expose: __expose, emit: __emit }) {
        const menuList = (0, _vue.ref)();
        const dropdown = (0, _vue.ref)();
        (0, _useImmediateFocusJs.u)(menuList);
        const close = ()=>{
            var _a;
            (_a = dropdown.value) == null || _a.hide();
            (0, _vue.nextTick)(()=>{
                var _a2;
                const el = (0, _unwrapElJs.u)((_a2 = dropdown.value) == null ? void 0 : _a2.anchorRef);
                if (el) (0, _focusJs.f)(el);
            });
        };
        const onKeydown = (event)=>{
            if (event.key === "Escape") close();
            if (event.key === "ArrowDown" || event.key === "ArrowUp") event.preventDefault();
        };
        const menuListProps = (0, _filterPropsJs.f)(VaMenuListProps);
        const dropdownProps = (0, _filterPropsJs.f)(VaDropdownProps);
        __expose({
            close
        });
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), (0, _vue.mergeProps)((0, _vue.unref)(dropdownProps), {
                ref_key: "dropdown",
                ref: dropdown
            }), {
                anchor: (0, _vue.withCtx)(()=>[
                        (0, _vue.renderSlot)(_ctx.$slots, "anchor")
                    ]),
                default: (0, _vue.withCtx)(()=>[
                        (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs2.V)), {
                            onKeydown
                        }, {
                            default: (0, _vue.withCtx)(()=>[
                                    (0, _vue.createVNode)((0, _vue.unref)((0, _indexJs1.V)), (0, _vue.mergeProps)({
                                        onKeydown: _cache[0] || (_cache[0] = (0, _vue.withKeys)((0, _vue.withModifiers)(()=>{}, [
                                            "prevent",
                                            "stop"
                                        ]), [
                                            "enter",
                                            "space"
                                        ]))
                                    }, (0, _vue.unref)(menuListProps), {
                                        ref_key: "menuList",
                                        ref: menuList,
                                        onSelected: _cache[1] || (_cache[1] = ($event)=>{
                                            _ctx.$emit("selected", $event);
                                            close();
                                        })
                                    }), (0, _vue.createSlots)({
                                        _: 2
                                    }, [
                                        _ctx.$slots.default ? {
                                            name: "default",
                                            fn: (0, _vue.withCtx)(()=>[
                                                    (0, _vue.renderSlot)(_ctx.$slots, "default")
                                                ]),
                                            key: "0"
                                        } : void 0
                                    ]), 1040)
                                ]),
                            _: 3
                        })
                    ]),
                _: 3
            }, 16);
        };
    }
});

},{"vue":"gzxs9","../va-dropdown/index.js":"2ag98","../va-menu-list/index.js":"3V4NA","../../utils/focus.js":"e1Xlj","../../utils/unwrapEl.js":"bYHKv","../../composables/useImmediateFocus.js":"2aOC4","../va-dropdown/components/VaDropdownContent/index.js":"eUpbA","../../utils/component-options/extract-component-options.js":"1ODzH","../../composables/useComponentPreset.js":"2HoaT","../../utils/component-options/filter-props.js":"4HycW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3V4NA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaMenuList);
parcelHelpers.export(exports, "a", ()=>VaMenuItem);
parcelHelpers.export(exports, "b", ()=>VaMenuGroup);
var _vaMenuListVueVueTypeScriptSetupTrueLangJs = require("./VaMenuList.vue_vue_type_script_setup_true_lang.js");
var _vaMenuItemVueVueTypeScriptSetupTrueLangJs = require("./components/VaMenuItem.vue_vue_type_script_setup_true_lang.js");
var _vaMenuGroupJs = require("./components/VaMenuGroup.js");
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
const VaMenuList = (0, _withConfigTransportJs.a)((0, _vaMenuListVueVueTypeScriptSetupTrueLangJs._));
const VaMenuItem = (0, _withConfigTransportJs.a)((0, _vaMenuItemVueVueTypeScriptSetupTrueLangJs._));
const VaMenuGroup = (0, _withConfigTransportJs.a)((0, _vaMenuGroupJs._));

},{"./VaMenuList.vue_vue_type_script_setup_true_lang.js":"iSfGh","./components/VaMenuItem.vue_vue_type_script_setup_true_lang.js":"lqI00","./components/VaMenuGroup.js":"d0wNl","../../services/config-transport/withConfigTransport.js":"b7Tgy","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iSfGh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _vaMenuItemVueVueTypeScriptSetupTrueLangJs = require("./components/VaMenuItem.vue_vue_type_script_setup_true_lang.js");
var _vaMenuGroupJs = require("./components/VaMenuGroup.js");
var _useMenuKeyboardNavigationJs = require("./composables/useMenuKeyboardNavigation.js");
var _useSelectableListJs = require("../../composables/useSelectableList.js");
var _vaMenuListCss = require("../../../VaMenuList.css");
const _hoisted_1 = {
    colspan: "9999"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaMenuList",
    __name: "VaMenuList",
    props: {
        ...(0, _useSelectableListJs.u),
        options: {
            type: Array,
            default: ()=>[]
        }
    },
    emits: [
        "selected"
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const container = (0, _vue.ref)();
        (0, _useMenuKeyboardNavigationJs.u)(container);
        const { getText, getValue, getDisabled, getGroupBy, getTrackBy } = (0, _useSelectableListJs.a)(props);
        const optionGroups = (0, _vue.computed)(()=>props.options.reduce((groups, option)=>{
                const groupBy = getGroupBy(option);
                if (!groupBy) groups._noGroup.push(option);
                else {
                    if (!groups[groupBy]) groups[groupBy] = [];
                    groups[groupBy].push(option);
                }
                return groups;
            }, {
                _noGroup: []
            }));
        const getUnSlottedVNodes = (nodes)=>{
            if (Array.isArray(nodes) && nodes[0].type === (0, _vue.Fragment)) return nodes[0].children;
            return nodes;
        };
        const getVNodeComponentName = (node)=>{
            if (typeof node.type === "object" && "name" in node.type && typeof node.type.name === "string") return node.type.name;
            return "";
        };
        const getVNodeKey = (node)=>{
            if (typeof node.type === "string") return node.type;
            if (typeof node.type === "object" && "name" in node.type && typeof node.type.name === "string") return node.type.name;
            return String(node.key);
        };
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("table", (0, _vue.mergeProps)({
                class: "va-menu-list",
                ref_key: "container",
                ref: container
            }, (0, _vue.unref)((0, _useMenuKeyboardNavigationJs.m))()), [
                (0, _vue.createElementVNode)("tbody", null, [
                    _ctx.$slots.default ? ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                        key: 0
                    }, (0, _vue.renderList)(getUnSlottedVNodes(_ctx.$slots.default()), (child)=>{
                        return (0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), null, [
                            getVNodeComponentName(child) === "VaMenuItem" ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.resolveDynamicComponent)(child), {
                                key: getVNodeKey(child) + "menuitem"
                            })) : getVNodeComponentName(child) === "VaDropdown" ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.resolveDynamicComponent)(child), {
                                key: getVNodeKey(child) + "menu-dropdown"
                            })) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("td", {
                                colspan: "999",
                                key: getVNodeKey(child),
                                class: "va-menu-list__virtual-td"
                            }, [
                                ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.resolveDynamicComponent)(child)))
                            ]))
                        ], 64);
                    }), 256)) : (0, _vue.renderSlot)(_ctx.$slots, "default", {
                        key: 1
                    }, ()=>[
                            ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)(optionGroups.value, (options, groupName)=>{
                                return (0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                                    key: groupName
                                }, [
                                    groupName !== "_noGroup" ? (0, _vue.renderSlot)(_ctx.$slots, "group", {
                                        key: 0
                                    }, ()=>[
                                            (0, _vue.createElementVNode)("tr", null, [
                                                (0, _vue.createElementVNode)("td", _hoisted_1, [
                                                    (0, _vue.createVNode)((0, _vaMenuGroupJs._), {
                                                        "group-name": groupName
                                                    }, null, 8, [
                                                        "group-name"
                                                    ])
                                                ])
                                            ])
                                        ]) : (0, _vue.createCommentVNode)("", true),
                                    ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)(options, (option)=>{
                                        return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vaMenuItemVueVueTypeScriptSetupTrueLangJs._), {
                                            key: (0, _vue.unref)(getTrackBy)(option),
                                            name: (0, _vue.unref)(getText)(option),
                                            icon: option.icon,
                                            "right-icon": option.rightIcon,
                                            disabled: (0, _vue.unref)(getDisabled)(option),
                                            onSelected: ($event)=>_ctx.$emit("selected", (0, _vue.unref)(getValue)(option), option)
                                        }, {
                                            "left-icon": (0, _vue.withCtx)((bind)=>[
                                                    (0, _vue.renderSlot)(_ctx.$slots, "left-icon", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(bind)))
                                                ]),
                                            "right-icon": (0, _vue.withCtx)((bind)=>[
                                                    (0, _vue.renderSlot)(_ctx.$slots, "right-icon", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(bind)))
                                                ]),
                                            _: 2
                                        }, 1032, [
                                            "name",
                                            "icon",
                                            "right-icon",
                                            "disabled",
                                            "onSelected"
                                        ]);
                                    }), 128))
                                ], 64);
                            }), 128))
                        ])
                ])
            ], 16);
        };
    }
});

},{"vue":"gzxs9","./components/VaMenuItem.vue_vue_type_script_setup_true_lang.js":"lqI00","./components/VaMenuGroup.js":"d0wNl","./composables/useMenuKeyboardNavigation.js":"86YVd","../../composables/useSelectableList.js":"5kDaP","../../../VaMenuList.css":"lQemv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lqI00":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _indexJs = require("../../va-icon/index.js");
var _useMenuKeyboardNavigationJs = require("../composables/useMenuKeyboardNavigation.js");
var _useKeyboardOnlyFocusJs = require("../../../composables/useKeyboardOnlyFocus.js");
var _vaMenuItemCss = require("../../../../VaMenuItem.css");
const _hoisted_1 = {
    class: "va-menu-item__cell va-menu-item__cell--left"
};
const _hoisted_2 = {
    class: "va-menu-item__cell va-menu-item__cell--center"
};
const _hoisted_3 = {
    class: "va-menu-item__content"
};
const _hoisted_4 = {
    class: "va-menu-item__cell va-menu-item__cell--right"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaMenuItem",
    __name: "VaMenuItem",
    props: {
        name: {
            type: String,
            default: ""
        },
        icon: {
            type: String,
            defatult: ""
        },
        rightIcon: {
            type: String,
            defatult: ""
        },
        disabled: {
            type: Boolean,
            default: false
        }
    },
    emits: [
        "selected"
    ],
    setup (__props, { emit: __emit }) {
        const { hasKeyboardFocus, keyboardFocusListeners } = (0, _useKeyboardOnlyFocusJs.a)();
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("tr", (0, _vue.mergeProps)({
                class: "va-menu-item"
            }, (0, _vue.unref)((0, _useMenuKeyboardNavigationJs.a))({
                disabled: __props.disabled
            }), (0, _vue.toHandlers)((0, _vue.unref)(keyboardFocusListeners), true), {
                class: {
                    "va-menu-item--disabled": __props.disabled,
                    "va-menu-item--keyboard-focus": (0, _vue.unref)(hasKeyboardFocus)
                },
                onClick: _cache[0] || (_cache[0] = ($event)=>_ctx.$emit("selected")),
                onKeydown: _cache[1] || (_cache[1] = (0, _vue.withKeys)(($event)=>_ctx.$emit("selected"), [
                    "enter",
                    "space"
                ]))
            }), [
                (0, _vue.createElementVNode)("td", _hoisted_1, [
                    (0, _vue.renderSlot)(_ctx.$slots, "left-icon", {}, ()=>[
                            __props.icon ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), {
                                key: 0,
                                class: "va-menu-item__icon--left",
                                name: __props.icon
                            }, null, 8, [
                                "name"
                            ])) : (0, _vue.createCommentVNode)("", true)
                        ])
                ]),
                (0, _vue.createElementVNode)("td", _hoisted_2, [
                    (0, _vue.renderSlot)(_ctx.$slots, "default", {}, ()=>[
                            (0, _vue.createElementVNode)("a", _hoisted_3, (0, _vue.toDisplayString)(__props.name), 1)
                        ])
                ]),
                (0, _vue.createElementVNode)("td", _hoisted_4, [
                    (0, _vue.renderSlot)(_ctx.$slots, "right-icon", {}, ()=>[
                            __props.rightIcon ? ((0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _indexJs.V)), {
                                key: 0,
                                class: "va-menu-item__icon--right",
                                name: __props.rightIcon
                            }, null, 8, [
                                "name"
                            ])) : (0, _vue.createCommentVNode)("", true)
                        ])
                ])
            ], 16);
        };
    }
});

},{"vue":"gzxs9","../../va-icon/index.js":"82tPo","../composables/useMenuKeyboardNavigation.js":"86YVd","../../../composables/useKeyboardOnlyFocus.js":"lKbNJ","../../../../VaMenuItem.css":"iBGnr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"86YVd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "a", ()=>makeMenuItemAttributes);
parcelHelpers.export(exports, "m", ()=>makeMenuContainerAttributes);
parcelHelpers.export(exports, "u", ()=>useMenuKeyboardNavigation);
var _focusJs = require("../../../utils/focus.js");
var _useEventJs = require("../../../composables/useEvent.js");
const NON_DISABLED_MENU_ITEM_SELECTOR = '[role="menuitem"]:not([aria-disabled="true"])';
const FOCUSED_MENU_ITEM_SELECTOR = '[role="menuitem"]:focus';
const makeMenuItemAttributes = (options)=>({
        role: "menuitem",
        tabindex: -1,
        "aria-disabled": Boolean(options.disabled)
    });
const makeMenuContainerAttributes = ()=>({
        role: "menu",
        tabindex: 0
    });
const useMenuKeyboardNavigation = (container)=>{
    (0, _useEventJs.u)("keydown", ({ key })=>{
        if (!container.value) return;
        const items = container.value.querySelectorAll(NON_DISABLED_MENU_ITEM_SELECTOR);
        const focusedItem = container.value.querySelector(FOCUSED_MENU_ITEM_SELECTOR);
        if (!items.length) return;
        if (!focusedItem) {
            const firstItem = container.value.querySelector(NON_DISABLED_MENU_ITEM_SELECTOR);
            if (firstItem) (0, _focusJs.a)(firstItem);
            return;
        }
        if (key === "ArrowDown" || key === "ArrowRight") {
            const focusedElementIndex = Array.from(items).indexOf(focusedItem);
            (0, _focusJs.a)(items[focusedElementIndex + 1]);
        }
        if (key === "ArrowUp" || key === "ArrowLeft") {
            const focusedElementIndex = Array.from(items).indexOf(focusedItem);
            (0, _focusJs.a)(items[focusedElementIndex - 1]);
        }
    }, container);
};

},{"../../../utils/focus.js":"e1Xlj","../../../composables/useEvent.js":"9kzUn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iBGnr":[function() {},{}],"d0wNl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_VaMenuGroup);
var _vaMenuGroupVueVueTypeScriptSetupTrueLangJs = require("./VaMenuGroup.vue_vue_type_script_setup_true_lang.js");
var _pluginVueExportHelperJs = require("../../../../plugin-vue_export-helper.js");
var _vaMenuGroupCss = require("../../../../VaMenuGroup.css");
const VaMenuGroup_vue_vue_type_style_index_0_scoped_4dd1ae9a_lang = "";
const _VaMenuGroup = /* @__PURE__ */ (0, _pluginVueExportHelperJs._)((0, _vaMenuGroupVueVueTypeScriptSetupTrueLangJs._), [
    [
        "__scopeId",
        "data-v-4dd1ae9a"
    ]
]);

},{"./VaMenuGroup.vue_vue_type_script_setup_true_lang.js":"5v9xF","../../../../plugin-vue_export-helper.js":"broGc","../../../../VaMenuGroup.css":"fJG7U","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5v9xF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useColorsJs = require("../../../composables/useColors.js");
var _vaMenuGroupCss = require("../../../../VaMenuGroup.css");
const _hoisted_1 = {
    class: "va-menu-list__group-name"
};
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    name: "VaMenuGroup",
    __name: "VaMenuGroup",
    props: {
        groupName: {
            type: String,
            required: true
        },
        color: {
            type: String,
            default: "secondary"
        }
    },
    setup (__props) {
        const props = __props;
        const { getColor } = (0, _useColorsJs.u)();
        const colorComputed = (0, _vue.computed)(()=>getColor(props.color));
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), null, [
                (0, _vue.createElementVNode)("div", {
                    class: "va-menu-list__group-name-wrapper",
                    colspan: "99999",
                    style: (0, _vue.normalizeStyle)(`--va-color-computed: ${String(colorComputed.value)}`)
                }, [
                    (0, _vue.createElementVNode)("span", _hoisted_1, (0, _vue.toDisplayString)(__props.groupName), 1)
                ], 4),
                (0, _vue.renderSlot)(_ctx.$slots, "default", {
                    style: (0, _vue.normalizeStyle)(`--va-color-computed: ${String(colorComputed.value)}`)
                }, void 0, true)
            ], 64);
        };
    }
});

},{"vue":"gzxs9","../../../composables/useColors.js":"a4Qgv","../../../../VaMenuGroup.css":"fJG7U","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fJG7U":[function() {},{}],"fJG7U":[function() {},{}],"lQemv":[function() {},{}],"2aOC4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>useImmediateFocus);
var _vue = require("vue");
var _focusJs = require("../utils/focus.js");
var _unwrapElJs = require("../utils/unwrapEl.js");
const useImmediateFocus = (el)=>{
    (0, _vue.watchEffect)(()=>{
        if (el.value) (0, _vue.nextTick)(()=>{
            (0, _focusJs.a)((0, _unwrapElJs.u)(el.value));
        });
    });
};

},{"vue":"gzxs9","../utils/focus.js":"e1Xlj","../utils/unwrapEl.js":"bYHKv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ewKGs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "V", ()=>VaFormField);
var _withConfigTransportJs = require("../../services/config-transport/withConfigTransport.js");
var _vaFormFieldVueVueTypeScriptSetupTrueLangJs = require("./VaFormField.vue_vue_type_script_setup_true_lang.js");
const VaFormField = (0, _withConfigTransportJs.a)((0, _vaFormFieldVueVueTypeScriptSetupTrueLangJs._));

},{"../../services/config-transport/withConfigTransport.js":"b7Tgy","./VaFormField.vue_vue_type_script_setup_true_lang.js":"lTwKj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lTwKj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", ()=>_sfc_main);
var _vue = require("vue");
var _useValidationPropsJs = require("../../composables/useValidation.props.js");
var _useStatefulPropsJs = require("../../composables/useStateful.props.js");
var _vaMessageListJs = require("../va-message-list/VaMessageList.js");
var _useStatefulJs = require("../../composables/useStateful.js");
var _useValidationJs = require("../../composables/useValidation.js");
const _sfc_main = /* @__PURE__ */ (0, _vue.defineComponent)({
    __name: "VaFormField",
    props: /* @__PURE__ */ (0, _vue.mergeDefaults)({
        stateful: {
            type: Boolean
        },
        modelValue: {},
        name: {},
        rules: {},
        dirty: {
            type: Boolean
        },
        error: {
            type: Boolean
        },
        errorMessages: {},
        errorCount: {},
        success: {
            type: Boolean
        },
        messages: {},
        immediateValidation: {
            type: Boolean
        },
        clearValue: {}
    }, {
        ...(0, _useStatefulPropsJs.s),
        ...(0, _useValidationPropsJs.v)
    }),
    emits: [
        "update:error",
        "update:errorMessages",
        "update:dirty",
        "update:modelValue"
    ],
    setup (__props, { emit: __emit }) {
        const props = __props;
        const emit = __emit;
        const { valueComputed } = (0, _useStatefulJs.b)(props, emit, "modelValue");
        const reset = ()=>{
            valueComputed.value = props.clearValue;
        };
        const focus = ()=>{};
        const { computedError, computedErrorMessages, validate, isDirty, isLoading, isValid, resetValidation, validationAriaAttributes, listeners } = (0, _useValidationJs.a)(props, emit, {
            reset,
            focus,
            value: valueComputed
        });
        const messagesComputed = (0, _vue.computed)(()=>computedError.value ? computedErrorMessages.value : props.messages);
        const messagesColor = (0, _vue.computed)(()=>{
            if (!isValid.value) return "danger";
            if (props.success) return "success";
            return "";
        });
        const innerValue = (0, _vue.ref)(valueComputed.value);
        (0, _vue.watchEffect)(()=>{
            innerValue.value = valueComputed.value;
        });
        const makeSlotRef = ()=>{
            return new Proxy(innerValue, {
                get (v, key) {
                    if (key === "ref") return innerValue.value;
                    return Reflect.get(v, key);
                },
                set (_, key, value) {
                    if (key === "ref") {
                        innerValue.value = value;
                        valueComputed.value = value;
                        return true;
                    }
                    return Reflect.set(valueComputed, key, value);
                }
            });
        };
        return (_ctx, _cache)=>{
            return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.unref)((0, _vaMessageListJs.V)), {
                "model-value": messagesComputed.value,
                "has-error": !(0, _vue.unref)(isValid),
                color: messagesColor.value
            }, (0, _vue.createSlots)({
                default: (0, _vue.withCtx)(({ ariaAttributes, attrs })=>[
                        (0, _vue.renderSlot)(_ctx.$slots, "default", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)({
                            error: (0, _vue.unref)(computedError),
                            errorMessages: messagesComputed.value,
                            messages: messagesComputed.value,
                            validate: (0, _vue.unref)(validate),
                            isDirty: (0, _vue.unref)(isDirty),
                            isLoading: (0, _vue.unref)(isLoading),
                            isValid: (0, _vue.unref)(isValid),
                            resetValidation: (0, _vue.unref)(resetValidation),
                            validationAriaAttributes: (0, _vue.unref)(validationAriaAttributes),
                            ...(0, _vue.unref)(listeners),
                            value: makeSlotRef(),
                            modelValue: makeSlotRef(),
                            ariaAttributes,
                            bind: {
                                ...attrs,
                                ...ariaAttributes,
                                ...(0, _vue.unref)(listeners)
                            }
                        })))
                    ]),
                _: 2
            }, [
                (0, _vue.renderList)([
                    "message",
                    "messages"
                ], (name)=>{
                    return {
                        name,
                        fn: (0, _vue.withCtx)((slotScope)=>[
                                (0, _vue.renderSlot)(_ctx.$slots, name, (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(slotScope)))
                            ])
                    };
                })
            ]), 1032, [
                "model-value",
                "has-error",
                "color"
            ]);
        };
    }
});

},{"vue":"gzxs9","../../composables/useValidation.props.js":"9XcSU","../../composables/useStateful.props.js":"hUqNw","../va-message-list/VaMessageList.js":"kMkwf","../../composables/useStateful.js":"h9zUi","../../composables/useValidation.js":"iFHh2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9XcSU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "v", ()=>validationPropsDefaults);
const validationPropsDefaults = {
    rules: ()=>[],
    dirty: false,
    errorCount: 1,
    success: false,
    messages: ()=>[],
    immediateValidation: false
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hUqNw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "s", ()=>statefulPropsDefaults);
const statefulPropsDefaults = {
    stateful: false
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lUxGX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u", ()=>usePlugin);
const isPluginFabric = (plugin)=>typeof plugin === "function";
const usePlugin = (app, plugin, ...options)=>{
    if (isPluginFabric(plugin)) app.use(plugin(...options));
    else app.use(plugin);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3Snlp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require("c1eabb2df19d3cf4");
    if (script.__esModule) script = script.default;
    script.render = require("a2611b4026b811a").render;
    script.__cssModules = require("5f6824dd6b9c1f8f").default;
    require("2933b535d1ff850e").default(script);
    script.__scopeId = "data-v-565a54";
    script.__file = "/Users/jordank/Sites/tror/web/wp-content/plugins/wp-otis/assets/js/vue/components/04_templates/Dashboard.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "565a54-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("565a54-hmr", script)) __VUE_HMR_RUNTIME__.reload("565a54-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"c1eabb2df19d3cf4":"8i5c4","a2611b4026b811a":"dudkv","5f6824dd6b9c1f8f":"7TpLY","2933b535d1ff850e":"iKgNc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8i5c4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _vue = require("vue");
var _loadingIndicatorVue = require("../01_atoms/LoadingIndicator.vue");
var _loadingIndicatorVueDefault = parcelHelpers.interopDefault(_loadingIndicatorVue);
var _cardVue = require("../02_molecules/Card.vue");
var _cardVueDefault = parcelHelpers.interopDefault(_cardVue);
var _alertVue = require("../02_molecules/Alert.vue");
var _alertVueDefault = parcelHelpers.interopDefault(_alertVue);
var _modalVue = require("../02_molecules/Modal.vue");
var _modalVueDefault = parcelHelpers.interopDefault(_modalVue);
var _useApi = require("../../composables/useApi");
var _useApiDefault = parcelHelpers.interopDefault(_useApi);
var _otisConfigVue = require("../03_organisms/OtisConfig.vue");
var _otisConfigVueDefault = parcelHelpers.interopDefault(_otisConfigVue);
var _initialPOIImportVue = require("../03_organisms/InitialPOIImport.vue");
var _initialPOIImportVueDefault = parcelHelpers.interopDefault(_initialPOIImportVue);
// Refs
exports.default = {
    __name: "Dashboard",
    setup (__props, { expose: __expose }) {
        __expose();
        // Dashboard uses https://vuestic.dev/ UI Framework
        const modifiedDate = (0, _vue.ref)(new Date());
        const lastImportDate = (0, _vue.ref)("");
        const importSchedule = (0, _vue.ref)({});
        const poiCount = (0, _vue.ref)({});
        const importLog = (0, _vue.ref)([]);
        const importStarting = (0, _vue.ref)(false);
        const importStarted = (0, _vue.ref)(false);
        const importerActive = (0, _vue.ref)(false);
        const logLoading = (0, _vue.ref)(false);
        const countsLoading = (0, _vue.ref)(false);
        const activeFilters = (0, _vue.ref)([]);
        const credentials = (0, _vue.ref)({});
        const storedCredentials = (0, _vue.ref)({});
        const pendingCredentials = (0, _vue.ref)({});
        const showSyncModal = (0, _vue.ref)(false);
        const showCancelModal = (0, _vue.ref)(false);
        const showImportModal = (0, _vue.ref)(false);
        const showStopAllModal = (0, _vue.ref)(false);
        const showOtisSyncModal = (0, _vue.ref)(false);
        const { triggerAction } = (0, _useApiDefault.default)();
        const displayInitialConfig = (0, _vue.ref)(true);
        // Computed
        const lastImport = (0, _vue.computed)(()=>{
            if (!lastImportDate.value) return "N/A";
            const lastImportDateObject = new Date(lastImportDate.value);
            const month = lastImportDateObject.getMonth() + 1; // months are zero indexed
            const day = lastImportDateObject.getDate();
            const year = lastImportDateObject.getFullYear();
            const hours = lastImportDateObject.getHours();
            const minutes = lastImportDateObject.getMinutes() > 9 ? lastImportDateObject.getMinutes() : "0" + lastImportDateObject.getMinutes();
            return `${month}/${day}/${year} @ ${hours}:${minutes}`;
        });
        const nextImport = (0, _vue.computed)(()=>{
            if (!importSchedule.value) return "N/A";
            const { nextScheduledImport } = importSchedule.value;
            if (!nextScheduledImport) return "N/A";
            const nextScheduledImportTimestamp = parseInt(nextScheduledImport) * 1000;
            const nextImportDateObject = new Date(nextScheduledImportTimestamp);
            const month = nextImportDateObject.getMonth() + 1; // months are zero indexed
            const day = nextImportDateObject.getDate();
            const year = nextImportDateObject.getFullYear();
            const hours = nextImportDateObject.getHours();
            const minutes = nextImportDateObject.getMinutes() > 9 ? nextImportDateObject.getMinutes() : "0" + nextImportDateObject.getMinutes();
            return `${month}/${day}/${year} @ ${hours}:${minutes}`;
        });
        const importerStatus = (0, _vue.computed)(()=>{
            const { fetchListings, processListings, deleteListings, syncAllPoisFetch, syncAllPoisProcess, syncAllPoisImport, syncAllPoisTransient } = importSchedule.value;
            if (fetchListings) return "Fetching Listings";
            if (processListings) return "Processing Listings";
            if (deleteListings) return "Deleting Listings";
            if (syncAllPoisFetch) return "Fetching POIs for Sync All";
            if (syncAllPoisProcess) return "Processing POIs for Sync All";
            if (syncAllPoisImport) return "Importing POIs for Sync All";
            if (syncAllPoisTransient) return "Creating Transient for Sync All";
            if (importerActive.value) return "Active";
            return "Inactive";
        });
        const maxDate = (0, _vue.computed)(()=>{
            return new Date();
        });
        const displayInitialImport = (0, _vue.computed)(()=>{
            if (countsLoading.value) return false;
            let count = 0;
            for(const key in poiCount.value)if (Object.hasOwnProperty.call(poiCount.value, key)) {
                const statusCount = poiCount.value[key];
                count += parseInt(statusCount);
            }
            return count === 0;
        });
        const credentialsNeeded = (0, _vue.computed)(()=>{
            return credentials.value.username ? false : true;
        });
        const dateIsValid = (0, _vue.computed)(()=>{
            return modifiedDate.value ? true : false;
        });
        const importLogUrl = (0, _vue.computed)(()=>{
            return `${otisDash.admin_url}edit.php?post_type=poi&page=tror_poi_otis_log`;
        });
        const importActive = (0, _vue.computed)(()=>{
            const { fetchListings, processListings, deleteListings } = importSchedule.value;
            return fetchListings || processListings || deleteListings;
        });
        const syncAllActive = (0, _vue.computed)(()=>{
            const { syncAllPoisFetch, syncAllPoisProcess, syncAllPoisImport, syncAllPoisTransient } = importSchedule.value;
            return syncAllPoisFetch || syncAllPoisProcess || syncAllPoisImport || syncAllPoisTransient;
        });
        const modifiedDateString = (0, _vue.computed)(()=>{
            if (!modifiedDate.value) return "N/A";
            // Return the date in the format of MM/DD/YYYY
            const month = modifiedDate.value.getMonth() + 1; // months are zero indexed
            const day = modifiedDate.value.getDate();
            const year = modifiedDate.value.getFullYear();
            return `${month}/${day}/${year}`;
        });
        // Methods
        const poiPostsUrl = (status = null)=>{
            if (!status) return `${otisDash.admin_url}edit.php?post_type=poi`;
            return `${otisDash.admin_url}edit.php?post_status=${status}&post_type=poi`;
        };
        const notifyImportStarted = ()=>{
            importStarted.value = true;
        };
        const otisStatus = async ()=>{
            countsLoading.value = true;
            const { data } = await triggerAction("otis_status");
            Object.keys(data).forEach((key)=>{
                switch(key){
                    case "lastImportDate":
                        lastImportDate.value = data[key];
                        break;
                    case "importSchedule":
                        importSchedule.value = data[key];
                        break;
                    case "importerActive":
                        importerActive.value = data[key] === "1";
                        break;
                    case "poiCount":
                        poiCount.value = data[key];
                        break;
                    case "activeFilters":
                        activeFilters.value = data[key];
                        break;
                    case "credentials":
                        storedCredentials.value = data[key];
                        break;
                    default:
                        break;
                }
            });
            countsLoading.value = false;
            await otisLogPreview();
        };
        const otisLogPreview = async ()=>{
            logLoading.value = true;
            const { data } = await triggerAction("otis_preview_log");
            logLoading.value = false;
            importLog.value = data;
        };
        const cancelImporter = async ()=>{
            await triggerAction("otis_cancel_importer");
            await otisStatus();
        };
        const triggerInitialImport = async ()=>{
            importStarting.value = true;
            await triggerAction("otis_import", {
                initial_import: true
            });
            await otisStatus();
            importStarting.value = false;
        };
        const triggerModifiedImport = async ()=>{
            if (!dateIsValid.value) return;
            importStarting.value = true;
            const modifiedFromDate = modifiedDate.value.toISOString().split("T")[0];
            const importData = {
                from_date: modifiedFromDate
            };
            await triggerAction("otis_import", importData);
            await otisStatus();
            notifyImportStarted();
            importStarting.value = false;
        };
        const triggerSyncPois = async ()=>{
            importStarting.value = true;
            await triggerAction("otis_sync_all_pois");
            await otisStatus();
            notifyImportStarted();
            importStarting.value = false;
        };
        const triggerStopAll = async ()=>{
            await triggerAction("otis_stop_all");
            await otisStatus();
        };
        const triggerSyncOtisConfig = async ()=>{
            if (pendingCredentials.value.username && pendingCredentials.value.password) {
                credentials.value = pendingCredentials.value;
                pendingCredentials.value = {};
                await triggerAction("otis_save_credentials", credentials.value);
                await otisStatus();
            }
        };
        const cancelSyncOtisConfig = ()=>{
            pendingCredentials.value = {};
        };
        const toggleSyncConfirm = ()=>{
            showSyncModal.value = !showSyncModal.value;
        };
        const toggleConfigSyncConfirm = ()=>{
            showOtisSyncModal.value = !showOtisSyncModal.value;
        };
        const toggleCancelConfirm = ()=>{
            showCancelModal.value = !showCancelModal.value;
        };
        const toggleImportConfirm = ()=>{
            showImportModal.value = !showImportModal.value;
        };
        const toggleStopAllConfirm = ()=>{
            showStopAllModal.value = !showStopAllModal.value;
        };
        const updateCredentials = (newCredentials)=>{
            if (newCredentials.username && newCredentials.password) pendingCredentials.value = newCredentials;
        };
        // On Mount
        (0, _vue.onMounted)(async ()=>{
            await otisStatus();
            // Setup interval to check for import status
            const interval = setInterval(async ()=>{
                await otisStatus();
            }, 30000);
        });
        const __returned__ = {
            modifiedDate,
            lastImportDate,
            importSchedule,
            poiCount,
            importLog,
            importStarting,
            importStarted,
            importerActive,
            logLoading,
            countsLoading,
            activeFilters,
            credentials,
            storedCredentials,
            pendingCredentials,
            showSyncModal,
            showCancelModal,
            showImportModal,
            showStopAllModal,
            showOtisSyncModal,
            triggerAction,
            displayInitialConfig,
            lastImport,
            nextImport,
            importerStatus,
            maxDate,
            displayInitialImport,
            credentialsNeeded,
            dateIsValid,
            importLogUrl,
            importActive,
            syncAllActive,
            modifiedDateString,
            poiPostsUrl,
            notifyImportStarted,
            otisStatus,
            otisLogPreview,
            cancelImporter,
            triggerInitialImport,
            triggerModifiedImport,
            triggerSyncPois,
            triggerStopAll,
            triggerSyncOtisConfig,
            cancelSyncOtisConfig,
            toggleSyncConfirm,
            toggleConfigSyncConfirm,
            toggleCancelConfirm,
            toggleImportConfirm,
            toggleStopAllConfirm,
            updateCredentials,
            ref: (0, _vue.ref),
            computed: (0, _vue.computed),
            onMounted: (0, _vue.onMounted),
            LoadingIndicator: (0, _loadingIndicatorVueDefault.default),
            Card: (0, _cardVueDefault.default),
            Alert: (0, _alertVueDefault.default),
            Modal: (0, _modalVueDefault.default),
            get useApi () {
                return 0, _useApiDefault.default;
            },
            OtisConfig: (0, _otisConfigVueDefault.default),
            InitialPOIImport: (0, _initialPOIImportVueDefault.default)
        };
        Object.defineProperty(__returned__, "__isScriptSetup", {
            enumerable: false,
            value: true
        });
        return __returned__;
    }
};

},{"vue":"gzxs9","../01_atoms/LoadingIndicator.vue":"8RWTs","../02_molecules/Card.vue":"eZkOW","../02_molecules/Alert.vue":"cdGyZ","../02_molecules/Modal.vue":"aPaKd","../../composables/useApi":"cMhyd","../03_organisms/OtisConfig.vue":"77HTZ","../03_organisms/InitialPOIImport.vue":"5n22R","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8RWTs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require("4b20e2f234dba91b");
    if (script.__esModule) script = script.default;
    script.render = require("45c7f6643fb41eaa").render;
    require("93d112519d017dd4").default(script);
    script.__scopeId = "data-v-6a6cd7";
    script.__file = "/Users/jordank/Sites/tror/web/wp-content/plugins/wp-otis/assets/js/vue/components/01_atoms/LoadingIndicator.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "6a6cd7-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("6a6cd7-hmr", script)) __VUE_HMR_RUNTIME__.reload("6a6cd7-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"4b20e2f234dba91b":"bU4O2","45c7f6643fb41eaa":"iq5ss","93d112519d017dd4":"7zpLu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bU4O2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    name: "LoadingIndicator"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iq5ss":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
function render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_va_progress_bar = (0, _vue.resolveComponent)("va-progress-bar");
    return (0, _vue.openBlock)(), (0, _vue.createBlock)(_component_va_progress_bar, {
        indeterminate: ""
    });
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("6a6cd7-hmr", render);
});

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7zpLu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eZkOW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = {};
    script.render = require("f62dca6685dcc895").render;
    require("db5313633e66a6e8").default(script);
    script.__scopeId = "data-v-b3bc84";
    script.__file = "/Users/jordank/Sites/tror/web/wp-content/plugins/wp-otis/assets/js/vue/components/02_molecules/Card.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "b3bc84-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("b3bc84-hmr", script)) __VUE_HMR_RUNTIME__.reload("b3bc84-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"f62dca6685dcc895":"iDkF8","db5313633e66a6e8":"6hNuK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iDkF8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
function render(_ctx, _cache) {
    const _component_va_card_title = (0, _vue.resolveComponent)("va-card-title");
    const _component_va_card_content = (0, _vue.resolveComponent)("va-card-content");
    const _component_va_card_actions = (0, _vue.resolveComponent)("va-card-actions");
    const _component_va_card = (0, _vue.resolveComponent)("va-card");
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), null, [
        (0, _vue.createCommentVNode)(" Card "),
        (0, _vue.createVNode)(_component_va_card, null, {
            default: (0, _vue.withCtx)(()=>[
                    (0, _vue.createCommentVNode)(" Title "),
                    (0, _vue.createVNode)(_component_va_card_title, null, {
                        default: (0, _vue.withCtx)(()=>[
                                (0, _vue.renderSlot)(_ctx.$slots, "title")
                            ]),
                        _: 3 /* FORWARDED */ 
                    }),
                    (0, _vue.createCommentVNode)(" Content "),
                    (0, _vue.createVNode)(_component_va_card_content, null, {
                        default: (0, _vue.withCtx)(()=>[
                                (0, _vue.renderSlot)(_ctx.$slots, "content")
                            ]),
                        _: 3 /* FORWARDED */ 
                    }),
                    (0, _vue.createCommentVNode)(" Actions "),
                    (0, _vue.createVNode)(_component_va_card_actions, null, {
                        default: (0, _vue.withCtx)(()=>[
                                (0, _vue.renderSlot)(_ctx.$slots, "actions")
                            ]),
                        _: 3 /* FORWARDED */ 
                    })
                ]),
            _: 3 /* FORWARDED */ 
        })
    ], 2112 /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */ );
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("b3bc84-hmr", render);
});

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6hNuK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cdGyZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require("4cbfe64e87d1f055");
    if (script.__esModule) script = script.default;
    script.render = require("995770a342cbf561").render;
    require("8a5a4da5a32c6d3f").default(script);
    script.__scopeId = "data-v-d8ca9f";
    script.__file = "/Users/jordank/Sites/tror/web/wp-content/plugins/wp-otis/assets/js/vue/components/02_molecules/Alert.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "d8ca9f-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("d8ca9f-hmr", script)) __VUE_HMR_RUNTIME__.reload("d8ca9f-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"4cbfe64e87d1f055":"g3ppW","995770a342cbf561":"g1CDE","8a5a4da5a32c6d3f":"7dc1w","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g3ppW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    props: {
        value: {
            type: Boolean,
            default: false
        },
        color: {
            type: String,
            default: "success"
        }
    },
    methods: {
        updateValue (newValue) {
            this.$emit("update:value", newValue);
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g1CDE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
function render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_va_alert = (0, _vue.resolveComponent)("va-alert");
    return (0, _vue.openBlock)(), (0, _vue.createBlock)(_component_va_alert, {
        value: $props.value,
        onInput: $options.updateValue,
        color: $props.color,
        icon: "info",
        closeable: ""
    }, {
        default: (0, _vue.withCtx)(()=>[
                (0, _vue.createCommentVNode)(" Named slot for the alert message "),
                (0, _vue.renderSlot)(_ctx.$slots, "message")
            ]),
        _: 3 /* FORWARDED */ 
    }, 8 /* PROPS */ , [
        "value",
        "onInput",
        "color"
    ]);
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("d8ca9f-hmr", render);
});

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7dc1w":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aPaKd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require("413acda1ed0a3b28");
    if (script.__esModule) script = script.default;
    script.render = require("10a3145c8395de7c").render;
    require("23a0ce3b2cdd4643").default(script);
    script.__scopeId = "data-v-3a7730";
    script.__file = "/Users/jordank/Sites/tror/web/wp-content/plugins/wp-otis/assets/js/vue/components/02_molecules/Modal.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "3a7730-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("3a7730-hmr", script)) __VUE_HMR_RUNTIME__.reload("3a7730-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"413acda1ed0a3b28":"5I0E0","10a3145c8395de7c":"2NvkX","23a0ce3b2cdd4643":"hrX9k","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5I0E0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    props: {
        value: {
            type: Boolean,
            default: false
        },
        title: {
            type: String,
            default: ""
        },
        cancelText: {
            type: String,
            default: ""
        },
        okText: {
            type: String,
            default: ""
        },
        action: {
            type: Function,
            default: ()=>{}
        }
    },
    methods: {
        updateValue (newValue) {
            this.$emit("update:value", newValue);
        },
        triggerAction () {
            this.$emit("update:value", false);
            this.action();
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2NvkX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
function render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_va_modal = (0, _vue.resolveComponent)("va-modal");
    return (0, _vue.openBlock)(), (0, _vue.createBlock)(_component_va_modal, {
        value: $props.value,
        onInput: $options.updateValue,
        title: $props.title,
        "cancel-text": $props.cancelText,
        "ok-text": $props.okText,
        onOk: $options.triggerAction
    }, {
        default: (0, _vue.withCtx)(()=>[
                (0, _vue.createCommentVNode)(" Named slot for the modal content "),
                (0, _vue.renderSlot)(_ctx.$slots, "content")
            ]),
        _: 3 /* FORWARDED */ 
    }, 8 /* PROPS */ , [
        "value",
        "onInput",
        "title",
        "cancel-text",
        "ok-text",
        "onOk"
    ]);
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("3a7730-hmr", render);
});

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hrX9k":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cMhyd":[function(require,module,exports) {
// Composables/useApi.js
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>useApi);
var _axios = require("axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
function useApi() {
    const makePayload = (payloadData = {})=>{
        const payload = new FormData();
        Object.keys(payloadData).forEach((key)=>{
            payload.append(key, payloadData[key]);
        });
        return payload;
    };
    const triggerAction = async (action, data = {})=>{
        const payload = makePayload({
            action,
            ...data
        });
        return await (0, _axiosDefault.default).post(otisDash.ajax_url, payload, {
            timeout: 0
        });
    };
    return {
        triggerAction
    };
}

},{"axios":"jo6P5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jo6P5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>(0, _axiosJsDefault.default));
parcelHelpers.export(exports, "Axios", ()=>Axios);
parcelHelpers.export(exports, "AxiosError", ()=>AxiosError);
parcelHelpers.export(exports, "CanceledError", ()=>CanceledError);
parcelHelpers.export(exports, "isCancel", ()=>isCancel);
parcelHelpers.export(exports, "CancelToken", ()=>CancelToken);
parcelHelpers.export(exports, "VERSION", ()=>VERSION);
parcelHelpers.export(exports, "all", ()=>all);
parcelHelpers.export(exports, "Cancel", ()=>Cancel);
parcelHelpers.export(exports, "isAxiosError", ()=>isAxiosError);
parcelHelpers.export(exports, "spread", ()=>spread);
parcelHelpers.export(exports, "toFormData", ()=>toFormData);
parcelHelpers.export(exports, "AxiosHeaders", ()=>AxiosHeaders);
parcelHelpers.export(exports, "HttpStatusCode", ()=>HttpStatusCode);
parcelHelpers.export(exports, "formToJSON", ()=>formToJSON);
parcelHelpers.export(exports, "getAdapter", ()=>getAdapter);
parcelHelpers.export(exports, "mergeConfig", ()=>mergeConfig);
var _axiosJs = require("./lib/axios.js");
var _axiosJsDefault = parcelHelpers.interopDefault(_axiosJs);
// This module is intended to unwrap Axios default export as named.
// Keep top-level export same with static properties
// so that it can keep same with es module or cjs
const { Axios, AxiosError, CanceledError, isCancel, CancelToken, VERSION, all, Cancel, isAxiosError, spread, toFormData, AxiosHeaders, HttpStatusCode, formToJSON, getAdapter, mergeConfig } = (0, _axiosJsDefault.default);

},{"./lib/axios.js":"63MyY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"63MyY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _bindJs = require("./helpers/bind.js");
var _bindJsDefault = parcelHelpers.interopDefault(_bindJs);
var _axiosJs = require("./core/Axios.js");
var _axiosJsDefault = parcelHelpers.interopDefault(_axiosJs);
var _mergeConfigJs = require("./core/mergeConfig.js");
var _mergeConfigJsDefault = parcelHelpers.interopDefault(_mergeConfigJs);
var _indexJs = require("./defaults/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _formDataToJSONJs = require("./helpers/formDataToJSON.js");
var _formDataToJSONJsDefault = parcelHelpers.interopDefault(_formDataToJSONJs);
var _canceledErrorJs = require("./cancel/CanceledError.js");
var _canceledErrorJsDefault = parcelHelpers.interopDefault(_canceledErrorJs);
var _cancelTokenJs = require("./cancel/CancelToken.js");
var _cancelTokenJsDefault = parcelHelpers.interopDefault(_cancelTokenJs);
var _isCancelJs = require("./cancel/isCancel.js");
var _isCancelJsDefault = parcelHelpers.interopDefault(_isCancelJs);
var _dataJs = require("./env/data.js");
var _toFormDataJs = require("./helpers/toFormData.js");
var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
var _axiosErrorJs = require("./core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _spreadJs = require("./helpers/spread.js");
var _spreadJsDefault = parcelHelpers.interopDefault(_spreadJs);
var _isAxiosErrorJs = require("./helpers/isAxiosError.js");
var _isAxiosErrorJsDefault = parcelHelpers.interopDefault(_isAxiosErrorJs);
var _axiosHeadersJs = require("./core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
var _adaptersJs = require("./adapters/adapters.js");
var _adaptersJsDefault = parcelHelpers.interopDefault(_adaptersJs);
var _httpStatusCodeJs = require("./helpers/HttpStatusCode.js");
var _httpStatusCodeJsDefault = parcelHelpers.interopDefault(_httpStatusCodeJs);
"use strict";
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */ function createInstance(defaultConfig) {
    const context = new (0, _axiosJsDefault.default)(defaultConfig);
    const instance = (0, _bindJsDefault.default)((0, _axiosJsDefault.default).prototype.request, context);
    // Copy axios.prototype to instance
    (0, _utilsJsDefault.default).extend(instance, (0, _axiosJsDefault.default).prototype, context, {
        allOwnKeys: true
    });
    // Copy context to instance
    (0, _utilsJsDefault.default).extend(instance, context, null, {
        allOwnKeys: true
    });
    // Factory for creating new instances
    instance.create = function create(instanceConfig) {
        return createInstance((0, _mergeConfigJsDefault.default)(defaultConfig, instanceConfig));
    };
    return instance;
}
// Create the default instance to be exported
const axios = createInstance((0, _indexJsDefault.default));
// Expose Axios class to allow class inheritance
axios.Axios = (0, _axiosJsDefault.default);
// Expose Cancel & CancelToken
axios.CanceledError = (0, _canceledErrorJsDefault.default);
axios.CancelToken = (0, _cancelTokenJsDefault.default);
axios.isCancel = (0, _isCancelJsDefault.default);
axios.VERSION = (0, _dataJs.VERSION);
axios.toFormData = (0, _toFormDataJsDefault.default);
// Expose AxiosError class
axios.AxiosError = (0, _axiosErrorJsDefault.default);
// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;
// Expose all/spread
axios.all = function all(promises) {
    return Promise.all(promises);
};
axios.spread = (0, _spreadJsDefault.default);
// Expose isAxiosError
axios.isAxiosError = (0, _isAxiosErrorJsDefault.default);
// Expose mergeConfig
axios.mergeConfig = (0, _mergeConfigJsDefault.default);
axios.AxiosHeaders = (0, _axiosHeadersJsDefault.default);
axios.formToJSON = (thing)=>(0, _formDataToJSONJsDefault.default)((0, _utilsJsDefault.default).isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = (0, _adaptersJsDefault.default).getAdapter;
axios.HttpStatusCode = (0, _httpStatusCodeJsDefault.default);
axios.default = axios;
// this module should only have a default export
exports.default = axios;

},{"./utils.js":"5By4s","./helpers/bind.js":"haRQb","./core/Axios.js":"cpqD8","./core/mergeConfig.js":"b85oP","./defaults/index.js":"hXfHM","./helpers/formDataToJSON.js":"01RfH","./cancel/CanceledError.js":"9PwCG","./cancel/CancelToken.js":"45wzn","./cancel/isCancel.js":"a0VmF","./env/data.js":"h29L9","./helpers/toFormData.js":"ajoez","./core/AxiosError.js":"3u8Tl","./helpers/spread.js":"dyQ8N","./helpers/isAxiosError.js":"eyiLq","./core/AxiosHeaders.js":"cgSSx","./adapters/adapters.js":"d7JxI","./helpers/HttpStatusCode.js":"fdR61","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5By4s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _bindJs = require("./helpers/bind.js");
var _bindJsDefault = parcelHelpers.interopDefault(_bindJs);
var global = arguments[3];
"use strict";
// utils is a library of generic helper functions non-specific to axios
const { toString } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = ((cache)=>(thing)=>{
        const str = toString.call(thing);
        return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(Object.create(null));
const kindOfTest = (type)=>{
    type = type.toLowerCase();
    return (thing)=>kindOf(thing) === type;
};
const typeOfTest = (type)=>(thing)=>typeof thing === type;
/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */ const { isArray } = Array;
/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */ const isUndefined = typeOfTest("undefined");
/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */ function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */ const isArrayBuffer = kindOfTest("ArrayBuffer");
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */ function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) result = ArrayBuffer.isView(val);
    else result = val && val.buffer && isArrayBuffer(val.buffer);
    return result;
}
/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */ const isString = typeOfTest("string");
/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */ const isFunction = typeOfTest("function");
/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */ const isNumber = typeOfTest("number");
/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */ const isObject = (thing)=>thing !== null && typeof thing === "object";
/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */ const isBoolean = (thing)=>thing === true || thing === false;
/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */ const isPlainObject = (val)=>{
    if (kindOf(val) !== "object") return false;
    const prototype = getPrototypeOf(val);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */ const isDate = kindOfTest("Date");
/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */ const isFile = kindOfTest("File");
/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */ const isBlob = kindOfTest("Blob");
/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */ const isFileList = kindOfTest("FileList");
/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */ const isStream = (val)=>isObject(val) && isFunction(val.pipe);
/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */ const isFormData = (thing)=>{
    let kind;
    return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
    kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */ const isURLSearchParams = kindOfTest("URLSearchParams");
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */ const trim = (str)=>str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */ function forEach(obj, fn, { allOwnKeys = false } = {}) {
    // Don't bother if no value provided
    if (obj === null || typeof obj === "undefined") return;
    let i;
    let l;
    // Force an array if not already something iterable
    if (typeof obj !== "object") /*eslint no-param-reassign:0*/ obj = [
        obj
    ];
    if (isArray(obj)) // Iterate over array values
    for(i = 0, l = obj.length; i < l; i++)fn.call(null, obj[i], i, obj);
    else {
        // Iterate over object keys
        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys.length;
        let key;
        for(i = 0; i < len; i++){
            key = keys[i];
            fn.call(null, obj[key], key, obj);
        }
    }
}
function findKey(obj, key) {
    key = key.toLowerCase();
    const keys = Object.keys(obj);
    let i = keys.length;
    let _key;
    while(i-- > 0){
        _key = keys[i];
        if (key === _key.toLowerCase()) return _key;
    }
    return null;
}
const _global = (()=>{
    /*eslint no-undef:0*/ if (typeof globalThis !== "undefined") return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context)=>!isUndefined(context) && context !== _global;
/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */ function merge() {
    const { caseless } = isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key)=>{
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) result[targetKey] = merge(result[targetKey], val);
        else if (isPlainObject(val)) result[targetKey] = merge({}, val);
        else if (isArray(val)) result[targetKey] = val.slice();
        else result[targetKey] = val;
    };
    for(let i = 0, l = arguments.length; i < l; i++)arguments[i] && forEach(arguments[i], assignValue);
    return result;
}
/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */ const extend = (a, b, thisArg, { allOwnKeys } = {})=>{
    forEach(b, (val, key)=>{
        if (thisArg && isFunction(val)) a[key] = (0, _bindJsDefault.default)(val, thisArg);
        else a[key] = val;
    }, {
        allOwnKeys
    });
    return a;
};
/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */ const stripBOM = (content)=>{
    if (content.charCodeAt(0) === 0xFEFF) content = content.slice(1);
    return content;
};
/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */ const inherits = (constructor, superConstructor, props, descriptors)=>{
    constructor.prototype = Object.create(superConstructor.prototype, descriptors);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
};
/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */ const toFlatObject = (sourceObj, destObj, filter, propFilter)=>{
    let props;
    let i;
    let prop;
    const merged = {};
    destObj = destObj || {};
    // eslint-disable-next-line no-eq-null,eqeqeq
    if (sourceObj == null) return destObj;
    do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while(i-- > 0){
            prop = props[i];
            if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
                destObj[prop] = sourceObj[prop];
                merged[prop] = true;
            }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
    }while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
};
/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */ const endsWith = (str, searchString, position)=>{
    str = String(str);
    if (position === undefined || position > str.length) position = str.length;
    position -= searchString.length;
    const lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
};
/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */ const toArray = (thing)=>{
    if (!thing) return null;
    if (isArray(thing)) return thing;
    let i = thing.length;
    if (!isNumber(i)) return null;
    const arr = new Array(i);
    while(i-- > 0)arr[i] = thing[i];
    return arr;
};
/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */ // eslint-disable-next-line func-names
const isTypedArray = ((TypedArray)=>{
    // eslint-disable-next-line func-names
    return (thing)=>{
        return TypedArray && thing instanceof TypedArray;
    };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */ const forEachEntry = (obj, fn)=>{
    const generator = obj && obj[Symbol.iterator];
    const iterator = generator.call(obj);
    let result;
    while((result = iterator.next()) && !result.done){
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
    }
};
/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */ const matchAll = (regExp, str)=>{
    let matches;
    const arr = [];
    while((matches = regExp.exec(str)) !== null)arr.push(matches);
    return arr;
};
/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */ const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str)=>{
    return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
        return p1.toUpperCase() + p2;
    });
};
/* Creating a function that will check if an object has a property. */ const hasOwnProperty = (({ hasOwnProperty })=>(obj, prop)=>hasOwnProperty.call(obj, prop))(Object.prototype);
/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */ const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer)=>{
    const descriptors = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};
    forEach(descriptors, (descriptor, name)=>{
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) reducedDescriptors[name] = ret || descriptor;
    });
    Object.defineProperties(obj, reducedDescriptors);
};
/**
 * Makes all methods read-only
 * @param {Object} obj
 */ const freezeMethods = (obj)=>{
    reduceDescriptors(obj, (descriptor, name)=>{
        // skip restricted props in strict mode
        if (isFunction(obj) && [
            "arguments",
            "caller",
            "callee"
        ].indexOf(name) !== -1) return false;
        const value = obj[name];
        if (!isFunction(value)) return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
            descriptor.writable = false;
            return;
        }
        if (!descriptor.set) descriptor.set = ()=>{
            throw Error("Can not rewrite read-only method '" + name + "'");
        };
    });
};
const toObjectSet = (arrayOrString, delimiter)=>{
    const obj = {};
    const define = (arr)=>{
        arr.forEach((value)=>{
            obj[value] = true;
        });
    };
    isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
    return obj;
};
const noop = ()=>{};
const toFiniteNumber = (value, defaultValue)=>{
    value = +value;
    return Number.isFinite(value) ? value : defaultValue;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
    DIGIT,
    ALPHA,
    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT)=>{
    let str = "";
    const { length } = alphabet;
    while(size--)str += alphabet[Math.random() * length | 0];
    return str;
};
/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */ function isSpecCompliantForm(thing) {
    return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj)=>{
    const stack = new Array(10);
    const visit = (source, i)=>{
        if (isObject(source)) {
            if (stack.indexOf(source) >= 0) return;
            if (!("toJSON" in source)) {
                stack[i] = source;
                const target = isArray(source) ? [] : {};
                forEach(source, (value, key)=>{
                    const reducedValue = visit(value, i + 1);
                    !isUndefined(reducedValue) && (target[key] = reducedValue);
                });
                stack[i] = undefined;
                return target;
            }
        }
        return source;
    };
    return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing)=>thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
exports.default = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isBoolean,
    isObject,
    isPlainObject,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge,
    extend,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    ALPHABET,
    generateString,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable
};

},{"./helpers/bind.js":"haRQb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"haRQb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>bind);
"use strict";
function bind(fn, thisArg) {
    return function wrap() {
        return fn.apply(thisArg, arguments);
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cpqD8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _buildURLJs = require("../helpers/buildURL.js");
var _buildURLJsDefault = parcelHelpers.interopDefault(_buildURLJs);
var _interceptorManagerJs = require("./InterceptorManager.js");
var _interceptorManagerJsDefault = parcelHelpers.interopDefault(_interceptorManagerJs);
var _dispatchRequestJs = require("./dispatchRequest.js");
var _dispatchRequestJsDefault = parcelHelpers.interopDefault(_dispatchRequestJs);
var _mergeConfigJs = require("./mergeConfig.js");
var _mergeConfigJsDefault = parcelHelpers.interopDefault(_mergeConfigJs);
var _buildFullPathJs = require("./buildFullPath.js");
var _buildFullPathJsDefault = parcelHelpers.interopDefault(_buildFullPathJs);
var _validatorJs = require("../helpers/validator.js");
var _validatorJsDefault = parcelHelpers.interopDefault(_validatorJs);
var _axiosHeadersJs = require("./AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
"use strict";
const validators = (0, _validatorJsDefault.default).validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */ class Axios {
    constructor(instanceConfig){
        this.defaults = instanceConfig;
        this.interceptors = {
            request: new (0, _interceptorManagerJsDefault.default)(),
            response: new (0, _interceptorManagerJsDefault.default)()
        };
    }
    /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */ async request(configOrUrl, config) {
        try {
            return await this._request(configOrUrl, config);
        } catch (err) {
            if (err instanceof Error) {
                let dummy;
                Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
                // slice off the Error: ... line
                const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
                if (!err.stack) err.stack = stack;
                else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) err.stack += "\n" + stack;
            }
            throw err;
        }
    }
    _request(configOrUrl, config) {
        /*eslint no-param-reassign:0*/ // Allow for axios('example/url'[, config]) a la fetch API
        if (typeof configOrUrl === "string") {
            config = config || {};
            config.url = configOrUrl;
        } else config = configOrUrl || {};
        config = (0, _mergeConfigJsDefault.default)(this.defaults, config);
        const { transitional, paramsSerializer, headers } = config;
        if (transitional !== undefined) (0, _validatorJsDefault.default).assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
        if (paramsSerializer != null) {
            if ((0, _utilsJsDefault.default).isFunction(paramsSerializer)) config.paramsSerializer = {
                serialize: paramsSerializer
            };
            else (0, _validatorJsDefault.default).assertOptions(paramsSerializer, {
                encode: validators.function,
                serialize: validators.function
            }, true);
        }
        // Set config.method
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        // Flatten headers
        let contextHeaders = headers && (0, _utilsJsDefault.default).merge(headers.common, headers[config.method]);
        headers && (0, _utilsJsDefault.default).forEach([
            "delete",
            "get",
            "head",
            "post",
            "put",
            "patch",
            "common"
        ], (method)=>{
            delete headers[method];
        });
        config.headers = (0, _axiosHeadersJsDefault.default).concat(contextHeaders, headers);
        // filter out skipped interceptors
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
            if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) return;
            synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
            requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
            responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
            const chain = [
                (0, _dispatchRequestJsDefault.default).bind(this),
                undefined
            ];
            chain.unshift.apply(chain, requestInterceptorChain);
            chain.push.apply(chain, responseInterceptorChain);
            len = chain.length;
            promise = Promise.resolve(config);
            while(i < len)promise = promise.then(chain[i++], chain[i++]);
            return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        i = 0;
        while(i < len){
            const onFulfilled = requestInterceptorChain[i++];
            const onRejected = requestInterceptorChain[i++];
            try {
                newConfig = onFulfilled(newConfig);
            } catch (error) {
                onRejected.call(this, error);
                break;
            }
        }
        try {
            promise = (0, _dispatchRequestJsDefault.default).call(this, newConfig);
        } catch (error) {
            return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while(i < len)promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        return promise;
    }
    getUri(config) {
        config = (0, _mergeConfigJsDefault.default)(this.defaults, config);
        const fullPath = (0, _buildFullPathJsDefault.default)(config.baseURL, config.url);
        return (0, _buildURLJsDefault.default)(fullPath, config.params, config.paramsSerializer);
    }
}
// Provide aliases for supported request methods
(0, _utilsJsDefault.default).forEach([
    "delete",
    "get",
    "head",
    "options"
], function forEachMethodNoData(method) {
    /*eslint func-names:0*/ Axios.prototype[method] = function(url, config) {
        return this.request((0, _mergeConfigJsDefault.default)(config || {}, {
            method,
            url,
            data: (config || {}).data
        }));
    };
});
(0, _utilsJsDefault.default).forEach([
    "post",
    "put",
    "patch"
], function forEachMethodWithData(method) {
    /*eslint func-names:0*/ function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
            return this.request((0, _mergeConfigJsDefault.default)(config || {}, {
                method,
                headers: isForm ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url,
                data
            }));
        };
    }
    Axios.prototype[method] = generateHTTPMethod();
    Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
exports.default = Axios;

},{"./../utils.js":"5By4s","../helpers/buildURL.js":"3bwC2","./InterceptorManager.js":"1VRIM","./dispatchRequest.js":"6sjJ6","./mergeConfig.js":"b85oP","./buildFullPath.js":"1I5TW","../helpers/validator.js":"9vgkY","./AxiosHeaders.js":"cgSSx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3bwC2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>buildURL);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _axiosURLSearchParamsJs = require("../helpers/AxiosURLSearchParams.js");
var _axiosURLSearchParamsJsDefault = parcelHelpers.interopDefault(_axiosURLSearchParamsJs);
"use strict";
/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */ function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
    /*eslint no-param-reassign:0*/ if (!params) return url;
    const _encode = options && options.encode || encode;
    const serializeFn = options && options.serialize;
    let serializedParams;
    if (serializeFn) serializedParams = serializeFn(params, options);
    else serializedParams = (0, _utilsJsDefault.default).isURLSearchParams(params) ? params.toString() : new (0, _axiosURLSearchParamsJsDefault.default)(params, options).toString(_encode);
    if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) url = url.slice(0, hashmarkIndex);
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
}

},{"../utils.js":"5By4s","../helpers/AxiosURLSearchParams.js":"hz84m","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hz84m":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _toFormDataJs = require("./toFormData.js");
var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
"use strict";
/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */ function encode(str) {
    const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
    });
}
/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */ function AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && (0, _toFormDataJsDefault.default)(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
    this._pairs.push([
        name,
        value
    ]);
};
prototype.toString = function toString(encoder) {
    const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode);
    } : encode;
    return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
};
exports.default = AxiosURLSearchParams;

},{"./toFormData.js":"ajoez","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ajoez":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored
var _formDataJs = require("../platform/node/classes/FormData.js");
var _formDataJsDefault = parcelHelpers.interopDefault(_formDataJs);
var Buffer = require("adfd9b103875c2dd").Buffer;
"use strict";
/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */ function isVisitable(thing) {
    return (0, _utilsJsDefault.default).isPlainObject(thing) || (0, _utilsJsDefault.default).isArray(thing);
}
/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */ function removeBrackets(key) {
    return (0, _utilsJsDefault.default).endsWith(key, "[]") ? key.slice(0, -2) : key;
}
/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */ function renderKey(path, key, dots) {
    if (!path) return key;
    return path.concat(key).map(function each(token, i) {
        // eslint-disable-next-line no-param-reassign
        token = removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
    }).join(dots ? "." : "");
}
/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */ function isFlatArray(arr) {
    return (0, _utilsJsDefault.default).isArray(arr) && !arr.some(isVisitable);
}
const predicates = (0, _utilsJsDefault.default).toFlatObject((0, _utilsJsDefault.default), {}, null, function filter(prop) {
    return /^is[A-Z]/.test(prop);
});
/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/ /**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */ function toFormData(obj, formData, options) {
    if (!(0, _utilsJsDefault.default).isObject(obj)) throw new TypeError("target must be an object");
    // eslint-disable-next-line no-param-reassign
    formData = formData || new ((0, _formDataJsDefault.default) || FormData)();
    // eslint-disable-next-line no-param-reassign
    options = (0, _utilsJsDefault.default).toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
    }, false, function defined(option, source) {
        // eslint-disable-next-line no-eq-null,eqeqeq
        return !(0, _utilsJsDefault.default).isUndefined(source[option]);
    });
    const metaTokens = options.metaTokens;
    // eslint-disable-next-line no-use-before-define
    const visitor = options.visitor || defaultVisitor;
    const dots = options.dots;
    const indexes = options.indexes;
    const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && (0, _utilsJsDefault.default).isSpecCompliantForm(formData);
    if (!(0, _utilsJsDefault.default).isFunction(visitor)) throw new TypeError("visitor must be a function");
    function convertValue(value) {
        if (value === null) return "";
        if ((0, _utilsJsDefault.default).isDate(value)) return value.toISOString();
        if (!useBlob && (0, _utilsJsDefault.default).isBlob(value)) throw new (0, _axiosErrorJsDefault.default)("Blob is not supported. Use a Buffer instead.");
        if ((0, _utilsJsDefault.default).isArrayBuffer(value) || (0, _utilsJsDefault.default).isTypedArray(value)) return useBlob && typeof Blob === "function" ? new Blob([
            value
        ]) : Buffer.from(value);
        return value;
    }
    /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */ function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
            if ((0, _utilsJsDefault.default).endsWith(key, "{}")) {
                // eslint-disable-next-line no-param-reassign
                key = metaTokens ? key : key.slice(0, -2);
                // eslint-disable-next-line no-param-reassign
                value = JSON.stringify(value);
            } else if ((0, _utilsJsDefault.default).isArray(value) && isFlatArray(value) || ((0, _utilsJsDefault.default).isFileList(value) || (0, _utilsJsDefault.default).endsWith(key, "[]")) && (arr = (0, _utilsJsDefault.default).toArray(value))) {
                // eslint-disable-next-line no-param-reassign
                key = removeBrackets(key);
                arr.forEach(function each(el, index) {
                    !((0, _utilsJsDefault.default).isUndefined(el) || el === null) && formData.append(// eslint-disable-next-line no-nested-ternary
                    indexes === true ? renderKey([
                        key
                    ], index, dots) : indexes === null ? key : key + "[]", convertValue(el));
                });
                return false;
            }
        }
        if (isVisitable(value)) return true;
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
    }
    const stack = [];
    const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
    });
    function build(value, path) {
        if ((0, _utilsJsDefault.default).isUndefined(value)) return;
        if (stack.indexOf(value) !== -1) throw Error("Circular reference detected in " + path.join("."));
        stack.push(value);
        (0, _utilsJsDefault.default).forEach(value, function each(el, key) {
            const result = !((0, _utilsJsDefault.default).isUndefined(el) || el === null) && visitor.call(formData, el, (0, _utilsJsDefault.default).isString(key) ? key.trim() : key, path, exposedHelpers);
            if (result === true) build(el, path ? path.concat(key) : [
                key
            ]);
        });
        stack.pop();
    }
    if (!(0, _utilsJsDefault.default).isObject(obj)) throw new TypeError("data must be an object");
    build(obj);
    return formData;
}
exports.default = toFormData;

},{"adfd9b103875c2dd":"fCgem","../utils.js":"5By4s","../core/AxiosError.js":"3u8Tl","../platform/node/classes/FormData.js":"aFlee","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fCgem":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ "use strict";
var base64 = require("9c62938f1dccc73c");
var ieee754 = require("aceacb6a4531a9d2");
var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" // eslint-disable-line dot-notation
 ? Symbol["for"]("nodejs.util.inspect.custom") // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        var arr = new Uint8Array(1);
        var proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === "string") return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    var b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== "number") throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
    if (!Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
    var length = byteLength(string, encoding) | 0;
    var buf = createBuffer(length);
    var actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length);
    for(var i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    var buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    var x = a.length;
    var y = b.length;
    for(var i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    var i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for(i = 0; i < list.length; ++i){
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) Buffer.from(buf).copy(buffer, pos);
            else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    var len = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    var loweredCase = false;
    for(;;)switch(encoding){
        case "ascii":
        case "latin1":
        case "binary":
            return len;
        case "utf8":
        case "utf-8":
            return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return len * 2;
        case "hex":
            return len >>> 1;
        case "base64":
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    var loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return "";
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return "";
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return "";
    if (!encoding) encoding = "utf8";
    while(true)switch(encoding){
        case "hex":
            return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
            return utf8Slice(this, start, end);
        case "ascii":
            return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
            return latin1Slice(this, start, end);
        case "base64":
            return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for(var i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for(var i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for(var i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    var length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    var str = "";
    var max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for(var i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === "string") val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    var i;
    if (dir) {
        var foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            var found = true;
            for(var j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    var strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    for(var i = 0; i < length; ++i){
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = "utf8";
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    if (!encoding) encoding = "utf8";
    var loweredCase = false;
    for(;;)switch(encoding){
        case "hex":
            return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
            return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
            return asciiWrite(this, string, offset, length);
        case "base64":
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while(i < end){
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    var res = "";
    var i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function latin1Slice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = "";
    for(var i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = "";
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(var i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    var newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset + --byteLength];
    var mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    var len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== "string") throw new TypeError("encoding must be a string");
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
        if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === "number") val = val & 255;
    else if (typeof val === "boolean") val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;
    if (typeof val === "number") for(i = start; i < end; ++i)this[i] = val;
    else {
        var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        var len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// HELPER FUNCTIONS
// ================
var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split("=")[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, "");
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return "";
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + "=";
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for(var i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error("Invalid code point");
    }
    return bytes;
}
function asciiToBytes(str) {
    var byteArray = [];
    for(var i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for(var i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    for(var i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = function() {
    var alphabet = "0123456789abcdef";
    var table = new Array(256);
    for(var i = 0; i < 16; ++i){
        var i16 = i * 16;
        for(var j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();

},{"9c62938f1dccc73c":"eIiSV","aceacb6a4531a9d2":"cO95r"}],"eIiSV":[function(require,module,exports) {
"use strict";
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join("");
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + "==");
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + "=");
    }
    return parts.join("");
}

},{}],"cO95r":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"3u8Tl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */ function AxiosError(message, code, config, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
    else this.stack = new Error().stack;
    this.message = message;
    this.name = "AxiosError";
    code && (this.code = code);
    config && (this.config = config);
    request && (this.request = request);
    response && (this.response = response);
}
(0, _utilsJsDefault.default).inherits(AxiosError, Error, {
    toJSON: function toJSON() {
        return {
            // Standard
            message: this.message,
            name: this.name,
            // Microsoft
            description: this.description,
            number: this.number,
            // Mozilla
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            // Axios
            config: (0, _utilsJsDefault.default).toJSONObject(this.config),
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
        };
    }
});
const prototype = AxiosError.prototype;
const descriptors = {};
[
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
].forEach((code)=>{
    descriptors[code] = {
        value: code
    };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", {
    value: true
});
// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps)=>{
    const axiosError = Object.create(prototype);
    (0, _utilsJsDefault.default).toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
    }, (prop)=>{
        return prop !== "isAxiosError";
    });
    AxiosError.call(axiosError, error.message, code, config, request, response);
    axiosError.cause = error;
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
};
exports.default = AxiosError;

},{"../utils.js":"5By4s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aFlee":[function(require,module,exports) {
// eslint-disable-next-line strict
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = null;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1VRIM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
class InterceptorManager {
    constructor(){
        this.handlers = [];
    }
    /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */ use(fulfilled, rejected, options) {
        this.handlers.push({
            fulfilled,
            rejected,
            synchronous: options ? options.synchronous : false,
            runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
    }
    /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */ eject(id) {
        if (this.handlers[id]) this.handlers[id] = null;
    }
    /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */ clear() {
        if (this.handlers) this.handlers = [];
    }
    /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */ forEach(fn) {
        (0, _utilsJsDefault.default).forEach(this.handlers, function forEachHandler(h) {
            if (h !== null) fn(h);
        });
    }
}
exports.default = InterceptorManager;

},{"./../utils.js":"5By4s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6sjJ6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>dispatchRequest);
var _transformDataJs = require("./transformData.js");
var _transformDataJsDefault = parcelHelpers.interopDefault(_transformDataJs);
var _isCancelJs = require("../cancel/isCancel.js");
var _isCancelJsDefault = parcelHelpers.interopDefault(_isCancelJs);
var _indexJs = require("../defaults/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _canceledErrorJs = require("../cancel/CanceledError.js");
var _canceledErrorJsDefault = parcelHelpers.interopDefault(_canceledErrorJs);
var _axiosHeadersJs = require("../core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
var _adaptersJs = require("../adapters/adapters.js");
var _adaptersJsDefault = parcelHelpers.interopDefault(_adaptersJs);
"use strict";
/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */ function throwIfCancellationRequested(config) {
    if (config.cancelToken) config.cancelToken.throwIfRequested();
    if (config.signal && config.signal.aborted) throw new (0, _canceledErrorJsDefault.default)(null, config);
}
function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = (0, _axiosHeadersJsDefault.default).from(config.headers);
    // Transform request data
    config.data = (0, _transformDataJsDefault.default).call(config, config.transformRequest);
    if ([
        "post",
        "put",
        "patch"
    ].indexOf(config.method) !== -1) config.headers.setContentType("application/x-www-form-urlencoded", false);
    const adapter = (0, _adaptersJsDefault.default).getAdapter(config.adapter || (0, _indexJsDefault.default).adapter);
    return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        // Transform response data
        response.data = (0, _transformDataJsDefault.default).call(config, config.transformResponse, response);
        response.headers = (0, _axiosHeadersJsDefault.default).from(response.headers);
        return response;
    }, function onAdapterRejection(reason) {
        if (!(0, _isCancelJsDefault.default)(reason)) {
            throwIfCancellationRequested(config);
            // Transform response data
            if (reason && reason.response) {
                reason.response.data = (0, _transformDataJsDefault.default).call(config, config.transformResponse, reason.response);
                reason.response.headers = (0, _axiosHeadersJsDefault.default).from(reason.response.headers);
            }
        }
        return Promise.reject(reason);
    });
}

},{"./transformData.js":"eRqJY","../cancel/isCancel.js":"a0VmF","../defaults/index.js":"hXfHM","../cancel/CanceledError.js":"9PwCG","../core/AxiosHeaders.js":"cgSSx","../adapters/adapters.js":"d7JxI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eRqJY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>transformData);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _indexJs = require("../defaults/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _axiosHeadersJs = require("../core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
"use strict";
function transformData(fns, response) {
    const config = this || (0, _indexJsDefault.default);
    const context = response || config;
    const headers = (0, _axiosHeadersJsDefault.default).from(context.headers);
    let data = context.data;
    (0, _utilsJsDefault.default).forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
    });
    headers.normalize();
    return data;
}

},{"./../utils.js":"5By4s","../defaults/index.js":"hXfHM","../core/AxiosHeaders.js":"cgSSx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hXfHM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _transitionalJs = require("./transitional.js");
var _transitionalJsDefault = parcelHelpers.interopDefault(_transitionalJs);
var _toFormDataJs = require("../helpers/toFormData.js");
var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
var _toURLEncodedFormJs = require("../helpers/toURLEncodedForm.js");
var _toURLEncodedFormJsDefault = parcelHelpers.interopDefault(_toURLEncodedFormJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _formDataToJSONJs = require("../helpers/formDataToJSON.js");
var _formDataToJSONJsDefault = parcelHelpers.interopDefault(_formDataToJSONJs);
"use strict";
/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */ function stringifySafely(rawValue, parser, encoder) {
    if ((0, _utilsJsDefault.default).isString(rawValue)) try {
        (parser || JSON.parse)(rawValue);
        return (0, _utilsJsDefault.default).trim(rawValue);
    } catch (e) {
        if (e.name !== "SyntaxError") throw e;
    }
    return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
    transitional: (0, _transitionalJsDefault.default),
    adapter: [
        "xhr",
        "http"
    ],
    transformRequest: [
        function transformRequest(data, headers) {
            const contentType = headers.getContentType() || "";
            const hasJSONContentType = contentType.indexOf("application/json") > -1;
            const isObjectPayload = (0, _utilsJsDefault.default).isObject(data);
            if (isObjectPayload && (0, _utilsJsDefault.default).isHTMLForm(data)) data = new FormData(data);
            const isFormData = (0, _utilsJsDefault.default).isFormData(data);
            if (isFormData) return hasJSONContentType ? JSON.stringify((0, _formDataToJSONJsDefault.default)(data)) : data;
            if ((0, _utilsJsDefault.default).isArrayBuffer(data) || (0, _utilsJsDefault.default).isBuffer(data) || (0, _utilsJsDefault.default).isStream(data) || (0, _utilsJsDefault.default).isFile(data) || (0, _utilsJsDefault.default).isBlob(data)) return data;
            if ((0, _utilsJsDefault.default).isArrayBufferView(data)) return data.buffer;
            if ((0, _utilsJsDefault.default).isURLSearchParams(data)) {
                headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
                return data.toString();
            }
            let isFileList;
            if (isObjectPayload) {
                if (contentType.indexOf("application/x-www-form-urlencoded") > -1) return (0, _toURLEncodedFormJsDefault.default)(data, this.formSerializer).toString();
                if ((isFileList = (0, _utilsJsDefault.default).isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
                    const _FormData = this.env && this.env.FormData;
                    return (0, _toFormDataJsDefault.default)(isFileList ? {
                        "files[]": data
                    } : data, _FormData && new _FormData(), this.formSerializer);
                }
            }
            if (isObjectPayload || hasJSONContentType) {
                headers.setContentType("application/json", false);
                return stringifySafely(data);
            }
            return data;
        }
    ],
    transformResponse: [
        function transformResponse(data) {
            const transitional = this.transitional || defaults.transitional;
            const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
            const JSONRequested = this.responseType === "json";
            if (data && (0, _utilsJsDefault.default).isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
                const silentJSONParsing = transitional && transitional.silentJSONParsing;
                const strictJSONParsing = !silentJSONParsing && JSONRequested;
                try {
                    return JSON.parse(data);
                } catch (e) {
                    if (strictJSONParsing) {
                        if (e.name === "SyntaxError") throw (0, _axiosErrorJsDefault.default).from(e, (0, _axiosErrorJsDefault.default).ERR_BAD_RESPONSE, this, null, this.response);
                        throw e;
                    }
                }
            }
            return data;
        }
    ],
    /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */ timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: (0, _indexJsDefault.default).classes.FormData,
        Blob: (0, _indexJsDefault.default).classes.Blob
    },
    validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
    },
    headers: {
        common: {
            "Accept": "application/json, text/plain, */*",
            "Content-Type": undefined
        }
    }
};
(0, _utilsJsDefault.default).forEach([
    "delete",
    "get",
    "head",
    "post",
    "put",
    "patch"
], (method)=>{
    defaults.headers[method] = {};
});
exports.default = defaults;

},{"../utils.js":"5By4s","../core/AxiosError.js":"3u8Tl","./transitional.js":"lM32f","../helpers/toFormData.js":"ajoez","../helpers/toURLEncodedForm.js":"9hjry","../platform/index.js":"7tDev","../helpers/formDataToJSON.js":"01RfH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lM32f":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
exports.default = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9hjry":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>toURLEncodedForm);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _toFormDataJs = require("./toFormData.js");
var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
"use strict";
function toURLEncodedForm(data, options) {
    return (0, _toFormDataJsDefault.default)(data, new (0, _indexJsDefault.default).classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path, helpers) {
            if ((0, _indexJsDefault.default).isNode && (0, _utilsJsDefault.default).isBuffer(value)) {
                this.append(key, value.toString("base64"));
                return false;
            }
            return helpers.defaultVisitor.apply(this, arguments);
        }
    }, options));
}

},{"../utils.js":"5By4s","./toFormData.js":"ajoez","../platform/index.js":"7tDev","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7tDev":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./node/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _utilsJs = require("./common/utils.js");
exports.default = {
    ..._utilsJs,
    ...(0, _indexJsDefault.default)
};

},{"./node/index.js":"cVeqE","./common/utils.js":"iIwkL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cVeqE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _urlsearchParamsJs = require("./classes/URLSearchParams.js");
var _urlsearchParamsJsDefault = parcelHelpers.interopDefault(_urlsearchParamsJs);
var _formDataJs = require("./classes/FormData.js");
var _formDataJsDefault = parcelHelpers.interopDefault(_formDataJs);
var _blobJs = require("./classes/Blob.js");
var _blobJsDefault = parcelHelpers.interopDefault(_blobJs);
exports.default = {
    isBrowser: true,
    classes: {
        URLSearchParams: (0, _urlsearchParamsJsDefault.default),
        FormData: (0, _formDataJsDefault.default),
        Blob: (0, _blobJsDefault.default)
    },
    protocols: [
        "http",
        "https",
        "file",
        "blob",
        "url",
        "data"
    ]
};

},{"./classes/URLSearchParams.js":"5cIHE","./classes/FormData.js":"7i1jd","./classes/Blob.js":"8chF6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5cIHE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _axiosURLSearchParamsJs = require("../../../helpers/AxiosURLSearchParams.js");
var _axiosURLSearchParamsJsDefault = parcelHelpers.interopDefault(_axiosURLSearchParamsJs);
"use strict";
exports.default = typeof URLSearchParams !== "undefined" ? URLSearchParams : (0, _axiosURLSearchParamsJsDefault.default);

},{"../../../helpers/AxiosURLSearchParams.js":"hz84m","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7i1jd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
exports.default = typeof FormData !== "undefined" ? FormData : null;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8chF6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
exports.default = typeof Blob !== "undefined" ? Blob : null;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iIwkL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hasBrowserEnv", ()=>hasBrowserEnv);
parcelHelpers.export(exports, "hasStandardBrowserWebWorkerEnv", ()=>hasStandardBrowserWebWorkerEnv);
parcelHelpers.export(exports, "hasStandardBrowserEnv", ()=>hasStandardBrowserEnv);
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */ const hasStandardBrowserEnv = ((product)=>{
    return hasBrowserEnv && [
        "ReactNative",
        "NativeScript",
        "NS"
    ].indexOf(product) < 0;
})(typeof navigator !== "undefined" && navigator.product);
/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */ const hasStandardBrowserWebWorkerEnv = (()=>{
    return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"01RfH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */ function parsePropPath(name) {
    // foo[x][y][z]
    // foo.x.y.z
    // foo-x-y-z
    // foo x y z
    return (0, _utilsJsDefault.default).matchAll(/\w+|\[(\w*)]/g, name).map((match)=>{
        return match[0] === "[]" ? "" : match[1] || match[0];
    });
}
/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */ function arrayToObject(arr) {
    const obj = {};
    const keys = Object.keys(arr);
    let i;
    const len = keys.length;
    let key;
    for(i = 0; i < len; i++){
        key = keys[i];
        obj[key] = arr[key];
    }
    return obj;
}
/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */ function formDataToJSON(formData) {
    function buildPath(path, value, target, index) {
        let name = path[index++];
        if (name === "__proto__") return true;
        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path.length;
        name = !name && (0, _utilsJsDefault.default).isArray(target) ? target.length : name;
        if (isLast) {
            if ((0, _utilsJsDefault.default).hasOwnProp(target, name)) target[name] = [
                target[name],
                value
            ];
            else target[name] = value;
            return !isNumericKey;
        }
        if (!target[name] || !(0, _utilsJsDefault.default).isObject(target[name])) target[name] = [];
        const result = buildPath(path, value, target[name], index);
        if (result && (0, _utilsJsDefault.default).isArray(target[name])) target[name] = arrayToObject(target[name]);
        return !isNumericKey;
    }
    if ((0, _utilsJsDefault.default).isFormData(formData) && (0, _utilsJsDefault.default).isFunction(formData.entries)) {
        const obj = {};
        (0, _utilsJsDefault.default).forEachEntry(formData, (name, value)=>{
            buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
    }
    return null;
}
exports.default = formDataToJSON;

},{"../utils.js":"5By4s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cgSSx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _parseHeadersJs = require("../helpers/parseHeaders.js");
var _parseHeadersJsDefault = parcelHelpers.interopDefault(_parseHeadersJs);
"use strict";
const $internals = Symbol("internals");
function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
    if (value === false || value == null) return value;
    return (0, _utilsJsDefault.default).isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
    const tokens = Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match;
    while(match = tokensRE.exec(str))tokens[match[1]] = match[2];
    return tokens;
}
const isValidHeaderName = (str)=>/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
    if ((0, _utilsJsDefault.default).isFunction(filter)) return filter.call(this, value, header);
    if (isHeaderNameFilter) value = header;
    if (!(0, _utilsJsDefault.default).isString(value)) return;
    if ((0, _utilsJsDefault.default).isString(filter)) return value.indexOf(filter) !== -1;
    if ((0, _utilsJsDefault.default).isRegExp(filter)) return filter.test(value);
}
function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str)=>{
        return char.toUpperCase() + str;
    });
}
function buildAccessors(obj, header) {
    const accessorName = (0, _utilsJsDefault.default).toCamelCase(" " + header);
    [
        "get",
        "set",
        "has"
    ].forEach((methodName)=>{
        Object.defineProperty(obj, methodName + accessorName, {
            value: function(arg1, arg2, arg3) {
                return this[methodName].call(this, header, arg1, arg2, arg3);
            },
            configurable: true
        });
    });
}
class AxiosHeaders {
    constructor(headers){
        headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
        const self = this;
        function setHeader(_value, _header, _rewrite) {
            const lHeader = normalizeHeader(_header);
            if (!lHeader) throw new Error("header name must be a non-empty string");
            const key = (0, _utilsJsDefault.default).findKey(self, lHeader);
            if (!key || self[key] === undefined || _rewrite === true || _rewrite === undefined && self[key] !== false) self[key || _header] = normalizeValue(_value);
        }
        const setHeaders = (headers, _rewrite)=>(0, _utilsJsDefault.default).forEach(headers, (_value, _header)=>setHeader(_value, _header, _rewrite));
        if ((0, _utilsJsDefault.default).isPlainObject(header) || header instanceof this.constructor) setHeaders(header, valueOrRewrite);
        else if ((0, _utilsJsDefault.default).isString(header) && (header = header.trim()) && !isValidHeaderName(header)) setHeaders((0, _parseHeadersJsDefault.default)(header), valueOrRewrite);
        else header != null && setHeader(valueOrRewrite, header, rewrite);
        return this;
    }
    get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
            const key = (0, _utilsJsDefault.default).findKey(this, header);
            if (key) {
                const value = this[key];
                if (!parser) return value;
                if (parser === true) return parseTokens(value);
                if ((0, _utilsJsDefault.default).isFunction(parser)) return parser.call(this, value, key);
                if ((0, _utilsJsDefault.default).isRegExp(parser)) return parser.exec(value);
                throw new TypeError("parser must be boolean|regexp|function");
            }
        }
    }
    has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
            const key = (0, _utilsJsDefault.default).findKey(this, header);
            return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
    }
    delete(header, matcher) {
        const self = this;
        let deleted = false;
        function deleteHeader(_header) {
            _header = normalizeHeader(_header);
            if (_header) {
                const key = (0, _utilsJsDefault.default).findKey(self, _header);
                if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
                    delete self[key];
                    deleted = true;
                }
            }
        }
        if ((0, _utilsJsDefault.default).isArray(header)) header.forEach(deleteHeader);
        else deleteHeader(header);
        return deleted;
    }
    clear(matcher) {
        const keys = Object.keys(this);
        let i = keys.length;
        let deleted = false;
        while(i--){
            const key = keys[i];
            if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
                delete this[key];
                deleted = true;
            }
        }
        return deleted;
    }
    normalize(format) {
        const self = this;
        const headers = {};
        (0, _utilsJsDefault.default).forEach(this, (value, header)=>{
            const key = (0, _utilsJsDefault.default).findKey(headers, header);
            if (key) {
                self[key] = normalizeValue(value);
                delete self[header];
                return;
            }
            const normalized = format ? formatHeader(header) : String(header).trim();
            if (normalized !== header) delete self[header];
            self[normalized] = normalizeValue(value);
            headers[normalized] = true;
        });
        return this;
    }
    concat(...targets) {
        return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
        const obj = Object.create(null);
        (0, _utilsJsDefault.default).forEach(this, (value, header)=>{
            value != null && value !== false && (obj[header] = asStrings && (0, _utilsJsDefault.default).isArray(value) ? value.join(", ") : value);
        });
        return obj;
    }
    [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
        return Object.entries(this.toJSON()).map(([header, value])=>header + ": " + value).join("\n");
    }
    get [Symbol.toStringTag]() {
        return "AxiosHeaders";
    }
    static from(thing) {
        return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target)=>computed.set(target));
        return computed;
    }
    static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
            accessors: {}
        };
        const accessors = internals.accessors;
        const prototype = this.prototype;
        function defineAccessor(_header) {
            const lHeader = normalizeHeader(_header);
            if (!accessors[lHeader]) {
                buildAccessors(prototype, _header);
                accessors[lHeader] = true;
            }
        }
        (0, _utilsJsDefault.default).isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
    }
}
AxiosHeaders.accessor([
    "Content-Type",
    "Content-Length",
    "Accept",
    "Accept-Encoding",
    "User-Agent",
    "Authorization"
]);
// reserved names hotfix
(0, _utilsJsDefault.default).reduceDescriptors(AxiosHeaders.prototype, ({ value }, key)=>{
    let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
    return {
        get: ()=>value,
        set (headerValue) {
            this[mapped] = headerValue;
        }
    };
});
(0, _utilsJsDefault.default).freezeMethods(AxiosHeaders);
exports.default = AxiosHeaders;

},{"../utils.js":"5By4s","../helpers/parseHeaders.js":"kqDd5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kqDd5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = (0, _utilsJsDefault.default).toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
]);
/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */ exports.default = (rawHeaders)=>{
    const parsed = {};
    let key;
    let val;
    let i;
    rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) return;
        if (key === "set-cookie") {
            if (parsed[key]) parsed[key].push(val);
            else parsed[key] = [
                val
            ];
        } else parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    });
    return parsed;
};

},{"./../utils.js":"5By4s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a0VmF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isCancel);
"use strict";
function isCancel(value) {
    return !!(value && value.__CANCEL__);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9PwCG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */ function CanceledError(message, config, request) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    (0, _axiosErrorJsDefault.default).call(this, message == null ? "canceled" : message, (0, _axiosErrorJsDefault.default).ERR_CANCELED, config, request);
    this.name = "CanceledError";
}
(0, _utilsJsDefault.default).inherits(CanceledError, (0, _axiosErrorJsDefault.default), {
    __CANCEL__: true
});
exports.default = CanceledError;

},{"../core/AxiosError.js":"3u8Tl","../utils.js":"5By4s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d7JxI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _httpJs = require("./http.js");
var _httpJsDefault = parcelHelpers.interopDefault(_httpJs);
var _xhrJs = require("./xhr.js");
var _xhrJsDefault = parcelHelpers.interopDefault(_xhrJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
const knownAdapters = {
    http: (0, _httpJsDefault.default),
    xhr: (0, _xhrJsDefault.default)
};
(0, _utilsJsDefault.default).forEach(knownAdapters, (fn, value)=>{
    if (fn) {
        try {
            Object.defineProperty(fn, "name", {
                value
            });
        } catch (e) {
        // eslint-disable-next-line no-empty
        }
        Object.defineProperty(fn, "adapterName", {
            value
        });
    }
});
const renderReason = (reason)=>`- ${reason}`;
const isResolvedHandle = (adapter)=>(0, _utilsJsDefault.default).isFunction(adapter) || adapter === null || adapter === false;
exports.default = {
    getAdapter: (adapters)=>{
        adapters = (0, _utilsJsDefault.default).isArray(adapters) ? adapters : [
            adapters
        ];
        const { length } = adapters;
        let nameOrAdapter;
        let adapter;
        const rejectedReasons = {};
        for(let i = 0; i < length; i++){
            nameOrAdapter = adapters[i];
            let id;
            adapter = nameOrAdapter;
            if (!isResolvedHandle(nameOrAdapter)) {
                adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
                if (adapter === undefined) throw new (0, _axiosErrorJsDefault.default)(`Unknown adapter '${id}'`);
            }
            if (adapter) break;
            rejectedReasons[id || "#" + i] = adapter;
        }
        if (!adapter) {
            const reasons = Object.entries(rejectedReasons).map(([id, state])=>`adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build"));
            let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
            throw new (0, _axiosErrorJsDefault.default)(`There is no suitable adapter to dispatch the request ` + s, "ERR_NOT_SUPPORT");
        }
        return adapter;
    },
    adapters: knownAdapters
};

},{"../utils.js":"5By4s","./http.js":"aFlee","./xhr.js":"ldm57","../core/AxiosError.js":"3u8Tl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ldm57":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _settleJs = require("./../core/settle.js");
var _settleJsDefault = parcelHelpers.interopDefault(_settleJs);
var _cookiesJs = require("./../helpers/cookies.js");
var _cookiesJsDefault = parcelHelpers.interopDefault(_cookiesJs);
var _buildURLJs = require("./../helpers/buildURL.js");
var _buildURLJsDefault = parcelHelpers.interopDefault(_buildURLJs);
var _buildFullPathJs = require("../core/buildFullPath.js");
var _buildFullPathJsDefault = parcelHelpers.interopDefault(_buildFullPathJs);
var _isURLSameOriginJs = require("./../helpers/isURLSameOrigin.js");
var _isURLSameOriginJsDefault = parcelHelpers.interopDefault(_isURLSameOriginJs);
var _transitionalJs = require("../defaults/transitional.js");
var _transitionalJsDefault = parcelHelpers.interopDefault(_transitionalJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _canceledErrorJs = require("../cancel/CanceledError.js");
var _canceledErrorJsDefault = parcelHelpers.interopDefault(_canceledErrorJs);
var _parseProtocolJs = require("../helpers/parseProtocol.js");
var _parseProtocolJsDefault = parcelHelpers.interopDefault(_parseProtocolJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _axiosHeadersJs = require("../core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
var _speedometerJs = require("../helpers/speedometer.js");
var _speedometerJsDefault = parcelHelpers.interopDefault(_speedometerJs);
"use strict";
function progressEventReducer(listener, isDownloadStream) {
    let bytesNotified = 0;
    const _speedometer = (0, _speedometerJsDefault.default)(50, 250);
    return (e)=>{
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : undefined;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
            loaded,
            total,
            progress: total ? loaded / total : undefined,
            bytes: progressBytes,
            rate: rate ? rate : undefined,
            estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
            event: e
        };
        data[isDownloadStream ? "download" : "upload"] = true;
        listener(data);
    };
}
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
exports.default = isXHRAdapterSupported && function(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
        let requestData = config.data;
        const requestHeaders = (0, _axiosHeadersJsDefault.default).from(config.headers).normalize();
        let { responseType, withXSRFToken } = config;
        let onCanceled;
        function done() {
            if (config.cancelToken) config.cancelToken.unsubscribe(onCanceled);
            if (config.signal) config.signal.removeEventListener("abort", onCanceled);
        }
        let contentType;
        if ((0, _utilsJsDefault.default).isFormData(requestData)) {
            if ((0, _indexJsDefault.default).hasStandardBrowserEnv || (0, _indexJsDefault.default).hasStandardBrowserWebWorkerEnv) requestHeaders.setContentType(false); // Let the browser set it
            else if ((contentType = requestHeaders.getContentType()) !== false) {
                // fix semicolon duplication issue for ReactNative FormData implementation
                const [type, ...tokens] = contentType ? contentType.split(";").map((token)=>token.trim()).filter(Boolean) : [];
                requestHeaders.setContentType([
                    type || "multipart/form-data",
                    ...tokens
                ].join("; "));
            }
        }
        let request = new XMLHttpRequest();
        // HTTP basic authentication
        if (config.auth) {
            const username = config.auth.username || "";
            const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
            requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
        }
        const fullPath = (0, _buildFullPathJsDefault.default)(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), (0, _buildURLJsDefault.default)(fullPath, config.params, config.paramsSerializer), true);
        // Set the request timeout in MS
        request.timeout = config.timeout;
        function onloadend() {
            if (!request) return;
            // Prepare the response
            const responseHeaders = (0, _axiosHeadersJsDefault.default).from("getAllResponseHeaders" in request && request.getAllResponseHeaders());
            const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
            const response = {
                data: responseData,
                status: request.status,
                statusText: request.statusText,
                headers: responseHeaders,
                config,
                request
            };
            (0, _settleJsDefault.default)(function _resolve(value) {
                resolve(value);
                done();
            }, function _reject(err) {
                reject(err);
                done();
            }, response);
            // Clean up request
            request = null;
        }
        if ("onloadend" in request) // Use onloadend if available
        request.onloadend = onloadend;
        else // Listen for ready state to emulate onloadend
        request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) return;
            // The request errored out and we didn't get a response, this will be
            // handled by onerror instead
            // With one exception: request that using file: protocol, most browsers
            // will return status as 0 even though it's a successful request
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) return;
            // readystate handler is calling before onerror or ontimeout handlers,
            // so we should call onloadend on the next 'tick'
            setTimeout(onloadend);
        };
        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
            if (!request) return;
            reject(new (0, _axiosErrorJsDefault.default)("Request aborted", (0, _axiosErrorJsDefault.default).ECONNABORTED, config, request));
            // Clean up request
            request = null;
        };
        // Handle low level network errors
        request.onerror = function handleError() {
            // Real errors are hidden from us by the browser
            // onerror should only fire if it's a network error
            reject(new (0, _axiosErrorJsDefault.default)("Network Error", (0, _axiosErrorJsDefault.default).ERR_NETWORK, config, request));
            // Clean up request
            request = null;
        };
        // Handle timeout
        request.ontimeout = function handleTimeout() {
            let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
            const transitional = config.transitional || (0, _transitionalJsDefault.default);
            if (config.timeoutErrorMessage) timeoutErrorMessage = config.timeoutErrorMessage;
            reject(new (0, _axiosErrorJsDefault.default)(timeoutErrorMessage, transitional.clarifyTimeoutError ? (0, _axiosErrorJsDefault.default).ETIMEDOUT : (0, _axiosErrorJsDefault.default).ECONNABORTED, config, request));
            // Clean up request
            request = null;
        };
        // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.
        if ((0, _indexJsDefault.default).hasStandardBrowserEnv) {
            withXSRFToken && (0, _utilsJsDefault.default).isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
            if (withXSRFToken || withXSRFToken !== false && (0, _isURLSameOriginJsDefault.default)(fullPath)) {
                // Add xsrf header
                const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && (0, _cookiesJsDefault.default).read(config.xsrfCookieName);
                if (xsrfValue) requestHeaders.set(config.xsrfHeaderName, xsrfValue);
            }
        }
        // Remove Content-Type if data is undefined
        requestData === undefined && requestHeaders.setContentType(null);
        // Add headers to the request
        if ("setRequestHeader" in request) (0, _utilsJsDefault.default).forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
        });
        // Add withCredentials to request if needed
        if (!(0, _utilsJsDefault.default).isUndefined(config.withCredentials)) request.withCredentials = !!config.withCredentials;
        // Add responseType to request if needed
        if (responseType && responseType !== "json") request.responseType = config.responseType;
        // Handle progress if needed
        if (typeof config.onDownloadProgress === "function") request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
        // Not all browsers support upload events
        if (typeof config.onUploadProgress === "function" && request.upload) request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
        if (config.cancelToken || config.signal) {
            // Handle cancellation
            // eslint-disable-next-line func-names
            onCanceled = (cancel)=>{
                if (!request) return;
                reject(!cancel || cancel.type ? new (0, _canceledErrorJsDefault.default)(null, config, request) : cancel);
                request.abort();
                request = null;
            };
            config.cancelToken && config.cancelToken.subscribe(onCanceled);
            if (config.signal) config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
        }
        const protocol = (0, _parseProtocolJsDefault.default)(fullPath);
        if (protocol && (0, _indexJsDefault.default).protocols.indexOf(protocol) === -1) {
            reject(new (0, _axiosErrorJsDefault.default)("Unsupported protocol " + protocol + ":", (0, _axiosErrorJsDefault.default).ERR_BAD_REQUEST, config));
            return;
        }
        // Send the request
        request.send(requestData || null);
    });
};

},{"./../utils.js":"5By4s","./../core/settle.js":"dD9aC","./../helpers/cookies.js":"4WJjt","./../helpers/buildURL.js":"3bwC2","../core/buildFullPath.js":"1I5TW","./../helpers/isURLSameOrigin.js":"lxXtv","../defaults/transitional.js":"lM32f","../core/AxiosError.js":"3u8Tl","../cancel/CanceledError.js":"9PwCG","../helpers/parseProtocol.js":"7NfWU","../platform/index.js":"7tDev","../core/AxiosHeaders.js":"cgSSx","../helpers/speedometer.js":"gQeo1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dD9aC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>settle);
var _axiosErrorJs = require("./AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
"use strict";
function settle(resolve, reject, response) {
    const validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) resolve(response);
    else reject(new (0, _axiosErrorJsDefault.default)("Request failed with status code " + response.status, [
        (0, _axiosErrorJsDefault.default).ERR_BAD_REQUEST,
        (0, _axiosErrorJsDefault.default).ERR_BAD_RESPONSE
    ][Math.floor(response.status / 100) - 4], response.config, response.request, response));
}

},{"./AxiosError.js":"3u8Tl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4WJjt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
exports.default = (0, _indexJsDefault.default).hasStandardBrowserEnv ? // Standard browser envs support document.cookie
{
    write (name, value, expires, path, domain, secure) {
        const cookie = [
            name + "=" + encodeURIComponent(value)
        ];
        (0, _utilsJsDefault.default).isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
        (0, _utilsJsDefault.default).isString(path) && cookie.push("path=" + path);
        (0, _utilsJsDefault.default).isString(domain) && cookie.push("domain=" + domain);
        secure === true && cookie.push("secure");
        document.cookie = cookie.join("; ");
    },
    read (name) {
        const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
    },
    remove (name) {
        this.write(name, "", Date.now() - 86400000);
    }
} : // Non-standard browser env (web workers, react-native) lack needed support.
{
    write () {},
    read () {
        return null;
    },
    remove () {}
};

},{"./../utils.js":"5By4s","../platform/index.js":"7tDev","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1I5TW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>buildFullPath);
var _isAbsoluteURLJs = require("../helpers/isAbsoluteURL.js");
var _isAbsoluteURLJsDefault = parcelHelpers.interopDefault(_isAbsoluteURLJs);
var _combineURLsJs = require("../helpers/combineURLs.js");
var _combineURLsJsDefault = parcelHelpers.interopDefault(_combineURLsJs);
"use strict";
function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !(0, _isAbsoluteURLJsDefault.default)(requestedURL)) return (0, _combineURLsJsDefault.default)(baseURL, requestedURL);
    return requestedURL;
}

},{"../helpers/isAbsoluteURL.js":"jD6NM","../helpers/combineURLs.js":"brOWK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jD6NM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isAbsoluteURL);
"use strict";
function isAbsoluteURL(url) {
    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    // by any combination of letters, digits, plus, period, or hyphen.
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"brOWK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>combineURLs);
"use strict";
function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lxXtv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
"use strict";
exports.default = (0, _indexJsDefault.default).hasStandardBrowserEnv ? // Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    /**
    * Parse a URL to discover its components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */ function resolveURL(url) {
        let href = url;
        if (msie) {
            // IE needs attribute set twice to normalize properties
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
    }
    originURL = resolveURL(window.location.href);
    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */ return function isURLSameOrigin(requestURL) {
        const parsed = (0, _utilsJsDefault.default).isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
}() : // Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
        return true;
    };
}();

},{"./../utils.js":"5By4s","../platform/index.js":"7tDev","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7NfWU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>parseProtocol);
"use strict";
function parseProtocol(url) {
    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || "";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gQeo1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */ function speedometer(samplesCount, min) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min = min !== undefined ? min : 1000;
    return function push(chunkLength) {
        const now = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) firstSampleTS = now;
        bytes[head] = chunkLength;
        timestamps[head] = now;
        let i = tail;
        let bytesCount = 0;
        while(i !== head){
            bytesCount += bytes[i++];
            i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) tail = (tail + 1) % samplesCount;
        if (now - firstSampleTS < min) return;
        const passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
    };
}
exports.default = speedometer;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b85oP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>mergeConfig);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _axiosHeadersJs = require("./AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
"use strict";
const headersToObject = (thing)=>thing instanceof (0, _axiosHeadersJsDefault.default) ? {
        ...thing
    } : thing;
function mergeConfig(config1, config2) {
    // eslint-disable-next-line no-param-reassign
    config2 = config2 || {};
    const config = {};
    function getMergedValue(target, source, caseless) {
        if ((0, _utilsJsDefault.default).isPlainObject(target) && (0, _utilsJsDefault.default).isPlainObject(source)) return (0, _utilsJsDefault.default).merge.call({
            caseless
        }, target, source);
        else if ((0, _utilsJsDefault.default).isPlainObject(source)) return (0, _utilsJsDefault.default).merge({}, source);
        else if ((0, _utilsJsDefault.default).isArray(source)) return source.slice();
        return source;
    }
    // eslint-disable-next-line consistent-return
    function mergeDeepProperties(a, b, caseless) {
        if (!(0, _utilsJsDefault.default).isUndefined(b)) return getMergedValue(a, b, caseless);
        else if (!(0, _utilsJsDefault.default).isUndefined(a)) return getMergedValue(undefined, a, caseless);
    }
    // eslint-disable-next-line consistent-return
    function valueFromConfig2(a, b) {
        if (!(0, _utilsJsDefault.default).isUndefined(b)) return getMergedValue(undefined, b);
    }
    // eslint-disable-next-line consistent-return
    function defaultToConfig2(a, b) {
        if (!(0, _utilsJsDefault.default).isUndefined(b)) return getMergedValue(undefined, b);
        else if (!(0, _utilsJsDefault.default).isUndefined(a)) return getMergedValue(undefined, a);
    }
    // eslint-disable-next-line consistent-return
    function mergeDirectKeys(a, b, prop) {
        if (prop in config2) return getMergedValue(a, b);
        else if (prop in config1) return getMergedValue(undefined, a);
    }
    const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b)=>mergeDeepProperties(headersToObject(a), headersToObject(b), true)
    };
    (0, _utilsJsDefault.default).forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
        const merge = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge(config1[prop], config2[prop], prop);
        (0, _utilsJsDefault.default).isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
}

},{"../utils.js":"5By4s","./AxiosHeaders.js":"cgSSx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9vgkY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _dataJs = require("../env/data.js");
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
"use strict";
const validators = {};
// eslint-disable-next-line func-names
[
    "object",
    "boolean",
    "number",
    "function",
    "string",
    "symbol"
].forEach((type, i)=>{
    validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
    };
});
const deprecatedWarnings = {};
/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */ validators.transitional = function transitional(validator, version, message) {
    function formatMessage(opt, desc) {
        return "[Axios v" + (0, _dataJs.VERSION) + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    // eslint-disable-next-line func-names
    return (value, opt, opts)=>{
        if (validator === false) throw new (0, _axiosErrorJsDefault.default)(formatMessage(opt, " has been removed" + (version ? " in " + version : "")), (0, _axiosErrorJsDefault.default).ERR_DEPRECATED);
        if (version && !deprecatedWarnings[opt]) {
            deprecatedWarnings[opt] = true;
            // eslint-disable-next-line no-console
            console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future"));
        }
        return validator ? validator(value, opt, opts) : true;
    };
};
/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */ function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== "object") throw new (0, _axiosErrorJsDefault.default)("options must be an object", (0, _axiosErrorJsDefault.default).ERR_BAD_OPTION_VALUE);
    const keys = Object.keys(options);
    let i = keys.length;
    while(i-- > 0){
        const opt = keys[i];
        const validator = schema[opt];
        if (validator) {
            const value = options[opt];
            const result = value === undefined || validator(value, opt, options);
            if (result !== true) throw new (0, _axiosErrorJsDefault.default)("option " + opt + " must be " + result, (0, _axiosErrorJsDefault.default).ERR_BAD_OPTION_VALUE);
            continue;
        }
        if (allowUnknown !== true) throw new (0, _axiosErrorJsDefault.default)("Unknown option " + opt, (0, _axiosErrorJsDefault.default).ERR_BAD_OPTION);
    }
}
exports.default = {
    assertOptions,
    validators
};

},{"../env/data.js":"h29L9","../core/AxiosError.js":"3u8Tl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h29L9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VERSION", ()=>VERSION);
const VERSION = "1.6.8";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"45wzn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _canceledErrorJs = require("./CanceledError.js");
var _canceledErrorJsDefault = parcelHelpers.interopDefault(_canceledErrorJs);
"use strict";
/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */ class CancelToken {
    constructor(executor){
        if (typeof executor !== "function") throw new TypeError("executor must be a function.");
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
            resolvePromise = resolve;
        });
        const token = this;
        // eslint-disable-next-line func-names
        this.promise.then((cancel)=>{
            if (!token._listeners) return;
            let i = token._listeners.length;
            while(i-- > 0)token._listeners[i](cancel);
            token._listeners = null;
        });
        // eslint-disable-next-line func-names
        this.promise.then = (onfulfilled)=>{
            let _resolve;
            // eslint-disable-next-line func-names
            const promise = new Promise((resolve)=>{
                token.subscribe(resolve);
                _resolve = resolve;
            }).then(onfulfilled);
            promise.cancel = function reject() {
                token.unsubscribe(_resolve);
            };
            return promise;
        };
        executor(function cancel(message, config, request) {
            if (token.reason) // Cancellation has already been requested
            return;
            token.reason = new (0, _canceledErrorJsDefault.default)(message, config, request);
            resolvePromise(token.reason);
        });
    }
    /**
   * Throws a `CanceledError` if cancellation has been requested.
   */ throwIfRequested() {
        if (this.reason) throw this.reason;
    }
    /**
   * Subscribe to the cancel signal
   */ subscribe(listener) {
        if (this.reason) {
            listener(this.reason);
            return;
        }
        if (this._listeners) this._listeners.push(listener);
        else this._listeners = [
            listener
        ];
    }
    /**
   * Unsubscribe from the cancel signal
   */ unsubscribe(listener) {
        if (!this._listeners) return;
        const index = this._listeners.indexOf(listener);
        if (index !== -1) this._listeners.splice(index, 1);
    }
    /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */ static source() {
        let cancel;
        const token = new CancelToken(function executor(c) {
            cancel = c;
        });
        return {
            token,
            cancel
        };
    }
}
exports.default = CancelToken;

},{"./CanceledError.js":"9PwCG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dyQ8N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>spread);
"use strict";
function spread(callback) {
    return function wrap(arr) {
        return callback.apply(null, arr);
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eyiLq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isAxiosError);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
function isAxiosError(payload) {
    return (0, _utilsJsDefault.default).isObject(payload) && payload.isAxiosError === true;
}

},{"./../utils.js":"5By4s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fdR61":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value])=>{
    HttpStatusCode[value] = key;
});
exports.default = HttpStatusCode;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"77HTZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require("f03f3676ce86c0c3");
    if (script.__esModule) script = script.default;
    script.render = require("fb01a38a159ff10c").render;
    require("a6421673610fe9ec").default(script);
    script.__scopeId = "data-v-9eb6ae";
    script.__file = "/Users/jordank/Sites/tror/web/wp-content/plugins/wp-otis/assets/js/vue/components/03_organisms/OtisConfig.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "9eb6ae-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("9eb6ae-hmr", script)) __VUE_HMR_RUNTIME__.reload("9eb6ae-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"f03f3676ce86c0c3":"lhe5q","fb01a38a159ff10c":"96vIx","a6421673610fe9ec":"fFawY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lhe5q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _vue = require("vue");
var _cardVue = require("../02_molecules/Card.vue");
var _cardVueDefault = parcelHelpers.interopDefault(_cardVue);
// Props.
exports.default = {
    __name: "OtisConfig",
    props: {
        importStarting: {
            type: Boolean,
            default: false
        },
        importActive: {
            type: Boolean,
            default: false
        },
        syncAllActive: {
            type: Boolean,
            default: false
        },
        toggleConfigSyncConfirm: {
            type: Function,
            default: ()=>{}
        },
        storedCredentials: {
            type: Object,
            default: {
                username: "",
                password: ""
            }
        },
        countsLoading: {
            type: Boolean,
            default: false
        }
    },
    emits: [
        "credentials"
    ],
    setup (__props, { expose: __expose, emit: __emit }) {
        __expose();
        const props = __props;
        // Refs.
        const username = (0, _vue.ref)("");
        const password = (0, _vue.ref)("");
        // Emit.
        const emit = __emit;
        const emitCredentials = ()=>{
            emit("credentials", {
                username: username.value,
                password: password.value
            });
            props.toggleConfigSyncConfirm();
        };
        const __returned__ = {
            props,
            username,
            password,
            emit,
            emitCredentials,
            ref: (0, _vue.ref),
            Card: (0, _cardVueDefault.default)
        };
        Object.defineProperty(__returned__, "__isScriptSetup", {
            enumerable: false,
            value: true
        });
        return __returned__;
    }
};

},{"vue":"gzxs9","../02_molecules/Card.vue":"eZkOW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"96vIx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
const _hoisted_1 = {
    class: "otis-dashboard__form-grid"
};
const _hoisted_2 = {
    class: "otis-dashboard__fieldset"
};
const _hoisted_3 = {
    id: "otis-dashboard__description",
    class: "otis-dashboard__description"
};
const _hoisted_4 = {
    class: "otis-dashboard__fieldset"
};
const _hoisted_5 = {
    id: "otis-dashboard__description",
    class: "otis-dashboard__description"
};
const _hoisted_6 = [
    "disabled"
];
const _hoisted_7 = /*#__PURE__*/ (0, _vue.createElementVNode)("span", null, "Update Credentials", -1 /* HOISTED */ );
const _hoisted_8 = [
    _hoisted_7
];
function render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_va_input = (0, _vue.resolveComponent)("va-input");
    return (0, _vue.openBlock)(), (0, _vue.createBlock)($setup["Card"], null, {
        title: (0, _vue.withCtx)(()=>[
                (0, _vue.createTextVNode)(" OTIS Config ")
            ]),
        content: (0, _vue.withCtx)(()=>[
                (0, _vue.createCommentVNode)(" Form grid "),
                (0, _vue.createElementVNode)("div", _hoisted_1, [
                    (0, _vue.createCommentVNode)(" Username "),
                    (0, _vue.createElementVNode)("fieldset", _hoisted_2, [
                        (0, _vue.createVNode)(_component_va_input, {
                            modelValue: $setup.username,
                            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event)=>$setup.username = $event),
                            placeholder: "Enter value",
                            label: "Username",
                            "aria-describedby": "otis-dashboard__description"
                        }, null, 8 /* PROPS */ , [
                            "modelValue"
                        ]),
                        (0, _vue.createElementVNode)("p", _hoisted_3, "Current username: " + (0, _vue.toDisplayString)($props.storedCredentials.username), 1 /* TEXT */ )
                    ]),
                    (0, _vue.createCommentVNode)(" Password "),
                    (0, _vue.createElementVNode)("fieldset", _hoisted_4, [
                        (0, _vue.createVNode)(_component_va_input, {
                            modelValue: $setup.password,
                            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event)=>$setup.password = $event),
                            placeholder: "Enter value",
                            label: "Password",
                            "aria-describedby": "otis-dashboard__description"
                        }, null, 8 /* PROPS */ , [
                            "modelValue"
                        ]),
                        (0, _vue.createElementVNode)("p", _hoisted_5, "Current password: " + (0, _vue.toDisplayString)($props.storedCredentials.password), 1 /* TEXT */ )
                    ])
                ])
            ]),
        actions: (0, _vue.withCtx)(()=>[
                (0, _vue.createElementVNode)("button", {
                    class: "button button-primary",
                    disabled: $props.importStarting || $props.importActive || $props.syncAllActive || $props.countsLoading,
                    onClick: $setup.emitCredentials
                }, [
                    ..._hoisted_8
                ], 8 /* PROPS */ , _hoisted_6)
            ]),
        _: 1 /* STABLE */ 
    });
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("9eb6ae-hmr", render);
});

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fFawY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5n22R":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require("a01faf89635561c9");
    if (script.__esModule) script = script.default;
    script.render = require("ec998ce39cd75433").render;
    require("acaf13ac49e5dc44").default(script);
    script.__scopeId = "data-v-902ec2";
    script.__file = "/Users/jordank/Sites/tror/web/wp-content/plugins/wp-otis/assets/js/vue/components/03_organisms/InitialPOIImport.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "902ec2-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("902ec2-hmr", script)) __VUE_HMR_RUNTIME__.reload("902ec2-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"a01faf89635561c9":"fHytb","ec998ce39cd75433":"jzAWM","acaf13ac49e5dc44":"3x5p2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fHytb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _vue = require("vue");
var _cardVue = require("../02_molecules/Card.vue");
var _cardVueDefault = parcelHelpers.interopDefault(_cardVue);
var _loadingIndicatorVue = require("../01_atoms/LoadingIndicator.vue");
var _loadingIndicatorVueDefault = parcelHelpers.interopDefault(_loadingIndicatorVue);
exports.default = {
    __name: "InitialPOIImport",
    props: {
        importStarting: {
            type: Boolean,
            default: false
        },
        credentialsNeeded: {
            type: Boolean,
            default: false
        },
        triggerInitialImport: {
            type: Function,
            default: ()=>{}
        }
    },
    setup (__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const __returned__ = {
            props,
            ref: (0, _vue.ref),
            Card: (0, _cardVueDefault.default),
            LoadingIndicator: (0, _loadingIndicatorVueDefault.default)
        };
        Object.defineProperty(__returned__, "__isScriptSetup", {
            enumerable: false,
            value: true
        });
        return __returned__;
    }
};

},{"vue":"gzxs9","../02_molecules/Card.vue":"eZkOW","../01_atoms/LoadingIndicator.vue":"8RWTs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jzAWM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
const _hoisted_1 = /*#__PURE__*/ (0, _vue.createElementVNode)("h2", null, "Initial POI Import", -1 /* HOISTED */ );
const _hoisted_2 = /*#__PURE__*/ (0, _vue.createElementVNode)("p", null, "Start here if this is your first time running the plugin. This interface will let you store your OTIS credentials and start your initial import.", -1 /* HOISTED */ );
const _hoisted_3 = /*#__PURE__*/ (0, _vue.createElementVNode)("p", null, [
    /*#__PURE__*/ (0, _vue.createElementVNode)("em", null, "Note: The importer will run based on the wp_otis_listings filter if it is set in your theme or a different plugin.")
], -1 /* HOISTED */ );
const _hoisted_4 = {
    key: 0
};
const _hoisted_5 = [
    "disabled"
];
const _hoisted_6 = {
    key: 0
};
const _hoisted_7 = {
    key: 1
};
function render(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, _vue.openBlock)(), (0, _vue.createBlock)($setup["Card"], null, {
        title: (0, _vue.withCtx)(()=>[
                _hoisted_1
            ]),
        content: (0, _vue.withCtx)(()=>[
                $props.importStarting ? ((0, _vue.openBlock)(), (0, _vue.createBlock)($setup["LoadingIndicator"], {
                    key: 0
                })) : (0, _vue.createCommentVNode)("v-if", true),
                _hoisted_2,
                _hoisted_3
            ]),
        actions: (0, _vue.withCtx)(()=>[
                $props.importStarting ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("p", _hoisted_4, "POI import starting, please wait this usually takes a few minutes...")) : (0, _vue.createCommentVNode)("v-if", true),
                (0, _vue.createElementVNode)("button", {
                    class: "button button-primary",
                    disabled: $props.importStarting || $props.credentialsNeeded,
                    onClick: _cache[0] || (_cache[0] = (...args)=>$props.triggerInitialImport && $props.triggerInitialImport(...args))
                }, [
                    $props.importStarting ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("span", _hoisted_6, " Import Starting Please Wait... ")) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("span", _hoisted_7, "Start Importing POIs"))
                ], 8 /* PROPS */ , _hoisted_5)
            ]),
        _: 1 /* STABLE */ 
    });
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("902ec2-hmr", render);
});

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3x5p2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dudkv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
const _withScopeId = (n)=>((0, _vue.pushScopeId)("data-v-565a54"), n = n(), (0, _vue.popScopeId)(), n);
const _hoisted_1 = {
    class: "otis-dashboard"
};
const _hoisted_2 = /*#__PURE__*/ _withScopeId(()=>/*#__PURE__*/ (0, _vue.createElementVNode)("h1", null, "OTIS Dashboard", -1 /* HOISTED */ ));
const _hoisted_3 = {
    key: 0,
    class: "otis-dashboard__banner"
};
const _hoisted_4 = {
    class: "otis-dashboard__settings"
};
const _hoisted_5 = {
    class: "otis-dashboard__setting-group"
};
const _hoisted_6 = {
    class: "otis-dashboard__setting"
};
const _hoisted_7 = /*#__PURE__*/ _withScopeId(()=>/*#__PURE__*/ (0, _vue.createElementVNode)("p", null, "Start an import of POIs that have been modified since a given date. POIs that already exist on the site will be updated or trashed if the have been updated or deleted on or after that date.", -1 /* HOISTED */ ));
const _hoisted_8 = /*#__PURE__*/ _withScopeId(()=>/*#__PURE__*/ (0, _vue.createElementVNode)("p", null, [
        /*#__PURE__*/ (0, _vue.createElementVNode)("em", null, "Note: This will run the importer based on the wp_otis_listings filter if it is set in your theme or a different plugin.")
    ], -1 /* HOISTED */ ));
const _hoisted_9 = /*#__PURE__*/ _withScopeId(()=>/*#__PURE__*/ (0, _vue.createElementVNode)("label", {
        for: "modified-date"
    }, "Date To Import From", -1 /* HOISTED */ ));
const _hoisted_10 = [
    "disabled"
];
const _hoisted_11 = {
    key: 0
};
const _hoisted_12 = {
    key: 1
};
const _hoisted_13 = {
    key: 2
};
const _hoisted_14 = {
    key: 3
};
const _hoisted_15 = {
    class: "otis-dashboard__statuses"
};
const _hoisted_16 = {
    class: "otis-dashboard__status"
};
const _hoisted_17 = {
    key: 0
};
const _hoisted_18 = {
    key: 1
};
const _hoisted_19 = {
    class: "otis-dashboard__status"
};
const _hoisted_20 = {
    key: 0
};
const _hoisted_21 = {
    key: 1
};
const _hoisted_22 = {
    class: "otis-dashboard__status"
};
const _hoisted_23 = {
    key: 0
};
const _hoisted_24 = {
    key: 1
};
const _hoisted_25 = {
    class: "otis-dashboard__status otis-dashboard__status--full-width"
};
const _hoisted_26 = {
    key: 0
};
const _hoisted_27 = {
    key: 1
};
const _hoisted_28 = /*#__PURE__*/ _withScopeId(()=>/*#__PURE__*/ (0, _vue.createElementVNode)("p", null, "Use this to restart standard automatic imports, useful if automatic imports seem stuck.", -1 /* HOISTED */ ));
const _hoisted_29 = [
    _hoisted_28
];
const _hoisted_30 = [
    "disabled"
];
const _hoisted_31 = {
    class: "otis-dashboard__setting otis-dashboard__setting--full-width"
};
const _hoisted_32 = /*#__PURE__*/ _withScopeId(()=>/*#__PURE__*/ (0, _vue.createElementVNode)("p", null, [
        /*#__PURE__*/ (0, _vue.createElementVNode)("i", null, [
            /*#__PURE__*/ (0, _vue.createElementVNode)("strong", null, "Note:"),
            /*#__PURE__*/ (0, _vue.createTextVNode)(" This is a lengthy and resource intensive process")
        ])
    ], -1 /* HOISTED */ ));
const _hoisted_33 = /*#__PURE__*/ _withScopeId(()=>/*#__PURE__*/ (0, _vue.createElementVNode)("p", null, "This will sync all relevant POIs that are active in OTIS with WordPress using the Otis filters you have set. This is useful if you find there are POIs that are stale/should have been imported/deleted.", -1 /* HOISTED */ ));
const _hoisted_34 = /*#__PURE__*/ _withScopeId(()=>/*#__PURE__*/ (0, _vue.createElementVNode)("p", null, "This process is split into several actions and each action is split into pages. The process will run until all pages have been processed. You can cancel the process at any time but it will need to be started from the beginning if canceled.", -1 /* HOISTED */ ));
const _hoisted_35 = /*#__PURE__*/ _withScopeId(()=>/*#__PURE__*/ (0, _vue.createElementVNode)("p", null, [
        /*#__PURE__*/ (0, _vue.createElementVNode)("strong", null, "This process will trash POI posts if they've been removed from OTIS.")
    ], -1 /* HOISTED */ ));
const _hoisted_36 = [
    "disabled"
];
const _hoisted_37 = {
    key: 0
};
const _hoisted_38 = {
    key: 1
};
const _hoisted_39 = {
    class: "otis-dashboard__setting otis-dashboard__setting--full-width"
};
const _hoisted_40 = {
    class: "otis-dashboard__setting"
};
const _hoisted_41 = {
    key: 0
};
const _hoisted_42 = {
    key: 1
};
const _hoisted_43 = [
    "href"
];
const _hoisted_44 = {
    class: "va-table-responsive"
};
const _hoisted_45 = {
    class: "va-table va-table--striped"
};
const _hoisted_46 = /*#__PURE__*/ _withScopeId(()=>/*#__PURE__*/ (0, _vue.createElementVNode)("thead", null, [
        /*#__PURE__*/ (0, _vue.createElementVNode)("tr", null, [
            /*#__PURE__*/ (0, _vue.createElementVNode)("th", null, "Log Entry")
        ])
    ], -1 /* HOISTED */ ));
const _hoisted_47 = [
    "href"
];
const _hoisted_48 = {
    class: "otis-dashboard__setting"
};
const _hoisted_49 = {
    key: 0
};
const _hoisted_50 = {
    key: 1
};
const _hoisted_51 = {
    class: "va-table-responsive"
};
const _hoisted_52 = {
    class: "va-table va-table--striped"
};
const _hoisted_53 = /*#__PURE__*/ _withScopeId(()=>/*#__PURE__*/ (0, _vue.createElementVNode)("thead", null, [
        /*#__PURE__*/ (0, _vue.createElementVNode)("tr", null, [
            /*#__PURE__*/ (0, _vue.createElementVNode)("th", null, "Status"),
            /*#__PURE__*/ (0, _vue.createElementVNode)("th", null, "Count")
        ])
    ], -1 /* HOISTED */ ));
const _hoisted_54 = [
    "href"
];
const _hoisted_55 = {
    key: 2,
    class: "otis-dashboard__notifications"
};
const _hoisted_56 = /*#__PURE__*/ _withScopeId(()=>/*#__PURE__*/ (0, _vue.createElementVNode)("p", null, [
        /*#__PURE__*/ (0, _vue.createElementVNode)("strong", null, "Are you sure you want to sync all POIs?")
    ], -1 /* HOISTED */ ));
const _hoisted_57 = /*#__PURE__*/ _withScopeId(()=>/*#__PURE__*/ (0, _vue.createElementVNode)("p", null, "This action could take several hours to complete. You may close this browser window while the sync is running.", -1 /* HOISTED */ ));
const _hoisted_58 = /*#__PURE__*/ _withScopeId(()=>/*#__PURE__*/ (0, _vue.createElementVNode)("p", null, "Are you sure you want to cancel?", -1 /* HOISTED */ ));
const _hoisted_59 = /*#__PURE__*/ _withScopeId(()=>/*#__PURE__*/ (0, _vue.createElementVNode)("p", null, "Are you sure you want to restart automatic imports?", -1 /* HOISTED */ ));
const _hoisted_60 = /*#__PURE__*/ _withScopeId(()=>/*#__PURE__*/ (0, _vue.createElementVNode)("p", null, "Are you sure you want to sync OTIS configuration?", -1 /* HOISTED */ ));
function render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Datepicker = (0, _vue.resolveComponent)("Datepicker");
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_1, [
        _hoisted_2,
        (0, _vue.createCommentVNode)(" Initial import "),
        $setup.displayInitialImport ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_3, [
            (0, _vue.createCommentVNode)(" Config Import "),
            $setup.displayInitialConfig ? ((0, _vue.openBlock)(), (0, _vue.createBlock)($setup["OtisConfig"], {
                key: 0,
                importStarting: $setup.importStarting,
                importActive: $setup.importActive,
                syncAllActive: $setup.syncAllActive,
                onCredentials: $setup.updateCredentials,
                toggleConfigSyncConfirm: $setup.toggleConfigSyncConfirm,
                storedCredentials: $setup.storedCredentials
            }, null, 8 /* PROPS */ , [
                "importStarting",
                "importActive",
                "syncAllActive",
                "storedCredentials"
            ])) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
                key: 1
            }, [
                (0, _vue.createCommentVNode)(" POI Import "),
                (0, _vue.createVNode)($setup["InitialPOIImport"], {
                    importStarting: $setup.importStarting,
                    credentialsNeeded: $setup.credentialsNeeded,
                    triggerInitialImport: $setup.triggerInitialImport
                }, null, 8 /* PROPS */ , [
                    "importStarting",
                    "credentialsNeeded"
                ])
            ], 64 /* STABLE_FRAGMENT */ ))
        ])) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), {
            key: 1
        }, [
            (0, _vue.createCommentVNode)(" POI import and update, reset and status "),
            (0, _vue.createElementVNode)("div", _hoisted_4, [
                (0, _vue.createElementVNode)("div", _hoisted_5, [
                    (0, _vue.createCommentVNode)(" POI import and update "),
                    (0, _vue.createElementVNode)("div", _hoisted_6, [
                        (0, _vue.createVNode)($setup["Card"], null, {
                            title: (0, _vue.withCtx)(()=>[
                                    (0, _vue.createTextVNode)(" POI Import & Update ")
                                ]),
                            content: (0, _vue.withCtx)(()=>[
                                    _hoisted_7,
                                    _hoisted_8,
                                    _hoisted_9,
                                    (0, _vue.createVNode)(_component_Datepicker, {
                                        modelValue: $setup.modifiedDate,
                                        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event)=>$setup.modifiedDate = $event),
                                        "enable-time-picker": false,
                                        "max-date": $setup.maxDate,
                                        format: "MM/dd/yyyy"
                                    }, null, 8 /* PROPS */ , [
                                        "modelValue",
                                        "max-date"
                                    ])
                                ]),
                            actions: (0, _vue.withCtx)(()=>[
                                    (0, _vue.createElementVNode)("button", {
                                        class: "button button-primary",
                                        disabled: !$setup.dateIsValid || $setup.importStarting || $setup.importActive || $setup.syncAllActive,
                                        onClick: $setup.toggleImportConfirm
                                    }, [
                                        $setup.importStarting ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("span", _hoisted_11, " Import Starting Please Wait... ")) : $setup.importActive ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("span", _hoisted_12, "Import Running Please Wait...")) : $setup.syncAllActive ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("span", _hoisted_13, "Sync Running Please Wait...")) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("span", _hoisted_14, "Start Importing Modified POIs"))
                                    ], 8 /* PROPS */ , _hoisted_10),
                                    $setup.importActive ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("button", {
                                        key: 0,
                                        class: "button button-primary",
                                        onClick: $setup.toggleCancelConfirm
                                    }, " Cancel Import ")) : (0, _vue.createCommentVNode)("v-if", true)
                                ]),
                            _: 1 /* STABLE */ 
                        })
                    ]),
                    (0, _vue.createCommentVNode)(" Statuses and reset "),
                    (0, _vue.createElementVNode)("div", _hoisted_15, [
                        (0, _vue.createCommentVNode)(" Last Import "),
                        (0, _vue.createElementVNode)("div", _hoisted_16, [
                            (0, _vue.createVNode)($setup["Card"], null, {
                                title: (0, _vue.withCtx)(()=>[
                                        (0, _vue.createTextVNode)(" Last Import ")
                                    ]),
                                content: (0, _vue.withCtx)(()=>[
                                        $setup.countsLoading ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_17, [
                                            (0, _vue.createVNode)($setup["LoadingIndicator"])
                                        ])) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_18, (0, _vue.toDisplayString)($setup.lastImport), 1 /* TEXT */ ))
                                    ]),
                                _: 1 /* STABLE */ 
                            })
                        ]),
                        (0, _vue.createCommentVNode)(" Next import "),
                        (0, _vue.createElementVNode)("div", _hoisted_19, [
                            (0, _vue.createVNode)($setup["Card"], null, {
                                title: (0, _vue.withCtx)(()=>[
                                        (0, _vue.createTextVNode)(" Next Import ")
                                    ]),
                                content: (0, _vue.withCtx)(()=>[
                                        $setup.countsLoading ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_20, [
                                            (0, _vue.createVNode)($setup["LoadingIndicator"])
                                        ])) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_21, (0, _vue.toDisplayString)($setup.nextImport), 1 /* TEXT */ ))
                                    ]),
                                _: 1 /* STABLE */ 
                            })
                        ]),
                        (0, _vue.createCommentVNode)(" Status "),
                        (0, _vue.createElementVNode)("div", _hoisted_22, [
                            (0, _vue.createVNode)($setup["Card"], null, {
                                title: (0, _vue.withCtx)(()=>[
                                        (0, _vue.createTextVNode)(" Importer Status ")
                                    ]),
                                content: (0, _vue.withCtx)(()=>[
                                        $setup.countsLoading ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_23, [
                                            (0, _vue.createVNode)($setup["LoadingIndicator"])
                                        ])) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_24, (0, _vue.toDisplayString)($setup.importerStatus), 1 /* TEXT */ ))
                                    ]),
                                _: 1 /* STABLE */ 
                            })
                        ]),
                        (0, _vue.createCommentVNode)(" Reset Importer Processes "),
                        (0, _vue.createElementVNode)("div", _hoisted_25, [
                            (0, _vue.createVNode)($setup["Card"], null, {
                                title: (0, _vue.withCtx)(()=>[
                                        (0, _vue.createTextVNode)(" Reset Importer Processes ")
                                    ]),
                                content: (0, _vue.withCtx)(()=>[
                                        $setup.countsLoading ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_26, [
                                            (0, _vue.createVNode)($setup["LoadingIndicator"])
                                        ])) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_27, [
                                            ..._hoisted_29
                                        ]))
                                    ]),
                                actions: (0, _vue.withCtx)(()=>[
                                        (0, _vue.createElementVNode)("button", {
                                            class: "button button-primary",
                                            disabled: $setup.importActive || $setup.syncAllActive,
                                            onClick: $setup.toggleStopAllConfirm
                                        }, " Reset Importer Processes ", 8 /* PROPS */ , _hoisted_30)
                                    ]),
                                _: 1 /* STABLE */ 
                            })
                        ])
                    ])
                ]),
                (0, _vue.createCommentVNode)(" Sync all POIs "),
                (0, _vue.createElementVNode)("div", _hoisted_31, [
                    (0, _vue.createVNode)($setup["Card"], null, {
                        title: (0, _vue.withCtx)(()=>[
                                (0, _vue.createTextVNode)(" Sync All POIs ")
                            ]),
                        content: (0, _vue.withCtx)(()=>[
                                _hoisted_32,
                                _hoisted_33,
                                _hoisted_34,
                                _hoisted_35
                            ]),
                        actions: (0, _vue.withCtx)(()=>[
                                (0, _vue.createElementVNode)("button", {
                                    class: "button button-primary",
                                    disabled: $setup.importStarting || $setup.importActive || $setup.syncAllActive,
                                    onClick: $setup.toggleSyncConfirm
                                }, [
                                    $setup.importStarting || $setup.importActive || $setup.syncAllActive ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("span", _hoisted_37, "Sync Running Please Wait...")) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("span", _hoisted_38, "Sync POIs"))
                                ], 8 /* PROPS */ , _hoisted_36),
                                $setup.syncAllActive ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("button", {
                                    key: 0,
                                    class: "button button-primary",
                                    onClick: $setup.toggleCancelConfirm
                                }, " Cancel Sync All ")) : (0, _vue.createCommentVNode)("v-if", true)
                            ]),
                        _: 1 /* STABLE */ 
                    })
                ]),
                (0, _vue.createCommentVNode)(" OTIS Config "),
                (0, _vue.createElementVNode)("div", _hoisted_39, [
                    (0, _vue.createVNode)($setup["OtisConfig"], {
                        importStarting: $setup.importStarting,
                        importActive: $setup.importActive,
                        syncAllActive: $setup.syncAllActive,
                        onCredentials: $setup.updateCredentials,
                        toggleConfigSyncConfirm: $setup.toggleConfigSyncConfirm,
                        storedCredentials: $setup.storedCredentials,
                        countsLoading: $setup.countsLoading
                    }, null, 8 /* PROPS */ , [
                        "importStarting",
                        "importActive",
                        "syncAllActive",
                        "storedCredentials",
                        "countsLoading"
                    ])
                ]),
                (0, _vue.createCommentVNode)(" Import log preview "),
                (0, _vue.createElementVNode)("div", _hoisted_40, [
                    (0, _vue.createVNode)($setup["Card"], null, {
                        title: (0, _vue.withCtx)(()=>[
                                (0, _vue.createTextVNode)(" Import Log Preview ")
                            ]),
                        content: (0, _vue.withCtx)(()=>[
                                $setup.countsLoading ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_41, [
                                    (0, _vue.createVNode)($setup["LoadingIndicator"])
                                ])) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_42, [
                                    (0, _vue.createElementVNode)("p", null, [
                                        (0, _vue.createTextVNode)("The last 15 entries in the import log. The full import log is available under "),
                                        (0, _vue.createElementVNode)("a", {
                                            href: $setup.importLogUrl
                                        }, "POI > Import Log", 8 /* PROPS */ , _hoisted_43),
                                        (0, _vue.createTextVNode)(".")
                                    ]),
                                    (0, _vue.createElementVNode)("div", _hoisted_44, [
                                        (0, _vue.createElementVNode)("table", _hoisted_45, [
                                            _hoisted_46,
                                            (0, _vue.createElementVNode)("tbody", null, [
                                                ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)($setup.importLog, ({ post_content }, index)=>{
                                                    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("tr", {
                                                        key: index
                                                    }, [
                                                        (0, _vue.createElementVNode)("td", null, (0, _vue.toDisplayString)(post_content), 1 /* TEXT */ )
                                                    ]);
                                                }), 128 /* KEYED_FRAGMENT */ ))
                                            ])
                                        ])
                                    ])
                                ]))
                            ]),
                        actions: (0, _vue.withCtx)(()=>[
                                (0, _vue.createElementVNode)("a", {
                                    href: $setup.importLogUrl,
                                    role: "button",
                                    class: "button"
                                }, "View Full Import Log", 8 /* PROPS */ , _hoisted_47)
                            ]),
                        _: 1 /* STABLE */ 
                    })
                ]),
                (0, _vue.createCommentVNode)(" POI counts "),
                (0, _vue.createElementVNode)("div", _hoisted_48, [
                    (0, _vue.createVNode)($setup["Card"], null, {
                        title: (0, _vue.withCtx)(()=>[
                                (0, _vue.createTextVNode)(" POI Counts ")
                            ]),
                        content: (0, _vue.withCtx)(()=>[
                                $setup.countsLoading ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_49, [
                                    (0, _vue.createVNode)($setup["LoadingIndicator"])
                                ])) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_50, [
                                    (0, _vue.createElementVNode)("div", _hoisted_51, [
                                        (0, _vue.createElementVNode)("table", _hoisted_52, [
                                            _hoisted_53,
                                            (0, _vue.createElementVNode)("tbody", null, [
                                                ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)($setup.poiCount, (count, status)=>{
                                                    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("tr", {
                                                        key: status
                                                    }, [
                                                        (0, _vue.createElementVNode)("td", null, (0, _vue.toDisplayString)(status), 1 /* TEXT */ ),
                                                        (0, _vue.createElementVNode)("td", null, [
                                                            (0, _vue.createElementVNode)("a", {
                                                                href: $setup.poiPostsUrl(status)
                                                            }, (0, _vue.toDisplayString)(count), 9 /* TEXT, PROPS */ , _hoisted_54)
                                                        ])
                                                    ]);
                                                }), 128 /* KEYED_FRAGMENT */ ))
                                            ])
                                        ])
                                    ])
                                ]))
                            ]),
                        _: 1 /* STABLE */ 
                    })
                ])
            ])
        ], 2112 /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */ )),
        (0, _vue.createCommentVNode)(" Notifications "),
        $setup.importStarted ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_55, [
            (0, _vue.createVNode)($setup["Alert"], {
                modelValue: $setup.importStarted,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event)=>$setup.importStarted = $event),
                color: "success"
            }, {
                message: (0, _vue.withCtx)(()=>[
                        (0, _vue.createTextVNode)(" OTIS Importer Started. ")
                    ]),
                _: 1 /* STABLE */ 
            }, 8 /* PROPS */ , [
                "modelValue"
            ])
        ])) : (0, _vue.createCommentVNode)("v-if", true),
        (0, _vue.createCommentVNode)(" Modal - Confirm Sync "),
        (0, _vue.createVNode)($setup["Modal"], {
            modelValue: $setup.showSyncModal,
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event)=>$setup.showSyncModal = $event),
            title: "Confirm Sync All POIs",
            "cancel-text": "No, do not start the sync.",
            "ok-text": "Yes, start the sync process.",
            onOk: $setup.triggerSyncPois
        }, {
            default: (0, _vue.withCtx)(()=>[
                    _hoisted_56,
                    _hoisted_57
                ]),
            _: 1 /* STABLE */ 
        }, 8 /* PROPS */ , [
            "modelValue"
        ]),
        (0, _vue.createCommentVNode)(" Modal - Confirm Cancel "),
        (0, _vue.createVNode)($setup["Modal"], {
            modelValue: $setup.showCancelModal,
            "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event)=>$setup.showCancelModal = $event),
            title: "Confirm Cancellation",
            "cancel-text": "No, continue the process.",
            "ok-text": "Yes, cancel the process.",
            onOk: $setup.cancelImporter
        }, {
            default: (0, _vue.withCtx)(()=>[
                    _hoisted_58
                ]),
            _: 1 /* STABLE */ 
        }, 8 /* PROPS */ , [
            "modelValue"
        ]),
        (0, _vue.createCommentVNode)(" Modal - Confirm import "),
        (0, _vue.createVNode)($setup["Modal"], {
            modelValue: $setup.showImportModal,
            "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event)=>$setup.showImportModal = $event),
            title: "Confirm POI Import",
            "cancel-text": "No, do not start the import.",
            "ok-text": "Yes, start the import process.",
            onOk: $setup.triggerModifiedImport
        }, {
            default: (0, _vue.withCtx)(()=>[
                    (0, _vue.createElementVNode)("p", null, "Are you sure you want to start the importer using the date: " + (0, _vue.toDisplayString)($setup.modifiedDateString) + "?", 1 /* TEXT */ )
                ]),
            _: 1 /* STABLE */ 
        }, 8 /* PROPS */ , [
            "modelValue"
        ]),
        (0, _vue.createCommentVNode)(" Modal - Confirm Stop All "),
        (0, _vue.createVNode)($setup["Modal"], {
            modelValue: $setup.showStopAllModal,
            "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event)=>$setup.showStopAllModal = $event),
            title: "Confirm Reset",
            "cancel-text": "No, do not reset importer.",
            "ok-text": "Yes, reset importer.",
            onOk: $setup.triggerStopAll
        }, {
            default: (0, _vue.withCtx)(()=>[
                    _hoisted_59
                ]),
            _: 1 /* STABLE */ 
        }, 8 /* PROPS */ , [
            "modelValue"
        ]),
        (0, _vue.createCommentVNode)(" Modal - Confirm OTIS sync "),
        (0, _vue.createVNode)($setup["Modal"], {
            modelValue: $setup.showOtisSyncModal,
            "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event)=>$setup.showOtisSyncModal = $event),
            title: "Confirm OTIS config sync",
            "cancel-text": "No, do not sync.",
            "ok-text": "Yes, sync config.",
            onOk: $setup.triggerSyncOtisConfig,
            onCancel: $setup.cancelSyncOtisConfig
        }, {
            default: (0, _vue.withCtx)(()=>[
                    _hoisted_60
                ]),
            _: 1 /* STABLE */ 
        }, 8 /* PROPS */ , [
            "modelValue"
        ])
    ]);
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("565a54-hmr", render);
});

},{"vue":"gzxs9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7TpLY":[function() {},{}],"iKgNc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"clNoW":[function() {},{}]},["jKlMn","6gilS"], "6gilS", "parcelRequiree80c")

//# sourceMappingURL=otis.js.map
